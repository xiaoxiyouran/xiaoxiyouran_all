# 20180418 JVM 内存模型和分区



还有一个很好的引用： https://blog.csdn.net/a910626/article/details/52318590

--------------------

原文：https://blog.csdn.net/honjane/article/details/51542183

Java虚拟机在程序执行过程会把jvm的内存分为若干个不同的数据区域来管理，这些区域有自己的用途，以及创建和销毁时间。 
jvm管理的内存区域包括以下几个区域： 
![这里写图片描述](https://img-blog.csdn.net/20160530222930189)

**栈区：** 
栈分为**java虚拟机栈和本地方法栈**

- 重点是Java虚拟机栈，它是线程**私有的**，生命周期与线程相同。
- 每个方法执行都会创建一个栈帧，用于存放**局部变量表，操作栈，动态链接，方法出口**等。每个方法从被调用，直到被执行完。对应着一个栈帧在虚拟机中从入栈到出栈的过程。
- 通常说的栈就是指**局部变量表**部分，存放编译期间可知的8种基本数据类型，及对象引用和指令地址。局部变量表是在**编译期间**完成分配，当进入一个方法时，这个栈中的局部变量分配内存大小是确定的。
- 会有两种异常StackOverFlowError和 OutOfMemoneyError。当线程请求栈深度大于虚拟机所允许的深度就会抛出StackOverFlowError错误；虚拟机栈动态扩展，当扩展无法申请到足够的内存空间时候，抛出OutOfMemoneyError。
- 本地方法栈 为虚拟机使用到本地方法服务（native）

**堆区：**

- 堆被所有**线程共享**区域，在虚拟机启动时创建，唯一目的存放**对象实例**。
- 堆区是gc的主要区域，通常情况下分为两个区块年轻代和年老代。更细一点年轻代又分为Eden区最要放新创建对象，From survivor 和 To survivor 保存gc后幸存下的对象，默认情况下各自占比 8:1:1。 
  不过很多文章介绍分为3个区块，把方法区算着为永久代。这大概是基于Hotspot虚拟机划分， 然后比如IBM j9就不存在永久代概论。不管怎么分区，都是存放对象实例。
- 会有异常OutOfMemoneyError

**方法区：**

- 被所有**线程共享**区域，用于存放**已被虚拟机加载**的类信息，常量，静态变量等数据。被Java虚拟机描述为堆的一个逻辑部分。习惯是也叫它永久代（permanment generation）
- 垃圾回收很少光顾这个区域，不过也是需要回收的，主要针对常量池回收，类型卸载。
- 常量池用于存放**编译期**生成的各种字节码和符号引用，常量池具有一定的动态性，里面可以存放编译期生成的常量；**运行期间**的常量也可以添加进入常量池中，比如string的intern()方法。

**程序计数器**：

- 当前线程所执行的行号指示器。通过改变计数器的值来确定下一条指令，比如循环，分支，跳转，异常处理，线程恢复等都是依赖计数器来完成。
- Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式实现的。为了线程切换能恢复到正确的位置，每条线程都需要一个**独立的程序计数器**，所以它是线程私有的。
- 唯一一块Java虚拟机**没有**规定任何OutofMemoryError的区块

jvm分区大致就这个块，具体里面还有很多细节，及其各个模块工作的算法都很复杂，这里只是对分区进行简单介绍，掌握一些基本的知识点。