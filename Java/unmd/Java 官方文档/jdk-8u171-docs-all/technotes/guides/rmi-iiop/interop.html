<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>Enterprise JavaBeans Components and CORBA Clients: A
Developer Guide</title>
<link rel="stylesheet" type="text/css" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>Enterprise JavaBeans Components and CORBA
Clients: A Developer Guide</h1>
<p>This paper discusses how to enable a client written in any
language supported by CORBA to access Enterprise
JavaBeans components
(EJB components).
This paper is directed at programmers with advanced knowledge of
both the Java Platform,
Enterprise Edition (Java EE) and CORBA (Common Object Request
Broker Architecture).</p>
<p><strong>Java EE technology</strong> simplifies enterprise
applications by basing them on standardized, modular and re-usable
components based on the Enterprise JavaBeans (EJB)
architecture, providing a complete set of services to those
components, and handling many details of application behavior
automatically. By automating many of the time-consuming and
difficult tasks of application development, Java EE technology allows
enterprise developers to focus on adding value, that is, enhancing
business logic, rather than building infrastructure.</p>
<p>The <strong>EJB server-side
component model</strong> simplifies development of middleware
components that are transactional, scalable, and portable.
Enterprise JavaBeans servers reduce the complexity of developing
middleware by providing automatic support for middleware services
such as transactions, security, database connectivity, and
more.</p>
<p><strong>CORBA</strong> is an Object Management Group (OMG)
standard that is an open, vendor-independent architecture and
infrastructure that computer applications use to work together over
networks. Using the standard Internet Inter-ORB Protocol (IIOP), a
CORBA-based program from any vendor, on almost any computer,
operating system, programming language, and network, can
interoperate with a CORBA-based program from the same or another
vendor, on almost any other computer, operating system, programming
language, and network. To learn more about CORBA, see the <a target=
"AuxWindow" href=
"http://www.omg.org/gettingstarted/gettingstartedindex.htm">Object Management Group</a> website.</p>
<p><a name="pgfId-1000422" id="pgfId-1000422"></a>CORBA technology
complements the Java platform by providing a distributed objects
framework, services to support that framework, and interoperability
with other languages. CORBA technology is an integral part of the
Java SE platform, being used in Enterprise JavaBeans components,
Java Remote Method Invocation APIs running over Internet Inter-ORB
Protocol (&quot;Java RMI-IIOP&quot;), and Java IDL APIs (&quot;Java
IDL&quot;).</p>
<p><a name="pgfId-998373" id="pgfId-998373"></a>OMG Interface
Definition Language (IDL) is used to describe the interfaces being
implemented by the remote objects. IDL is used to define the name
of the interface and the names of each of the attributes and
methods. Once you create the IDL file, you can use an IDL compiler
to generate the client stub and the server skeleton in any language
for which the OMG has defined a specification for such language
mapping. To learn more about OMG IDL, see the <a target="AuxWindow"
href=
"http://www.omg.org/gettingstarted/omg_idl.htm">OMG IDL</a> web page.</p>
<p><a name="pgfId-1000436" id="pgfId-1000436"></a><strong>Java
IDL</strong> makes it possible for distributed Java applications to
transparently invoke operations on remote network services using
the industry standard OMG IDL and IIOP defined by the Object
Management Group (<a target="AuxWindow" href=
"http://www.omg.org/">http://www.omg.org</a>). Java RMI over IIOP
APIs enable the programming of CORBA servers and applications via
the <code>javax.rmi</code> API.</p>
<p><a name="pgfId-998262" id="pgfId-998262"></a>Developers who
program EJB components follow the Java RMI programming model for
their distributed object model, where the required transport common
across all application servers is Java RMI-IIOP. In heterogeneous
server environments, the standard mapping of the EJB architecture
to CORBA enables the following interoperability:</p>
<ul>
<li><a name="pgfId-998228" id="pgfId-998228"></a>A client using an
ORB from one vendor can access enterprise beans residing on a
server enabled with Enterprise JavaBeans technology (&quot;EJB
server&quot;) provided by another vendor.</li>
<li class="Bullet1-"><a name="pgfId-998230" id=
"pgfId-998230"></a>Enterprise beans in one EJB server can access
enterprise beans in another EJB server.</li>
<li class="Bullet1-"><a name="pgfId-998232" id="pgfId-998232"></a>A
CORBA client written in a language other than the Java programming
language can access any EJB component as long as there is a mapping
from OMG IDL to that programming language.</li>
</ul>
<p><a name="pgfId-1000334" id="pgfId-1000334"></a>The rest of this
document provides an example of a CORBA client application
accessing an enterprise bean object. In this document, a CORBA
client means a client application written in any language supported
by CORBA, including the Java programming language, C++, C,
Smalltalk, COBOL, Ada, Lisp, or Python. While the Java code in this
example is specific to enterprise beans, the process for developing
a CORBA client that accesses a server created using the Java
RMI-IIOP APIs is the same.</p>
<p><a name="pgfId-1004703" id="pgfId-1004703"></a>Links to similar
example applications from other vendors who implement Java EE
can be found in <a href="#a41577" class="XRef"><em>Links
to similar examples</em></a>.</p>
<br />
<hr width="50%" />
<br />
<h1><a name="pgfId-998204" id="pgfId-998204"></a> Developing a
CORBA Client that Accesses an Enterprise JavaBean Component</h1>
<p><a name="pgfId-998322" id="pgfId-998322"></a>This is an example
of how to develop a CORBA client application that accesses an EJB
component. In this example, the client is written in the C++
programming language, but the client could be written in any
language supported by CORBA.</p>
<p><a name="pgfId-998347" id="pgfId-998347"></a>The general process
for developing a CORBA client so that it can access an enterprise
bean is demonstrated in the following sections:</p>
<ol>
<li><a href="#a27206">Write the Enterprise JavaBean
component</a></li>
<li><a href="#a31647">Generate the CORBA IDL</a></li>
<li><a href="#a64914">Create a CORBA client</a></li>
<li><a href="#a73772">Deploy the Enterprise JavaBean
component</a></li>
<li><a href="#a33286">Run the client executable</a></li>
</ol>
<p><a name="pgfId-996969" id="pgfId-996969"></a>This document also
includes:</p>
<ul>
<li class="Bullet1-"><a name="pgfId-997525" id=
"pgfId-997525"></a><a href="#a23458">Creating a Java RMI-IIOP
client application</a></li>
<li><a name="pgfId-997515" id="pgfId-997515"></a><a href=
"#a74676">Where to go from here</a></li>
<li class="Bullet1-"><a name="pgfId-997520" id=
"pgfId-997520"></a><a href="#a15189">Tips for complex
interfaces</a></li>
<li class="Bullet1-"><a name="pgfId-997530" id=
"pgfId-997530"></a><a href="#a41577">Links to similar
examples</a></li>
</ul>
<p><a name="pgfId-998358" id="pgfId-998358"></a>In order to make
the example simple, we have taken a few shortcuts. For information
on building more advanced solutions, see <a href="#a15189"><em>Tips
for complex interfaces</em></a>.</p>
<ol>
<li style="list-style: none; display: inline">
<h2><a name="pgfId-997537" id="pgfId-997537"></a><a name="a27206"
id="a27206"></a>Part I: Write the Enterprise JavaBean
component</h2>
<p><a name="pgfId-996979" id="pgfId-996979"></a>The following
examples show the code for an enterprise bean that will accept
simple <code>String</code> log messages sent to the application
server from Java RMI-IIOP and CORBA clients. The enterprise bean
prints them on the server along with the current server time.</p>
</li>
<li><strong><a name="pgfId-998454" id="pgfId-998454"></a>Create the
files <code>Logger.java</code> , <code>LoggerHome.java</code> ,
<code>LoggerEJB.java</code> , and <code>LogMessage.java</code> in
the <code>/Java/src/ejbinterop</code> directory.</strong><a name=
"pgfId-998534" id="pgfId-998534"></a>
<h3 class="Head4"><a name="pgfId-1005375" id=
"pgfId-1005375"></a>Logger.java</h3>
<p><a name="pgfId-1005376" id="pgfId-1005376"></a>The file
<code>Logger.java</code> is the enterprise bean's remote interface,
and as such, it extends <code>EJBObject</code> . A remote interface
provides the remote client view of an EJB object and defines the
business methods callable by a remote client.</p>
<pre>
<a name="pgfId-996984" id="pgfId-996984"></a>
//Code Example 1: Logger.java
package ejbinterop;

import javax.ejb.EJBObject;
import java.rmi.RemoteException;

/**
 * Accepts simple String log messages and prints
 * them on the server.
 */
public interface Logger extends EJBObject
{
    /**
     * Logs the given message on the server with
     * the current server time.
     */
    void logString(String message) throws RemoteException;
}
</pre>
<h3 class="Head4"><a name="pgfId-997002" id=
"pgfId-997002"></a>LoggerHome.java</h3>
<p><a name="pgfId-1005381" id="pgfId-1005381"></a>The file
<code>LoggerHome.java</code> extends <code>EJBHome</code> . The
<code>EJBHome</code> interface must be extended by all EJB
component's remote home interfaces. A home interface defines the
methods that allow a remote client to create, find, and remove EJB
objects, as well as home business methods that are not specific to
an EJB instance.</p>
<pre>
<a name="pgfId-997005" id="pgfId-997005"></a>
//Code Example 2: LoggerHome.java
package ejbinterop;

import java.rmi.RemoteException;
import javax.ejb.EJBHome;
import javax.ejb.CreateException;

public interface LoggerHome extends EJBHome
{
    Logger create() throws RemoteException, CreateException;
}
</pre>
<h3 class="Head4"><a name="pgfId-997015" id=
"pgfId-997015"></a>LoggerEJB.java</h3>
<p><a name="pgfId-1005382" id="pgfId-1005382"></a>The file
<code>LoggerEJB.java</code> contains the code for a session bean. A
session bean is an enterprise bean that is created by a client and
that usually exists only for the duration of a single client-server
session. A session bean performs operations such as calculations or
accessing a database for the client. In this example, the
enterprise bean accepts simple <code>String</code> log messages
from the client and prints them on the server.</p>
<pre>
<a name="pgfId-997018" id="pgfId-997018"></a>
//LoggerEJB.java
package ejbinterop;

import javax.ejb.*;
import java.util.*;
import java.rmi.*;
import java.io.*;

/**
 * Accepts simple String log messages and prints
 * them on the server.
 */
public class LoggerEJB implements SessionBean {

    public LoggerEJB() {}
    public void ejbCreate() {}
    public void ejbRemove() {}
    public void ejbActivate() {}
    public void ejbPassivate() {}
    public void setSessionContext(SessionContext sc) {}

    /**
     * Logs the given message on the server with
     * the current server time.
     */
    public void logString(String message) {
        LogMessage msg = new LogMessage(message);

        System.out.println(msg);
    }
}
</pre>
<h3 class="Head4"><a name="pgfId-998529" id=
"pgfId-998529"></a>LogMessage.java</h3>
<p><a name="pgfId-1005383" id="pgfId-1005383"></a>The file
<code>LogMessage.java</code> takes the current date and time,
creates a formatted <code>String</code> showing the message, and
prints the message to the server.</p>
<pre>
//LogMessage.java
package ejbinterop;

import java.io.Serializable;
import java.util.Date;
import java.text.*;

/**
 * Simple message class that handles pretty
 * printing of log messages.
 */
public class LogMessage implements Serializable
{
    private String message;
    private long datetime;

    /**
     * Constructor taking the message. This will
     * take the current date and time.
     */
    public LogMessage(String msg) {
        message = msg;
        datetime = (new Date()).getTime();
    }

    /**
     * Creates a formatted String showing the message.
     */
    public String toString() {
        StringBuffer sbuf = new StringBuffer();
        DateFormat dformat
            = DateFormat.getDateTimeInstance(DateFormat.MEDIUM,
        DateFormat.LONG);
        FieldPosition fpos = new
            FieldPosition(DateFormat.DATE_FIELD);
        dformat.format(new Date(datetime), sbuf, fpos);
        sbuf.append(&quot;: &quot;);
        sbuf.append(message);
        return sbuf.toString();
    }
}
</pre>
<p><a name="pgfId-999274" id="pgfId-999274"></a></p>
</li>
<li><strong>Compile the files written in this section, for
example,</strong>
<pre>
<strong><a name="pgfId-999275" id=
"pgfId-999275"></a>javac -classpath $JAVA_EE_HOME/lib/java_ee.jar:.. *.java</strong>
</pre>
<p><a name="pgfId-1000519" id="pgfId-1000519"></a>These commands
create <code>class</code> files for all of the <code>.java</code>
files in the current directory. This command and others in this
paper assume that the <em class="Variable">JAVA_EE_HOME</em>
environment variable has been set correctly. Using <em class=
"Variable">$JAVA_EE_HOME</em> is a convention of the UNIX
operating environment. Substitute <em class=
"Variable">%JAVA_EE_HOME%</em> when working in the Microsoft Windows
operating environment.</p>
<h2><a name="pgfId-999277" id="pgfId-999277"></a><a name="a31647"
id="a31647"></a>Part II: Generate the CORBA IDL</h2>
<p><a name="pgfId-999278" id="pgfId-999278"></a>This sections
discusses generating the Interface Definition Language (IDL) files
from the Java class files generated in the previous section. In
this example, we will use the <code>rmic</code> compiler to map the
Java code to IDL. IDL provides a purely declarative, programming
language-independent way of specifying an object's API.</p>
<p><a name="pgfId-998675" id="pgfId-998675"></a></p>
</li>
<li><strong>Run the <code>rmic</code> compiler against the Java
class files generated in the previous step as follows:</strong>
<pre>
<strong><a name="pgfId-998678" id=
"pgfId-998678"></a>rmic -idl -noValueMethods -classpath
  $JAVA_EE_HOME/lib/java_ee.jar:&lt;path_to_ejbinterop_dir&gt;
  -d &lt;path_to_where_idl_files_should_be_generated&gt;
  ejbinterop.Logger ejbinterop.LoggerHome
</strong>
</pre>
<p><a name="pgfId-998700" id="pgfId-998700"></a>In the preceding
example, we are including the JAR file containing definitions for
the <code>javax.ejb</code> package as well as the directory to our
<code>ejbinterop</code> files. If you're using the Java Platform, Enterprise Edition
(Java EE), Reference
Implementation (RI), the JAR files are located in
<code><em>$JAVA_EE_HOME</em>/lib/java_ee.jar</code> .</p>
<p><a name="pgfId-998701" id="pgfId-998701"></a>In the command line
for <code>rmic</code> above, we recommend a shortcut -- using the
<code>noValueMethods</code> option. This option tells
<code>rmic</code> to skip any methods with parameter or return
types that would be mapped to CORBA value types. The advantage is
that it will prevent us from generating a lot of unnecessary IDL
that we might have to implement in the C++ client. The disadvantage
is that we can only use primitive data types, arrays, and
<code>Strings</code> as parameters or return values, and not our
own Java class types. Read more about this in <a href=
"#a15189"><em>Tips for complex interfaces</em></a></p>
<p><a name="pgfId-997565" id="pgfId-997565"></a>Running the
<code>rmic</code> compiler on the Java class files generates the
following files to the directory indicated with the <em class=
"Variable">-d</em> option in the <code>rmic</code> statement
above:</p>
<ul>
<li><a name="pgfId-997068" id=
"pgfId-997068"></a><code>java/lang/Ex.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997069" id=
"pgfId-997069"></a><code>java/lang/Exception.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997070" id=
"pgfId-997070"></a><code>java/lang/Object.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997071" id=
"pgfId-997071"></a><code>java/lang/Throwable.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997072" id=
"pgfId-997072"></a><code>java/lang/ThrowableEx.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997073" id=
"pgfId-997073"></a><code>javax/ejb/CreateEx.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997074" id=
"pgfId-997074"></a><code>javax/ejb/CreateException.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997075" id=
"pgfId-997075"></a><code>javax/ejb/EJBHome.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997076" id=
"pgfId-997076"></a><code>javax/ejb/EJBMetaData.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997077" id=
"pgfId-997077"></a><code>javax/ejb/EJBObject.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997078" id=
"pgfId-997078"></a><code>javax/ejb/Handle.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997079" id=
"pgfId-997079"></a><code>javax/ejb/HomeHandle.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997080" id=
"pgfId-997080"></a><code>javax/ejb/RemoveEx.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997081" id=
"pgfId-997081"></a><code>javax/ejb/RemoveException.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997082" id=
"pgfId-997082"></a><code>ejbinterop/Logger.idl</code></li>
<li class="Bullet1-"><a name="pgfId-997083" id=
"pgfId-997083"></a><code>ejbinterop/LoggerHome.idl</code></li>
</ul>
<p><a name="pgfId-997578" id="pgfId-997578"></a>&nbsp;</p>
<dl>
<dd class="Note"><a name="pgfId-997579" id="pgfId-997579"></a></dd>
<dd><strong>NOTE:</strong> A number of these generated files
contain API that can only be used within a Java programming
environment. For example, the <code>EJBMetaData</code>
implementation is currently specific to each application server,
and thus it will be difficult to develop equivalents that will
continue to work over time on platforms other than the Java
platform. One option is to remove these from the IDL, but if you
do, you'll have to remove them from the IDL every time you change
the Java interface and regenerate the IDL files from the
<code>rmic</code> compiler.</dd>
</dl>
<dl>
<dd class="Note"><a name="pgfId-997847" id="pgfId-997847"></a></dd>
<dd>
<p><strong>NOTE:</strong> Since CORBA exceptions don't support
inheritance, the Java language to IDL mapping creates an
<code>Ex</code> class that contains a CORBA value type representing
the actual Java exception. In this basic example, we're not going
to worry much about exception support. More information about
exceptions can be found at <code><a target="AuxWindow" href=
"../idl/jidlExceptions.html" class="URL">Exceptions</a>.</code></p>
</dd>
</dl>
</li>
<li><strong><a name="pgfId-998896" id="pgfId-998896"></a>Compile
the IDL files with your C++ vendor's &quot;IDL to C++&quot;
compiler to generate the C++ code corresponding to the IDL. The
steps for this procedure vary by vendor, so consult your product
documentation for the specific steps for your vendor.</strong>
<h3><a name="pgfId-998902" id="pgfId-998902"></a><a name="a64914"
id="a64914"></a>Part III: Create a CORBA client</h3>
<p><a name="pgfId-997094" id="pgfId-997094"></a>The client
application can be written in any language supported by CORBA. The
following example provides the code for a simple C++ client that,
given an Object Request Broker (ORB) and a <code>corbaname</code>
URL for a <code>LoggerHome</code> object, logs a simple
<code>String</code> message on the server. You'll have to adjust
the <code>include</code> statements and modify the code for
registering the value factories based on your C++ ORB vendor's
libraries. This example was written for ORBacus for C++ 4.0.5 and
some of the C++ code in this example is specific to that
product.</p>
<p><a name="pgfId-1000121" id="pgfId-1000121"></a>A
<code>corbaname</code> URL is a human-readable URL format that
enables you to access CORBA objects. It is used to resolve a
stringified name from a specific naming context. This is part of
the CORBA Interoperable Naming Service (INS). INS is an extension
to CORBA Object Services (COS) Naming Service, which was delivered
in previous releases of the Java EE platform. To read more about INS,
see <a href="../idl/jidlNaming.html#INS" target=
"AuxWindow">Interoperable Naming Service</a>.</p>
<p><a name="pgfId-998739" id="pgfId-998739"></a>In this example,
the client code does the following:</p>
<ul>
<li><a name="pgfId-998741" id="pgfId-998741"></a>Creates an Object
Request Broker (ORB). The ORB connects objects requesting services
to the objects providing them.</li>
<li><a name="pgfId-998750" id="pgfId-998750"></a>Registers value
factories.</li>
<li><a name="pgfId-998751" id="pgfId-998751"></a>Looks up the
<code>LoggerHome</code> object in the naming context pointed to by
the <code>corbaname</code> URL.</li>
<li><a name="pgfId-998746" id="pgfId-998746"></a>Performs a safe
downcast from the object returned to a <code>LoggerHome</code>
object.</li>
<li><a name="pgfId-998747" id="pgfId-998747"></a>Creates a
<code>LoggerEJB</code> object reference.</li>
<li><a name="pgfId-998748" id="pgfId-998748"></a>Logs our
message.</li>
<li>Tells the application server we won't use this EJB reference
again.</li>
</ul>
</li>
<li><strong>Create the client using C++ code similar to the
following. The exact code may vary with your C++ implementation.
This code was written for ORBacus for C++ 4.0.5 and some of the C++
code in this example may be specific to that
product.</strong><a name="pgfId-997590" id="pgfId-997590"></a>
<pre>
//Code Example: Client.cpp
#include &lt;fstream.h&gt;

// C++ ORB Vendor specific include files
// These are from C++ ORBacus 4.0.5

#include &lt;OB/CORBA.h&gt;
#include &lt;OB/OBORB.h&gt;

// Include files generated from our IDL
#include &lt;java/lang/Exception.h&gt;
#include &lt;java/lang/Throwable.h&gt;
#include &lt;javax/ejb/CreateException.h&gt;
#include &lt;javax/ejb/RemoveException.h&gt;
#include &lt;ejbinterop/Logger.h&gt;
#include &lt;ejbinterop/LoggerHome.h&gt;

/**
 * Given an ORB and a corbaname URL for a LoggerHome
 * object, logs a simple string message on the server.
 */
void
run(CORBA::ORB_ptr orb, const char* logger_home_url)
{
  cout &lt;&lt; &quot;Looking for: &quot; &lt;&lt; logger_home_url &lt;&lt; endl;

  // Look up the LoggerHome object in the naming context
  // pointed to by the corbaname URL
  CORBA::Object_var home_obj
    = orb-&gt;string_to_object(logger_home_url);

  // Perform a safe downcast
  ejbinterop::LoggerHome_var home
    = ejbinterop::LoggerHome::_narrow(home_obj.in());

  assert(!CORBA::is_nil(home));

  // Create a Logger EJB reference
  ejbinterop::Logger_var logger = home-&gt;create();

  CORBA::WStringValue_var msg =
    new CORBA::WStringValue((const CORBA::WChar*)L&quot;Message
      from a C++ client&quot;);

  cout &lt;&lt; &quot;Logging...&quot; &lt;&lt; endl;

  // Log our message
  logger-&gt;logString(msg);

  // Tell the application server we won't use this
  // EJB reference any more
  logger-&gt;remove();

  cout &lt;&lt; &quot;Done&quot; &lt;&lt; endl;
}

/**
 * Simple main method that checks arguments, creates an
 * ORB, and handles exceptions.
 */
int
main(int argc, char* argv[])
{
  int exit_code = 0;
  CORBA::ORB_var orb;

  try {

  // Check the arguments
  if (argc != 2) {
    cerr &lt;&lt; &quot;Usage: Client &lt;corbaname URL of LoggerHome&gt;&quot; &lt;&lt; endl;
    return 1;
  }

  // Create an ORB
  orb = CORBA::ORB_init(argc, argv);

  // Register value factories

  // NOTE: This is overkill for the example since we'll never
  // get these exceptions.  Also, the _OB_id method is a
  // proprietary feature of ORBacus C++ generated code.
  CORBA::ValueFactory factory = new java::lang::Throwable_init;
  orb -&gt; register_value_factory(java::lang::Throwable::_OB_id(),
    factory);
  factory -&gt; _remove_ref();

  factory = new java::lang::Exception_init;
  orb -&gt; register_value_factory(java::lang::Exception::_OB_id(),
    factory);
  factory -&gt; _remove_ref();

  factory = new javax::ejb::CreateException_init;
  orb -&gt;                 register_value_factory(javax::ejb::CreateException::_OB_id(),
      factory);
  factory -&gt; _remove_ref();

  factory = new javax::ejb::RemoveException_init;
  orb -&gt;
    register_value_factory(javax::ejb::RemoveException::_OB_id(),
      factory);
  factory -&gt; _remove_ref();

  // Perform the work
  run(orb, argv[1]);

} catch(const CORBA::Exception&amp; ex) {
  // Handle any CORBA related exceptions
  cerr &lt;&lt; ex._to_string() &lt;&lt; endl;
  exit_code = 1;
}

  // Release any ORB resources
  if (!CORBA::is_nil(orb)) {
    try {
      orb -&gt; destroy();
    } catch(const CORBA::Exception&amp; ex) {
      cerr &lt;&lt; ex._to_string() &lt;&lt; endl;
      exit_code = 1;
    }
  }

  return exit_code;
}
</pre></li>
<li><strong>Use your C++ compiler to compile all of the C++ files,
including the Client.cpp file, to create a Client executable. Such
tools vary widely across platforms, so consult your product
documentation for instructions.</strong>
<h3><a name="a73772" id="a73772"></a> <a name="pgfId-998921" id=
"pgfId-998921"></a>Part IV: Deploy the Enterprise JavaBean
component</h3>
</li>
<li><strong>Deploy the enterprise bean using your favorite
application server. The following steps describe how to deploy the
<code>LoggerEJB</code> component using the Java EE Reference
Implementation (RI).</strong>
<ol>
<li>Start the RI application from a terminal window or command
prompt by typing:
<pre>
   $JAVA_EE_HOME/bin/java_ee -verbose
</pre></li>
<li>When the Java EE RI indicates &quot;Java EE server startup
complete&quot;, run the deployment tool from another terminal
window or command prompt by typing:
<pre>
   $JAVA_EE_HOME/bin/deploytool
</pre></li>
<li>From the deployment tool, select <code>File</code>
<code>-&gt;</code> <code>New</code> <code>-&gt;</code>
<code>Application.</code></li>
<li><a name="pgfId-997618" id="pgfId-997618"></a>In the Application
File Name field, enter <code>Logger.ear</code> to indicate in which
file to create the application.</li>
<li><a name="pgfId-997623" id="pgfId-997623"></a>In the Application
Display Name field, enter <code>Logger</code></li>
<li><a name="pgfId-997628" id="pgfId-997628"></a>Select OK to save
the settings and close this dialog window.</li>
<li><a name="pgfId-997633" id="pgfId-997633"></a>From the
deployment tool, select <code>File</code> <code>-&gt;</code>
<code>New</code> <code>-&gt;</code> <code>Enterprise
Bean.</code></li>
<li><a name="pgfId-1005451" id="pgfId-1005451"></a>Select Next if
you get the Introduction screen. If not, continue.</li>
<li><a name="pgfId-998943" id="pgfId-998943"></a>In the New
EnterpriseBean Wizard, select Edit in the Contents box.</li>
<li><a name="pgfId-1005452" id="pgfId-1005452"></a>Expand the
Available Files list, and add the following four
<code>.class</code> files from our <code>ejbinterop</code> package:
<code>Logger.class</code> , <code>LoggerHome.class</code> ,
<code>LoggerEJB.class</code> , <code>LogMessage.class</code> .
Select OK, then Next.</li>
<li><a name="pgfId-997641" id="pgfId-997641"></a>Select
<code>Stateless</code> <code>Session</code> <code>Bean</code>
<code>Type.</code></li>
<li><a name="pgfId-997646" id="pgfId-997646"></a>Select
<code>ejbinterop.LoggerEJB</code> for the <code>Enterprise</code>
<code>Bean</code> <code>Class</code> .</li>
<li><a name="pgfId-997650" id="pgfId-997650"></a>Select
<code>ejbinterop.LoggerHome</code> for the <code>Remote</code>
<code>Home</code> <code>Interface</code> .</li>
<li><a name="pgfId-997654" id="pgfId-997654"></a>Select
<code>ejbinterop.Logger</code> for the <code>Remote</code>
<code>Interface</code> .</li>
<li><a name="pgfId-997658" id="pgfId-997658"></a>Select the Next
button until you get to the <code>Security</code>
<code>Settings</code> page.</li>
<li><a name="pgfId-997662" id="pgfId-997662"></a>Select the
<code>Deployment</code> <code>Settings</code>
button<code>.</code></li>
<li><a name="pgfId-997666" id="pgfId-997666"></a>Select
<code>Support</code> <code>Client</code> <code>Choice</code> .</li>
<li><a name="pgfId-997670" id="pgfId-997670"></a>Select OK to save
the settings and close this dialog window.</li>
<li><a name="pgfId-997674" id="pgfId-997674"></a>Select
Finish.</li>
<li><a name="pgfId-997678" id="pgfId-997678"></a>From the
deployment tool, select, <code>Tools</code> <code>-&gt;</code>
<code>Deploy.</code></li>
<li><a name="pgfId-1005453" id="pgfId-1005453"></a><strong>If
running the Java RMI-IIOP client only</strong>, select Return
Client JAR.</li>
<li><a name="pgfId-998953" id="pgfId-998953"></a>Select Next.</li>
<li><a name="pgfId-997682" id="pgfId-997682"></a>Enter
<code>ejbinterop/logger</code> in the <code>JNDI</code>
<code>Name</code> for our LoggerEJB field.</li>
<li><a name="pgfId-998963" id="pgfId-998963"></a>Select
Finish.</li>
<li><a name="pgfId-1005772" id="pgfId-1005772"></a>Select File
-&gt; Exit to exit the deploytool.</li>
</ol>
<p><a name="pgfId-997891" id="pgfId-997891"></a>Now, the Logger
application with our <code>LoggerEJB</code> components are deployed
and ready to receive messages.</p>
<h3><a name="pgfId-997893" id="pgfId-997893"></a><a name="a33286"
id="a33286"></a>Part V: Run the client executable</h3>
</li>
<li><strong>Run the client executable. One way you can run the
client executable is to enter the following URL in a terminal
window from the directory containing the executable client
file:</strong>
<pre>
<strong><a name="pgfId-1000172" id=
"pgfId-1000172"></a>Client corbaname:iiop:1.2@localhost:1050#ejbinterop/logger</strong>
</pre>
<p><a name="pgfId-999091" id="pgfId-999091"></a>In this URL,</p>
<ul>
<li><code>Client</code> is the name of the application to run.</li>
<li><a name="pgfId-999094" id=
"pgfId-999094"></a><code>corbaname</code> specifies that we will
resolve a stringified name from a specific naming context.</li>
<li><a name="pgfId-999095" id=
"pgfId-999095"></a><code>iiop:1.2</code> tells the ORB to use the
IIOP protocol and GIOP 1.2.</li>
<li><a name="pgfId-999096" id="pgfId-999096"></a>The host machine
on which to find the reference is <code>localhost</code>, the local
machine. To expand this example to run on two machines, enter the
IP address or host name of the machine on which the server is
running instead of <code>localhost</code>.</li>
<li><a name="pgfId-999098" id="pgfId-999098"></a><code>1050</code>
is the port on which the naming service is listening for requests.
By default in the Java EE RI, the default port the naming
service listens on is port 1050. The portion of the reference up to
this point at the hash mark (<code>Client
corbaname:iiop:1.2@localhost:1050</code> ) is the URL that returns
the root naming context.</li>
<li><a name="pgfId-1000198" id=
"pgfId-1000198"></a><code>ejbinterop/logger</code> is the name to
resolve in the naming context.</li>
</ul>
<p><a name="pgfId-999099" id="pgfId-999099"></a>If you are using
the Java EE Reference Implementation, you should see a message
similar to the following printed on the application server:</p>
<pre>
<a name="pgfId-1000207" id="pgfId-1000207"></a>
Sep 21, 2001 3:33:07 PM PDT: Message from a C++ client<code> ejbinterop/
logger</code> is the name to be resolved from the Naming Service.
</pre>
<h3><a name="pgfId-1005501" id="pgfId-1005501"></a>Part VI: Stop
the Java EE Server</h3>
</li>
<li><strong><a name="pgfId-1005504" id="pgfId-1005504"></a>Stop the
Java EE server. To stop the server, enter this command in a terminal
window or command prompt.</strong>
<pre>
<strong><a name="pgfId-1005736" id=
"pgfId-1005736"></a>$JAVA_EE_HOME/bin/java_ee -stop</strong>
</pre>
<p class="StepPara1"><a name="pgfId-1005726" id=
"pgfId-1005726"></a>Procedures for stopping running processes vary
among operating systems, so if you are running a different server,
consult your system documentation for details.</p>
</li>
</ol>
<br />
<hr width="50%" />
<br />
<h1><a name="pgfId-997911" id="pgfId-997911"></a><a name="a23458"
id="a23458"></a>Creating a Java RMI-IIOP client application</h1>
<p><a name="pgfId-997310" id="pgfId-997310"></a>Using the same
example, we can easily develop a Java RMI-IIOP client that connects
to an enterprise bean. The differences from the example using a C++
client are:</p>
<ul>
<li><a name="pgfId-999143" id="pgfId-999143"></a>In your client
CLASSPATH, you must include the location of the client JAR file
created by the Java EE application server running the desired
enterprise bean. That JAR file contains the necessary client
stubs.</li>
<li><a name="pgfId-997314" id="pgfId-997314"></a>When deploying the
application using the Java EE RI, check the box <code>Return
Client Jar</code> in the Deploytool on the first page of the Deploy
screen.</li>
</ul>
<p><a name="pgfId-997316" id="pgfId-997316"></a>The following code
is the Java RMI-IIOP version of a client for our
<code>LoggerEJB</code> component. Follow the same steps as those
presented for the C++ client example. When running the client, use
the same URL as in the C++ example.</p>
<div style="margin-left: 2em"><a name="pgfId-997773" id=
"pgfId-997773"></a>
<pre>
//Code Example: LogClient.java
package ejbinterop;

import java.rmi.RemoteException;
import javax.rmi.*;
import java.io.*;
import javax.naming.*;
import javax.ejb.*;

/**
 * Simple Java RMI-IIOP client that uses an EJB component.
 */
public class LogClient
{
    /**
     * Given a corbaname URL for a LoggerHome,
     * log a simple String message on the server.
     */
    public static void run(String loggerHomeURL)
        throws CreateException, RemoveException,
               RemoteException, NamingException
    {
        System.out.println(&quot;Looking for: &quot; + loggerHomeURL);

        // Create an InitialContext. This will use the
        // CosNaming provider we will specify at runtime.
        InitialContext ic = new InitialContext();

        // Lookup the LoggerHome in the naming context
        // pointed to by the corbaname URL
        Object homeObj = ic.lookup(loggerHomeURL);

        // Perform a safe downcast
        LoggerHome home
            = (LoggerHome)PortableRemoteObject.narrow(homeObj,
        LoggerHome.class);

        // Create a Logger EJB reference
        Logger logger = home.create();

        System.out.println(&quot;Logging...&quot;);

        // Log our message
        logger.logString(&quot;Message from a Java RMI-IIOP client&quot;);

        // Tell the application server we won't use this
        // EJB reference anymore
        logger.remove();

        System.out.println(&quot;Done&quot;);
    }

    /**
     * Simple main method to check arguments and handle
     * exceptions.
     */
    public static void main(String args[])
    {
        try {

            if (args.length != 1) {
                System.out.println(&quot;Args: corbaname URL of LoggerHome&quot;);
                System.exit(1);
            }

            LogClient.run(args[0]);

        } catch (Throwable t) {
            t.printStackTrace();
            System.exit(1);
        }
    }
}
</pre></div>
<h2 class="Head3"><a name="pgfId-1005509" id=
"pgfId-1005509"></a>Running the application with the Java RMI-IIOP
client</h2>
<p><a name="pgfId-1005517" id="pgfId-1005517"></a>When running the
example application with a Java RMI-IIOP client instead of a C++
client, follow these steps:</p>
<ol>
<li><a name="pgfId-1005518" id="pgfId-1005518"></a>Compile the
.<code>java</code> files in the <code>ejbinterop</code> / directory
with the following command:
<pre>
<a name="pgfId-1005545" id=
"pgfId-1005545"></a><code>javac -classpath $JAVA_EE_HOME/lib/java_ee.jar:&lt;ejbinterop_directory&gt; *.java</code>
</pre></li>
<li><a name="pgfId-1005626" id="pgfId-1005626"></a>Deploy the
Enterprise JavaBean component as described in <a href=
"#a73772"><em>Deploy the Enterprise JavaBean component</em></a>.
Remember to select Return Client JAR on the Tools -&gt; Deploy page
when running a Java RMI-IIOP client application. The commands in
the Deployment topic instruct you to start the Java EE RI or other
application server.</li>
<li><a name="pgfId-1005537" id="pgfId-1005537"></a>Run the client
application using a command similar to the following:
<pre>
<a name="pgfId-1005538" id=
"pgfId-1005538"></a>java -classpath $JAVA_EE_HOME/lib/java_ee.jar:
&lt;path to LoggerClient.jar&gt;/LoggerClient.jar:
&lt;directory_above_ejbinterop&gt;:&lt;ejbinterop_directory&gt;
ejbinterop.LogClient
corbaname:iiop:1.2@localhost:1050#ejbinterop/logger 
</pre>
<p>In the window in which the Java EE RI is running, you will see
this:</p>
<pre>
<a name="pgfId-1005828" id=
"pgfId-1005828"></a><code>Jan 31, 2002 2:27:47 PM PST: Message from a Java RMI-IIOP client</code>
</pre>
<p>In the window from where the client is run, you will see
this:</p>
<pre>
<a name="pgfId-1005831" id=
"pgfId-1005831"></a><code>Looking for: corbaname:iiop:1.2@localhost:1050#ejbinterop/logger
Logging...
Done</code>
</pre></li>
<li><a name="pgfId-1005539" id="pgfId-1005539"></a>Stop the Java EE
server.</li>
</ol>
<br />
<hr width="50%" />
<br />
<a name="pgfId-1005483" id="pgfId-1005483"></a>
<h1>Beyond the Basic Application</h1>
<p><a name="pgfId-1005484" id="pgfId-1005484"></a>This section
contains the following information:</p>
<ul>
<li><a name="pgfId-1005485" id="pgfId-1005485"></a><a href=
"#a74676">Where to go from here</a></li>
<li class="Bullet1-"><a name="pgfId-1005489" id=
"pgfId-1005489"></a><a href="#a15189">Tips for complex
interfaces</a></li>
<li class="Bullet1-"><a name="pgfId-1005497" id=
"pgfId-1005497"></a><a href="#a41577">Links to similar
examples</a></li>
</ul>
<h2><a name="pgfId-997901" id="pgfId-997901"></a><a name="a74676"
id="a74676"></a>Where to go from here</h2>
<p><a name="pgfId-997902" id="pgfId-997902"></a>To enhance the
application you could:</p>
<ul>
<li><a name="pgfId-999100" id="pgfId-999100"></a>Develop the
example to use valuetypes.</li>
<li style="list-style: none; display: inline">
<p class="ParaIndent2"><a name="pgfId-999103" id=
"pgfId-999103"></a>To do this, remove the
<code>-noValueMethods</code> switch when you run <code>rmic</code>
. Rerun your IDL to C++ language mapping compiler to verify that it
supports the valuetypes that have been generated.</p>
</li>
<li><a name="pgfId-999115" id="pgfId-999115"></a>Add another method
to <code>Logger</code> that actually takes a
<code>LogMessage</code> .</li>
</ul>
<h2><a name="pgfId-997719" id="pgfId-997719"></a><a name="a15189"
id="a15189"></a>Tips for complex interfaces</h2>
<p><a name="pgfId-999118" id="pgfId-999118"></a>The interfaces are
key to the communication between clients and servers speaking
different languages. To increase the probability of success in this
area, consider the following suggestions:</p>
<ul>
<li><a name="pgfId-997278" id="pgfId-997278"></a>Avoid using
complex Java classes, such as collections in <code>java.util</code>
, for method parameters or return types.</li>
<li style="list-style: none; display: inline">
<p class="ParaIndent2"><a name="pgfId-1004697" id=
"pgfId-1004697"></a>After these types are mapped to IDL, you will
be forced to implement them in your client programming language. In
addition, since Java Object Serialization and RMI-IIOP APIs allow
the wire format and internal representation of classes to evolve
over time, your CORBA client applications may be incompatible
across Java Platform, Standard Edition (Java SE)
implementations or versions.</p>
</li>
<li><a name="pgfId-997294" id="pgfId-997294"></a>Start with
IDL.</li>
<li style="list-style: none; display: inline">
<p class="ParaIndent2"><a name="pgfId-997296" id=
"pgfId-997296"></a>You may want complex data structures in your
return types or method parameters. In this case, try starting with
IDL. Define data structures and even exceptions in IDL, and then
use them in your EJB interfaces. This will prevent artifacts of the
reverse mapping from creeping into your CORBA interfaces.</p>
<p class="ParaIndent2"><a name="pgfId-997300" id=
"pgfId-997300"></a>For instance, try defining the
<code>LogMessage</code> class in IDL initially, and then using the
resulting class of a Java language to IDL compilation as a method
parameter in the Logger EJB component.</p>
</li>
<li><a name="pgfId-1000237" id="pgfId-1000237"></a>Avoid
overloading in EJB interfaces.</li>
<li style="list-style: none; display: inline">
<p class="ParaIndent2"><a name="pgfId-1000238" id=
"pgfId-1000238"></a>CORBA IDL does not support method overloading,
and the Java language to IDL mapping specification handles this by
creating IDL method definitions that combine the method name with
all its IDL parameter types. This leads to very unfriendly method
names for developers using languages other than the Java
programming language.</p>
</li>
<li><a name="pgfId-997303" id="pgfId-997303"></a>Consider using
bridges.</li>
<li style="list-style: none; display: inline">
<p class="ParaIndent2"><a name="pgfId-999134" id=
"pgfId-999134"></a>If the available options are still too limited
or impact the code you wish to write, consider using a server-side
bridge. You can read more about constructing such bridges from the
sites listed in the links section.</p>
</li>
</ul>
<h3><a name="pgfId-1005512" id="pgfId-1005512"></a><a name="a41577"
id="a41577"></a>Links to similar examples</h3>
<p><a name="pgfId-997394" id="pgfId-997394"></a>Several vendors
implementing Java EE technology have excellent examples and tips for
integrating CORBA and Enterprise JavaBeans technology. For example, see the <a name="pgfId-997397" id="pgfId-997397"></a>
<a href="http://docs.oracle.com/cd/E13211_01/wle/wle50/interop/ejbcorba.htm"
target="AuxWindow" class=
"Hypertext">EJB-to-CORBA/Java Simpapp Sample Application</a>.</p>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
