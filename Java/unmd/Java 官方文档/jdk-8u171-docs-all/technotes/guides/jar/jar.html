<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>JAR File Specification</title>
<link rel="stylesheet" type="text/css" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>JAR File Specification</h1>
<h2>Contents</h2>
<ul>
<li><a href="#Intro">Introduction</a></li>
<li><a href="#The_META-INF_directory">The
META-INF&nbsp;directory</a></li>
<li><a href="#Name-Value_pairs_and_Sections">Name-Value pairs and
Sections</a></li>
<li><a href="#JAR_Manifest">JAR Manifest</a>
<ul>
<li><a href="#Manifest-Overview">Overview</a></li>
<li><a href="#Manifest_Specification">Manifest
Specification</a></li>
<li><a href="#Main_Attributes">Main Attributes</a></li>
<li><a href="#Per-Entry_Attributes">Per-Entry Attributes</a></li>
</ul>
</li>
<li><a href="#Signed_JAR_File">Signed JAR file</a>
<ul>
<li><a href="#SignedJar-Overview">Overview</a></li>
<li><a href="#Signature_File">Signature File</a>
<ul>
<li><a href="#Signature_Validation">Signature validation</a></li>
<li><a href="#The_Magic_Attribute">The Magic Attribute</a></li>
</ul>
</li>
<li><a href="#Digital_Signatures">Digital Signatures</a></li>
</ul>
</li>
<li><a href="#Notes_on_Manifest_and_Signature_Files">Notes on
Manifest and Signature Files</a></li>
<li><a href="#JAR_Index">JAR Index</a>
<ul>
<li><a href="#Overview">Overview</a></li>
<li><a href="#Index_File_Specification">Index File
Specification</a></li>
<li><a href="#Backward_Compatibility">Backward
Compatibility</a></li>
</ul>
</li>
<li><a href="#Service_Provider">Service Provider</a>
<ul>
<li><a href="#Service_Provider_Overview">Overview</a></li>
<li><a href="#Provider_Configuration_File">Provider Configuration
File</a></li>
<li><a href="#Example">Example</a></li>
</ul>
</li>
<li><a href="#classpath">Class-Path attribute</a></li>
<li><a href="#sealing">Package Sealing</a></li>
<li><a href="#API_Details">API&nbsp;Details</a></li>
<li><a href="#See_Also">See Also</a></li>
</ul>
<h2><a name="Intro" id="Intro"></a>Introduction</h2>
JAR file is a file format based on the popular ZIP file format and
is used for aggregating many files into one. A&nbsp; JAR file is
essentially a zip file that contains an optional META-INF
directory. A JAR file can be created by the command-line <a href=
"../../tools/windows/jar.html">jar</a> tool, or by using the&nbsp;
<tt><a href=
"../../../api/java/util/jar/package-summary.html">java.util.jar</a></tt>
API in the Java platform. There is no restriction on the name of a
JAR file, it can be any legal file name on a particular platform.
<p>In many cases, JAR files are not just simple archives of java
classes files and/or resources. They are used as building blocks
for applications and extensions. The META-INF directory, if it
exists, is used to store package and extension configuration data,
including security, versioning, extension and services.</p>
<h2><a name="The_META-INF_directory" id=
"The_META-INF_directory"></a>The META-INF directory</h2>
The following files/directories in the META-INF directory are
recognized and interpreted by the Java 2 Platform to configure
applications, extensions, class loaders and services:
<ul>
<li><tt>MANIFEST.MF</tt></li>
</ul>
The manifest file that is used to define extension and package
related data.
<ul>
<li><tt>INDEX.LIST</tt></li>
</ul>
This file is generated by the new "<tt>-i"</tt> option of the jar
tool, which contains location information for packages defined in
an application or extension.&nbsp; It is part of the JarIndex
implementation and used by class loaders to speed up their class
loading process.
<ul>
<li><tt>x.SF</tt></li>
</ul>
The signature file for the JAR file.&nbsp; 'x' stands for the base
file name.
<ul>
<li><tt>x.DSA</tt></li>
</ul>
The signature block file associated with the signature file with
the same base file name. This file stores the digital signature of
the corresponding signature file.
<ul>
<li><tt>services/</tt></li>
</ul>
This directory stores all the service provider configuration files.
<h2><a name="Name-Value_pairs_and_Sections" id=
"Name-Value_pairs_and_Sections"></a>Name-Value pairs and
Sections</h2>
Before we go to the details of the contents of the individual
configuration files, some format convention needs to be defined. In
most cases, information contained within the manifest file and
signature files is represented as so-called "name: value" pairs
inspired by the RFC822 standard.&nbsp; We also call these pairs
headers or attributes.
<p>Groups of name-value pairs are known as a "section". Sections
are separated from other sections by empty lines.</p>
<p>Binary data of any form is represented as base64. Continuations
are required for binary data which causes line length to exceed 72
bytes. Examples of binary data are digests and signatures.</p>
<p>Implementations shall support header values of up to 65535
bytes.</p>
<p>All the specifications in this document use the same grammar in
which terminal symbols are shown in fixed width font and
non-terminal symbols are shown in italic type face.</p>
<h3><a name="Section-Specification" id=
"Section-Specification"></a>Specification:</h3>
&nbsp;
<i>section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
*header +newline</i><br />
<i>&nbsp; nonempty-section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; +header
+newline</i><br />
<i>&nbsp;
newline:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
<tt>CR LF | LF | CR</tt> (<i>not followed by</i> <tt>LF</tt>)<br />
&nbsp;
<i>header:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
name</i> <tt>:</tt> <i>value</i><br />
<i>&nbsp;
name:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
alphanum *headerchar</i><br />
<i>&nbsp;
value:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
SPACE *<i>otherchar newline *continuation</i><br />
&nbsp;
<i>continuation:</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
SPACE <i>*otherchar newline</i><br />
&nbsp;
<i>alphanum</i>:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<tt>A-Z</tt>} | {<tt>a-z</tt>} | {<tt>0-9</tt>}<br />
&nbsp;
<i>headerchar:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
alphanum</i> | <tt>-</tt> | <tt>_</tt><br />
&nbsp;
<i>otherchar:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
any UTF-8 character except</i> <tt>NUL, CR</tt> <i>and</i>
<tt>LF</tt>
<p><i>; Also: To prevent mangling of files sent via straight
e-mail, no</i><br />
<i>; header will start with the four letters "From".</i><br />
&nbsp;</p>
<p>Non-terminal symbols defined in the above specification will be
referenced in the following specifications.</p>
<h2><a name="JAR_Manifest" id="JAR_Manifest"></a>JAR Manifest</h2>
<h3><a name="Manifest-Overview" id=
"Manifest-Overview"></a>Overview</h3>
A JAR file manifest consists of a main section followed by a list
of sections for individual JAR file entries, each separated by a
newline. Both the main section and individual sections follow the
section syntax specified above. They each have their own specific
restrictions and rules.
<p>The main section contains security and configuration information
about the JAR file itself, as well as the application or extension
that this JAR file is a part of. It also defines main attributes
that apply to every individual manifest entry.&nbsp; No attribute
in this section can have its name equal to&nbsp; "<tt>Name</tt>".
This section is terminated by an empty line.</p>
<p>The individual sections define various attributes for packages
or files contained in this JAR file. Not all files in the JAR file
need to be listed in the manifest as entries, but all files which
are to be signed must be listed. The manifest file itself must not
be listed.&nbsp; Each section must start with an attribute with the
name as "<tt>Name</tt>", and the value must be a relative path to
the file, or an absolute URL referencing data outside the
archive.</p>
<p>If there are multiple individual sections for the same file
entry, the attributes in these sections are merged. If a certain
attribute have different values in different sections, the last one
is recognized.</p>
<p>Attributes which are not understood are ignored. Such attributes
may include implementation specific information used by
applications.</p>
<h3><a name="Manifest_Specification" id=
"Manifest_Specification"></a>Manifest Specification:</h3>
&nbsp;
<i>manifest-file:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
main-section newline *individual-section</i><br />
<i>&nbsp;
main-section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
version-info newline *main-attribute</i><br />
<i>&nbsp;
version-info:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
<tt>Manifest-Version :</tt> <i>version-number</i><br />
&nbsp; <i>version-number
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
digit+{</i><tt>.</tt><i>digit+}*</i><br />
&nbsp;
<i>main-attribute:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(any legitimate main attribute) newline</i><br />
<i>&nbsp;
individual-section:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</i>
<tt>Name :</tt> <i>value</i> <i>newline
*perentry-attribute</i><br />
<i>&nbsp;
perentry-attribute:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
(any legitimate perentry attribute) newline</i><br />
<i>&nbsp; newline
:&nbsp;</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt>CR LF | LF | CR</tt> (<i>not followed by</i> <tt>LF</tt>)<br />
&nbsp;&nbsp;
<i>digit:</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt>{0-9}&nbsp;</tt>
<p>In the above specification, attributes that can appear in the
main section are referred to as main attributes, whereas attributes
that can appear in individual sections are referred to as per-entry
attributes. Certain attributes can appear both in the main section
and the individual sections, in which case the per-entry attribute
value overrides the main attribute value for the specified entry.
The two types of attributes are defined as follows.<br />
&nbsp;</p>
<h3><a name="Main_Attributes" id="Main_Attributes"></a>Main
Attributes</h3>
Main attributes are the attributes that are present in the main
section of the manifest. They fall into the following different
groups:
<ul>
<li>general main attributes
<ul>
<li>Manifest-Version: Defines the manifest file version. The value
is a legitimate version number, as described in the above
spec.</li>
<li>Created-By: Defines the version and the vendor of the java
implementation on top of which this manifest file is generated.
This attribute is generated by the <tt>jar</tt> tool.</li>
<li>Signature-Version: Defines the signature version of the jar
file. The value should be a valid <i>version-number</i>
string.</li>
<li>Class-Path: The value of this attribute specifies the relative
URLs of the extensions or libraries that this application or
extension needs. URLs are separated by one or more spaces. The
application or extension class loader uses the value of this
attribute to construct its internal search path. See the
<a href="#classpath">Class-Path Attribute</a> section for details.</li>
</ul>
</li>
<li>attribute defined for stand-alone applications: This attribute
is used by stand-alone applications that are bundled into
executable jar files which can be invoked by the java runtime
directly by running "<tt>java -jar x.jar</tt>".
<ul>
<li>Main-Class: The value of this attribute is the class name of
the main application class which the launcher will load at startup
time. The value must <em>not</em> have the <tt>.class</tt>
extension appended to the class name.</li>
</ul>
</li>
<li>attributes defined for applets:
<strong>Deprecated: These attributes and the mechanism
which implements it may be removed in a future release.</strong> 
These attributes are used by an
applet which is bundled into JAR files to define requirements,
version and location information for the extensions which this
applet depends on. (see <a href=
"../extensions/versioning.html">Extension Versioning</a> ).
<ul>
<li>Extension-List: This attribute indicates the extensions that
are needed by the applet. Each extension listed in this attribute
will have a set of additional attributes that the applet uses to
specify which version and vendor of the extension it requires.</li>
<li>&lt;extension&gt;-Extension-Name: This attribute is the unique
name of the extension. The Java Plug-in will compare the value of
this attribute with the Extension-Name attribute in the manifests
of installed extensions to determine if the extension is
installed.</li>
<li>&lt;extension&gt;-Specification-Version: This attribute
specifies the minimum extension specification version that is
required by the applet. The Java Plug-in will compare the value of
this attribute with the Specification-Version attribute of the
installed extension to determine if the extension is up to
date.</li>
<li>&lt;extension&gt;-Implementation-Version: This attritute
specifies the minimum extension implementation version number that
is required by the applet. The Java Plug-in will compare the value
of this attribute with the Implementation-Version attribute of the
installed extension to see if a more recent implementation needs to
be downloaded.</li>
<li>&lt;extension&gt;-Implementation-Vendor-Id: This attribute can
be used to identify the vendor of an extension implementation if
the applet requires an implementation from a specific vendor. The
Java Plug-in will compare the value of this attribute with the
Implementation-Vendor-Id attribute of the installed extension.</li>
<li>&lt;extension&gt;-Implementation-URL: This attribute specifies
a URL that can be used to obtain the most recent version of the
extension if the required version is not already installed.</li>
</ul>
</li>
<li>attribute defined for extension identification: This attribute
is used by extensions to define their unique identity.
<ul>
<li>Extension-Name: This attribute specifies a name for the
extension contained in the Jar file. The name should be a unique
identifier such as the name of the main package comprising the
extension.</li>
</ul>
</li>
<li>attributes defined for extension and&nbsp; package <a href=
"../versioning/index.html">versioning</a>&nbsp; and <a href=
"#sealing">sealing</a> information: These
attributes define features of the extension which the JAR file is a
part of. The value of these attributes apply to all the packages in
the JAR&nbsp;file, but can be overridden by per-entry attributes.
<ul>
<li>Implementation-Title: The value is a string that defines the
title of the extension implementation.</li>
<li>Implementation-Version: The value is a string that defines the
version of the extension implementation.</li>
<li>Implementation-Vendor: The value is a string that defines the
organization that maintains the extension implementation.</li>
<li>Implementation-Vendor-Id: <strong>Deprecated: 
This attribute may be ignored in a future release.</strong>
The value is a string id that
uniquely defines the organization that maintains the&nbsp;
extension implementation.</li>
<li>Implementation-URL: <strong>Deprecated: 
This attribute may be ignored in a future release.</strong>
This attribute defines the URL from which
the extension implementation can be downloaded from.</li>
<li>Specification-Title: The value is a string that defines the
title of the extension specification.</li>
<li>Specification-Version: The value is a string that defines the
version of the extension specification.</li>
<li>Specification-Vendor: The value is a string that defines the
organization that maintains the extension specification.</li>
<li>Sealed: This attribute defines whether this JAR file is sealed
or not. The value can be either "true" or "false", case is ignored.
If it is set to "true", then all the packages in the JAR file are
defaulted to be sealed, unless they are defined otherwise
individually.</li>
</ul>
</li>
</ul>
<h3><a name="Per-Entry_Attributes" id=
"Per-Entry_Attributes"></a>Per-Entry Attributes</h3>
Per-entry attributes apply only to the individual JAR file entry to
which the manifest entry is associated with.&nbsp; If the same
attribute also appeared in the main section, then the value of the
per-entry attribute overwrites the main attribute's value. For
example, if JAR file a.jar has the following manifest content:
<pre>
Manifest-Version: 1.0
Created-By: 1.2 (Sun Microsystems Inc.)
Sealed: true
Name: foo/bar/
Sealed: false
</pre>
<p>It means that all the packages archived in a.jar are sealed,
except that package foo.bar is not.</p>
<p>The per-entry attributes fall into the following groups:</p>
<ul>
<li>attributes defined for file contents:
<ul>
<li>Content-Type: This attribute can be used to specify the MIME
type and subtype of data for a specific file entry in the
JAR&nbsp;file. The value should be a string in the form of
<i>type/subtype.</i> For example "image/bmp" is an image type with
a subtype of bmp (representing bitmap). This would indicate the
file entry as an image with the data stored as a bitmap. RFC
<a href="ftp://www.ietf.org/rfc/rfc1521.txt">1521</a> and <a href=
"ftp://www.ietf.org/rfc/rfc1522.txt">1522</a> discuss and define
the MIME types definition.</li>
</ul>
</li>
<li>attributes defined for package versioning and sealing
information: These are the same set of attributes defined above as
main attributes that defines the extension package versioning and
sealing information. When used as per-entry attributes, these
attributes overwrites the main attributes but only apply to the
individual file specified by the manifest entry.</li>
<li>attribute defined for beans objects:
<ul>
<li>Java-Bean: Defines whether the specific jar file entry is a
Java Beans object or not. The value should be either "true" or
"false", case is ignored.</li>
</ul>
</li>
<li>attributes defined for signing: These attributes are used for
signing and verifying purposes. More details here.
<ul>
<li>x-Digest-y: The name of this attribute specifies the name of
the digest algorithm used to compute the digest value for the
corresponding jar file entry. The value of this attribute stores
the actual digest value. The prefix 'x' specifies the algorithm
name and the optional suffix 'y'&nbsp; indicates to which language
the digest value should be verified against.</li>
<li>Magic: This is an optional attribute that can be used by
applications to indicate how verifier should compute the digest
value contained in the manifest entry.&nbsp; The value of this
attribute is a set of comma separated context specific strings.
Detailed description is here.</li>
</ul>
</li>
</ul>
<h2><a name="Signed_JAR_File" id="Signed_JAR_File"></a>Signed JAR
File</h2>
<h3><a name="SignedJar-Overview" id=
"SignedJar-Overview"></a>Overview</h3>
A JAR file can be signed by using the command line <a href=
"../security/SecurityToolsSummary.html">jarsigner</a> tool or
directly through the <code>java.security</code> API. Every file
entry, including non-signature related files in the
<code>META-INF</code> directory, will be signed if the JAR file is
signed by the jarsigner tool. The signature related files are:
<ul>
<li><code>META-INF/MANIFEST.MF</code></li>
<li><code>META-INF/*.SF</code></li>
<li><code>META-INF/*.DSA</code></li>
<li><code>META-INF/*.RSA</code></li>
<li><code>META-INF/SIG-*</code></li>
</ul>
Note that if such files are located in <code>META-INF</code>
subdirectories, they are not considered signature-related.
Case-insensitive versions of these filenames are reserved and will
also not be signed.
<p>Subsets of a JAR file can be signed by using the
<code>java.security</code> API. A signed JAR file is exactly the
same as the original JAR file, except that its manifest is updated
and two additional files are added to the <code>META-INF</code>
directory: a signature file and a signature block file. When
jarsigner is not used, the signing program has to construct both
the signature file and the signature block file.</p>
<p>For every file entry signed in the signed JAR file, an
individual manifest entry is created for it as long as it does not
already exist in the manifest. Each manifest entry lists one or
more digest attributes and an optional <a href=
"#The_Magic_Attribute">Magic attribute</a>.</p>
<h3><a name="Signature_File" id="Signature_File"></a>Signature
File</h3>
Each signer is represented by a signature file with extension
<code>.SF</code>. The major part of the file is similar to the
manifest file. It consists of a main section which includes
information supplied by the signer but not specific to any
particular jar file entry. In addition to the
<code>Signature-Version</code> and <code>Created-By</code>
attributes (see <a href="#Main_Attributes">Main Attributes</a>),
the main section can also include the following security
attributes:
<ul>
<li>x-Digest-Manifest-Main-Attributes (where x is the standard name
of a <code>java.security.MessageDigest</code> algorithm): The value
of this attribute is the digest value of the main attributes of the
manifest.</li>
<li>x-Digest-Manifest (where x is the standard name of a
<code>java.security.MessageDigest</code> algorithm): The value of
this attribute is the digest value of the entire manifest.</li>
</ul>
The main section is followed by a list of individual entries whose
names must also be present in the manifest file. Each individual
entry must contain at least the digest of its corresponding entry
in the manifest file.
<p>Paths or URLs appearing in the manifest file but not in the
signature file are not used in the calculation.</p>
<h3><a name="Signature_Validation" id=
"Signature_Validation"></a>Signature Validation</h3>
A successful JAR file verification occurs if the signature(s) are
valid, and none of the files that were in the JAR file when the
signatures were generated have been changed since then. JAR file
verification involves the following steps:
<ol>
<li>
<p>Verify the signature over the signature file when the manifest
is first parsed. For efficiency, this verification can be
remembered. Note that this verification only validates the
signature directions themselves, not the actual archive files.</p>
</li>
<li>
<p>If an <code>x-Digest-Manifest</code> attribute exists in the
signature file, verify the value against a digest calculated over
the entire manifest. If more than one
<code>x-Digest-Manifest</code> attribute exists in the signature
file, verify that at least one of them matches the calculated
digest value.</p>
</li>
<li>
<p>If an <code>x-Digest-Manifest</code> attribute does not exist in
the signature file or none of the digest values calculated in the
previous step match, then a less optimized verification is
performed:</p>
<ol>
<li>
<p>If an <code>x-Digest-Manifest-Main-Attributes</code> entry
exists in the signature file, verify the value against a digest
calculated over the main attributes in the manifest file. If this
calculation fails, then JAR file verification fails. This decision
can be remembered for efficiency. If an
<code>x-Digest-Manifest-Main-Attributes</code> entry does not exist
in the signature file, its nonexistence does not affect JAR file
verification and the manifest main attributes are not verified.</p>
</li>
<li>
<p>Verify the digest value in each source file information section
in the signature file against a digest value calculated against the
corresponding entry in the manifest file. If any of the digest
values don't match, then JAR file verification fails.</p>
</li>
</ol>
<p>One reason the digest value of the manifest file that is stored
in the <code>x-Digest-Manifest</code> attribute may not equal the
digest value of the current manifest file is that one or more files
were added to the JAR file (using the jar tool) after the signature
(and thus the signature file) was generated. When the jar tool is
used to add files, the manifest file is changed (sections are added
to it for the new files), but the signature file is not. A
verification is still considered successful if none of the files
that were in the JAR file when the signature was generated have
been changed since then, which is the case if the digest values in
the non-header sections of the signature file equal the digest
values of the corresponding sections in the manifest file.</p>
</li>
<li>
<p>For each entry in the manifest, verify the digest value in the
manifest file against a digest calculated over the actual data
referenced in the "Name:" attribute, which specifies either a
relative file path or URL. If any of the digest values don't match,
then JAR file verification fails.</p>
</li>
</ol>
<p>Example manifest file:</p>
<pre>
Manifest-Version: 1.0
Created-By: 1.7.0 (Sun Microsystems Inc.)

Name: common/class1.class
SHA-256-Digest: (base64 representation of SHA-256 digest)

Name: common/class2.class
SHA1-Digest: (base64 representation of SHA1 digest)
SHA-256-Digest: (base64 representation of SHA-256 digest)
</pre>
The corresponding signature file would be:
<pre>
Signature-Version: 1.0
SHA-256-Digest-Manifest: (base64 representation of SHA-256 digest)
SHA-256-Digest-Manifest-Main-Attributes: (base64 representation of SHA-256 digest)

Name: common/class1.class
SHA-256-Digest: (base64 representation of SHA-256 digest)

Name: common/class2.class
SHA-256-Digest: (base64 representation of SHA-256 digest)
</pre>
<h3><a name="The_Magic_Attribute" id="The_Magic_Attribute"></a>The
Magic Attribute</h3>
Another requirement to validate the signature on a given manifest
entry is that the verifier understand the value or values of the
Magic key-pair value in that entry's manifest entry.
<p>The Magic attribute is optional but it is required that a parser
understand the value of an entry's Magic key if it is verifying
that entry's signature.</p>
<p>The value or values of the Magic attribute are a set of
comma-separated context-specific strings. The spaces before and
after the commas are ignored. Case is ignored. The exact meaning of
the magic attributes is application specific. These values indicate
how to compute the hash value contained in the manifest entry, and
are therefore crucial to the proper verification of the signature.
The keywords may be used for dynamic or embedded content, multiple
hashes for multilingual documents, etc.</p>
<p>Here are two examples of the potential use of Magic attribute in
the manifest file:</p>
<pre>
        Name: http://www.example-scripts.com/index#script1
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        Magic: JavaScript, Dynamic

        Name: http://www.example-tourist.com/guide.html
        SHA-256-Digest: (base64 representation of SHA-256 hash)
        SHA-256-Digest-French: (base64 representation of SHA-256 hash)
        SHA-256-Digest-German: (base64 representation of SHA-256 hash)
        Magic: Multilingual
</pre>
<p>In the first example, these Magic values may indicate that the
result of an http query is the script embedded in the document, as
opposed to the document itself, and also that the script is
generated dynamically. These two pieces of information indicate how
to compute the hash value against which to compare the manifest's
digest value, thus comparing a valid signature.</p>
<p>In the second example, the Magic value indicates that the
document retrieved may have been content-negotiated for a specific
language, and that the digest to verify against is dependent on
which language the document retrieved is written in.</p>
<h2><a name="Digital_Signatures" id=
"Digital_Signatures"></a>Digital Signatures</h2>
A digital signature is a signed version of the <code>.SF</code>
signature file. These are binary files not intended to be
interpreted by humans.
<p>Digital signature files have the same filenames as the .SF files
but different extensions. The extension varies depending on the
type of digital signature.</p>
<ul>
<li><code>.RSA</code> (PKCS7 signature, SHA-256 + RSA)</li>
<li><code>.DSA</code> (PKCS7 signature, DSA)</li>
</ul>
Digital signature files for signature algorithms not listed above
must reside in the <code>META-INF</code> directory and have the
prefix "<code>SIG-</code>". The corresonding signature file
(<code>.SF</code> file) must also have the same prefix.
<p>For those formats that do not support external signed data, the
file shall consist of a signed copy of the <code>.SF</code> file.
Thus some data may be duplicated and a verifier should compare the
two files.</p>
<p>Formats that support external data either reference the
<code>.SF</code> file, or perform calculations on it with implicit
reference.</p>
<p>Each <code>.SF</code> file may have multiple digital signatures,
but those signatures should be generated by the same legal
entity.</p>
<p>File name extensions may be 1 to 3 <i>alphanum</i> characters.
Unrecognized extensions are ignored.</p>
<h2><a name="Notes_on_Manifest_and_Signature_Files" id=
"Notes_on_Manifest_and_Signature_Files"></a>Notes on Manifest and
Signature Files</h2>
Following is a list of additional restrictions and rules that apply
to manifest and signature files.
<ul>
<li>Before parsing:
<ul>
<li>If the last character of the file is an EOF character (code
26), the EOF is treated as whitespace. Two newlines are appended
(one for editors that don't put a newline at the end of the last
line, and one so that the grammar doesn't have to special-case the
last entry, which may not have a blank line after it).</li>
</ul>
</li>
<li>Attributes:
<ul>
<li>In all cases for all sections, attributes which are not
understood are ignored.</li>
<li>Attribute names are case insensitive. Programs which generate
manifest and signature files should use the cases shown in this
specification however.</li>
<li>Attribute names cannot be repeated within a section.</li>
</ul>
</li>
<li>Versions:
<ul>
<li>Manifest-Version and Signature-Version must be first, and in
exactly that case (so that they can be recognized easily as magic
strings). Other than that, the order of attributes within a main
section is not significant.</li>
</ul>
</li>
<li>Ordering:
<ul>
<li>The order of individual manifest entries is not
significant.</li>
<li>The order of individual signature entries is not significant,
except that the digests that get signed are in that order.</li>
</ul>
</li>
<li>Line length:
<ul>
<li>No line may be longer than 72 bytes (not characters), in its
UTF8-encoded form. If a value would make the initial line longer
than this, it should be continued on extra lines (each starting
with a single SPACE).</li>
</ul>
</li>
<li>Errors:
<ul>
<li>If a file cannot be parsed according to this spec, a warning
should be output, and none of the signatures should be
trusted.</li>
</ul>
</li>
<li>Limitations:
<ul>
<li>Because header names cannot be continued, the maximum length of
a header name is 70 bytes (there must be a colon and a SPACE after
the name).</li>
<li>NUL, CR, and LF can't be embedded in header values, and NUL,
CR, LF and ":" can't be embedded in header names.</li>
<li>Implementations should support 65535-byte (not character)
header values, and 65535 headers per file. They might run out of
memory, but there should not be hard-coded limits below these
values.</li>
</ul>
</li>
<li>Signers:
<ul>
<li>It is technically possible that different entities may use
different signing algorithms to share a single signature file. This
violates the standard, and the extra signature may be ignored.</li>
</ul>
</li>
<li>Algorithms:
<ul>
<li>No digest algorithm or signature algorithm is mandated by this
standard. However, at least one of MD5 and SHA1&nbsp;digest
algorithm must be supported.</li>
</ul>
</li>
</ul>
<h2><a name="JAR_Index" id="JAR_Index"></a>JAR Index</h2>
<h3><a name="Overview" id="Overview"></a>Overview</h3>
Since 1.3, JarIndex is introduced to optimize the class searching
process of class loaders for network applications, especially
applets. Originally, an applet class loader uses a simple linear
search algorithm to search each element on its internal search
path, which is constructed from the "ARCHIVE" tag or the
"Class-Path" main attribute. The class loader downloads and opens
each element in its search path, until the class or resource is
found. If the class loader tries to find a nonexistent resource,
then all the jar files within the application or applet will have
to be downloaded. For large network applications and applets this
could result in slow startup, sluggish response and wasted network
bandwidth. The JarIndex mechanism collects the contents of all the
jar files defined in an applet and stores the information in an
index file in the first jar file on the applet's class path. After
the first jar file is downloaded, the applet class loader will use
the collected content information for efficient downloading of jar
files.
<p>The existing <tt>jar</tt> tool is enhanced to be able to examine
a list of jar files and generate directory information as to which
classes and resources reside in which jar file. This directory
information is stored in a simple text file named
<tt>INDEX.LIST</tt> in the <tt>META-INF</tt> directory of the root
jar file. When the classloader loads the root jar file,&nbsp; it
reads the <tt>INDEX.LIST</tt> file and uses it to construct a hash
table of mappings from file and package names to lists of jar file
names. In order to find a class or a resource, the class loader
queries the hashtable to find the proper jar file and then
downloads it if necessary.</p>
<p>Once the class loader finds a <tt>INDEX.LIST</tt> file in a
particular jar file, it always trusts the information listed in it.
If a mapping is found for a particular class, but the class loader
fails to find it by following the link, an InvalidJarIndexException
is thrown. When this occurs, the application developer should rerun
the <tt>jar</tt> tool on the extension to get the right information
into the index file.</p>
<p>To prevent adding too much space overhead to the application and
to speed up the construction of the in-memory hash table, the
INDEX.LIST file is kept as small as possible. For classes with
non-null package names, mappings are recorded at the package level.
Normally one package name is mapped to one jar file, but if a
particular package spans more than one jar file, then the mapped
value of this package will be a list of jar files. For resource
files with non-empty directory prefixes, mappings are also recorded
at the directory level.&nbsp; Only for classes with null package
name, and resource files which reside in the root directory, will
the mapping be recorded at the individual file level.</p>
<h3><a name="Index_File_Specification" id=
"Index_File_Specification"></a>Index File Specification</h3>
The <tt>INDEX.LIST</tt> file contains one or more sections each
separated by a single blank line. Each section defines the content
of a particular jar file, with a header defining the jar file path
name, followed by a list of package or file names, one per
line.&nbsp; All the jar file paths are relative to the code base of
the root jar file. These path names are resolved in the same way as
the current extension mechanism does for bundled extensions.
<p>The UTF-8 encoding is used to support non ASCII characters in
file or package names in the index file.<br />
&nbsp;</p>
<h4>Specification</h4>
&nbsp;&nbsp;&nbsp; <i>index file
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
version-info blankline section*</i><br />
<i>&nbsp;&nbsp;&nbsp; version-info
:&nbsp;</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt>JarIndex-Version:</tt> <i>version-number</i><br />
<i>&nbsp;&nbsp;&nbsp; version-number
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
digit+{.digit+}*</i><br />
<i>&nbsp;&nbsp;&nbsp; section
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
body blankline</i><br />
<i>&nbsp;&nbsp;&nbsp; body
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
header name*</i><br />
<i>&nbsp;&nbsp;&nbsp; header
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
char+</i><tt>.jar</tt> <i>newline</i><br />
<i>&nbsp;&nbsp;&nbsp; name
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
char+ newline</i><br />
<i>&nbsp;&nbsp;&nbsp; char
:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
any valid Unicode character except</i> <tt>NULL, CR</tt>
<i>and</i><tt>LF</tt><br />
&nbsp;&nbsp;&nbsp;
<i>blankline:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
newline newline</i><br />
<i>&nbsp;&nbsp;&nbsp; newline
:&nbsp;</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
<tt>CR LF | LF | CR</tt> (<i>not followed by</i> <tt>LF</tt>)<br />
&nbsp;&nbsp;&nbsp;
<i>digit:&nbsp;</i>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
{<tt>0-9</tt>}<br />
&nbsp;<br />
The <tt>INDEX.LIST</tt> file is generated by running <tt>jar
-i.</tt> See the <a href="../../tools/windows/jar.html">jar</a> man
page for more details.
<h3><a name="Backward_Compatibility" id=
"Backward_Compatibility"></a>Backward Compatibility</h3>
The new class loading scheme is totally backward compatible with
applications developed on top of the current extension
mechanism.&nbsp; When the class loader loads the first jar file and
an <tt>INDEX.LIST</tt> file is found in the <tt>META-INF</tt>
directory, it would construct the index hash table and use the new
loading scheme for the extension. Otherwise, the class loader will
simply use the original linear search algorithm.
<h2><a name="Service_Provider" id="Service_Provider"></a>Service
Provider</h2>
<h3><a name="Service_Provider_Overview" id=
"Service_Provider_Overview"></a>Overview</h3>
<p>Files in the <tt>META-INF/services</tt> directory are service
provider configuration files. A service is a well-known set of
interfaces and (usually abstract) classes. A service provider is a
specific implementation of a service. The classes in a provider
typically implement the interfaces and subclass the classes defined
in the service itself. Service providers may be installed in an
implementation of the Java platform in the form of extensions, that
is, jar files placed into any of the usual extension directories.
Providers may also be made available by adding them to the applet
or application class path or by some other platform-specific
means.</p>
<p>A service is represented by an abstract class. A provider of a
given service contains one or more concrete classes that extend
this service class with data and code specific to the provider.
This provider class will typically not be the entire provider
itself but rather a proxy that contains enough information to
decide whether the provider is able to satisfy a particular request
together with code that can create the actual provider on demand.
The details of provider classes tend to be highly service-specific;
no single class or interface could possibly unify them, so no such
class has been defined. The only requirement enforced here is that
provider classes must have a zero-argument constructor so that they
may be instantiated during lookup.</p>
<h3><a name="Provider_Configuration_File" id=
"Provider_Configuration_File"></a>Provider-Configuration File</h3>
<p>A service provider identifies itself by placing a
provider-configuration file in the resource directory
<tt>META-INF/services</tt>. The file's name should consist of the
fully-qualified name of the abstract service class. The file should
contain a newline-separated list of unique concrete provider-class
names. Space and tab characters, as well as blank lines, are
ignored. The comment character is '#' (0x23); on each line all
characters following the first comment character are ignored. The
file must be encoded in UTF-8.</p>
<h3><a name="Example" id="Example"></a>Example</h3>
Suppose we have a service class named java.io.spi.CharCodec. It has
two abstract methods:
<ul>
<li><code>public abstract CharEncoder getEncoder(String
encodingName);</code></li>
<li><code>public abstract CharDecoder getDecoder(String
encodingName);</code></li>
</ul>
<p>Each method returns an appropriate object or null if it cannot
translate the given encoding. Typical CharCodec providers will
support more than one encoding.</p>
<p>If sun.io.StandardCodec is a provider of the CharCodec service
then its jar file would contain the file
<tt>META-INF/services/java.io.spi.CharCodec</tt>. This file would
contain the single line:</p>
<pre>
sun.io.StandardCodec    # Standard codecs for the platform
</pre>
<p>To locate an encoder for a given encoding name, the internal I/O
code would do something like this:</p>
<pre>
   CharEncoder getEncoder(String encodingName) {
       Iterator ps = Service.providers(CharCodec.class);
       while (ps.hasNext()) {
           CharCodec cc = (CharCodec)ps.next();
           CharEncoder ce = cc.getEncoder(encodingName);
           if (ce != null)
               return ce;
       }
       return null;
   }
</pre>
<p>The provider-lookup mechanism always executes in the security
context of the caller. Trusted system code should typically invoke
the methods in this class from within a privileged security
context.</p>

<a name="classpath" id="classpath"></a>
<h2>Class-Path Attribute</h2>

<p>The manifest for an application can specify one or more relative URLs
referring to the JAR files and directories for other libraries that it requires.
These relative URLs are treated relative to the code base from which
the containing application was loaded.</p>

<p>An application (or, more generally, a JAR file) specifies the
relative URLs of the libraries that it requires with the manifest attribute
<code>Class-Path</code>. This attribute lists the URLs to search for 
implementations of other libraries if they cannot be found 
on the host Java virtual machine.
These
relative URLs may include JAR files and directories for any
libraries or resources needed by the application. Relative URLs 
not ending with a slash (<code>/</code>) are assumed to refer to JAR files. For example:</p>

<pre>Class-Path: servlet.jar infobus.jar acme/beans.jar images/</pre>

<p>At most one <code>Class-Path</code> header may be specified in a JAR
file's manifest.</p>

<p>Currently, the URLs must be <em>relative</em> to the code base of
the JAR file for security reasons. Thus, remote optional packages will
originate from the same code base as the application.</p>

<p>Each relative URL is resolved against the code base from which the
containing application or library was loaded. If the
resulting URL is invalid or refers to a resource that cannot be
found, then it is ignored.</p>

<p>The resulting URLs are used to extend the class path for the
application, applet, or servlet by inserting the URLs in the class
path immediately following the URL of the containing JAR file. Any
duplicate URLs are omitted. For example, given the following class
path:</p>

<pre>a.jar b.jar</pre>

<p>Suppose <code>b.jar</code> contained the following
<code>Class-Path</code> manifest attribute:</p>

<pre>Class-Path: x.jar a.jar</pre>

<p>As a result, the resulting application class path would be the following:</p>

<pre>a.jar b.jar x.jar</pre>

<p>If <code>x.jar</code> had dependencies of its own, then these
would be added according to the same rules for each
subsequent URL. In the actual implementation, JAR file dependencies
are processed lazily so that the JAR files are not opened
until needed.</p>

<a name="sealing" id="sealing"></a>
<h2>Package Sealing</h2>

<p>JAR files and packages can be optionally <em>sealed</em> so that an
package can enforce consistency within a version.</p>

<p>A package sealed within a JAR specifies that all classes defined
in that package must originate from the same JAR. Otherwise, a
<code>SecurityException</code> is thrown.</p>

<p>A sealed JAR specifies that all packages defined by that JAR are
sealed unless overridden specifically for a package.</p>

<p>A sealed package is specified through the manifest attribute,
<code>Sealed</code>, whose value is <code>true</code> or <code>false</code>
(case irrelevant). For example:</p>

<pre>Name: javax/servlet/internal/
Sealed: true</pre>

<p>This specifies that the <code>javax.servlet.internal</code> package is
sealed, and that all classes in that package must be loaded from
the same JAR file.</p>

<p>If this attribute is missing, then the package sealing attribute is
that of the containing JAR file.</p>

<p>A sealed JAR is specified via the same manifest header,
<code>Sealed</code>, with the value again of either <code>true</code> or
<code>false</code>. For example:</p>

<pre>Sealed: true</pre>

<p>This specifies that all packages in this archive are sealed unless
explicitly overridden for a particular package with the
<code>Sealed</code> attribute in a manifest entry.</p>

<p>If this attribute is missing, the JAR file is assumed to
<em>not</em> be sealed, for backwards compatibility. The system then
defaults to examining package headers for sealing information.</p>

<p>Package sealing is also important for security because it
restricts access to package-protected members to only those classes
defined in the package that originated from the same JAR file.</p>

<p>An unnamed package is not sealable, so classes
that are to be sealed must be placed in their own packages.</p> 

<h2><a name="API_Details" id="API_Details"></a>API Details</h2>
 
<p>Package <a href=
"../../../api/java/util/jar/package-summary.html">java.util.jar</a></p>
 
<h2><a name="See_Also" id="See_Also"></a>See Also</h2>

<p>Package <a href=
"../../../api/java/security/package-summary.html">java.security</a></p>

<p>Package <a href=
"../../../api/java/util/zip/package-summary.html">java.util.zip</a></p>

<!-- Body text ends here -->

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
