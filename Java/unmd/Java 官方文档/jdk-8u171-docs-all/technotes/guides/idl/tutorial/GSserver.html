<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>Getting Started with Java IDL: Developing the Hello World
Server</title>
<link rel="stylesheet" type="text/css" href="../../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>Getting Started with Java IDL:<br />
Developing the Hello World Server</h1>
<p>The example server consists of two classes, the servant and the
server. The servant, <tt>HelloImpl</tt>, is the implementation of
the <tt>Hello</tt> IDL interface; each <tt>Hello</tt> instance is
implemented by a <tt>HelloImpl</tt> instance. The servant is a
subclass of <tt>HelloPOA</tt>, which is generated by the
<tt>idlj</tt> compiler from the example IDL.</p>
<p>The servant contains one method for each IDL operation, in this
example, the <tt>sayHello()</tt> and <tt>shutdown()</tt> methods.
Servant methods are just like ordinary Java methods; the extra code
to deal with the ORB, with marshaling arguments and results, and so
on, is provided by the skeleton.</p>
<p>The server class has the server's <tt>main()</tt> method,
which:</p>
<ul>
<li>Creates and initializes an ORB instance</li>
<li>Gets a reference to the root POA and activates the
<tt>POAManager</tt></li>
<li>Creates a servant instance (the implementation of one CORBA
<tt>Hello</tt> object) and tells the ORB about it</li>
<li>Gets a CORBA object reference for a naming context in which to
register the new CORBA object</li>
<li>Gets the root naming context</li>
<li>Registers the new object in the naming context under the name
"Hello"</li>
<li>Waits for invocations of the new object from the client</li>
</ul>
<p>This lesson introduces the basics of writing a CORBA server. For
an example of the "Hello World" program with a persistent object
server, see <a href="../jidlExample2.html"><em>Example 2: Hello
World with Persistent State</em></a>. For more discussion of CORBA
servers, see <a href="../jidlServers.html"><em>Developing
Servers</em></a>.</p>
<p>The steps in this lesson cover:</p>
<ol>
<li><a href="#create">Creating HelloServer.java</a></li>
<li><a href="#understand">Understanding HelloServer.java</a></li>
<li><a href="#compile">Compiling the Hello World Server</a></li>
</ol>
<hr />
<h2><a name="create" id="create">Creating HelloServer.java</a></h2>
<p>To create <tt>HelloServer.java</tt>,</p>
<ol>
<li>Start your text editor and create a file named
<tt>HelloServer.java</tt> in your main project directory,
<tt>Hello</tt>.</li>
<li>Enter the following code for <tt>HelloServer.java</tt> in the
text file. The following section, <a href=
"#understand">Understanding HelloServer.java</a>, explains each
line of code in some detail.
<pre class="codeblock">
// <strong>HelloServer.java</strong>
import HelloApp.*;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;
import org.omg.PortableServer.*;
import org.omg.PortableServer.POA;

import java.util.Properties;

class HelloImpl extends HelloPOA {
  private ORB orb;

  public void setORB(ORB orb_val) {
    orb = orb_val; 
  }
    
  // implement sayHello() method
  public String sayHello() {
    return "\nHello world !!\n";
  }
    
  // implement shutdown() method
  public void shutdown() {
    orb.shutdown(false);
  }
}


public class HelloServer {

  public static void main(String args[]) {
    try{
      // create and initialize the ORB
      ORB orb = ORB.init(args, null);

      // get reference to rootpoa and activate the POAManager
      POA rootpoa = POAHelper.narrow(orb.resolve_initial_references("RootPOA"));
      rootpoa.the_POAManager().activate();

      // create servant and register it with the ORB
      HelloImpl helloImpl = new HelloImpl();
      helloImpl.setORB(orb); 

      // get object reference from the servant
      org.omg.CORBA.Object ref = rootpoa.servant_to_reference(helloImpl);
      Hello href = HelloHelper.narrow(ref);
          
      // get the root naming context
      org.omg.CORBA.Object objRef =
          orb.resolve_initial_references("NameService");
      // Use NamingContextExt which is part of the Interoperable
      // Naming Service (INS) specification.
      NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);

      // bind the Object Reference in Naming
      String name = "Hello";
      NameComponent path[] = ncRef.to_name( name );
      ncRef.rebind(path, href);

      System.out.println("HelloServer ready and waiting ...");

      // wait for invocations from clients
      orb.run();
    } 
        
      catch (Exception e) {
        System.err.println("ERROR: " + e);
        e.printStackTrace(System.out);
      }
          
      System.out.println("HelloServer Exiting ...");
        
  }
}
&nbsp;
</pre></li>
<li>Save and close <tt>HelloServer.java</tt>.</li>
</ol>
<!--**********************************-->
<hr />
<h2><a name="understand" id="understand">Understanding
HelloServer.java</a></h2>
<p>This section explains each line of <tt>HelloServer.java</tt>,
describing what the code does, as well as why it is needed for this
application.</p>
<h3><a name="setup" id="setup">Performing Basic Setup</a></h3>
<p>The structure of a CORBA server program is the same as most Java
applications:&nbsp;You import required library packages, declare
the server class, define a <tt>main()</tt> method, and handle
exceptions.</p>
<h4><a name="import" id="import">Importing Required
Packages</a></h4>
<p>First, we import the packages required for the server class:</p>
<pre class="codeblock">
// The package containing our stubs
import HelloApp.*;

// HelloServer will use the naming service
import org.omg.CosNaming.*;

// The package containing special exceptions thrown by the name service
import org.omg.CosNaming.NamingContextPackage.*;

// All CORBA applications need these classes
import org.omg.CORBA.*;

// Classes needed for the Portable Server Inheritance Model
import org.omg.PortableServer.*;
import org.omg.PortableServer.POA;

// Properties to initiate the ORB
import java.util.Properties;
</pre>
<h4><a name="helloservant" id="helloservant">Defining the Servant
Class</a></h4>
<p>In this example, we are defining the class for the servant
object within <tt>HelloServer.java</tt>, but outside the
<tt>HelloServer</tt> class.</p>
<pre class="codeblock">
class HelloImpl extends HelloPOA
{
  // The sayHello() and shutdown() methods go here.
}
</pre>
<p>The servant is a subclass of <tt>HelloPOA</tt> so that it
inherits the general CORBA functionality generated for it by the
compiler.</p>
<p>First, we create a private variable, <code>orb</code> that is
used in the <code>setORB(ORB)</code> method. The <tt>setORB</tt>
method is a private method defined by the application developer so
that they can set the ORB value with the servant. This ORB value is
used to invoke <tt>shutdown()</tt> on that specific ORB in response
to the <tt>shutdown()</tt> method invocation from the client.</p>
<pre class="codeblock">
  private ORB orb;
  
  public void setORB(ORB orb_val) {
    orb = orb_val; 
  }
</pre>
<p>Next, we declare and implement the required <tt>sayHello()</tt>
method:</p>
<pre class="codeblock">
  public String sayHello()
  {
    return "\nHello world!!\n";   
  }
</pre>
<p>And last of all, we implement the <code>shutdown()</code> method
in a similar way. The <code>shutdown()</code> method calls the
<code>org.omg.CORBA.ORB.shutdown(boolean)</code> method for the
ORB. The <code>shutdown(false)</code> operation indicate that the
ORB should shut down immediately, without waiting for processing to
complete.</p>
<pre class="codeblock">
  public void shutdown() {
    orb.shutdown(false);
  }
</pre>
<h4><a name="class" id="class">Declaring the Server Class</a></h4>
<p>The next step is to declare the server class:</p>
<pre class="codeblock">
public class HelloServer 
{
  // The main() method goes here.
}
</pre>
<h4><a name="main" id="main">Defining the main() Method</a></h4>
<p>Every Java application needs a <tt>main</tt> method. It is
declared within the scope of the <tt>HelloServer</tt> class:</p>
<pre class="codeblock">
  public static void main(String args[])
  {
    // The try-catch block goes here.
  }
</pre>
<h4><a name="except" id="except">Handling CORBA System
Exceptions</a></h4>
<p>Because all CORBA programs can throw CORBA system exceptions at
runtime, all of the <tt>main()</tt> functionality is placed within
a try-catch block. CORBA programs throw runtime exceptions whenever
trouble occurs during any of the processes (marshaling,
unmarshaling, upcall) involved in invocation. The exception handler
simply prints the exception and its stack trace to standard output
so you can see what kind of thing has gone wrong.</p>
<p>The try-catch block is set up inside <tt>main()</tt>, as
shown:</p>
<pre class="codeblock">
    try{
    
      // The rest of the HelloServer code goes here.
    
    } catch(Exception e) {
        System.err.println("ERROR: " + e);
        e.printStackTrace(System.out);
      }
</pre>
<!--************************************************-->
<h3><a name="orb" id="orb">Creating and Initializing an ORB
Object</a></h3>
<p>A CORBA server needs a local ORB object, as does the CORBA
client. Every server instantiates an ORB and registers its <a href=
"../jidlGlossary.html#servant__object">servant objects</a> so that
the ORB can find the server when it receives an invocation for
it.</p>
<p>The ORB variable is declared and initialized inside the
try-catch block.</p>
<pre class="codeblock">
      ORB orb = ORB.init(args, null);
</pre>
<p>The call to the ORB's <tt>init()</tt> method passes in the
server's command line arguments, allowing you to set certain
properties at runtime. 
<!--************************************************--></p>
<h3><a name="poaref" id="poaref">Get a Reference to the Root POA
and Activate the <tt>POAManager</tt></a></h3>
<p>The ORB obtains the initial object references to services such
as the Name Service using the method
<code>resolve_initial_references</code>.</p>
<p>The reference to the root POA is retrieved and the
<tt>POAManager</tt> is activated from within the try-catch
block.</p>
<pre class="codeblock">
      POA rootpoa = POAHelper.narrow(orb.resolve_initial_references("RootPOA"));
      rootpoa.the_POAManager().activate();
</pre>
<p>The <code>activate()</code> operation changes the state of the
POA manager to active, causing associated POAs to start processing
requests. The POA manager encapsulates the processing state of the
POAs with which it is associated. Each <code>POA</code> object has
an associated <code>POAManager</code> object. A POA manager may be
associated with one or more POA objects. 
<!--**********************************--></p>
<h3><a name="servantobject" id="servantobject">Managing the Servant
Object</a></h3>
A <a href="../jidlGlossary.html#server">server</a> is a process
that instantiates one or more servant objects. The <a href=
"../jidlGlossary.html#servant__object">servant</a> inherits from
the interface generated by <tt>idlj</tt> and actually performs the
work of the operations on that interface. Our <tt>HelloServer</tt>
needs a <tt>HelloImpl</tt>.
<h4><a name="servant" id="servant">Instantiating the Servant
Object</a></h4>
<p>We instantiate the servant object inside the try-catch block,
just after activating the POA manager, as shown:</p>
<pre class="codeblock">
      HelloImpl helloImpl = new HelloImpl();
</pre>
<p>The section of code describing the servant class was explained
previously.</p>
<p>In the next line of code, <tt>setORB(orb)</tt> is defined on the
servant so that <tt>ORB.shutdown()</tt> can be called as part of
the shutdown operation. This step is required because of the
<tt>shutdown()</tt> method defined in <tt>Hello.idl</tt>.</p>
<pre class="codeblock">
      helloImpl.setORB(orb); 
</pre>
<p>There are other options for implementing the shutdown operation.
In this example, the <tt>shutdown()</tt> method called on the
<tt>Object</tt> takes care of shutting down an ORB. In another
implementation, the shutdown method implementation could have
simply set a flag, which the server could have checked and called
<tt>shutdown()</tt>.</p>
<p>The next set of code is used to get the object reference
associated with the servant. The <tt>narrow()</tt> method is
required to cast CORBA <a href=
"../jidlGlossary.html#object__reference">object references</a> to
their proper types.</p>
<pre class="codeblock">
      org.omg.CORBA.Object ref = rootpoa.servant_to_reference(helloImpl);
      Hello href = HelloHelper.narrow(ref);
</pre>
<!--*********************************************-->
<h3><a name="namingservice" id="namingservice">Working with COS
Naming</a></h3>
<p>The <tt>HelloServer</tt> works with the Common Object Services
(COS) Naming Service to make the servant object's operations
available to clients. The server needs an object reference to the
naming service so that it can publish the references to the objects
implementing various interfaces. These object references are used
by the clients for invoking methods. Another way a servant can make
the objects available to clients for invocations is by stringifying
the object references to a file.</p>
<p>The two options for Naming Services are:</p>
<ul>
<li><tt>orbd</tt> (<a href="../../../tools/unix/orbd.html">Solaris, Linux, or Mac OS X</a>
or <a href="../../../tools/unix/orbd.html">Windows</a>), which
includes both a Transient Naming Service and a Persistent Naming
Service, in addition to a Server Manager.</li>
<li><tt>tnameserv</tt> (<a href=
"../../../tools/unix/tnameserv.html">Solaris, Linux, or Mac OS X</a> or <a href=
"../../../tools/windows/tnameserv.html">Windows</a>) - a Transient
Naming Service.</li>
</ul>
<p>This example uses <tt>orbd</tt>.</p>
<h4><a name="rootnc" id="rootnc">Obtaining the Initial Naming
Context</a></h4>
<p>In the try-catch block, below getting the object reference for
the servant, we call <tt>orb.resolve_initial_references()</tt> to
get an object reference to the name server:</p>
<pre class="codeblock">
      org.omg.CORBA.Object objRef =
          orb.resolve_initial_references("NameService");
</pre>
<p>The string "NameService" is defined for all CORBA ORBs. When you
pass in that string, the ORB returns a naming context object that
is an object reference for the name service. The string
"NameService" indicates:</p>
<ul>
<li>The naming service will be persistent when using ORBD's naming
service, as we do in this example.</li>
<li>The naming service will be transient when using
<tt>tnameserv</tt>.</li>
</ul>
<p>The proprietary string "TNameService" indicates that the naming
service will be transient when using ORBD's naming service.</p>
<h4><a name="narrow" id="narrow">Narrowing the Object
Reference</a></h4>
<p>As with all CORBA object references, <tt>objRef</tt> is a
generic CORBA object. To use it as a <tt>NamingContextExt
object</tt>, you must narrow it to its proper type. The call to
<tt>narrow()</tt> is just below the previous statement:</p>
<pre class="codeblock">
      NamingContextExt ncRef = NamingContextExtHelper.narrow(objRef);
</pre>
<p>Here you see the use of an <tt>idlj</tt>-generated helper class,
similar in function to <tt>HelloHelper</tt>. The <tt>ncRef</tt>
object is now an <tt>org.omg.CosNaming.NamingContextExt</tt> and
you can use it to access the naming service and register the
server, as shown in the next topic.</p>
<p>The <tt>NamingContextExt object</tt> is part of the <a href=
"../jidlNaming.html#INS">Interoperable Naming Service</a>
specification.</p>
<h4><a name="naming" id="naming">Registering the Servant with the
Name Server</a></h4>
<p>Just below the call to <tt>narrow()</tt>, we create a new
<tt>NameComponent</tt> array. Because the path to <tt>Hello</tt>
has a single element, we create the single-element array that
<tt>NamingContext.resolve</tt> requires for its work:</p>
<pre class="codeblock">
      String name = "Hello";
      NameComponent path[] = ncRef.to_name( name );
</pre>
<p>Finally, we pass <tt>path</tt> and the servant object to the
naming service, binding the servant object to the "Hello" id:</p>
<pre class="codeblock">
      ncRef.rebind(path, href);
</pre>
<p>Now, when the client calls <tt>resolve("Hello")</tt> on the
initial naming context, the naming service returns an object
reference to the <tt>Hello</tt> servant.</p>
<p><!--**************************************--></p>
<h3><a name="invoke" id="invoke">Waiting for Invocation</a></h3>
<p>The previous sections describe the code that makes the server
ready; the next section explains the code that enables it to simply
wait around for a client to request its service. The following
code, which is at the end of (but within) the try-catch block,
shows how to accomplish this.</p>
<pre class="codeblock">
      orb.run();
</pre>
<p>When called by the main thread, <tt>ORB.run()</tt> enables the
ORB to perform work using the main thread, waiting until an
invocation comes from the ORB. Because of its placement in
<tt>main()</tt>, after an invocation completes and
<tt>sayHello()</tt> returns, the server will wait again. This is
the reason that the <code>HelloClient</code> explicitly shuts down
the ORB after completing its task.</p>
<hr />
<!--**************************************************-->
<h2><a name="compile" id="compile">Compiling the Hello World
Server</a></h2>
<p>Now we will compile the <tt>HelloServer.java</tt> so that we can
correct any errors before continuing with this tutorial.</p>
<p>Windows users note that you should substitute backslashes (\)
for the slashes (/) in all paths in this document.</p>
<p>To compile <tt>HelloServer.java</tt>,</p>
<ol>
<li>Change to the <tt>Hello</tt> directory.</li>
<li>Run the Java compiler on <tt>HelloServer.java</tt>:
<pre class="codeblock">
javac HelloServer.java HelloApp/*.java
</pre></li>
<li>Correct any errors in your file and recompile if
necessary.</li>
<li>The files <tt>HelloServer.class</tt> and
<tt>HelloImpl.class</tt> are generated in the <tt>Hello</tt>
directory.</li>
</ol>
<h3><a name="running" id="running">Running the Hello World
Server</a></h3>
<p><a href="GScompile.html">Running the Hello World Application</a>
discusses running <tt>HelloServer</tt> and the rest of the
application.</p>
<hr />
<p><!--**************************************--></p>
<h1><a name="models" id="models">Understanding The Server-Side
Implementation Models</a></h1>
<p>CORBA supports at least two different server-side mappings for
implementing an IDL interface:</p>
<ul>
<li>The Inheritance Model
<p>Using the Inheritance Model, you implement the IDL interface
using an implementation class that also extends the
compiler-generated skeleton.</p>
<p>Inheritance models include:</p>
<ul>
<li>The OMG-standard, <em>POA</em>. Given an interface <tt>My</tt>
defined in <tt>My.idl</tt>, the file <tt>MyPOA.java</tt> is
generated by the <tt>idlj</tt> compiler. You must provide the
implementation for <tt>My</tt> and it must inherit from
<tt>MyPOA</tt>, a stream-based skeleton that extends <a href=
"../../../../api/org/omg/PortableServer/Servant.html"><tt>org.omg.PortableServer.Servant</tt></a>,
which serves as the base class for all POA servant implementations.
<p>The default server-side mapping generated when either the
<tt>-fall</tt> or <tt>-fserver</tt> arguments are used conform to
Chapter 11, <em>Portable Object Adapter</em> (POA) of the CORBA
2.3.1 Specification (<a href=
"http://www.omg.org/cgi-bin/doc?formal/99-10-07">formal/99-10-07</a>).
For more information on the POA, see <a href="../POA.html">Portable
Object Adapter</a>.</p>
<p>The advantages of using the Portable Object Adaptor (POA)
are:</p>
<ul>
<li>Allow programmers to construct object implementations that are
portable between different ORB products.</li>
<li>Provide support for objects with persistent identities.</li>
<li>Provide support for transparent activation of objects.</li>
<li>Allow a single servant to support multiple object identities
simultaneously.</li>
</ul>
</li>
<li><em>ImplBase</em>. Given an interface <tt>My</tt> defined in
<tt>My.idl</tt>, the file <tt>_MyImplBase.java</tt> is generated.
You must provide the implementation for <tt>My</tt> and it must
inherit from <tt>_MyImplBase</tt>.
<p><strong>NOTE: ImplBase is obsoleted in favor of the POA model,
but is provided to allow compatibility with servers written in J2SE
1.3 and prior. We do not recommend creating new servers using this
nonstandard model.</strong></p>
</li>
</ul>
</li>
<li>The Delegation Model
<p>Using the Delegation Model, you implement the IDL interface
using two classes:</p>
<ul>
<li>An IDL-generated Tie class that inherits from the
compiler-generated skeleton, but delegates all calls to an
implementation class.</li>
<li>A class that implements the IDL-generated operations interface
(such as <tt>HelloOperations</tt>), which defines the IDL
function.</li>
</ul>
<p>The Delegation model is also known as the <em>Tie</em> model, or
the Tie Delegation model. It inherits from either the POA or
ImplBase compiler-generated skeleton, so the models will be
described as POA/Tie or ImplBase/Tie models in this document.</p>
</li>
</ul>
<p>This tutorial presents the POA Inheritance model for server-side
implementation. For tutorials using the other server-side
implementations, see the following documents:</p>
<ul>
<li><a href="../jidlTieServer.html"><em>Java IDL: The "Hello World"
Example with the POA/Tie Server-Side Model</em></a>
<p>You might want to use the Tie model instead of the typical
Inheritance model if your implementation must inherit from some
other implementation. Java allows any number of interface
inheritance, but there is only one slot for class inheritance. If
you use the inheritance model, that slot is used up . By using the
Tie Model, that slot is freed up for your own use. The drawback is
that it introduces a level of indirection: one extra method call
occurs when invoking a method.</p>
</li>
<li><a href="../jidlImplBaseServer.html"><em>Java IDL: The "Hello
World" Example with the ImplBase Server-Side Model</em></a>
<p>The ImplBase server-side model is an Inheritance Model, as is
the POA model. Use the <tt>idlj</tt> compiler with the
<tt>-oldImplBase</tt> flag to generate server-side bindings that
are compatible with older version of Java IDL (prior to J2SE
1.4).</p>
<p><strong>Note that using the <tt>-oldImplBase</tt> flag is
non-standard: these APIs are obsoleted. You would use this flag
ONLY for compatibility with existing servers written in J2SE 1.3 or
earlier. In that case, you would need to modify an existing
MAKEFILE to add the <tt>-oldImplBase</tt> flag to the <tt>idlj</tt>
compiler, otherwise POA-based server-side mappings will be
generated.</strong></p>
</li>
</ul>
<hr />
<!--**************************************-->
<h2><a name="information" id="information">For More
Information</a></h2>
<dl>
<dt><a href=
"../jidlExceptions.html#systemexceptions"><em>Exceptions: System
Exceptions</em></a></dt>
<dd>Explains how CORBA system exceptions work and provides details
on the minor codes of Java&nbsp;IDL's system exceptions</dd>
<dt><a href="../jidlServers.html"><em>Developing
Servers</em></a></dt>
<dd>Covers topics of interest to CORBA server programmers</dd>
<dt><a href="../jidlNaming.html"><em>Java IDL Naming
Service</em></a></dt>
<dd>Covers the COS Naming Service in greater detail</dd>
</dl>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
