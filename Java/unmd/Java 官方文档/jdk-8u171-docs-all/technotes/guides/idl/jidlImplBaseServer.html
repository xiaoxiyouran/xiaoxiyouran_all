<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>Java IDL: The "Hello World" Example With The ImplBase
Server-Side Model</title>
<link rel="stylesheet" type="text/css" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>Java IDL: The "Hello World" Example With The ImplBase
Server-Side Model</h1>
<p>This document is a high-level overview of how to create a
complete CORBA (Common Object Request Broker Architecture)
application using IDL (Interface Definiton Language) to define
interfaces and the Java IDL compiler to generate stubs and
skeletons. This document describes using the ImplBase Inheritance
Server-Side Model.</p>
<p>The <tt>idlj</tt> compiler now generates server-side mappings
based on the POA Inheritance Model as the default. For
compatibility with existing applications, a new flag has been added
to the <tt>idlj</tt> compiler to allow it to generate server-side
mappings based on the ImplBase Inheritance Model,
<tt>-oldImplBase</tt>.</p>
<p><strong>NOTE: ImplBase is deprecated in favor of the POA model,
but is provided to allow compatibility with servers written in J2SE
1.3 and prior. We do not recommend creating new servers using this
nonstandard model.</strong></p>
<p>This document contains:</p>
<ul>
<li>The <a href="#IDL">IDL</a> for a simple "Hello World"
program</li>
<li>A <a href="#server">server</a> that creates an object and
publishes it with a naming service using the ImplBase server-side
implementation</li>
<li>An <a href="#application">application client</a> that knows the
object's name, retrieves a reference for it from the naming
service, and invokes the object</li>
<li><a href="#instructions">Instructions</a> for compiling and
running the example</li>
</ul>
<h2><a name="IDL" id="IDL">Defining the Interface
(<code>Hello.idl</code>)</a></h2>
<p>The first step to creating a CORBA application is to specify all
of your objects and their interfaces using the OMG's Interface
Definition Language (IDL). IDL has a syntax similar to C++ and can
be used to define modules, interfaces, data structures, and more.
The IDL can be mapped to a variety of programming languages. The
IDL mapping for Java is summarized in <a href=
"mapping/jidlMapping.html">IDL to Java Language Mapping
Summary</a>.</p>
<p>The following code is written in the OMG IDL, and describes a
CORBA object whose <tt>sayHello()</tt> operation returns a string
and whose <tt>shutdown()</tt> operation shuts down the ORB. To
learn more about OMG IDL Syntax and Semantics, link to the OMG Web
site, and read Chapter 3 of the <a href=
"http://www.omg.org/cgi-bin/doc?formal/99-10-07">CORBA
Specification</a>.</p>
<p><em><strong>Hello.idl</strong></em></p>
<pre class="codeblock">
module HelloApp
{
  interface Hello
  {
  string sayHello();
  oneway void shutdown();
  };
};
</pre>
<a name="interop" id="interop"></a> <b>NOTE:</b> When writing code
in OMG IDL, do not use an interface name as the name of a module.
Doing so runs the risk of getting inconsistent results when
compiling with tools from different vendors, thereby jeopardizing
the code's portability. For example, code containing the same names
could be compiled with the IDL to Java compiler and get one result. The same code compiled with
another vendor's IDL to Java compiler could produce a different
result.
<p>To complete the application, you simply provide the server
(<code>HelloServer.java</code>) and client
(<code>HelloClient.java</code>) implementations. 
<!--************PERSISTENT SERVER*************--></p>
<h2><a name="server" id="server">Implementing the Server
(<code>HelloServer.java</code>)</a></h2>
<p>The example server consists of two classes, the servant and the
server. The servant, <tt>HelloImpl</tt>, is the implementation of
the <tt>Hello</tt> IDL interface; each <tt>Hello</tt> instance is
implemented by a <tt>HelloImpl</tt> instance. The servant is a
subclass of <tt>_HelloImplBase</tt>, which is generated by the
<tt>idlj</tt> compiler from the example IDL. The servant contains
one method for each IDL operation, in this example, the
<tt>sayHello()</tt> and <tt>shutdown()</tt> methods. Servant
methods are just like ordinary Java methods; the extra code to deal
with the ORB, with marshaling arguments and results, and so on, is
provided by the skeleton.</p>
<p>The <tt>HelloServer</tt> class has the server's <tt>main()</tt>
method, which:</p>
<ul>
<li>Creates and initializes an ORB instance</li>
<li>Creates a servant instance (the implementation of one CORBA
<tt>Hello</tt> object) and tells the ORB about it</li>
<li>Gets a CORBA object reference for a naming context in which to
register the new CORBA object</li>
<li>Gets the root naming context</li>
<li>Registers the new object in the naming context under the name
"Hello"</li>
<li>Waits for invocations of the new object from the client</li>
</ul>
<p>The <tt>HelloServer</tt> for the ImplBase server-side
implementation differs only slightly from its POA counterpart. The
sections of the POA-based server that get a reference to the root
POA and activate the <tt>POAManager</tt> are not necessary for this
implementation, which follows:</p>
<p><em><strong>HelloServer.java</strong></em></p>
<pre class="codeblock">
// <a href="examplelicense.html">Copyright and License</a> 
import HelloApp.*;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;

import java.util.Properties;

class HelloImpl extends _HelloImplBase{

  private ORB orb;

  public void setORB(ORB orb_val){
    orb = orb_val;
  }
  
  public String sayHello(){
    return "\nHello world !!\n";
  }
  
  public void shutdown(){
    orb.shutdown(false);
  }
}

public class HelloServer {

  public static void main(String args[]) {
    try{
      // create and initialize the ORB
      ORB orb = ORB.init(args, null);

      // create servant and register it with the ORB
      HelloImpl helloImpl = new HelloImpl();
      helloImpl.setORB(orb); 
            
      // get the root naming context
      org.omg.CORBA.Object objRef = 
          orb.resolve_initial_references("NameService");
      NamingContext ncRef = NamingContextHelper.narrow(objRef);

      Hello href = HelloHelper.narrow(helloImpl);

      // bind the Object Reference in Naming
      NameComponent nc = new NameComponent("Hello", "");
      NameComponent path[] = {nc};
      ncRef.rebind(path, href);

      System.out.println("HelloServer ready and waiting ...");

      // wait for invocations from clients
      orb.run();
    }
    
    catch (Exception e) {
      System.err.println("ERROR: " + e);
      e.printStackTrace(System.out);
    }

    System.out.println("HelloServer Exiting ...");
        
  }
}
&nbsp;
</pre>
<!--************APPLICATION*************-->
<h2><a name="application" id="application">Implementing the Client
Application (<code>HelloClient.java</code>)</a></h2>
<p>The example application client that follows is similar to the
one presented in the <a href="jidlExample.html">default
tutorial</a>, however, the new Interoperable Naming Service
features are not used in this example to preserve backward
compatibility. The example client application:</p>
<ul>
<li>Creates and initiliazes an ORB</li>
<li>Obtains a reference to the naming context</li>
<li>Looks up "Hello" in the naming context and receives a reference
to that CORBA object</li>
<li>Invokes the object's <tt>sayHello()</tt> and
<tt>shutdown()</tt> operations and prints the result</li>
</ul>
<p><em><strong>HelloClient.java</strong></em></p>
<pre class="codeblock">
// <a href="examplelicense.html">Copyright and License</a> 
&nbsp;
import HelloApp.*;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.*;

public class HelloClient{

  static Hello helloImpl;
  
  public static void main(String args[]){
  
    try{
      // create and initialize the ORB
      ORB orb = ORB.init(args, null);

      // get the root naming context
      org.omg.CORBA.Object objRef = 
          orb.resolve_initial_references("NameService");
      NamingContext ncRef = NamingContextHelper.narrow(objRef);
 
      // resolve the Object Reference in Naming
      NameComponent nc = new NameComponent("Hello", "");
      NameComponent path[] = {nc};
      Hello helloImpl = HelloHelper.narrow(ncRef.resolve(path));

      System.out.println("Obtained a handle on server object: " + helloImpl);
      System.out.println(helloImpl.sayHello());
      helloImpl.shutdown();
      }
      
    catch (Exception e) {
      System.out.println("ERROR : " + e) ;
      e.printStackTrace(System.out);
    }
  }
}
&nbsp;
</pre>
<!--************COMPILING THE EXAMPLES************-->
<h2><a name="instructions" id="instructions">Building and Running
Hello World</a></h2>
<p>Despite its simple design, the Hello World program lets you
learn and experiment with all the tasks required to develop almost
any CORBA program that uses <a href=
"jidlGlossary.html#invocation">static invocation</a>.</p>
<p>This example requires a naming service, which is a CORBA service
that allows <a href="jidlGlossary.html#CORBA__object">CORBA
objects</a> to be named by means of binding a name to an object
reference. The <a href="jidlGlossary.html#name__binding">name
binding</a> may be stored in the naming service, and a client may
supply the name to obtain the desired object reference. The two
options for Naming Services shipped with this version of Java SE
are <tt><a href="jidlNaming.html">tnameserv</a></tt>, a transient
naming service, and <tt>orbd</tt> (<tt><a href=
"../../tools/unix/orbd.html">Solaris, Linux, or Mac OS X</a></tt> or
<a href="../../tools/windows/orbd.html">Windows</a>), which is a daemon
process containing a Bootstrap Service, a Transient Naming Service,
a Persistent Naming Service, and a Server Manager. This example
uses <tt>orbd</tt>.</p>
<p>When running this example, remember that, when using Solaris
software, you must become root to start a process on a port under
1024. For this reason, we recommend that you use a port number
greater than or equal to 1024. The <tt>-ORBInitialPort</tt> option
is used to override the default port number in this example. The
following instructions assume you can use port 1050 for the
Java&nbsp;IDL Object Request Broker Daemon, <tt>orbd</tt>. You can
substitute a different port if necessary. When running these
examples on a Windows machine, subtitute a backslash (\) in path
names.</p>
<p>To run this client-server application on your development
machine:</p>
<ol>
<li>Create the program files or download and unzip <a href=
"HelloImplBase.zip">HelloImplBase.zip</a>.</li>
<li>Change to the directory that contains the file
<tt>Hello.idl</tt>.</li>
<li>Run the IDL-to-Java compiler, <tt>idlj</tt>, on the IDL file to
create stubs and skeletons. This step assumes that you have
included the path to the java/bin directory in your path.
<p><strong>NOTE: ImplBase is deprecated in favor of the POA model,
but is provided to allow compatibility with servers written in J2SE
1.3 and prior. We do not recommend creating new servers using this
nonstandard model.</strong><br /></p>
<pre class="codeblock">
  idlj -fall -oldImplBase Hello.idl
</pre>
<p>You must use the <tt>-fall</tt> option with the <tt>idlj</tt>
compiler to generate both client and server-side bindings. This
command line will generate the default server-side bindings, which
assumes the POA programming model. The <tt>-oldImplBase</tt> option
tells the compiler to generate the ImplBase Inheritance Model
server-side bindings, instead of the default POA Inheritance Model
server-side bindings. For more information on the <tt>idlj</tt>
options, see the <tt>idlj</tt> man page
(<a href="../../tools/unix/idlj.html">Solaris, Linux, or Mac OS X</a> or
<a href="../../tools/windows/idlj.html">Windows</a>).</p>
<p>The <tt>idlj</tt> compiler generates a number of files. The
actual number of files generated depends on the options selected
when the IDL file is compiled. The generated files provide standard
functionality, so you can ignore them until it is time to deploy
and run your program. The files generated by the <tt>idlj</tt>
compiler for <tt>Hello.idl</tt>, with the <tt>-fall</tt> command
line option, are:</p>
<ul>
<li><tt>_HelloImplBase.java</tt>
<p>This abstract class is the <a href=
"jidlGlossary.html#server__skeleton">server skeleton</a>,
providing basic CORBA functionality for the server. It implements
the <tt>InvokeHandler</tt> and the <tt>Hello</tt> interface. It
inherits from <tt>org.omg.CORBA.portable.ObjectImpl</tt>. The
server class <tt>HelloImpl</tt> inherits from
<tt>_HelloImplBase</tt>.</p>
</li>
<li><tt>_HelloStub.java</tt>
<p>This class is the <a href=
"jidlGlossary.html#client__stub">client stub</a>, providing CORBA
functionality for the client. It inherits from
<tt>org.omg.CORBA.portable.ObjectImpl</tt> and implements the
<tt>Hello</tt> interface.</p>
</li>
<li><tt>Hello.java</tt>
<p>This interface contains the Java version of our IDL interface.
The <tt>Hello.java</tt> interface inherits from
<tt>org.omg.CORBA.Object</tt>, providing standard CORBA object
functionality. It also inherits from <tt>HelloOperations</tt> and
<tt>org.omg.CORBA.portable.IDLEntity</tt>.</p>
</li>
<li><tt>HelloHelper.java</tt>
<p>This class provides auxiliary functionality, notably the
<tt>narrow()</tt> method required to cast CORBA <a href=
"jidlGlossary.html#object__reference">object references</a> to
their proper types.The Helper class is responsible for reading and
writing the data type to CORBA streams, and inserting and
extracting the data type from <tt>Any</tt>s. The Holder class
delegates to the methods in the Helper class for reading and
writing.</p>
</li>
<li><tt>HelloHolder.java</tt>
<p>This <tt>final</tt> class holds a public instance member of type
<tt>Hello</tt>. Whenever the IDL type is an <tt>out</tt> or an
<tt>inout</tt> parameter, the Holder class is used. It provides
operations for <tt>org.omg.CORBA.portable.OutputStream</tt> and
<tt>org.omg.CORBA.portable.InputStream</tt> arguments, which CORBA
allows, but which do not map easily to Java's semantics. The Holder
class delegates to the methods in the Helper class for reading and
writing. It implements
<tt>org.omg.CORBA.portable.Streamable</tt>.</p>
</li>
<li><tt>HelloOperations.java</tt>
<p>This interface contains the methods <tt>sayHello()</tt> and
<tt>shutdown()</tt>. The IDL-to-Java mapping puts all of the
operations defined on the IDL interface into this file, which is
shared by both the stubs and skeletons.</p>
</li>
</ul>
</li>
<li>Compile the <tt>.java</tt> files, including the stubs and
skeletons (which are in the directory <tt>HelloApp</tt>). This step
assumes the java/bin directory is included in your path.
<pre class="codeblock">
   javac *.java HelloApp/*.java
</pre></li>
<li>Start <tt>orbd</tt>.
<p>To start <tt>orbd</tt> from a command shell on Solaris,
Linux, or Mac OS X, enter:</p>
<pre class="codeblock">
  orbd -ORBInitialPort 1050 -ORBInitialHost localhost&amp;
</pre>
<p>From an MS-DOS system prompt (Windows), enter:</p>
<pre class="codeblock">
  start orbd -ORBInitialPort 1050 -ORBInitialHost localhost
</pre>
<p>Note that <tt>1050</tt> is the port on which you want the name
server to run. <tt>-ORBInitialPort</tt> is a required command-line
argument. Note that when using Solaris software, you must become
root to start a process on a port under 1024. For this reason, we
recommend that you use a port number greater than or equal to
1024.</p>
<p><tt>-ORBInitialHost</tt> is an optional command-line argument.
For this example, since both client and server on running on the
development machine, we have set the host to <tt>localhost</tt>.
When developing on more than one machine, you will replace this
with the name of the host. For an example of how to run this
program on two machines, see <a href=
"tutorial/jidl2machines.html">Running the Hello World Program on 2
machines</a>.</p>
</li>
<li>Start the Hello server:
<p>To start the Hello server from a command shell on Solaris,
Linux, or Mac OS X, enter:</p>
<pre class="codeblock">
  java HelloServer -ORBInitialPort 1050 -ORBInitialHost localhost&amp;
</pre>
<p>From an MS-DOS system prompt (Windows), enter:</p>
<pre class="codeblock">
  start java HelloServer -ORBInitialPort 1050 -ORBInitialHost localhost
</pre>
<p>For this example, you can omit <tt>-ORBInitialHost
localhost</tt> since the name server is running on the same host as
the Hello server. If the name server is running on a different
host, use <tt>-ORBInitialHost</tt> <em>nameserverhost</em> to
specify the host on which the IDL name server is running.</p>
<p>Specify the name server (<tt>orbd</tt>) port as done in the
previous step, for example, <tt>-ORBInitialPort 1050</tt>.</p>
<p>When the server is running, it will echo the following message
back to the terminal:</p>
<pre class="codeblock">
HelloServer ready and waiting ...
 
</pre></li>
<li>Run the client application:
<pre class="codeblock">
  java HelloClient -ORBInitialPort 1050 -ORBInitialHost localhost
</pre>
<p>For this example, you can omit <tt>-ORBInitialHost
localhost</tt> since the name server is running on the same host as
the Hello client. If the name server is running on a different
host, use <tt>-ORBInitialHost</tt> <em>nameserverhost</em> to
specify the host on which the IDL name server is running.</p>
<p>Specify the name server (<tt>orbd</tt>) port as done in the
previous step, for example, <tt>-ORBInitialPort 1050</tt>.</p>
<p>When the client is running, the following message will echo to
the terminal:</p>
<pre class="codeblock">
   Obtained a handle on server object: IOR: ...
   Hello World !!
   HelloServer Exiting ...
</pre></li>
</ol>
<p>When you have finished this tutorial, be sure to shut down or
kill the name server (<tt>orbd</tt>). To do this from a DOS prompt,
select the window that is running the server and enter
<tt>Ctrl+C</tt> to shut it down. To do this from a shell on Solaris,
Linux, or Mac OS X, find
the process, and kill it. The server will continue to wait for
invocations until it is explicitly stopped.</p>
<p><strong><a href="tutorial/jidl2machines.html">Running the Hello
World Application on Two Machines</a></strong> describes one way of
distributing the simple application across two machines - a client
and a server.</p>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
