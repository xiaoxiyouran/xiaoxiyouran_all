<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>Programming With Assertions</title>
<link rel="stylesheet" type="text/css" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<div align="center">
<h1>Programming With Assertions</h1>
</div>
<p>An <i>assertion</i> is a statement in the Java programming language that enables you to
test your assumptions about your program. For example, if you write
a method that calculates the speed of a particle, you might assert
that the calculated speed is less than the speed of light.</p>
<p>Each assertion contains a boolean expression that you believe
will be true when the assertion executes. If it is not true, the
system will throw an error. By verifying that the boolean
expression is indeed true, the assertion confirms your assumptions
about the behavior of your program, increasing your confidence that
the program is free of errors.</p>
<p>Experience has shown that writing assertions while programming
is one of the quickest and most effective ways to detect and
correct bugs. As an added benefit, assertions serve to document the
inner workings of your program, enhancing maintainability.</p>
<p>This document shows you how to program with assertions. It
covers the topics:</p>
<ul>
<li><a href="#intro">Introduction</a></li>
<li><a href="#usage">Putting Assertions Into Your Code</a></li>
<li><a href="#compiling">Compiling Files That Use
Assertions</a></li>
<li><a href="#enable-disable">Enabling and Disabling
Assertions</a></li>
<li><a href="#compatibility">Compatibility With Existing
Programs</a></li>
<li><a href="#design-faq">Design FAQ</a></li>
</ul>
<hr />
<h2><a name="intro" id="intro">Introduction</a></h2>
<p>The assertion statement has two forms. The first, simpler form
is:</p>
<pre>
assert <var>Expression<sub>1</sub></var> ;
</pre>
<p>where <var>Expression<font size="-1"><sub>1</sub></font></var>
is a <code>boolean</code> expression. When the system runs the
assertion, it evaluates <var>Expression<font size=
"-1"><sub>1</sub></font></var> and if it is <code>false</code>
throws an <a href=
"../../../api/java/lang/AssertionError.html"><code>AssertionError</code></a>
with no detail message.</p>
<p>The second form of the assertion statement is:</p>
<pre>
assert <var>Expression<sub>1</sub></var> : <var>Expression<sub>2</sub></var> ;
</pre>
<p>where:</p>
<ul>
<li><var>Expression<font size="-1"><sub>1</sub></font></var> is a
boolean expression.</li>
<li><var>Expression<font size="-1"><sub>2</sub></font></var> is an
expression that has a value. (It cannot be an invocation of a
method that is declared <code>void</code>.)</li>
</ul>
<p>Use this version of the <code>assert</code> statement to provide
a detail message for the <code>AssertionError</code>. The system
passes the value of <var>Expression<font size=
"-1"><sub>2</sub></font></var> to the appropriate
<code>AssertionError</code> constructor, which uses the string
representation of the value as the error's detail message.</p>
<p>The purpose of the detail message is to capture and communicate
the details of the assertion failure. The message should allow you
to diagnose and ultimately fix the error that led the assertion to
fail. Note that the detail message is <i>not</i> a user-level error
message, so it is generally unnecessary to make these messages
understandable in isolation, or to internationalize them. The
detail message is meant to be interpreted in the context of a full
stack trace, in conjunction with the source code containing the
failed assertion.</p>
<p>Like all uncaught exceptions, assertion failures are generally
labeled in the stack trace with the file and line number from which
they were thrown. The second form of the assertion statement should
be used in preference to the first only when the program has some
additional information that might help diagnose the failure. For
example, if <var>Expression<sub>1</sub></var> involves the
relationship between two variables <code>x</code> and
<code>y</code>, the second form should be used. Under these
circumstances, a reasonable candidate for
<var>Expression<sub>2</sub></var> would be <code>"x: " + x + ", y:
" + y</code>.</p>
<p>In some cases <var>Expression<font size=
"-1"><sub>1</sub></font></var> may be expensive to evaluate. For
example, suppose you write a method to find the minimum element in
an unsorted list, and you add an assertion to verify that the
selected element is indeed the minimum. The work done by the assert
will be at least as expensive as the work done by the method
itself. To ensure that assertions are not a performance liability
in deployed applications, assertions can be enabled or disabled
when the program is started, and are disabled by default. Disabling
assertions eliminates their performance penalty entirely. Once
disabled, they are essentially equivalent to <i>empty
statements</i> in semantics and performance. See <a href=
"#enable-disable">Enabling and Disabling Assertions</a> for more
information.</p>
<p>The addition of the <code>assert</code> keyword to the Java
programming language has implications for existing code. See
<a href="#compatibility">Compatibility With Existing Programs</a>
for more information.</p>
<h2><a name="usage" id="usage">Putting Assertions Into Your
Code</a></h2>
<p>There are many situations where it is good to use assertions,
including:</p>
<ul>
<li><a href="#usage-invariants">Internal Invariants</a></li>
<li><a href="#usage-control">Control-Flow Invariants</a></li>
<li><a href="#usage-conditions">Preconditions, Postconditions, and
Class Invariants</a></li>
</ul>
<p>There are also situations where you should <i>not</i> use
them:</p>
<ul>
<li>Do <i>not</i> use assertions for argument checking in public
methods.
<p>Argument checking is typically part of the published
specifications (or <i>contract</i>) of a method, and these
specifications must be obeyed whether assertions are enabled or
disabled. Another problem with using assertions for argument
checking is that erroneous arguments should result in an
appropriate runtime exception (such as
<code>IllegalArgumentException</code>,
<code>IndexOutOfBoundsException</code>, or
<code>NullPointerException</code>). An assertion failure will not
throw an appropriate exception.</p>
</li>
<li>Do <i>not</i> use assertions to do any work that your
application requires for correct operation.
<p>Because assertions may be disabled, programs must not assume
that the boolean expression contained in an assertion will be
evaluated. Violating this rule has dire consequences. For example,
suppose you wanted to remove all of the null elements from a list
<code>names</code>, and knew that the list contained one or more
nulls. It would be wrong to do this:</p>
<pre>
<b>// Broken! - action is contained in assertion</b>
assert names.remove(null);
</pre>
<p>The program would work fine when asserts were enabled, but would
fail when they were disabled, as it would no longer remove the null
elements from the list. The correct idiom is to perform the action
before the assertion and then assert that the action succeeded:</p>
<pre>
<b>// Fixed - action precedes assertion</b>
boolean nullsRemoved = names.remove(null);
assert nullsRemoved;  // Runs whether or not asserts are enabled
</pre>
<p>As a rule, the expressions contained in assertions should be
free of <i>side effects</i>: evaluating the expression should not
affect any state that is visible after the evaluation is complete.
One exception to this rule is that assertions can modify state that
is used only from within other assertions. <a href=
"#complexpostconditions">An idiom that makes use of this
exception</a> is presented later in this document.</p>
</li>
</ul>
<h3><a name="usage-invariants" id="usage-invariants">Internal
Invariants</a></h3>
<p>Before assertions were available, many programmers used comments
to indicate their assumptions concerning a program's behavior. For
example, you might have written something like this to explain your
assumption about an <code>else</code> clause in a multiway
if-statement:</p>
<pre>
if (i % 3 == 0) {
    ...
} else if (i % 3 == 1) {
    ...
} else { <b>// We know (i % 3 == 2)</b>
    ...
}
</pre>
<p>You should now <b>use an assertion whenever you would have
written a comment that asserts an invariant</b>. For example, you
should rewrite the previous if-statement like this:</p>
<pre>
if (i % 3 == 0) {
   ...
} else if (i % 3 == 1) {
    ...
} else {
    <b>assert i % 3 == 2 : i;</b>
    ...
}
</pre>
<p>Note, incidentally, that the assertion in the above example may
fail if <code>i</code> is negative, as the <code>%</code> operator
is not a true <i>modulus</i> operator, but computes the
<i>remainder</i>, which may be negative.</p>
<p>Another good candidate for an assertion is a <code>switch</code>
statement with no <code>default</code> case. The absence of a
<code>default</code> case typically indicates that a programmer
believes that one of the cases will always be executed. The
assumption that a particular variable will have one of a small
number of values is an invariant that should be checked with an
assertion. For example, suppose the following <code>switch</code>
statement appears in a program that handles playing cards:</p>
<pre>
switch(suit) {
  case Suit.CLUBS:
    ...
  break;

  case Suit.DIAMONDS:
    ...
  break;

  case Suit.HEARTS:
    ...
    break;

  case Suit.SPADES:
      ...
}
</pre>
<p>It probably indicates an assumption that the <code>suit</code>
variable will have one of only four values. To test this
assumption, you should add the following default case:</p>
<pre>
default:
    assert false : suit;
</pre>
<p>If the <code>suit</code> variable takes on another value and
assertions are enabled, the assert will fail and an
<code>AssertionError</code> will be thrown.</p>
<p>An acceptable alternative is:</p>
<pre>
default:
    throw new AssertionError(suit);
</pre>
<p>This alternative offers protection even if assertions are
disabled, but the extra protection adds no cost: the
<code>throw</code> statement won't execute unless the program has
failed. Moreover, the alternative is legal under some circumstances
where the <code>assert</code> statement is not. If the enclosing
method returns a value, each case in the <code>switch</code>
statement contains a <code>return</code> statement, and no
<code>return</code> statement follows the <code>switch</code>
statement, then it would cause a syntax error to add a default case
with an assertion. (The method would return without a value if no
case matched and assertions were disabled.)</p>
<h3><a name="usage-control" id="usage-control">Control-Flow
Invariants</a></h3>
<p>The previous example not only tests an invariant, it also checks
an assumption about the application's flow of control. The author
of the original <code>switch</code> statement probably assumed not
only that the <code>suit</code> variable would always have one of
four values, but also that one of the four cases would always be
executed. It points out another general area where you should use
assertions: <b>place an assertion at any location you assume will
not be reached</b>. The assertions statement to use is:</p>
<pre>
assert false;
</pre>
<p>For example, suppose you have a method that looks like this:</p>
<pre>
void foo() {
    for (...) {
      if (...)
        return;
    }
    <b>// Execution should never reach this point!!!</b>
}
</pre>
<p>Replace the final comment so that the code now reads:</p>
<pre>
void foo() {
    for (...) {
      if (...)
        return;
    }
    <b>assert false; // Execution should never reach this point!</b>
}
</pre>
<p><b>Note:</b> Use this technique with discretion. If a statement
is unreachable as defined in the Java Language Specification, you
will get a compile time error if you try to assert that it is not
reached. Again, an acceptable alternative is simply to throw an
<code>AssertionError</code>.</p>
<h3><a name="usage-conditions" id="usage-conditions">Preconditions,
Postconditions, and Class Invariants</a></h3>
<p>While the assert construct is not a full-blown
<i>design-by-contract</i> facility, it can help support an informal
design-by-contract style of programming. This section shows you how
to use asserts for:</p>
<ul>
<li><a href="#preconditions">Preconditions</a> &mdash; what must be
true when a method is invoked.</li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#usage-adv-locks">Lock-Status Preconditions</a>
&mdash; preconditions concerning whether or not a given lock is
held.</li>
</ul>
</li>
<li><a href="#postconditions">Postconditions</a> &mdash; what must
be true after a method completes successfully.</li>
<li><a href="#class-invariants">Class invariants</a> &mdash; what
must be true about each instance of a class.</li>
</ul>
<a name="preconditions" id="preconditions"></a>
<h4>Preconditions</h4>
<p>By convention, preconditions on <i>public</i> methods are
enforced by explicit checks that throw particular, specified
exceptions. For example:</p>
<pre>
/**
  * Sets the refresh rate.
  *
  * @param  rate refresh rate, in frames per second.
  * @throws IllegalArgumentException if rate &lt;= 0 or
  * rate &gt; MAX_REFRESH_RATE.
*/
public void setRefreshRate(int rate) {
  // <b>Enforce specified precondition in public method</b>
  if (rate &lt;= 0 || rate &gt; MAX_REFRESH_RATE)
    throw new IllegalArgumentException("Illegal rate: " + rate);
    setRefreshInterval(1000/rate);
  }
</pre>
<p>This convention is unaffected by the addition of the
<code>assert</code> construct. <b>Do not use assertions to check
the parameters of a public method.</b> An assert is inappropriate
because the method guarantees that it will always enforce the
argument checks. It must check its arguments whether or not
assertions are enabled. Further, the <code>assert</code> construct
does not throw an exception of the specified type. It can throw
only an <code>AssertionError</code>.</p>
<p>You can, however, use an assertion to test a <i>nonpublic</i>
method's precondition that you believe will be true no matter what
a client does with the class. For example, an assertion <i>is</i>
appropriate in the following "helper method" that is invoked by the
previous method:</p>
<pre>
/**
 * Sets the refresh interval (which must correspond to a legal frame rate).
 *
 * @param  interval refresh interval in milliseconds.
*/
 <b>private</b> void setRefreshInterval(int interval) {
  <b>// Confirm adherence to precondition in nonpublic method</b>
  assert interval &gt; 0 &amp;&amp; interval &lt;= 1000/MAX_REFRESH_RATE : interval;

  ... // Set the refresh interval
 } 
</pre>
<p>Note, the above assertion will fail if
<code>MAX_REFRESH_RATE</code> is greater than 1000 and the client
selects a refresh rate greater than 1000. This would, in fact,
indicate a bug in the library!</p>
<h5><a name="usage-adv-locks" id="usage-adv-locks">Lock-Status
Preconditions</a></h5>
<p>Classes designed for multithreaded use often have non-public
methods with preconditions relating to whether or not some lock is
held. For example, it is not uncommon to see something like
this:</p>
<pre>
private Object[] a;
public synchronized int find(Object key) {
  return find(key, a, 0, a.length);
}

<b>// Recursive helper method - always called with a lock on this object</b>
private int find(Object key, Object[] arr, int start, int len) {
 ...
} 
</pre>
<p>A static method called <code>holdsLock</code> has been added to
the <code>Thread</code> class to test whether the current thread
holds the lock on a specified object. This method can be used in
combination with an <code>assert</code> statement to supplement a
comment describing a lock-status precondition, as shown in the
following example:</p>
<pre>
// Recursive helper method - always called with a lock on this.
private int find(Object key, Object[] arr, int start, int len) {
  <b>assert Thread.holdsLock(this); // lock-status assertion </b>
  ...
} 
</pre>
<p>Note that it is also possible to write a lock-status assertion
asserting that a given lock <i>isn't</i> held. <a name=
"postconditions" id="postconditions"></a></p>
<h4>Postconditions</h4>
<p>You can test postcondition with assertions in both public and
nonpublic methods. For example, the following public method uses an
<code>assert</code> statement to check a post condition:</p>
<pre>
 /**
  * Returns a BigInteger whose value is (this<sup>-1</sup> mod m).
  *
  * @param  m the modulus.
  * @return this<sup>-1</sup> mod m.
  * @throws ArithmeticException  m &lt;= 0, or this BigInteger
  *has no multiplicative inverse mod m (that is, this BigInteger
  *is not <i>relatively prime</i> to m).
  */
public BigInteger modInverse(BigInteger m) {
  if (m.signum &lt;= 0)
    throw new ArithmeticException("Modulus not positive: " + m);
  ... // Do the computation
  <b>assert this.multiply(result).mod(m).equals(ONE) : this;</b>
  return result;
}
</pre>
<p><a name="complexpostconditions" id="complexpostconditions"></a>
Occasionally it is necessary to save some data prior to performing
a computation in order to check a postcondition. You can do this
with two <code>assert</code> statements and a simple inner class
that saves the state of one or more variables so they can be
checked (or rechecked) after the computation. For example, suppose
you have a piece of code that looks like this:</p>
<pre>
 void foo(int[] array) {
  // Manipulate array
  ...

  // At this point, array will contain exactly the ints that it did
  // prior to manipulation, in the same order.
 }
</pre>
<p>Here is how you could modify the above method to turn the
textual assertion of a postcondition into a functional one:</p>
<pre>
 void foo(final int[] array) {

  <b>// Inner class that saves state and performs final consistency check</b>
  class DataCopy {
private int[] arrayCopy;

DataCopy() { arrayCopy = (int[]) array.clone(); }

boolean isConsistent() { return Arrays.equals(array, arrayCopy); }
  }

  DataCopy copy = null;

  <b>// Always succeeds; has side effect of saving a copy of array</b>
  assert ((copy = new DataCopy()) != null);

  ... // Manipulate array

  <b>// Ensure array has same ints in same order as before manipulation.</b>
  assert copy.isConsistent();
  } 
</pre>
<p>You can easily generalize this idiom to save more than one data
field, and to test arbitrarily complex assertions concerning
pre-computation and post-computation values.</p>
<p>You might be tempted to replace the first assert statement
(which is executed solely for its side-effect) by the following,
more expressive statement:</p>
<pre>
 copy = new DataCopy(); 
</pre>
<p>Don't make this replacement. The statement above would copy the
array whether or not asserts were enabled, violating the principle
that assertions should have no cost when disabled. <a name=
"class-invariants" id="class-invariants"></a></p>
<h4>Class Invariants</h4>
<p>A class invariant is a type of <a href=
"#usage-invariants">internal invariant</a> that applies to every
instance of a class at all times, except when an instance is in
transition from one consistent state to another. A class invariant
can specify the relationships among multiple attributes, and should
be true before and after any method completes. For example, suppose
you implement a balanced tree data structure of some sort. A class
invariant might be that the tree is balanced and properly
ordered.</p>
<p>The assertion mechanism does not enforce any particular style
for checking invariants. It is sometimes convenient, though, to
combine the expressions that check required constraints into a
single internal method that can be called by assertions. Continuing
the balanced tree example, it might be appropriate to implement a
private method that checked that the tree was indeed balanced as
per the dictates of the data structure:</p>
<pre>
 // Returns true if this tree is properly balanced
 private boolean balanced() {
  ...
 }
</pre>
<p>Because this method checks a constraint that should be true
before and after any method completes, each public method and
constructor should contain the following line immediately prior to
its return:</p>
<pre>
 assert balanced(); 
</pre>
<p>It is generally unnecessary to place similar checks at the head
of each public method unless the data structure is implemented by
native methods. In this case, it is possible that a memory
corruption bug could corrupt a "native peer" data structure in
between method invocations. A failure of the assertion at the head
of such a method would indicate that such memory corruption had
occurred. Similarly, it may be advisable to include class invariant
checks at the heads of methods in classes whose state is modifiable
by other classes. (Better yet, design classes so that their state
is not directly visible to other classes!)</p>
<h3><a name="usage-advanced" id="usage-advanced">Advanced
Uses</a></h3>
<p>The following sections discuss topics that apply only to
resource-constrained devices and to systems where asserts must not
be disabled in the field. If you have no interest in these topics,
skip to the next section, <a href="#compiling">&quot;Compiling
Files that Use Assertions&quot;</a>.</p>
<h4><a name="usage-adv-removing" id="usage-adv-removing">Removing
all Trace of Assertions from Class Files</a></h4>
<p>Programmers developing applications for resource-constrained
devices may wish to strip assertions out of class files entirely.
While this makes it impossible to enable assertions in the field,
it also reduces class file size, possibly leading to improved class
loading performance. In the absence of a high quality JIT, it could
lead to decreased footprint and improved runtime performance.</p>
<p>The assertion facility offers no direct support for stripping
assertions out of class files. The assert statement may, however,
be used in conjunction with the "conditional compilation" idiom
described in the Java Language Specification, enabling the compiler
to eliminate all traces of these asserts from the class files that
it generates:</p>
<pre>
 static final boolean asserts = ... ; // false to eliminate asserts

 if (asserts)
  assert &lt;expr&gt; ; 
</pre>
<h4><a name="usage-adv-requiring" id=
"usage-adv-requiring">Requiring that Assertions are
Enabled</a></h4>
<p>Programmers of certain critical systems might wish to ensure
that assertions are not disabled in the field. The following static
initialization idiom prevents a class from being initialized if its
assertions have been disabled:</p>
<pre>
 static {
  boolean assertsEnabled = false;
  assert assertsEnabled = true; // <b>Intentional side effect!!!</b>
  if (!assertsEnabled)
throw new RuntimeException("Asserts must be enabled!!!");
 } 
</pre>
<p>Put this static-initializer at the top of your class.</p>
<h2><a name="compiling" id="compiling">Compiling Files That Use
Assertions</a></h2>
<p>In order for the <code>javac</code> compiler to accept code
containing assertions, you must use the
<code>-source&nbsp;1.4</code> command-line option as in this
example:</p>
<pre>
 javac <b>-source 1.4</b> MyClass.java 
</pre>
<p>This flag is necessary so as not to cause source <a href=
"#compatibility">compatibility</a> problems.</p>
<h2><a name="enable-disable" id="enable-disable">Enabling and
Disabling Assertions</a></h2>
<p>By default, assertions are disabled at runtime. Two command-line
switches allow you to selectively enable or disable assertions.</p>
<p>To enable assertions at various granularities, use the
<code>-enableassertions</code>, or
<code>-ea</code>, switch. To disable assertions at
various granularities, use the
<code>-disableassertions</code>, or
<code>-da</code>, switch. You specify the granularity
with the arguments that you provide to the switch:</p>
<ul>
<li style="list-style: none"><a name="arg-list" id=
"arg-list"></a></li>
<li>no arguments<br />
&nbsp;&nbsp;&nbsp;Enables or disables assertions in all classes
except system classes.</li>
<li><i>packageName</i><code>...</code><br />
&nbsp;&nbsp;&nbsp;Enables or disables assertions in the named
package and any subpackages.</li>
<li><code>...</code><br />
&nbsp;&nbsp;&nbsp;Enables or disables assertions in the unnamed
package in the current working directory.</li>
<li><i>className</i><br />
&nbsp;&nbsp;&nbsp;Enables or disables assertions in the named
class</li>
</ul>
<p>For example, the following command runs a program,
<code>BatTutor</code>, with assertions enabled in only package
<code>com.wombat.fruitbat</code> and its subpackages:</p>
<pre>
 java -ea:com.wombat.fruitbat... BatTutor
</pre>
<p>If a single command line contains multiple instances of these
switches, they are processed in order before loading any classes.
For example, the following command runs the <code>BatTutor</code>
program with assertions enabled in package
<code>com.wombat.fruitbat</code> but disabled in class
<code>com.wombat.fruitbat.Brickbat</code>:</p>
<pre>
 java -ea:com.wombat.fruitbat... -da:com.wombat.fruitbat.Brickbat BatTutor 
</pre>
<p>The above switches apply to all class loaders. With one
exception, they also apply to <i>system classes</i> (which do not
have an explicit class loader). The exception concerns the switches
with no arguments, which (as indicated above) do not apply to
system classes.This behavior makes it easy to enable asserts in all
classes except for system classes, which is commonly desirable.</p>
<p>To enable assertions in all system classes, use a different
switch: <code>-enablesystemassertions</code>, or
<code>-esa</code>. Similarly, to disable assertions in
system classes, use
<code>-disablesystemassertions</code>, or
<code>-dsa</code>.</p>
<p>For example, the following command runs the
<code>BatTutor</code> program with assertions enabled in system
classes, as well as in the <code>com.wombat.fruitbat</code> package
and its subpackages:</p>
<pre>
 java -esa -ea:com.wombat.fruitbat... 
</pre>
<p>The assertion status of a class (enabled or disabled) is set at
the time it is initialized, and does not change. There is, however,
one corner case that demands special treatment. It is possible,
though generally not desirable, to execute methods or constructors
prior to initialization. This can happen when a class hierarchy
contains a circularity in its static initialization.</p>
<p>If an <tt>assert</tt> statement executes before its class is
initialized, the execution must behave as if assertions were
enabled in the class. This topic is discussed in detail in the
assertions specification in the Java Language Specification.</p>
<h2><a name="compatibility" id="compatibility">Compatibility With
Existing Programs</a></h2>
<p>The addition of the <code>assert</code> keyword to the Java
programming language does not cause any problems with preexisting
binaries (<code>.class</code> files). If you try to compile an
application that uses <code>assert</code> as an identifier,
however, you will receive a warning or error message. In order to
ease the transition from a world where <code>assert</code> is a
legal identifier to one where it isn't, the compiler supports two
modes of operation in this release:</p>
<ul>
<li><b>source mode 1.3</b> (default) &mdash; the compiler accepts
programs that use <code>assert</code> as an identifier, but issues
warnings. In this mode, programs are <i>not</i> permitted to use
the <code>assert</code> statement.</li>
<li><b>source mode 1.4</b> &mdash; the compiler generates an error
message if the program uses <code>assert</code> as an identifier.
In this mode, programs <i>are</i> permitted to use the
<code>assert</code> statement.</li>
</ul>
<p>Unless you specifically request source mode 1.4 with the
<code>-source 1.4</code> flag, the compiler operates in source mode
1.3. <i>If you forget to use this flag, programs that use the new
<code>assert</code> statement will not compile</i>. Having the
compiler use the old semantics as its default behavior (that is,
allowing <code>assert</code> to be used as an identifier) was done
for maximal source compatibility. Source mode 1.3 is likely to be
phased out over time.</p>
<h2><a name="design-faq" id="design-faq">Design FAQ</a></h2>
<p>Here is a collection of frequently asked questions concerning
the design of the assertion facility.</p>
<ul>
<li><a href="#design-faq-general">General Questions</a></li>
<li><a href="#design-faq-compat">Compatibility</a></li>
<li><a href="#design-faq-ss">Syntax and Semantics</a></li>
<li><a href="#design-faq-error">The <code>AssertionError</code>
Class</a></li>
<li><a href="#design-faq-enable-disable">Enabling and Disabling
Assertions</a></li>
</ul>
<h3><a name="design-faq-general" id="design-faq-general">General
Questions</a></h3>
<ul>
<li><b>Why provide an assertion facility, given that one can
program assertions atop the Java programming language with no
special support?</b>
<p>Although ad hoc implementations are possible, they are of
necessity either ugly (requiring an <code>if</code> statement for
each assertion) or inefficient (evaluating the condition even if
assertions are disabled). Further, each ad hoc implementation has
its own means of enabling and disabling assertions, which lessens
the utility of these implementations, especially for debugging in
the field. As a result of these shortcomings, assertions have never
become a part of the culture among engineers using the Java
programming language. Adding assertion support to the platform
stands a good chance of rectifying this situation.</p>
</li>
<li><b>Why does this facility justify a language change, as opposed
to a library solution?</b>
<p>We recognize that a language change is a serious effort, not to
be undertaken lightly. The library approach was considered. It was,
however, deemed essential that the runtime cost of assertions be
negligible if they are disabled. In order to achieve this with a
library, the programmer is forced to hard-code each assertion as an
<code>if</code> statement. Many programmers would not do this.
Either they would omit the if statement and performance would
suffer, or they would ignore the facility entirely. Note also that
assertions were contained in James Gosling's original specification
for the Java programming language. Assertions were removed from the
Oak specification because time constraints prevented a satisfactory
design and implementation.</p>
</li>
<li><b>Why not provide a full-fledged <i>design-by-contract</i>
facility with preconditions, postconditions and class invariants,
like the one in the Eiffel programming language?</b>
<p>We considered providing such a facility, but were unable to
convince ourselves that it is possible to graft it onto the Java
programming language without massive changes to the Java platform
libraries, and massive inconsistencies between old and new
libraries. Further, we were not convinced that such a facility
would preserve the simplicity that is the hallmark of the Java
programming language. On balance, we came to the conclusion that a
simple boolean assertion facility was a fairly straight-forward
solution and far less risky. It's worth noting that adding a
boolean assertion facility to the language doesn't preclude adding
a full-fledged design-by-contract facility at some time in the
future.</p>
<p>The simple assertion facility does enable a limited form of
<a href="#usage-conditions">design-by-contract style
programming</a>. The <code>assert</code> statement is appropriate
for nonpublic precondition, postcondition and class invariant
checking. Public precondition checking should still be performed by
checks inside methods that result in particular, documented
exceptions, such as <code>IllegalArgumentException</code> and
<code>IllegalStateException</code>.</p>
</li>
<li><b>In addition to boolean assertions, why not provide an
assert-like construct to suppress the execution of an entire block
of code if assertions are disabled?</b>
<p>Providing such a construct would encourage programmers to put
complex assertions inline, when they are better relegated to
separate methods.</p>
</li>
</ul>
<h3><a name="design-faq-compat" id=
"design-faq-compat">Compatibility</a></h3>
<ul>
<li><b>Won't the new keyword cause compatibility problems with
existing programs that use <code>assert</code> as an
identifier?</b>
<p>Yes, for source files. (Binaries for classes that use
<code>assert</code> as an identifier will continue to work fine.)
To ease the transition, we implemented <a href="#compatibility">a
strategy</a> whereby developers can continue using
<code>assert</code> as an identifier during a transitional
period.</p>
</li>
<li><b>Doesn't this facility produce class files that cannot be run
against older JREs?</b>
<p>Yes. Class files will contain calls to the new
<tt>ClassLoader</tt> and <tt>Class</tt> methods, such as
<tt>desiredAssertionStatus</tt>. If a class file containing calls
to these methods is run against an older JRE (whose
<tt>ClassLoader</tt> class doesn't define the methods), the program
will fail at run time, throwing a <tt>NoSuchMethodError</tt>. It is
generally the case that programs using new facilities are not
compatible with older releases.</p>
</li>
</ul>
<h3><a name="design-faq-ss" id="design-faq-ss">Syntax and
Semantics</a></h3>
<ul>
<li><b>Why allow primitive types in <var>Expression<font size=
"1"><sub>2</sub></font></var>?</b>
<p>There is no compelling reason to restrict the type of this
expression. Allowing arbitrary types provides convenience for
developers who, for example, want to associate a unique integer
code with each assertion. Further, it makes this expression feel
like the argument of <code>System.out.println(...)</code>, which is
seen as desirable.</p>
</li>
</ul>
<h3><a name="design-faq-error" id="design-faq-error">The
AssertionError Class</a></h3>
<ul>
<li><b>When an <code>AssertionError</code> is generated by an
assert statement in which <var>Expression<font size=
"-1"><sub>2</sub></font></var> is absent, why isn't the program
text of the asserted condition used as the detail message (for
example, &quot;<code>height &lt;
maxHeight</code>&quot;)?</b>
<p>While doing so might improve out-of-the-box usefulness of
assertions in some cases, the benefit doesn't justify the cost of
adding all those string constants to <code>.class</code> files and
runtime images.</p>
</li>
<li><b>Why doesn't an <code>AssertionError</code> allow access to
the object that generated it? Similarly, why not pass an arbitrary
object from the assertion to the <code>AssertionError</code>
constructor in place of a detail message?</b>
<p>Access to these objects would encourage programmers to attempt
to recover from assertion failures, which defeats the purpose of
the facility.</p>
</li>
<li><b>Why not provide context accessors (like
<code>getFile</code>, <code>getline</code>, <code>getMethod</code>)
on <code>AssertionError</code>?</b>
<p>This facility is best provided on <code>Throwable</code>, so it
may be used for all throwables, not just assertion errors. We
enhanced <code>Throwable</code> with the <code>getStackTrace</code>
method to provide this functionality.</p>
</li>
<li><b>Why is <code>AssertionError</code> a subclass of
<code>Error</code> rather than <code>RuntimeException</code>?</b>
<p>This issue was controversial. The expert group discussed it at
length, and came to the conclusion that <code>Error</code> was more
appropriate to discourage programmers from attempting to recover
from assertion failures. It is, in general, difficult or impossible
to localize the source of an assertion failure. Such a failure
indicates that the program is operating "outside of known space,"
and attempts to continue execution are likely to be harmful.
Further, convention dictates that methods specify most runtime
exceptions they may throw (with <code>@throws</code> doc comments).
It makes little sense to include in a method's specification the
circumstances under which it may generate an assertion failure.
Such information may be regarded as an implementation detail, which
can change from implementation to implementation and release to
release.</p>
</li>
</ul>
<h3><a name="design-faq-enable-disable" id=
"design-faq-enable-disable">Enabling and Disabling
Assertions</a></h3>
<ul>
<li><b>Why not provide a compiler flag to completely eliminate
assertions from object files?</b>
<p>It is a firm requirement that it be possible to enable
assertions in the field, for enhanced serviceability. It would have
been possible to also permit developers to eliminate assertions
from object files at compile time. Assertions can contain side
effects, though they should not, and such a flag could therefore
alter the behavior of a program in significant ways. It is viewed
as good thing that there is only one semantics associated with each
valid Java program. Also, we want to encourage users to leave
asserts in object files so they can be enabled in the field.
Finally, the spec demands that assertions behave as if enabled when
a class runs before it is initialized. It would be impossible to
offer these semantics if assertions were stripped from the class
file. Note, however, that the standard "conditional compilation
idiom" described in the Java Language Specification can be used to
achieve this effect for developers who really want it.</p>
</li>
<li><b>Why do the commands that enable and disable assertions use
package-tree semantics instead of the more traditional package
semantics?</b>
<p>Hierarchical control is useful, as programmers really do use
package hierarchies to organize their code. For example,
package-tree semantics allow assertions to be enabled or disabled
in all of Swing at one time.</p>
</li>
<li><b>Why does <code>setClassAssertionStatus</code> return a
<code>boolean</code> instead of throwing an exception if it is
invoked when it's too late to set the assertion status (that is, if
the named class has already been initialized)?</b>
<p>No action (other than perhaps a warning message) is necessary or
desirable if it's too late to set the assertion status. An
exception seems unduly heavyweight.</p>
</li>
<li><b>Why not overload a single method name to take the place of
<code>setDefaultAssertionStatus</code> and
<code>setAssertionStatus</code>?</b>
<p>Clarity in method naming is for the greater good. Overloading
tends to cause confusion.</p>
</li>
<li><b>Why not tweak the semantics of
<tt>desiredAssertionStatus</tt> to make it more "programmer
friendly" by returning the actual assertion status if a class is
already initialized?</b>
<p>It's not clear that there would be any use for the resulting
method. The method isn't designed for application programmer use,
and it seems inadvisable to make it slower and more complex than
necessary.</p>
</li>
<li><b>Why is there no <code>RuntimePermission</code> to prevent
applets from enabling/disabling assertions?</b>
<p>While applets have no reason to call any of the
<code>ClassLoader</code> methods for modifying assertion status,
allowing them to do so seems harmless. At worst, an applet can
mount a weak denial-of-service attack by enabling assertions in
classes that have yet to be initialized. Moreover, applets can only
affect the assert status of classes that are to be loaded by class
loaders that the applets can access. There already exists a
<code>RuntimePermission</code> to prevent untrusted code from
gaining access to class loaders (<code>getClassLoader</code>).</p>
</li>
<li><b>Why not provide a construct to query the assert status of
the containing class?</b>
<p>Such a construct would encourage people to inline complex
assertion code, which we view as a bad thing. <!-- :

<PRE> if (assertsEnabled()) {
  ...
 } </PRE>

<p> -->
 Further, it is straightforward to query the assert status atop the
current API, if you feel you must:</p>
<pre>
boolean assertsEnabled = false;
assert assertsEnabled = true;  // <b>Intentional side-effect!!!</b>
// Now assertsEnabled is set to the correct value 
</pre></li>
<li><b>Why does an <tt>assert</tt> statement that executes before
its class is initialized behave as if assertions were enabled in
the class?</b></li>
<li style="list-style: none; display: inline">
<p>Few programmers are aware of the fact that a class's
constructors and methods can run prior to its initialization. When
this happens, it is quite likely that the class's invariants have
not yet been established, which can cause serious and subtle bugs.
Any assertion that executes in this state is likely to fail,
alerting the programmer to the problem. Thus, it is generally
helpful to the programmer to execute all assertions encountered
while in this state.</p>
</li>
</ul>
<!-- Body text ends here -->

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
