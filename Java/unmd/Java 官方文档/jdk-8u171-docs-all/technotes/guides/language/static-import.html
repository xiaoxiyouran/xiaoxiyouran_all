<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>Static Import</title>
<link rel="stylesheet" type="text/css" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->



<h1>Static Import</h1>

<!-- Body text begins here -->
In order to access static members, it is necessary to qualify
references with the class they came from. For example, one must
say:
<pre>
double r = <strong>Math.</strong>cos(<strong>Math.</strong>PI * theta);
</pre>
In order to get around this, people sometimes put static members
into an interface and inherit from that interface. This is a bad
idea. In fact, it's such a bad idea that there's a name for it: the
<i>Constant Interface Antipattern</i> (see <a href=
"http://www.oracle.com/technetwork/java/effectivejava-136174.html"><i>Effective
Java</i></a> Item 17). The problem is that a class's use of the
static members of another class is a mere implementation detail.
When a class implements an interface, it becomes part of the
class's public API. Implementation details should not leak into
public APIs.
<p>The static import construct allows unqualified access to static
members <i>without</i> inheriting from the type containing the
static members. Instead, the program <i>imports</i> the members,
either individually:</p>
<pre>
import static java.lang.Math.PI;
</pre>
or en masse:
<pre>
import static java.lang.Math.*;
</pre>
Once the static members have been imported, they may be used
without qualification:
<pre>
double r = cos(PI * theta);
</pre>
The static import declaration is analogous to the normal import
declaration. Where the normal import declaration imports classes
from packages, allowing them to be used without package
qualification, the static import declaration imports static members
from classes, allowing them to be used without class qualification.
<p>So when should you use static import? <b>Very sparingly!</b>
Only use it when you'd otherwise be tempted to declare local copies
of constants, or to abuse inheritance (the Constant Interface
Antipattern). In other words, use it when you require frequent
access to static members from one or two classes. If you overuse
the static import feature, it can make your program unreadable and
unmaintainable, polluting its namespace with all the static members
you import. Readers of your code (including you, a few months after
you wrote it) will not know which class a static member comes from.
Importing <i>all</i> of the static members from a class can be
particularly harmful to readability; if you need only one or two
members, import them individually. Used appropriately, static
import can make your program <i>more</i> readable, by removing the
boilerplate of repetition of class names. 
<!-- Body text ends here --></p>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
