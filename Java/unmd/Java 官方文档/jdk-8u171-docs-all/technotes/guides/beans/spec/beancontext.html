<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en">
<head>
<meta http-equiv="Content-Type" content=
"text/html; charset=utf-8" />
<meta http-equiv="Content-Style-Type" content="text/css" />
<meta name="GENERATOR" content=
"Quadralay WebWorks Publisher Professional Edition 7.0.2.1128" />
<meta name="TEMPLATEBASE" content="book-no-index" />
<meta name="LASTUPDATED" content="Mon Oct 21 22:24:34 2002" />
<title>Extensible Runtime Containment and Services Protocol for
JavaBeans Version 1.0</title>
<link rel="stylesheet" type="text/css" href="../../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>Extensible Runtime Containment and Services
Protocol for JavaBeans Version 1.0</h1>
<a name="wp473591" id="wp473591"></a>
<a name="wp916002" id="wp916002"></a>
<h2 class="pHeading1">1.0 Introduction.</h2>
<a name="wp916293" id="wp916293"></a>
<p class="pBody">Currently the JavaBeans specification (Version
1.0) contains neither conventions describing a hierarchy or logical
structure of JavaBeans, nor conventions for those JavaBeans to
rendezvous with, or obtain arbitrary services or facilities from,
the execution environment within which the JavaBean was
instantiated.</p>
<a name="wp916686" id="wp916686"></a>
<p class="pBody">It is desirable to both provide a logical,
traversable, hierarchy of JavaBeans, and further to provide a
general mechanism whereby an object instantiating an arbitrary
JavaBean can offer that JavaBean a variety of services, or
interpose itself between the underlying system service and the
JavaBean, in a conventional fashion.</p>
<a name="wp916294" id="wp916294"></a>
<p class="pBody">In other component models there exists the concept
of a relationship between a Component and its environment, or
Container, wherein a newly instantiated Component is provided with
a reference to its Container or Embedding Context.</p>
<a name="wp916610" id="wp916610"></a>
<p class="pBody">The Container, or Embedding Context not only
establishes the hierarchy or logical structure, but its also acts
as a service provider that Components may interrogate in order to
determine, and subsequently employ, the services provided by their
Context.</p>
<a name="wp916323" id="wp916323"></a>
<p class="pBody">This proposal defines such a protocol that
supports extensible mechanisms that:</p>
<div style="margin-left: 2em" class="pBullet1"><a name="wp916329"
id="wp916329"></a>
<div class="pBullet1">
<ul>
<li>Introduce an abstraction for the environment, or context, in
which a JavaBean logically functions during its lifecycle, that is
a hierarchy or structure of JavaBeans.</li>
</ul>
</div>
<a name="wp916384" id="wp916384"></a>
<div class="pBullet1Plus">
<ul>
<li>Enable the dynamic addition of arbitrary services to a
JavaBean&#8217;s environment.</li>
</ul>
</div>
<a name="wp916330" id="wp916330"></a>
<div class="pBullet1Plus">
<ul>
<li>Provide a single service discovery mechanism through which
JavaBeans may interrogate their environment in order both to
ascertain the availability of particular services and to
subsequently employ those services.</li>
</ul>
</div>
<a name="wp916383" id="wp916383"></a>
<div class="pBullet1Plus">
<ul>
<li>Provide a simple mechanism to propagate an Environment to a
JavaBean.</li>
</ul>
</div>
<a name="wp916385" id="wp916385"></a>
<div class="pBullet1Last">
<ul>
<li>Provide better support for JavaBeans that are also
Applets.</li>
</ul>
</div>
</div>
<img src="images/beancontext.gif" alt=
"graphic representation of previous list points" />
<p><a name="wp919929" id="wp919929"></a></p>
<h2 class="pHeading1">2.0 API Specification</h2>
<a name="wp916410" id="wp916410"></a>
<h3 class="pHeading2">2.1 interface
java.beans.beancontext.BeanContext</h3>
<a name="wp918560" id="wp918560"></a>
<p class="pBody">The hierarchal structure and general facilities of
a <em class="cEmphasis">BeanContext</em> are provided for as
follows:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public interface                java.beans.beancontext.BeanContext<a name="wp916433"
id="wp916433"> </a>
           extends              java.beans.beancontext.BeanContextChild,<a name="wp916424"
id="wp916424"> </a>
                      java.util.Collection,<a name="wp919360" id=
"wp919360"> </a>
                         java.beans.DesignMode,<a name="wp920705"
id="wp920705"> </a>
                         java.beans.Visibility {<a name="wp920706"
id="wp920706"> </a>
<a name="wp919236" id="wp919236"> </a>
        Object instantiateChild(String beanName)<a name="wp917986"
id="wp917986"> </a>
                  throws IOException, ClassNotFoundException;<a name="wp918017"
id="wp918017"> </a>
<a name="wp918565" id="wp918565"> </a>
        public InputStream<a name="wp919565" id="wp919565"> </a>
                getResourceAsStream(String           name,<a name=
"wp919700" id="wp919700"> </a>
                                    BeanContextChild requestor<a name="wp919701"
id="wp919701"> </a>
                );<a name="wp919702" id="wp919702"> </a>
<a name="wp919567" id="wp919567"> </a>
        public java.net.URL<a name="wp919569" id="wp919569"> </a>
                getResource(String           name,<a name=
"wp919704" id="wp919704"> </a>
                            BeanContextChild requestor<a name=
"wp919705" id="wp919705"> </a>
                );<a name="wp919706" id="wp919706"> </a>
<a name="wp919707" id="wp919707"> </a>
        void addBeanContextMembershipListener(<a name="wp919784"
id="wp919784"> </a>
                   BeanContextMembershipListener bcml<a name=
"wp920859" id="wp920859"> </a>
          );<a name="wp920860" id="wp920860"> </a>
<a name="wp919383" id="wp919383"> </a>
        void removeBeanContextMembershipListener{<a name="wp919380"
id="wp919380"> </a>
                    BeanContextMembershipListener bcml<a name=
"wp919392" id="wp919392"> </a>
        );<a name="wp920861" id="wp920861"> </a>
<a name="wp921035" id="wp921035"> </a>
        public static final Object globalHierarchyLock;<a name=
"wp921036" id="wp921036"> </a>
}<a name="wp919563" id="wp919563"> </a>
</pre></div>
<a name="wp919880" id="wp919880"></a>
<p class="pBody">Notifications of changes in the membership of a
<em class="cEmphasis">BeanContext</em> are modeled as follows:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public interface BeanContextMembershipListener<a name="wp919943"
id="wp919943"> </a>
          extends   java.util.Listener {<a name="wp919850" id=
"wp919850"> </a>
        void childrenAdded(BeanContextMembershipEvent   bcme);<a name="wp919851"
id="wp919851"> </a>
        void childrenRemoved(BeanContextMembershipEvent bcme);<a name="wp919852"
id="wp919852"> </a>
}<a name="wp919853" id="wp919853"> </a>
<a name="wp919854" id="wp919854"> </a>
</pre></div>
<a name="wp920752" id="wp920752"></a>
<p class="pBody">The base class of all <em class=
"cEmphasis">BeanContext</em> related Events is defined by:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public abstract class BeanContextEvent<a name="wp919856" id=
"wp919856"> </a>
          extends  java.util.EventObject {<a name="wp919857" id=
"wp919857"> </a>
        public BeanContext getBeanContext();<a name="wp919858" id=
"wp919858"> </a>
<a name="wp919859" id="wp919859"> </a>
        public synchronized void<a name="wp919860" id=
"wp919860"> </a>
                setPropagatedFrom(BeanContext bc);<a name=
"wp919861" id="wp919861"> </a>
<a name="wp919862" id="wp919862"> </a>
        public synchronized BeanContext getPropagatedFrom();<a name="wp919863"
id="wp919863"> </a>
<a name="wp919864" id="wp919864"> </a>
        public synchronized boolean isPropagated()<a name=
"wp919865" id="wp919865"> </a>
}<a name="wp919866" id="wp919866"> </a>
<a name="wp919867" id="wp919867"> </a>
</pre></div>
<a name="wp920753" id="wp920753"></a>
<p class="pBody">The <em class=
"cEmphasis">BeanContextMembershipEvent</em> is defined as:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public class BeanContextMembershipEvent<a name="wp919868" id=
"wp919868"> </a>
          extends BeanContextEvent {<a name="wp919869" id=
"wp919869"> </a>
<a name="wp919870" id="wp919870"> </a>
        public BeanContextMembershipEvent(BeanContext bc,<a name=
"wp919871" id="wp919871"> </a>
                                          Object[]    deltas);<a name="wp919872"
id="wp919872"> </a>
<a name="wp919873" id="wp919873"> </a>
        public BeanContextMembershipEvent(BeanContext bc,<a name=
"wp919874" id="wp919874"> </a>
                                          Collection     deltas);<a name="wp919875"
id="wp919875"> </a>
<a name="wp920025" id="wp920025"> </a>
        public int size();<a name="wp920026" id="wp920026"> </a>
<a name="wp919948" id="wp919948"> </a>
        public boolean contains(Object child);<a name="wp919949"
id="wp919949"> </a>
<a name="wp919950" id="wp919950"> </a>
        public Object[] toArray();<a name="wp919951" id=
"wp919951"> </a>
<a name="wp919952" id="wp919952"> </a>
        public Iterator iterator();<a name="wp919953" id=
"wp919953"> </a>
}<a name="wp919876" id="wp919876"> </a>
</pre></div>
<a name="wp919733" id="wp919733"></a>
<h4 class="pHeading3">2.1.1 The BeanContext as a participant in
nested structure</h4>
<a name="wp916698" id="wp916698"></a>
<p class="pBody">One of the roles of the <em class=
"cEmphasis">BeanContext</em> is to introduce the notion of a
hierarchical nesting or structure of <em class=
"cEmphasis">BeanContext</em> and JavaBean instances. In order to
model this structure the <em class="cEmphasis">BeanContext</em>
must expose API that defines the relationships in the structure or
hierarchy.</p>
<a name="wp916730" id="wp916730"></a>
<p class="pBody">The <em class="cEmphasis">BeanContext</em> exposes
its superstructure through implementation of the <em class=
"cEmphasis">java.beans.beancontext.BeanContextChild</em> interface
(as described later). This interface allows the discovery and
manipulation of a <em class="cEmphasis">BeanContext</em>&#8217;s
nesting <em class="cEmphasis">BeanContext</em>, and thus introduces
a facility to create a hierarchy of <em class=
"cEmphasis">BeanContexts</em>.</p>
<a name="wp916885" id="wp916885"></a>
<p class="pBody">The <em class="cEmphasis">BeanContext</em> exposes
its substructure through a number of interface methods modeled by
the <em class="cEmphasis">java.util.Collection</em> interface
semantics</p>
<a name="wp920020" id="wp920020"></a>
<p class="pBody"><em class="cEmphasis">BeanContexts</em> are
required to implement all the mandatory <em class=
"cEmphasis">Collection</em> API&#8217;s, with the following
particular semantics for <em class="cEmphasis">add</em>() and
<em class="cEmphasis">remove</em>():.</p>
<a name="wp916737" id="wp916737"></a>
<p class="pBody">The <em class="cEmphasis">add()</em> method may be
invoked in order to nest a new <em class="cEmphasis">Object</em>,
<em class="cEmphasis">BeanContextChild</em>, or <em class=
"cEmphasis">BeanContext</em> within the target <em class=
"cEmphasis">BeanContext</em>. A conformant <em class=
"cEmphasis">add()</em> implementation is required to adhere to the
following semantics:</p>
<div style="margin-left: 2em" class="pBullet1"><a name="wp916739"
id="wp916739"></a>
<div class="pBullet1">
<ul>
<li>Synchronize on the <em class=
"cEmphasis">BeanContext.globalHierarchyLock.</em></li>
</ul>
</div>
<a name="wp921039" id="wp921039"></a>
<div class="pBullet1Plus">
<ul>
<li>Each child object shall appear only once in the set of children
for a given <em class="cEmphasis">BeanContext</em>. If the instance
is already a member of the <em class="cEmphasis">BeanContext</em>
then the method shall return False.</li>
</ul>
</div>
<a name="wp918628" id="wp918628"></a>
<div class="pBullet1Plus">
<ul>
<li>Each valid child shall be added to the set of children of a
given source <em class="cEmphasis">BeanContext,</em> and thus shall
appear in the set of children, obtained through either the
<em class="cEmphasis">toArray(),</em> or <em class=
"cEmphasis">iterator()</em> methods, until such time as that child
is deleted from the nesting <em class="cEmphasis">BeanContext</em>
via an invocation of <em class="cEmphasis">remove()</em>,
<em class="cEmphasis">removeAll()</em>, <em class=
"cEmphasis">retainAll()</em>, or <em class=
"cEmphasis">clear</em>()</li>
</ul>
</div>
<a name="wp918643" id="wp918643"></a>
<div class="pBullet1Plus">
<ul>
<li>As the child is added to the set of nested children, and where
that child implements the <em class=
"cEmphasis">java.beans.beancontext.BeanContextChild</em> interface
(or <em class="cEmphasis">BeanContextProxy,</em> see later for
details<em class="cEmphasis">)</em>, the <em class=
"cEmphasis">BeanContext</em> shall invoke the <em class=
"cEmphasis">setBeanContext</em>() method upon that child, with a
reference to itself. Upon invocation, a child may, if it is for
some reason unable or unprepared to function in that <em class=
"cEmphasis">BeanContext</em>, throw a <em class=
"cEmphasis">PropertyVetoException</em> to notify the nesting
<em class="cEmphasis">BeanContext</em>. If the child throws such an
exception the <em class="cEmphasis">BeanContext</em> shall revoke
the addition of the child (and any other partial changes made to
the state of the BeanContext as a side effect of this addition
operation) to the set of nested children and throw an <em class=
"cEmphasis">IllegalStateException</em>.</li>
</ul>
</div>
<a name="wp917044" id="wp917044"></a>
<div class="pBullet1Plus">
<ul>
<li>JavaBeans that implement the <em class=
"cEmphasis">java.beans.Visibility</em> interface shall be notified
via the appropriate method, either <em class=
"cEmphasis">dontUseGui()</em> or <em class=
"cEmphasis">okToUseGui(),</em> of their current ability to render
GUI as defined the policy of the <em class=
"cEmphasis">BeanContext</em>.</li>
</ul>
</div>
<a name="wp918520" id="wp918520"></a>
<div class="pBullet1Plus">
<ul>
<li>If the newly added child implements <em class=
"cEmphasis">BeanContextChild</em>, the <em class=
"cEmphasis">BeanContext</em> shall register itself with the child
on both its <em class="cEmphasis">VetoableChangeListener</em> and
<em class="cEmphasis">PropertyChangeListener</em> interfaces to
monitor, at least, that <em class=
"cEmphasis">BeanContextChild</em>&#8217;s &#8220;beanContext&#8221;
property.</li>
</ul>
</div>
<a name="wp919523" id="wp919523"></a>
<p class="pIndented1">By doing so the <em class=
"cEmphasis">BeanContext</em> can monitor its child and can detect
when such children are removed by a 3rd party (usually another
<em class="cEmphasis">BeanContext</em>) invoking <em class=
"cEmphasis">setBeanContext</em>(). A <em class=
"cEmphasis">BeanContext</em> may veto such a change by a 3rd party
if it determines that the child is not in a state to depart
membership at that time.</p>
<a name="wp919769" id="wp919769"></a>
<div class="pBullet1Plus">
<ul>
<li>If the JavaBean(s) added implement <em class=
"cEmphasis">Listener</em> interfaces that the <em class=
"cEmphasis">BeanContext</em> is a source for, then the <em class=
"cEmphasis">BeanContext</em> may register the newly added objects
via the appropriate <em class="cEmphasis">Listener</em>
registration methods as a permissible side effect of nesting.</li>
</ul>
</div>
<a name="wp920785" id="wp920785"></a>
<div class="pBullet1Plus">
<ul>
<li>If the JavaBean(s) added are Event Sources for Event that a
particular <em class="cEmphasis">BeanContext</em> has interest in
the <em class="cEmphasis">BeanContext</em> may, as a side effect of
adding the child, register <em class="cEmphasis">Listeners</em> on
that child. The <em class="cEmphasis">BeanContext</em> should avoid
using <em class="cEmphasis">Serializable</em> <em class=
"cEmphasis">Listeners</em> thus avoiding accidental serialization
of unwanted structure when a child serializes itself.</li>
</ul>
</div>
<a name="wp920898" id="wp920898"></a>
<div class="pBullet1Plus">
<ul>
<li>Once the <em class="cEmphasis">targetChild</em> has been
successfully processed, the <em class="cEmphasis">BeanContext</em>
shall fire a <em class=
"cEmphasis">java.beans.beancontext.BeanContextMembershipEvent</em>,
containing a reference to the newly added <em class=
"cEmphasis">targetChild</em>, to the <em class=
"cEmphasis">childrenAdded</em>() method of all the <em class=
"cEmphasis">BeanContextMemebrshipListeners</em> currently
registered.</li>
</ul>
</div>
<a name="wp919528" id="wp919528"></a>
<div class="pBullet1Last">
<ul>
<li>The method shall return true if successful.</li>
</ul>
</div>
</div>
<a name="wp919527" id="wp919527"></a>
<p class="pBody">The <em class="cEmphasis">remove()</em> method may
be invoked in order to remove an existing child JavaBean or
<em class="cEmphasis">BeanContext</em> from within the target
<em class="cEmphasis">BeanContext</em>. A conformant <em class=
"cEmphasis">remove()</em> implementation is required to adhere to
the following semantics:</p>
<div style="margin-left: 2em" class="pBullet1"><a name="wp918671"
id="wp918671"></a>
<div class="pBullet1">
<ul>
<li>Synchronize with the <em class=
"cEmphasis">BeanContext.globalHierarchyLock.</em></li>
</ul>
</div>
<a name="wp921044" id="wp921044"></a>
<div class="pBullet1Plus">
<ul>
<li>If a particular child is not present in the set of children for
the source <em class="cEmphasis">BeanContext,</em> the method shall
return False.</li>
</ul>
</div>
<a name="wp919531" id="wp919531"></a>
<div class="pBullet1Plus">
<ul>
<li>Remove the valid <em class="cEmphasis">targetChild</em> from
the set of children for the source <em class=
"cEmphasis">BeanContext,</em> also removing that child from any
other <em class="cEmphasis">Listener</em> interfaces that it was
implicitly registered on, for that <em class=
"cEmphasis">BeanContext</em> as a side-effect of nesting.</li>
</ul>
</div>
<a name="wp918237" id="wp918237"></a>
<p class="pIndented1">Subsequently, if the <em class=
"cEmphasis">targetChild</em> implements the <em class=
"cEmphasis">java.beans.beancontext.BeanContextChild</em> interface
(or <em class="cEmphasis">BeanContextProxy,</em> see later for
deatils), the <em class="cEmphasis">BeanContext</em> shall invoke
the <em class="cEmphasis">setBeanContext</em>() with a null<a href=
"#wp919546"><span class="Footnote">1</span></a> <em class=
"cEmphasis">BeanContext</em> value, in order to notify that child
that it is no longer nested within the <em class=
"cEmphasis">BeanContext</em>.</p>
<a name="wp918780" id="wp918780"></a>
<p class="pIndented1">If a particular <em class=
"cEmphasis">BeanContextChild</em> is in a state where it is not
able to be un-nested from its nesting <em class=
"cEmphasis">BeanContext</em> it may throw a <em class=
"cEmphasis">PropertyVetoException</em>, upon receipt of this the
<em class="cEmphasis">BeanContext</em> shall revoke the remove
operation for this instance and throw <em class=
"cEmphasis">IllegalStateException</em>. To avoid infinite
recursion, children are not permitted to repeatedly veto subsequent
remove notifications. In practice, a child should attempt to
resolve the condition (if temporary) that precludes it&#8217;s
removal from it&#8217;s current nesting <em class=
"cEmphasis">BeanContext.</em></p>
<a name="wp918699" id="wp918699"></a>
<div class="pBullet1Plus">
<ul>
<li>If the <em class="cEmphasis">targetChild</em> implements
<em class="cEmphasis">java.beans.beancontext.BeanContextChild</em>
then the <em class="cEmphasis">BeanContext</em> shall de-register
itself from that child&#8217;s <em class=
"cEmphasis">PropertyChangeListener</em> and <em class=
"cEmphasis">VetoableChangeListener</em> sources.</li>
</ul>
</div>
<a name="wp919770" id="wp919770"></a>
<div class="pBullet1Plus">
<ul>
<li>If the <em class="cEmphasis">BeanContext</em> had previously
registered the object(s) removed as <em class=
"cEmphasis">Listeners</em> on events sources implemented by the
<em class="cEmphasis">BeanContext</em> as a side effect of nesting
those objects, then the <em class="cEmphasis">BeanContext</em>
shall de-register the newly removed object from the applicable
source(s) via the appropriate <em class="cEmphasis">Listener</em>
de-registration method(s)</li>
</ul>
</div>
<a name="wp920906" id="wp920906"></a>
<div class="pBullet1Plus">
<ul>
<li>If the <em class="cEmphasis">BeanContext</em> had previously
registered <em class="cEmphasis">Listener(s)</em> on the object(s)
removed then the <em class="cEmphasis">BeanContext</em> shall
remove those Listener(s) from those object(s).</li>
</ul>
</div>
<a name="wp920908" id="wp920908"></a>
<div class="pBullet1Plus">
<ul>
<li>Once the <em class="cEmphasis">targetChild</em> has been
removed from the set of children, the <em class=
"cEmphasis">BeanContext</em> shall fire a <em class=
"cEmphasis">java.beans.beancontext.BeanContextMembershipEvent,</em>
containing a reference to the <em class=
"cEmphasis">targetChild</em> just removed, to the <em class=
"cEmphasis">childrenRemoved</em>() method of all the <em class=
"cEmphasis">BeanContextMembershipListeners</em> currently
registered.</li>
</ul>
</div>
<a name="wp919575" id="wp919575"></a>
<div class="pBullet1Last">
<ul>
<li>Finally the method shall return the value true if
successful.</li>
</ul>
</div>
</div>
<a name="wp918703" id="wp918703"></a>
<p class="pBody">Note that the lifetime of any child of a nesting
<em class="cEmphasis">BeanContext</em>, is at least for the
duration of that child&#8217;s containment within a given
<em class="cEmphasis">BeanContext</em>. For simple JavaBeans that
are not aware of their containment within a <em class=
"cEmphasis">BeanContext</em>, this usually implies that the
JavaBean shall exist for at least the lifetime of the nesting
<em class="cEmphasis">BeanContext</em>.</p>
<a name="wp920917" id="wp920917"></a>
<p class="pBody"><em class="cEmphasis">BeanContext</em>&#8217;s are
not required to implement either <em class=
"cEmphasis">addAll()</em>, <em class="cEmphasis">removeAll</em>(),
<em class="cEmphasis">retainAll</em>() or <em class=
"cEmphasis">clear()</em> optional methods defined by <em class=
"cEmphasis">java.util.Collection API</em>, however if they do they
must implement the semantics defined, per object, for both
<em class="cEmphasis">add</em>() and <em class=
"cEmphasis">remove</em>() above. In the failure cases these methods
shall revoke any partially applied changes to return the <em class=
"cEmphasis">BeanContext</em> to the state it was in prior to the
failing composite operation being invoked, no <em class=
"cEmphasis">BeanContextEvents</em> shall be fired in the failure
case as is consistent with the definition of <em class=
"cEmphasis">add()</em> and <em class="cEmphasis">remove()</em>
above.</p>
<a name="wp920924" id="wp920924"></a>
<p class="pBody"><em class=
"cEmphasis">BeanContextMembershipListeners</em> may be added and
removed via invocations of <em class=
"cEmphasis">addBeanContextMembershipListener</em>() and <em class=
"cEmphasis">removeBeanContextMembershipListener</em>().</p>
<a name="wp920925" id="wp920925"></a>
<p class="pBody">The <em class="cEmphasis">toArray(),</em> method
shall return a copy of the current set of JavaBean or <em class=
"cEmphasis">BeanContext</em> instances nested within the target
<em class="cEmphasis">BeanContext</em>, and the <em class=
"cEmphasis">iterator</em>() method shall supply a <em class=
"cEmphasis">java.util.Iterator</em> object over the same set of
children.</p>
<a name="wp920926" id="wp920926"></a>
<p class="pBody">The <em class="cEmphasis">contains()</em> method
shall return true if the object specified is currently a child of
the <em class="cEmphasis">BeanContext</em>.</p>
<a name="wp920927" id="wp920927"></a>
<p class="pBody">The <em class="cEmphasis">size()</em> method
returns the current number of children nested.</p>
<a name="wp920928" id="wp920928"></a>
<p class="pBody">The <em class="cEmphasis">isEmpty</em>() method
returns true if the <em class="cEmphasis">BeanContext</em> has no
children.</p>
<a name="wp920929" id="wp920929"></a>
<p class="pBody">Note that all the <em class=
"cEmphasis">Collection</em> methods all require proper
synchronization between each other by a given implementation in
order to function correctly in a multi-threaded environment, that
is, to ensure that any changes to the membership of the set of
JavaBeans nested within a given <em class=
"cEmphasis">BeanContext</em> are applied atomically. All
implementations are required to synchronized their implementations
of these methods with the <em class=
"cEmphasis">BeanContext.globalHierarchyLock</em>.</p>
<a name="wp920930" id="wp920930"></a>
<p class="pBody">In some situations, <em class=
"cEmphasis">add()</em> and <em class="cEmphasis">remove()</em> (or
a variant thereof) operations may occur nested, that is multiple
occurrences may appear on the stack of the calling <em class=
"cEmphasis">Thread</em> simultaneously<em class="cEmphasis">,</em>
e.g: when <em class="cEmphasis">BeanContextChild,</em> A, is added
(or removed), it&#8217;s <em class=
"cEmphasis">setBeanContext()</em> method also adds (or removes)
another <em class="cEmphasis">BeanContextChild,</em> B. A
particular <em class="cEmphasis">BeanContext</em> implementation
may choose to fire either two <em class=
"cEmphasis">BeanContextMembershipListener</em> notifications, one
for each <em class="cEmphasis">add()</em>/<em class=
"cEmphasis">remove()</em> operation of B then A (in this order
since B is successfully added before A), or coalesce these into a
single notification containing both A, and B. Note that should A be
unable to be added or removed for any reason it shall not perform,
or undo, any add or remove operations upon B as a side-effect,
prior to throwing a <em class=
"cEmphasis">PropertyVetoException</em> to indicate this condition,
that is, it must avoid or undo any side-effect membership changes
prior to rejecting any changes to its own membership status.</p>
<a name="wp920949" id="wp920949"></a>
<p class="pBody">The <em class="cEmphasis">instantiateChild()</em>
method is a convenience method that may be invoked to instantiate a
new JavaBean instance as a child of the target <em class=
"cEmphasis">BeanContext</em>. The implementation of the JavaBean is
derived from the value of the <em class="cEmphasis">beanName</em>
actual parameter, and is defined by the <em class=
"cEmphasis">java.beans.Beans.instantiate()</em> method.</p>
<a name="wp920931" id="wp920931"></a>
<p class="pBody">Typically, this shall be implemented by calling
the appropriate <em class=
"cEmphasis">java.beans.Beans.instantiate()</em> method, using the
<em class="cEmphasis">ClassLoader</em> of the target <em class=
"cEmphasis">BeanContext</em>. However a particular <em class=
"cEmphasis">BeanContext</em> implementation may interpose
side-effects on the instantiate operation in their implementation
of this method.</p>
<a name="wp920030" id="wp920030"></a>
<p class="pBody">The <em class="cEmphasis">BeanContextEvent</em> is
the abstract root <em class="cEmphasis">EventObject</em> class for
all <em class="cEmphasis">Events</em> pertaining to changes in
state of a <em class="cEmphasis">BeanContext</em>&#8217;s defined
semantics. This abstract root class defines the <em class=
"cEmphasis">BeanContext</em> that is the source of the
notification, and also introduces a mechanism to allow the
propagation of <em class="cEmphasis">BeanContextEvent</em>
subclasses through a hierarchy of <em class=
"cEmphasis">BeanContexts</em>. The <em class=
"cEmphasis">setPropagatedFrom</em>() and <em class=
"cEmphasis">getPropagatedFrom</em>() methods allows a <em class=
"cEmphasis">BeanContext</em> to identify itself as the source of a
propagated Event to the <em class="cEmphasis">BeanContext</em> to
which it subsequently propagates the <em class=
"cEmphasis">Event</em> to. This is a general propagation mechanism
and should be used with care as it has significant performance
implications when propagated through large hierarchies.</p>
<a name="wp920016" id="wp920016"></a>
<p class="pBody">The <em class=
"cEmphasis">BeanContextMembershipEvent</em> describes changes that
occur in the membership of a particular <em class=
"cEmphasis">BeanContext</em> instance. This event encapsulates the
list of children either added to, or removed from, the membership
of a particular <em class="cEmphasis">BeanContext</em> instance,
i.e the delta in the membership set.</p>
<a name="wp920017" id="wp920017"></a>
<p class="pBody">Whenever a successful <em class=
"cEmphasis">add</em>(), <em class="cEmphasis">remove</em>(),
<em class="cEmphasis">addAll</em>(), <em class=
"cEmphasis">retainAll</em>(), <em class=
"cEmphasis">removeAll</em>(), or <em class="cEmphasis">clear</em>()
is invoked upon a particular <em class="cEmphasis">BeanContext</em>
instance, a <em class="cEmphasis">BeanContextMembershipEvent</em>
is fired describing the children effected by the operation.</p>
<a name="wp919576" id="wp919576"></a>
<h4 class="pHeading3">2.1.2 Resources.</h4>
<a name="wp919581" id="wp919581"></a>
<p class="pBody">The <em class="cEmphasis">BeanContext</em> defines
two methods; <em class="cEmphasis">getResourceAsStream</em>() and
<em class="cEmphasis">getResource</em>() which are analogous to
those methods found on <em class="cEmphasis">java.lang.ClassLoader.
BeanContextChild</em> instances nested within a <em class=
"cEmphasis">BeanContext</em> shall invoke the methods on their
nesting <em class="cEmphasis">BeanContext</em> in preference for
those on <em class="cEmphasis">ClassLoader</em>, to allow a
<em class="cEmphasis">BeanContext</em> implementation to augment
the semantics by interposing behavior between the child and the
underlying <em class="cEmphasis">ClassLoader</em> semantics.</p>
<a name="wp918705" id="wp918705"></a>
<h4 class="pHeading3">2.1.3 The BeanContext as a Service
Provider</h4>
<a name="wp919899" id="wp919899"></a>
<p class="pBody">The service facilities of a <em class=
"cEmphasis">BeanContext</em> are provided as follows:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public interface BeanContextServices<a name="wp919900" id=
"wp919900"> </a>
          extends   BeanContext,BeanContextServicesListener {<a name="wp919901"
id="wp919901"> </a>
<a name="wp919902" id="wp919902"> </a>
        boolean addService(Class           serviceClass, <a name=
"wp919903" id="wp919903"> </a>
                           BeanContextServiceProvider service);<a name="wp919904"
id="wp919904"> </a>
<a name="wp919905" id="wp919905"> </a>
        boolean revokeService(Class           serviceClass,<a name=
"wp919906" id="wp919906"> </a>
                              BeanContextServiceProvider bcsp,<a name="wp919907"
id="wp919907"> </a>
                              boolean         revokeNow<a name=
"wp920698" id="wp920698"> </a>
        );<a name="wp920697" id="wp920697"> </a>
<a name="wp920038" id="wp920038"> </a>
        boolean hasService(Class serviceClass);<a name="wp920036"
id="wp920036"> </a>
<a name="wp920037" id="wp920037"> </a>
        Object getService(BeanContextChild      bcc,<a name=
"wp919909" id="wp919909"> </a>
                          Object                requestor.<a name=
"wp920718" id="wp920718"> </a>
                          Class                 serviceClass,<a name="wp920717"
id="wp920717"> </a>
                          Object                serviceSelector,<a name="wp919910"
id="wp919910"> </a>
                          BeanContextServicesRevokedListener sl<a name="wp920714"
id="wp920714"> </a>
        ) throws TooManyListenersException;<a name="wp920009" id=
"wp920009"> </a>
<a name="wp920031" id="wp920031"> </a>
        void releaseService(BeanContextChild bcc,<a name="wp919914"
id="wp919914"> </a>
                            Object           requestor,<a name=
"wp920708" id="wp920708"> </a>
                            Object           service);<a name=
"wp920707" id="wp920707"> </a>
<a name="wp919916" id="wp919916"> </a>
        Iterator getCurrentServiceClasses();<a name="wp919917" id=
"wp919917"> </a>
<a name="wp919918" id="wp919918"> </a>
        public Iterator getCurrentServiceSelectors(Class sc);<a name="wp919919"
id="wp919919"> </a>
<a name="wp919920" id="wp919920"> </a>
        addBeanContextServicesListener(<a name="wp919921" id=
"wp919921"> </a>
                BeanContextServicesListener bcsl<a name="wp919922"
id="wp919922"> </a>
        );<a name="wp919923" id="wp919923"> </a>
<a name="wp919924" id="wp919924"> </a>
        removeBeanContextServicesListener(<a name="wp919925" id=
"wp919925"> </a>
                BeanContextServicesListener bcsl<a name="wp919926"
id="wp919926"> </a>
     );<a name="wp919927" id="wp919927"> </a>
}<a name="wp919928" id="wp919928"> </a>
</pre></div>
<a name="wp920757" id="wp920757"></a>
<p class="pBody">The <em class=
"cEmphasis">BeanContextServiceProvider</em> interface is defined as
follows:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public interface BeanContextServiceProvider {<a name="wp919957" id=
"wp919957"> </a>
        Object getService(BeanContext bc,<a name="wp919973" id=
"wp919973"> </a>
                          Object      requestor,<a name="wp920730"
id="wp920730"> </a>
                          Class       serviceCls,<a name="wp920729"
id="wp920729"> </a>
                          Object      serviceSelector);<a name=
"wp919974" id="wp919974"> </a>
<a name="wp919980" id="wp919980"> </a>
        void releaseService(BeanContext bc,<a name="wp920732" id=
"wp920732"> </a>
                            Object      requestor,<a name=
"wp920733" id="wp920733"> </a>
                            Object      service);<a name="wp919981"
id="wp919981"> </a>
<a name="wp919982" id="wp919982"> </a>
        Iterator getCurrentServiceSelectors(BeanContext bc,<a name=
"wp919983" id="wp919983"> </a>
                                            Class serviceCls);<a name="wp920737"
id="wp920737"> </a>
}<a name="wp919958" id="wp919958"> </a>
<a name="wp920232" id="wp920232"> </a>
The <em class=
"cEmphasis">BeanContextServiceRevokedListener</em> is defined as follows:<a name="wp920759"
id="wp920759"> </a>
<a name="wp920763" id="wp920763"> </a>
public interface BeanContextServiceRevokedListener<a name=
"wp920762" id="wp920762"> </a>
          extends java.util.EventListener {<a name="wp920238" id=
"wp920238"> </a>
        void serviceRevoked(<a name="wp920245" id="wp920245"> </a>
                BeanContextServiceRevokedEvent bcsre<a name=
"wp920246" id="wp920246"> </a>
        );<a name="wp920241" id="wp920241"> </a>
}<a name="wp920239" id="wp920239"> </a>
</pre></div>
<a name="wp920764" id="wp920764"></a>
<p class="pBody">The <em class=
"cEmphasis">BeanContextServicesListener</em> is defined as
follows:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public interface BeanContextServicesListener<a name="wp919964" id=
"wp919964"> </a>
          extends BeanContextServiceRevokedListener {<a name=
"wp919965" id="wp919965"> </a>
        void serviceAvailable(<a name="wp919972" id=
"wp919972"> </a>
                BeanContextServiceAvailableEvent bcsae<a name=
"wp919994" id="wp919994"> </a>
        );<a name="wp919995" id="wp919995"> </a>
}<a name="wp919966" id="wp919966"> </a>
</pre></div>
<a name="wp919967" id="wp919967"></a>
<p class="pBody">The <em class=
"cEmphasis">BeanContextServiceAvailableEvent</em> is defined as
follows:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public class BeanContextServiceAvailableEvent <a name="wp919968"
id="wp919968"> </a>
          extends BeanContextEvent {<a name="wp919969" id=
"wp919969"> </a>
<a name="wp920058" id="wp920058"> </a>
        public BeanContextServiceAvailableEvent(<a name="wp920055"
id="wp920055"> </a>
                        BeanContextServices        bcs,<a name=
"wp920059" id="wp920059"> </a>
                        Class                      sc<a name=
"wp920060" id="wp920060"> </a>
     );<a name="wp920746" id="wp920746"> </a>
<a name="wp920065" id="wp920065"> </a>
        BeanContextServices getSourceAsBeanContextServices();<a name="wp920049"
id="wp920049"> </a>
<a name="wp920054" id="wp920054"> </a>
        public Class getServiceClass();<a name="wp920051" id=
"wp920051"> </a>
<a name="wp920072" id="wp920072"> </a>
        public boolean isServiceClass(Class serviceClass);<a name=
"wp920073" id="wp920073"> </a>
<a name="wp920069" id="wp920069"> </a>
        public Iterator getCurrentServiceSelectors();<a name=
"wp920066" id="wp920066"> </a>
}<a name="wp919970" id="wp919970"> </a>
</pre></div>
<a name="wp920749" id="wp920749"></a>
<p class="pBody">The <em class=
"cEmphasis">BeanContextServiceRevokedEvent</em> is defined as
follows:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public class BeanContextServiceRevokedEvent <a name="wp920046" id=
"wp920046"> </a>
          extends BeanContextEvent {<a name="wp920044" id=
"wp920044"> </a>
        public BeanContextServiceRevokedEvent(<a name="wp920074"
id="wp920074"> </a>
                                BeanContextServices        bcs,<a name="wp920080"
id="wp920080"> </a>
                                Class                      sc,<a name="wp920081"
id="wp920081"> </a>
                             boolean                    invalidNow<a name="wp920125"
id="wp920125"> </a>
        );<a name="wp920083" id="wp920083"> </a>
        public BeanContextServices<a name="wp920085" id=
"wp920085"> </a>
                        getSourceAsBeanContextServices();<a name=
"wp920086" id="wp920086"> </a>
<a name="wp920100" id="wp920100"> </a>
        public Class getServiceClass();<a name="wp920087" id=
"wp920087"> </a>
<a name="wp920089" id="wp920089"> </a>
        public boolean isServiceClass(Class service);<a name=
"wp920094" id="wp920094"> </a>
<a name="wp920126" id="wp920126"> </a>
        public boolean isCurrentServiceInvalidNow();<a name=
"wp920127" id="wp920127"> </a>
}<a name="wp920045" id="wp920045"> </a>
<a name="wp921603" id="wp921603"> </a>
</pre></div>
<a name="wp921604" id="wp921604"></a>
<p class="pBody">The <em class=
"cEmphasis">BeanContextServiceProviderBeanInfo</em> is defined as
follows:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public interface BeanContextServicesProviderBeanInfo<a name=
"wp921605" id="wp921605"> </a>
       extends   java.beans.BeanInfo {<a name="wp921606" id=
"wp921606"> </a>
    java.beans.BeanInfo[] getServicesBeanInfo();<a name="wp921607"
id="wp921607"> </a>
}<a name="wp921608" id="wp921608"> </a>
<a name="wp920042" id="wp920042"> </a>
</pre></div>
<a name="wp920110" id="wp920110"></a>
<p class="pBody">Apart from providing a structured hierarchy, the
other major role of a <em class="cEmphasis">BeanContext</em> is to
provide a standard mechanism for a JavaBean component to obtain
context-specific facilities or services from its environment.</p>
<a name="wp920128" id="wp920128"></a>
<p class="pBody">A service, represented by a <em class=
"cEmphasis">Class</em> object, is typically a reference to either
an interface, or to an implementation that is not publicly
instantiable. This <em class="cEmphasis">Class</em> defines an
interface protocol or contract between a <em class=
"cEmphasis">BeanContextServiceProvider</em>, the factory of the
service, and an arbitrary object associated with a <em class=
"cEmphasis">BeanContextChild</em> that is currently nested within
the <em class="cEmphasis">BeanContext</em> the service is
registered with. Typically such protocols encapsulate some context
specific or sensitive behavior that isolates a <em class=
"cEmphasis">BeanContextChild</em>&#8217;s implementation from such
dependencies thus resulting in simpler implementations, greater
interoperability and portability.</p>
<a name="wp920151" id="wp920151"></a>
<p class="pBody">A <em class=
"cEmphasis">BeanContextServiceProvider</em>, is a
&#8220;factory&#8221; for one or more services. It registers itself
with a particular <em class="cEmphasis">BeanContextServices</em>
via it&#8217;s <em class="cEmphasis">adService</em>() method, if
the service is not already registered with the <em class=
"cEmphasis">BeanContextServices</em>, the <em class=
"cEmphasis">BeanContextServices</em> associates the service
specified with the <em class=
"cEmphasis">BeanContextServiceProvider,</em> and fires a <em class=
"cEmphasis">BeanContextServiceAvailableEvent</em> via the
<em class="cEmphasis">serviceAvailable</em>() method to those
<em class="cEmphasis">BeanContextServicesListeners</em> currently
registered, then returns true, otherwise false indicating that the
service is already registered for that <em class=
"cEmphasis">BeanContextServices</em>.</p>
<a name="wp920167" id="wp920167"></a>
<p class="pBody">Once registered, and until revoked, the service is
available via the <em class="cEmphasis">BeanContextServices</em>
<em class="cEmphasis">getService</em>() method.</p>
<a name="wp920771" id="wp920771"></a>
<p class="pBody">The <em class="cEmphasis">hasService</em>() method
may be used to test the presence of a particular service, and the
<em class="cEmphasis">getCurrentServices</em>() method returns an
iterator over the currently available services for that <em class=
"cEmphasis">BeanContextServices</em>.</p>
<a name="wp920196" id="wp920196"></a>
<p class="pBody">A <em class="cEmphasis">BeanContextChild</em> or
any arbitrary object associated with a <em class=
"cEmphasis">BeanContextChild</em>, may obtain a reference to a
currently registered service from its nesting <em class=
"cEmphasis">BeanContextServices</em> via an invocation of the
<em class="cEmphasis">getService</em>() method. The <em class=
"cEmphasis">getService</em>() method specifies; the <em class=
"cEmphasis">BeanContextChild</em>, the associated <em class=
"cEmphasis">requestor</em>, the <em class="cEmphasis">Class</em> of
the service requested, a service dependent parameter (known as a
Service Selector), and a <em class=
"cEmphasis">BeanContextServicesRevokedListener</em> used to
subsequently notify the requestor that the service class has been
revoked by the <em class=
"cEmphasis">BeanContextServiceProvider</em>. The <em class=
"cEmphasis">Listener</em> is registered automatically with a
unicast event source per requestor and service class and is
automatically unregistered when a requestor relinquishes all
references of a given service class, or as a side effect of the
service being &#8220;forcibly revoked&#8221; by the providing
<em class="cEmphasis">BeanContextServiceProvider</em>.</p>
<a name="wp920205" id="wp920205"></a>
<p class="pBody">The <em class="cEmphasis">BeanContextServices</em>
passes this <em class="cEmphasis">getService</em>() invocation onto
the associated <em class=
"cEmphasis">BeanContextServiceProvider</em> (if any) to be
satisfied via an invocation of its <em class=
"cEmphasis">getService</em>() method. The <em class=
"cEmphasis">BeanContextServiceProvider</em> is passed the
<em class="cEmphasis">BeanContext</em>, the <em class=
"cEmphasis">Class</em> of the service provided, the service
dependent service parameter (the Service Selector) and a reference
to the object requesting the service.</p>
<a name="wp920936" id="wp920936"></a>
<p class="pBody">The reference to the <em class=
"cEmphasis">BeanContext</em> is intended to enable the <em class=
"cEmphasis">BeanContextServiceProvider</em> to distinguish service
requests from multiple sources. A <em class=
"cEmphasis">BeanContextServiceProvider</em> is only permitted to
retain a weak reference to any <em class=
"cEmphasis">BeanContext</em> so obtained.</p>
<a name="wp920941" id="wp920941"></a>
<p class="pBody">The Service Selector parameter is a service
dependent value used by a service requestor for a particular
service in order to parameterize the service to be provided to it
by the <em class="cEmphasis">BeanContextServiceProvider</em>. Some
examples of its usage are; a parameter to a constructor for the
service implementation class; a value for a particular
service&#8217;s property, or as a key into a map of existing
implementations.</p>
<a name="wp920220" id="wp920220"></a>
<p class="pBody">The reference to the requestor is intended to
permit the <em class="cEmphasis">BeanContextServiceProvider</em> to
interrogate the state of the requestor in order to perform any
customization or parameterization of the service, therefore this
reference shall be treated as immutable by the <em class=
"cEmphasis">BeanContextServicesProvider</em>. Additionally the
<em class="cEmphasis">BeanContextServiceProvider</em> is permitted
to retain only weak and immutable reference to both the <em class=
"cEmphasis">requestor</em> and the <em class=
"cEmphasis">BeanContextChild</em> after returning from the
<em class="cEmphasis">getService</em>() invocation.</p>
<a name="wp920216" id="wp920216"></a>
<p class="pBody">The <em class=
"cEmphasis">BeanContextServiceProvider</em> may satisfy the
request, returning a reference to an instance of the <em class=
"cEmphasis">Class</em> of the requested service (such that the
reference returned shall result in the expression: <em class=
"cEmphasis">&lt;serviceRefence&gt;</em> instanceof <em class=
"cEmphasis">&lt;serviceClass&gt;</em> being true), return null, or
throw an unchecked exception.</p>
<a name="wp920796" id="wp920796"></a>
<p class="pBody">In the case when a nested <em class=
"cEmphasis">BeanContextServices</em> is requested for a particular
service that it has no <em class=
"cEmphasis">BeanContextServiceProvider</em> for, then the
<em class="cEmphasis">BeanContextServices</em> may delegate the
service requested to its own nesting <em class=
"cEmphasis">BeanContextServices</em> in order to be satisfied. Thus
delegation requests can propagate from the leaf <em class=
"cEmphasis">BeanContextServices</em> to the root <em class=
"cEmphasis">BeanContextServices.</em></p>
<a name="wp920221" id="wp920221"></a>
<p class="pBody">A <em class="cEmphasis">BeanContextChild</em> may
query a particular <em class="cEmphasis">BeanContextServices</em>
for a list of currently available Service Classes (via the
<em class="cEmphasis">getCurrentServiceClasses</em>() method)and
any associated Service Selectors, if a particular service
<em class="cEmphasis">Class</em> implements a finite list of
apriori values for a Service Class, via its nesting <em class=
"cEmphasis">BeanContextServices.getCurrentServiceSelectors</em>()
method, which in turn obtains the currently available Service
Selectors (if any) via the <em class=
"cEmphasis">BeanContextServiceProvider.getCurrentServiceSelectors</em>()
method.</p>
<a name="wp920224" id="wp920224"></a>
<p class="pBody">If the service in question does not implement a
finite set of apriori values for the set of valid Service Selectors
it shall return null.</p>
<a name="wp920874" id="wp920874"></a>
<p class="pBody">A reference obtained by a <em class=
"cEmphasis">BeanContextChild</em> via <em class=
"cEmphasis">getService</em>() is valid until the reference is
released by the <em class="cEmphasis">BeanContextChild</em> via an
invocation of its nesting <em class=
"cEmphasis">BeanContextServices</em> <em class=
"cEmphasis">releaseService</em>() method, except in the case where
the <em class="cEmphasis">BeanContextServices</em> fires a
<em class="cEmphasis">BeanContextServiceRevokedEvent</em> and that
Event&#8217;s <em class=
"cEmphasis">isCurrentServiceInvalidNow</em>() method returns true,
in this case the <em class="cEmphasis">BeanContextServices</em>
and/or the <em class="cEmphasis">BeanContextServiceProvider</em>
that provided the service has determined that current service
references are immediately invalidated, or &#8220;forcibly
revoked&#8221; (this typically occurs in the following
situation).</p>
<a name="wp920227" id="wp920227"></a>
<p class="pBody">When <em class="cEmphasis">BeanContextChild</em>
instances are removed from a particular <em class=
"cEmphasis">BeanContextServices</em> instance, they shall discard
all references to any services they obtained from that <em class=
"cEmphasis">BeanContextServices</em> by appropriate invocations of
<em class="cEmphasis">releaseService</em>(). If the un-nesting
<em class="cEmphasis">BeanContextChild</em> is also a <em class=
"cEmphasis">BeanContextServices</em> instance, and if any of these
service references have been exposed to the un-nesting <em class=
"cEmphasis">BeanContextServices</em>&#8217;s own members as a
result of a delegated <em class="cEmphasis">getService</em>()
request as defined above, the <em class=
"cEmphasis">BeanContextServiecs</em> shall fire a <em class=
"cEmphasis">BeanContextServiceRevokedEvent</em> to notify its
nested children that the service(s) are &#8220;forcibly
revoked&#8221;. This immediate invalidation of current references
to delegated services at un-nesting is to ensure that services that
are dependent upon the structure of the hierarchy are not used by
requestors after their location in the structure has changed.</p>
<a name="wp920877" id="wp920877"></a>
<p class="pBody"><em class="cEmphasis">BeanContextChild</em>
instances receiving a &#8220;forcable revocation&#8221; of a
Service Class shall not invoke <em class=
"cEmphasis">releaseService</em>() for any references it may hold of
that type, since in this case, the <em class=
"cEmphasis">BeanContextServiceProvider</em> or the <em class=
"cEmphasis">BeanContextServices</em> that provided the service
reference to that <em class="cEmphasis">BeanContextChild</em> has
already invalidated all references to that service on their
behalf.</p>
<a name="wp920228" id="wp920228"></a>
<p class="pBody">A <em class=
"cEmphasis">BeanContextServiceProvider</em> may revoke a Service
Class at any time after it has registered it with a <em class=
"cEmphasis">BeanContextServices</em> by invoking its <em class=
"cEmphasis">revokeService</em>() method. Once the <em class=
"cEmphasis">BeanContextServices</em> has fired a <em class=
"cEmphasis">BeanContextServiceRevokedEvent</em> notifying the
currently registered <em class=
"cEmphasis">BeanContextServiceRevokedListeners</em> and the
<em class="cEmphasis">BeanContextServicesListeners</em> that the
service is now unavailable it shall no longer satisfy any new
service requests for the revoked service until (if at all) that
Service Class is re-registered. References obtained by <em class=
"cEmphasis">BeanContextChild</em> requestors to a service prior to
its being revoked remain valid, and therefore the service shall
remain valid to satisfy those extant references, until all
references to that service are released, unless in exceptional
circumstances the <em class=
"cEmphasis">BeanContextServiceProvider,</em> or <em class=
"cEmphasis">BeanContextServices</em>, when revoking the service,
wants to immediately terminate service to all the current
references. This immediate revocation is achieved by invoking the
<em class="cEmphasis">BeanContextServices</em> .<em class=
"cEmphasis">revokeService</em>() method with an actual parameter
value of <em class="cEmphasis">revokeNow</em> == true. Subsequent
to immediate invalidation of current service references the service
implementation may throw a service specific unchecked exception in
response to any attempts to continue to use the revoked service by
service requestors that have erroneously retained references to the
service, ignoring the earlier immediate revocation
notification.</p>
<a name="wp920954" id="wp920954"></a>
<p class="pBody">Note that in order to function correctly (when
delegating service requests) in a multi-threaded environment,
implementations of <em class="cEmphasis">BeanContextServices</em>
are required to synchronize their implementations of; <em class=
"cEmphasis">addService(), hasService(), getCurrentServiceClasses(),
getCurrentServiceSelectors(), getService(), releaseService()</em>
and <em class="cEmphasis">revokeService()</em> with the <em class=
"cEmphasis">BeanContext.globalHierarhyLock</em>.</p>
<a name="wp921613" id="wp921613"></a>
<p class="pBody">A <em class=
"cEmphasis">BeanContextServicesProvider</em> may expose the
<em class="cEmphasis">BeanInfo</em> for the Service Classes it
provides implementations for by providing a <em class=
"cEmphasis">BeanInfo</em> class that implements <em class=
"cEmphasis">BeanContextServicesProviderBeanInfo.</em> Thus exposing
an array of <em class="cEmphasis">BeanInfo</em>&#8217;s, one for
each Service Class supported. Builder tools can, for example, use
this infomation to provide application developers with a palette of
Servlice Classes for inclusion in an application.</p>
<a name="wp920139" id="wp920139"></a>
<h4 class="pHeading3">2.1.4 The role of a BeanContext in
Persistence</h4>
<a name="wp916796" id="wp916796"></a>
<p class="pBody">Since one of the primary roles of a <em class=
"cEmphasis">BeanContext</em> is to represent a logical nested
structure of JavaBean component and <em class=
"cEmphasis">BeanContext</em> instance hierarchies, it is natural to
expect that in many scenarios that hierarchy should be persistent,
i.e that the <em class="cEmphasis">BeanContext</em> should
participate in persistence mechanisms, in particular, either
<em class="cEmphasis">java.io.Serializable</em> or <em class=
"cEmphasis">java.io.Externalizable (</em>If the latter the
<em class="cEmphasis">BeanContext</em> is responsible for acting as
the persistence container for the sub-graph of children, encoding
and decoding the class information, and maintaining sub-graph
equivalence after deserialization, basically the function(s)
provide for serialization by <em class=
"cEmphasis">ObjectOutputStream</em> and <em class=
"cEmphasis">ObjectInputStream</em>).</p>
<a name="wp918473" id="wp918473"></a>
<p class="pBody">In particular <em class=
"cEmphasis">BeanContext</em>s shall persist and restore their
current children that implement the appropriate persistence
interfaces when they themselves are made persistent or subsequently
restored.</p>
<a name="wp918472" id="wp918472"></a>
<p class="pBody">As a result of the above requirement, persistent
<em class="cEmphasis">BeanContextChil</em>d implementations are
required to not persist any references to either their nesting
<em class="cEmphasis">BeanContext</em>, or to any Delegates
obtained via its nesting <em class=
"cEmphasis">BeanContextServices</em>.</p>
<a name="wp919674" id="wp919674"></a>
<p class="pBody"><em class="cEmphasis">BeanContexts</em> shall,
when restoring an instance of <em class=
"cEmphasis">BeanContextChild</em> from its persistence state, be
required to perform the equivalent of invoking add()on the newly
instantiated <em class="cEmphasis">BeanContextChild,</em>, in order
to notify the newly restored instance of its nesting <em class=
"cEmphasis">BeanContext</em>, thus allowing that <em class=
"cEmphasis">BeanContextChild</em> to fully reestablish its
dependencies on its environment.</p>
<a name="wp917961" id="wp917961"></a>
<p class="pBody">Also note that since <em class=
"cEmphasis">BeanContext</em> implements <em class=
"cEmphasis">java.beans.beancontext.BeanContextChild</em> it shall
obey the persistence requirements defined below for implementors of
that interface.</p>
<a name="wp919984" id="wp919984"></a>
<h4 class="pHeading3">2.1.5 BeanContext with associated
presentation hierarchies</h4>
<a name="wp919985" id="wp919985"></a>
<p class="pBody">Although not required, many <em class=
"cEmphasis">BeanContext</em>s may be associated within a
presentation hierarchy of <em class=
"cEmphasis">java.awt.Container</em>s and <em class=
"cEmphasis">java.awt.Component</em>s. A <em class=
"cEmphasis">Container</em> cannot implement <em class=
"cEmphasis">BeanContext</em> directly<a href=
"#wp920835"><span class="Footnote">2</span></a> but may be
associated with one by implementing the <em class=
"cEmphasis">BeanContextProxy</em> interface described herein.</p>
<div class="pPreformatted">
<pre class="pPreformatted">
<a name="wp920969" id="wp920969"> </a>
public interface BeanContextProxy {<a name="wp920970" id=
"wp920970"> </a>
    BeanContext getBeanContext();<a name="wp920971" id=
"wp920971"> </a>
}<a name="wp920972" id="wp920972"> </a>
</pre></div>
<a name="wp920973" id="wp920973"></a>
<p class="pBody">For instances of classes that do not (or cannot in
the case of <em class="cEmphasis">Component</em> or subclasses
thereof) directly implement the <em class=
"cEmphasis">BeanContext</em> interface, but are associated with an
instance of such an implementation, (via delegation) such instances
may expose this association by implementing the <em class=
"cEmphasis">BeanContextProxy</em> interface. By doing so, this
enables arbitrary 3rd parties, such as builder tools, to
interrogate and discover the <em class="cEmphasis">BeanContext</em>
associated with such objects for the purposes of either nesting
objects within that associated <em class=
"cEmphasis">BeanContext</em>, observing changes in the membership,
or obtaining services thereof.</p>
<a name="wp920974" id="wp920974"></a>
<p class="pBody">This also permits multiple distinct objects (e.g:
<em class="cEmphasis">Containers</em>) to share a single <em class=
"cEmphasis">BeanContext</em>. [Note though that in this case a
shared <em class="cEmphasis">BeanContext</em> shall not implement
<em class="cEmphasis">BeanContextContainerProxy</em> since that is
a peer-to-peer relationship between a single <em class=
"cEmphasis">BeanContext</em> and the <em class=
"cEmphasis">Container</em> implementing that interface]</p>
<a name="wp920975" id="wp920975"></a>
<p class="pBody">The value returned from <em class=
"cEmphasis">getBeanContext()</em> is constant for the lifetime of
the implementing instance, that is the relationship between a
<em class="cEmphasis">BeanContextProxy</em> and it&#8217;s
associated <em class="cEmphasis">BeanContext</em> is static and
thus may not change for the lifetime of either participant.</p>
<a name="wp920976" id="wp920976"></a>
<p class="pBody">No class may implement both the <em class=
"cEmphasis">BeanContext</em> (or <em class=
"cEmphasis">BeanContextChild</em>) and the <em class=
"cEmphasis">BeanContextProxy</em> interfaces, they are mutually
exclusive.</p>
<a name="wp920990" id="wp920990"></a>
<p class="pBody">Some <em class="cEmphasis">BeanContextProxy</em>
implementors may also implement <em class=
"cEmphasis">java.util.Collection</em>, or some other
collection-like API (e.g <em class=
"cEmphasis">java.awt.Container</em>), in addition to, and possibly
distinct from, maintaining a <em class="cEmphasis">BeanContext</em>
based <em class="cEmphasis">Collection</em>.</p>
<a name="wp920991" id="wp920991"></a>
<p class="pBody">In such cases it is possible to add, or remove,
elements from either the <em class="cEmphasis">BeanContext,</em>
via it&#8217;s <em class="cEmphasis">Collection</em> API&#8217;s,
or the <em class="cEmphasis">BeanContextProxy</em> implementor
using it&#8217;s own collection-like API&#8217;s (e.g: <em class=
"cEmphasis">public boolean java.awt.Container.add(Component)</em>).
It is implementation dependent whether or not objects added or
removed from either the <em class=
"cEmphasis">BeanContext</em>&#8217;s <em class=
"cEmphasis">Collection</em>, or the <em class=
"cEmphasis">BeanContextProxy</em> implementor&#8217;s collection
are also added or removed from the corresponding object&#8217;s
collection (i.e: should a <em class=
"cEmphasis">Container.add(</em>) also infer a <em class=
"cEmphasis">BeanContext.add()</em> and vica-versa?). In such
situations both participants (the implementor of <em class=
"cEmphasis">BeanContextProxy</em> and the <em class=
"cEmphasis">BeanContext</em> itself) are required to; 1) implement
the same add/remove semantics as the other (i.e: if <em class=
"cEmphasis">x.add(o)</em> has a side effect of <em class=
"cEmphasis">x.getBeanContext().add(o)</em> then <em class=
"cEmphasis">x.getBeanContext().add(o)</em> should also a have side
effect of <em class="cEmphasis">x.add(o)</em>), and 2) before
adding/removing an object to/from the other participants
collection, it should test (synchronized) if that object is/is not
a member of the other participants collection before proceeding
with the operation in question (this is to avoid infinite recursion
between collection operations on both participants) (i.e:
<em class="cEmphasis">x.add(o)</em> should not invoke <em class=
"cEmphasis">x.getBeanContext().add(o)</em> if <em class=
"cEmphasis">x.getBeanContext().contains(o)</em> is true and
vica-versa).</p>
<a name="wp921595" id="wp921595"></a>
<p class="pBody">It is important to note that if an object that
implements <em class="cEmphasis">BeanContextProxy</em> is added to
, or removed from, a <em class="cEmphasis">BeanContext</em>, that
in addition to the operation performed on that object, the same
operation should be performed on the <em class=
"cEmphasis">BeanContext</em> returned from <em class=
"cEmphasis">BeanContextProxy.getBeanContext()</em>. That is an
implementor of <em class="cEmphasis">BeanContextProxy</em> shall be
treated as though it directly implemented <em class=
"cEmphasis">BeanContext</em> by any nesting <em class=
"cEmphasis">BeanContext</em>. (and vica-versa if the operation is
applied to the <em class="cEmphasis">BeanContext</em> its shall
also be applied to the corresponding <em class=
"cEmphasis">BeanContextProxy</em>)</p>
<a name="wp921598" id="wp921598"></a>
<p class="pBody">The following interface is defined to allow a
<em class="cEmphasis">BeanContext</em> to expose a reference to an
associated <em class="cEmphasis">Container</em> to enable
it&#8217;s <em class="cEmphasis">BeanContextChild</em> members to
add, or remove, their associated <em class=
"cEmphasis">Component</em> objects to/from that <em class=
"cEmphasis">Container</em> or to inspect some state on the
<em class="cEmphasis">Container</em>.</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public interface BeanContextContainerProxy {<a name="wp919988" id=
"wp919988"> </a>
        Container getContainer()<a name="wp919989" id=
"wp919989"> </a>
}<a name="wp919990" id="wp919990"> </a>
</pre></div>
<a name="wp921074" id="wp921074"></a>
<p class="pBody">When a <em class="cEmphasis">BeanContextChild</em>
with an associated <em class="cEmphasis">Component</em> is added to
a <em class="cEmphasis">BeanContext</em> with an associated
<em class="cEmphasis">Container</em> there are three models of
interaction that can occur in relation to the nesting of the
<em class="cEmphasis">Component</em> in the <em class=
"cEmphasis">Container</em> as a result:</p>
<div style="margin-left: 2em" class="pList1"><a name="wp921086" id=
"wp921086"></a>
<div class="pList1">
<ul>
<li>If the associated <em class="cEmphasis">Component</em> was
added to the associated <em class="cEmphasis">Container</em> via a
<em class="cEmphasis">Container</em> API, then the nesting of the
<em class="cEmphasis">BeanContextChild</em> in the <em class=
"cEmphasis">BeanContext</em> is a side effect of that and no
further action is required.</li>
</ul>
</div>
<a name="wp921085" id="wp921085"></a>
<div class="pList1Plus">
<ul>
<li>If the <em class="cEmphasis">Component</em> and <em class=
"cEmphasis">Container</em> are not nested then the nesting
<em class="cEmphasis">BeanContext</em> may as a side effect cause
the <em class="cEmphasis">Component</em> associated with the
<em class="cEmphasis">BeanContextChild</em> to be added to
it&#8217;s associated <em class="cEmphasis">Container</em>.</li>
</ul>
</div>
<a name="wp921091" id="wp921091"></a>
<p class="pIndented1">OR</p>
<a name="wp921092" id="wp921092"></a>
<div class="pList1Last">
<ul>
<li>If the <em class="cEmphasis">Component</em> and <em class=
"cEmphasis">Container</em> are not nested then the <em class=
"cEmphasis">BeanContextChild</em> being nested may as a side effect
may cause it&#8217;s <em class="cEmphasis">Component</em> to be
associated with the <em class="cEmphasis">Container</em> associated
with the nesting <em class="cEmphasis">BeanContext</em>.</li>
</ul>
</div>
</div>
<a name="wp921084" id="wp921084"></a>
<p class="pBody">Thus, for greatest interoperability a <em class=
"cEmphasis">BeanContextChild</em> shall always check if its
<em class="cEmphasis">Compoent</em>&#8217;s parent is the
<em class="cEmphasis">BeanContext</em> Container, and if it is not,
then it may add itself if appropriate. Thus a <em class=
"cEmphasis">BeanContextChild</em> may function correctly under all
scenarios.</p>
<a name="wp921096" id="wp921096"></a>
<p class="pBody">The <em class="cEmphasis">BeanContextChild</em> is
responsible for initially causing itself to eligible to be
displayed via an invocation of <em class="cEmphasis">show</em>()
[note that the <em class="cEmphasis">BeanContextChild</em> may also
subsequently repeatedly <em class="cEmphasis">hide()</em> and
<em class="cEmphasis">show()</em> itself].</p>
<a name="wp920295" id="wp920295"></a>
<p class="pBody">The nesting <em class=
"cEmphasis">BeanContext</em>, or its associated <em class=
"cEmphasis">Container</em>, may subsequently <em class=
"cEmphasis">hide</em>() or <em class="cEmphasis">show</em>() the
<em class="cEmphasis">BeanContextChild</em>&#8217;s <em class=
"cEmphasis">Component</em> arbitrarily, but it is strongly
recommended that it treat that <em class="cEmphasis">Component</em>
as immutable in all other respects with the exception of
registering <em class="cEmphasis">Listeners</em> to obtain event
notifications, or where other <em class=
"cEmphasis">Component</em>/<em class="cEmphasis">Container</em>
specific protocols permit or require the <em class=
"cEmphasis">Container</em> to alter the state of its <em class=
"cEmphasis">Component</em> containees. An example of such a
permitted interaction would be where a property such as <em class=
"cEmphasis">background</em> or <em class=
"cEmphasis">foreground</em> color were propagated from <em class=
"cEmphasis">Container</em> to <em class=
"cEmphasis">Component</em>.</p>
<a name="wp920857" id="wp920857"></a>
<p class="pBody">Once a <em class="cEmphasis">BeanContextChild</em>
has been un-nested from it&#8217;s <em class=
"cEmphasis">BeanContext</em>, it&#8217;s associated <em class=
"cEmphasis">Component</em> (if any) shall be removed from that
<em class="cEmphasis">BeanContext</em>&#8217;s <em class=
"cEmphasis">Container</em> as a side effect of the removal
operation, this is the responsibility of the <em class=
"cEmphasis">BeanContext</em> (typically if the <em class=
"cEmphasis">BeanContextChild</em> has been moved to another
<em class="cEmphasis">BeanContext</em> with an associated
<em class="cEmphasis">Container</em> via an invocation of
it&#8217;s <em class="cEmphasis">setBeanContext()</em> method, the
<em class="cEmphasis">Component</em> will already have been
re-parented as a side effect of that operation by the time the
original <em class="cEmphasis">BeanContext</em> is notified of the
change via a <em class="cEmphasis">PropertyChangeEvent</em> from
the child, however the check should be made and the <em class=
"cEmphasis">Component</em> removed if it has not already
occurred).</p>
<a name="wp920883" id="wp920883"></a>
<p class="pBody">To avoid infinite recursion, both a <em class=
"cEmphasis">BeanContext</em> and a <em class=
"cEmphasis">BeanContextChild</em> that also are associated with a
<em class="cEmphasis">Container</em> and <em class=
"cEmphasis">Component</em> nesting relationship should avoid
undoing any changes applied to the <em class=
"cEmphasis">Component</em> by the other party in the relationship.
In general the <em class="cEmphasis">BeanContext</em> is
responsible for the appearance, visibility and relative layout of
the <em class="cEmphasis">BeanContextChild</em>&#8217;s <em class=
"cEmphasis">Component,</em> and the <em class=
"cEmphasis">BeanContextChild</em> is responsible for the <em class=
"cEmphasis">Component</em>&#8217;s state and content pertaining to
the application functionality it is implementing.</p>
<a name="wp920839" id="wp920839"></a>
<p class="pBody">The value returned from the <em class=
"cEmphasis">getContainer()</em> method is constant for the lifetime
of the implementing <em class="cEmphasis">BeanContext,</em> that is
the relationship between a <em class="cEmphasis">BeanContext</em>
and a <em class="cEmphasis">Container</em> is static for the
lifetime of both participants.</p>
<a name="wp920805" id="wp920805"></a>
<p class="pBody">In addition the following interface is also
defined:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public interface BeanContextChildComponentProxy {<a name="wp920806"
id="wp920806"> </a>
    Component getComponent();<a name="wp920811" id="wp920811"> </a>
}<a name="wp920812" id="wp920812"> </a>
</pre></div>
<a name="wp920838" id="wp920838"></a>
<p class="pBody">A <em class="cEmphasis">BeanContext</em> or a
<em class="cEmphasis">BeanContextChild</em> may implement this
interface to expose the GUI <em class="cEmphasis">Component</em>
that it is associated with to it&#8217;s nesting <em class=
"cEmphasis">BeanContext</em>. A <em class=
"cEmphasis">BeanContext</em> may use this method to establish the
relationship between references to instances of <em class=
"cEmphasis">Component</em> and <em class=
"cEmphasis">BeanContextChild</em> that are known to it, where a
<em class="cEmphasis">BeanContextChild</em> and <em class=
"cEmphasis">Component</em> are not implemented by the same object
instance (that is the <em class="cEmphasis">BeanContextChild</em>
delegates its <em class="cEmphasis">Component</em> implementation
to a distinct object rather than inheriting from <em class=
"cEmphasis">Component</em>]. A <em class=
"cEmphasis">BeanContext</em> may interrogate the <em class=
"cEmphasis">Component</em> reference it obtains from a nested
<em class="cEmphasis">BeanContextChild</em> in order to determine
its state, and it may also register <em class=
"cEmphasis">Listeners</em> for particular events, however it is
strongly recommended that the <em class=
"cEmphasis">BeanContext</em> treat the reference as generally
immutable to avoid changing the <em class=
"cEmphasis">Component</em> state.</p>
<a name="wp920843" id="wp920843"></a>
<p class="pBody">The value returned from the <em class=
"cEmphasis">getComponent()</em> method is a constant for the
lifetime of that <em class="cEmphasis">BeanContextChild</em>.</p>
<a name="wp920884" id="wp920884"></a>
<p class="pBody">In the situation where a <em class=
"cEmphasis">BeanContext</em> has an associated <em class=
"cEmphasis">Container,</em> but does not wish to expose that
<em class="cEmphasis">Container</em> by implementing the <em class=
"cEmphasis">BeanContextContainerProxy</em> interface, but wishes to
handle the nesting of an arbitrary <em class=
"cEmphasis">BeanContextChild</em>&#8217;s associated <em class=
"cEmphasis">Component</em> (exposed by the <em class=
"cEmphasis">BeanContextChild</em> either implementing the
<em class="cEmphasis">BeanContextChildComponentProxy</em> interface
or as direct subclass of <em class="cEmphasis">Component</em>) the
<em class="cEmphasis">BeanContext</em> is permitted to add/remove
that <em class="cEmphasis">Component</em> to/from its associated
<em class="cEmphasis">Container</em>.In such cases the <em class=
"cEmphasis">BeanContextChild</em> and it&#8217;s associated
<em class="cEmphasis">Component</em> implementation shall not
interfere with this action.</p>
<a name="wp920858" id="wp920858"></a>
<p class="pBody">If a class implements both <em class=
"cEmphasis">BeanContextChildComponentProxy</em> and <em class=
"cEmphasis">BeanContextContainerProxy</em> then the object returned
by both <em class="cEmphasis">getComponent()</em> and <em class=
"cEmphasis">getContainer()</em> shall be the same object.</p>
<a name="wp916435" id="wp916435"></a>
<h3 class="pHeading2">2.2 interface
java.beans.beancontext.BeanContextChild<a href=
"#wp916664"><span class="Footnote">3</span></a></h3>
<a name="wp916525" id="wp916525"></a>
<p class="pBody">Simple JavaBeans that do not require any support
or knowledge of their environment shall continue to function as
they do today. However both JavaBeans that wish to utilize their
containing <em class="cEmphasis">BeanContext</em>, and <em class=
"cEmphasis">BeanContext</em>s that may be nested, require to
implement a mechanism that enables the propagation of the reference
to the enclosing <em class="cEmphasis">BeanContext</em> through to
cognizant JavaBeans and nested <em class=
"cEmphasis">BeanContext</em>s, the interface proposed is:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
<a name="wp918583" id="wp918583"> </a>
public interface java.beans.beancontext.BeanContextChild {<a name=
"wp918573" id="wp918573"> </a>
        void        setBeanContext(BeanContext bc)<a name=
"wp919588" id="wp919588"> </a>
                                throws PropertyVetoException;<a name="wp919589"
id="wp919589"> </a>
<a name="wp919590" id="wp919590"> </a>
        BeanContext getBeanContext();<a name="wp916442" id=
"wp916442"> </a>
<a name="wp919591" id="wp919591"> </a>
        void addPropertyChangeListener<a name="wp919617" id=
"wp919617"> </a>
                (String name, PropertyChangeListener pcl);<a name=
"wp919637" id="wp919637"> </a>
 <a name="wp919618" id="wp919618"> </a>
     void removePropertyChangeListener<a name="wp919623" id=
"wp919623"> </a>
                (String name, PropertyChangeListener pcl);<a name=
"wp919640" id="wp919640"> </a>
 <a name="wp919624" id="wp919624"> </a>
        void addVetoableChangeListener<a name="wp919629" id=
"wp919629"> </a>
                (String name, VetoableChangeListener pcl);<a name=
"wp919643" id="wp919643"> </a>
 <a name="wp919630" id="wp919630"> </a>
     void removeVetoableChangeListener<a name="wp919635" id=
"wp919635"> </a>
                (String name, VetoableChangeListener pcl);<a name=
"wp919646" id="wp919646"> </a>
<a name="wp919636" id="wp919636"> </a>
}<a name="wp916440" id="wp916440"> </a>
</pre></div>
<a name="wp918483" id="wp918483"></a>
<p class="pBody">The expected usage is that some 3rd party shall
invoke one of the appropriate methods defined on <em class=
"cEmphasis">BeanContext</em> (by virtue of its inheritance from
<em class="cEmphasis">Collection</em>) in order to add a <em class=
"cEmphasis">BeanContextChild</em> to the membership of the target
<em class="cEmphasis">BeanContext</em>. As a consequence the
<em class="cEmphasis">BeanContext</em> shall attempt to set the
<em class="cEmphasis">BeanContextChild</em>&#8217;s
&#8220;beanContext&#8221; property by invoking its setter method,
<em class="cEmphasis">setBeanContext</em>(). Only a <em class=
"cEmphasis">BeanContext</em> may call a <em class=
"cEmphasis">BeanContextChild</em>&#8217;s <em class=
"cEmphasis">setBeanContext</em>() method, since this is the
mechanism that a <em class="cEmphasis">BeanContext</em> uses to
notify a child that it is now has a new <em class=
"cEmphasis">BeanContext</em> value. Since this property is not
directly settable or customizable by a user in the context of an
application construction tool the <em class=
"cEmphasis">BeanInfo</em> for a <em class=
"cEmphasis">BeanContextChild</em> should set the hidden state for
this property in order for builder tools to avoid presenting the
property to the user for customization.</p>
<a name="wp919993" id="wp919993"></a>
<p class="pBody">A <em class="cEmphasis">BeanContextChild</em>
object may throw a <em class=
"cEmphasis">PropertyVetoException</em>, to notify the nesting
<em class="cEmphasis">BeanContext</em> that it is unable to
function/be nested within that particular <em class=
"cEmphasis">BeanContext</em>. Such a veto shall be interpreted by a
<em class="cEmphasis">BeanContext</em> as an indication that the
<em class="cEmphasis">BeanContextChild</em> has determined that it
is unable to function in that particular <em class=
"cEmphasis">BeanContext</em> and is final.</p>
<a name="wp918487" id="wp918487"></a>
<p class="pBody">During the un-nesting of a <em class=
"cEmphasis">BeanContextChild</em> from its <em class=
"cEmphasis">BeanContext</em>, it is possible for the child, or a
3rd party listening to the child&#8217;s &#8220;beanContext&#8221;
property for <em class="cEmphasis">PropertyVetoEvents</em>, to
throw a <em class="cEmphasis">PropertyVetoException</em> to notify
the caller that it is not in a state to be un-nested. In order to
bound this interaction a <em class=
"cEmphasis">BeanContextChild</em>, or 3rd party, may veto the
initial un-nesting notification, but may not veto any subsequent
notifications, and must, upon receipt of such notifications, amend
its state accordingly to prepare itself to be subsequently
un-nested.</p>
<a name="wp918776" id="wp918776"></a>
<p class="pBody">Note that classes that implement this interface,
also act as an Event Source for (sub)interface(s) of <em class=
"cEmphasis">java.beans.PropertyChangeListener</em>, and are
required to update their state accordingly and subsequently fire
the appropriate <em class=
"cEmphasis">java.beans.PropertyChangeEvent</em> with <em class=
"cEmphasis">propertyName</em> = &#8220;beanContext&#8221;,
<em class="cEmphasis">oldValue</em> = the reference to the previous
nesting <em class="cEmphasis">BeanContext</em>, and <em class=
"cEmphasis">newValue</em> = the reference to the new nesting
<em class="cEmphasis">BeanContext,</em> to notify any Listeners
that its nesting <em class="cEmphasis">BeanContext</em> has changed
value.</p>
<a name="wp917013" id="wp917013"></a>
<p class="pBody"><em class="cEmphasis">BeanContextChild</em>
instances, or nested <em class="cEmphasis">BeanContext</em>s in the
process of terminating themselves, shall invoke the <em class=
"cEmphasis">remove()</em> method on their nesting <em class=
"cEmphasis">BeanContext</em> in order to withdraw themselves from
the hierarchy prior to termination.</p>
<a name="wp917712" id="wp917712"></a>
<h4 class="pHeading3">2.2.1 Important Persistence
considerations</h4>
<a name="wp917711" id="wp917711"></a>
<p class="pBody">Instances of <em class=
"cEmphasis">BeanContextChild</em> nested within an <em class=
"cEmphasis">BeanContext,</em> will typically define fields or
instance variables that will contain references to their nesting
<em class="cEmphasis">BeanContext</em> instance, and possibly
services obtained from that <em class=
"cEmphasis">BeanContextServices</em> instance via its <em class=
"cEmphasis">getService()</em> method.</p>
<a name="wp917761" id="wp917761"></a>
<p class="pBody">In order to ensure that the act of making such an
instance persistent does not erroneously persist objects from the
instances nesting environment, such instances shall be required to
define such fields, or instance variables as either transient, or
to implement custom persistence methods that avoid persisting such
state.</p>
<a name="wp917762" id="wp917762"></a>
<p class="pBody">This requirement is crucial since operations such
as cutting and pasting object instances through a clipboard via
object serialization will not function correctly if the act of
serializing the target object also serializes much of the entire
source environment it is nested within.</p>
<a name="wp917715" id="wp917715"></a>
<h2 class="pHeading1">3.0 Overloading java.beans.instantiate()
static method</h2>
<a name="wp916569" id="wp916569"></a>
<p class="pBody">Since <em class=
"cEmphasis">java.beans.instantiate()</em> is the current mechanism
for (re)instantiating JavaBeans we need to extend or overload the
syntax and semantics of this method in order to accommodate the
introduction of the <em class="cEmphasis">BeanContext</em>
abstraction. The extension proposed is:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public static Object instantiate(ClassLoader cl,<a name="wp916576"
id="wp916576"> </a>
                                                String        beanName,<a name="wp916577"
id="wp916577"> </a>
                                                BeanContext beanContext);<a name="wp916578"
id="wp916578"> </a>
</pre></div>
<a name="wp916586" id="wp916586"></a>
<p class="pBody">This method behaves has it is currently defined in
the JavaBeans specification, but in addition to these existing
semantics, when a non-null <em class="cEmphasis">BeanContext</em>
is specified then the method invokes the <em class=
"cEmphasis">add()</em> method on the <em class=
"cEmphasis">beanContext</em> actual parameter with the value of the
<em class="cEmphasis">targetChild</em> actual parameter = a
reference to the newly instantiated JavaBean component.<a href=
"#wp917026"><span class="Footnote">4</span></a></p>
<a name="wp916575" id="wp916575"></a>
<h2 class="pHeading1">4.0 Providing better support for Beans that
are also Applets</h2>
<a name="wp916480" id="wp916480"></a>
<p class="pBody">The current implementation of <em class=
"cEmphasis">java.beans.instantiate()</em> contains minimal support
for instantiating JavaBeans that are also Applets. In particular,
this method will currently construct an <em class=
"cEmphasis">AppletContext</em> and <em class=
"cEmphasis">AppletStub</em> for the newly instantiated JavaBean,
set the stub on the newly instantiated <em class=
"cEmphasis">Applet,</em> and <em class="cEmphasis">init()</em> the
<em class="cEmphasis">Applet</em> if it has not already been
invoked.</p>
<a name="wp916481" id="wp916481"></a>
<p class="pBody">Unfortunately this does not provide sufficient
support in order to allow most Applets to be fully functional,
since the <em class="cEmphasis">AppletContext</em> and <em class=
"cEmphasis">AppletStub</em> created by <em class=
"cEmphasis">java.beans.instantiate()</em>, are no-ops. This is a
direct consequence of the lack of sufficient specification of how
to construct <em class="cEmphasis">AppletContext</em> and
<em class="cEmphasis">AppletStub</em> implementations in the
existing <em class="cEmphasis">Applet</em> API&#8217;s.
Furthermore, even if such specifications existed we would require
an API that propagated a number of <em class=
"cEmphasis">Applet</em> attributes such as its Codebase,
Parameters, <em class="cEmphasis">AppletContext</em>, and
Documentbase into <em class=
"cEmphasis">java.beans.instantiate()</em> in order for it to
subsequently instantiate the appropriately initialized objects.</p>
<a name="wp916596" id="wp916596"></a>
<p class="pBody">Since key to supporting fully functional Applets
is to provide them with fully functional <em class=
"cEmphasis">AppletContext</em> and <em class=
"cEmphasis">AppletStub</em> instances, the design goal is to
provide a mechanism to provide this state to <em class=
"cEmphasis">instantiate()</em> so that it may carry out the
appropriate initialization and binding<a href=
"#wp916719"><span class="Footnote">5</span></a>, therefore the
proposed interface is:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public static Object <a name="wp916486" id="wp916486"> </a>
                        instantiate(ClassLoader                                 cl,<a name="wp919297"
id="wp919297"> </a>
                                          String                beanName,<a name="wp916487"
id="wp916487"> </a>
                                          BeanContext           bCtxt,<a name="wp916488"
id="wp916488"> </a>
                                          AppletInitializer                                                                                                                     ai<a name="wp916489"
id="wp916489"> </a>
                        );<a name="wp919312" id="wp919312"> </a>
<a name="wp919341" id="wp919341"> </a>
public interface AppletInitializer {<a name="wp919342" id=
"wp919342"> </a>
        void initialize(Applet newApplet, BeanContext bCtxt);<a name="wp919304"
id="wp919304"> </a>
        void activate(Applet newApplet);<a name="wp919339" id=
"wp919339"> </a>
}<a name="wp919303" id="wp919303"> </a>
</pre></div>
<a name="wp916490" id="wp916490"></a>
<p class="pBody">If the newly instantiated JavaBean component is an
instance of <em class="cEmphasis">java.applet.Apple</em>t then the
new constructed <em class="cEmphasis">Applet</em>, (Bean) will be
passed to the <em class="cEmphasis">AppletInitializer</em> via a
call to <em class="cEmphasis">initialize().</em></p>
<a name="wp919311" id="wp919311"></a>
<p class="pBody">Compliant implementations of <em class=
"cEmphasis">AppletInitializer.initialize()</em> shall:</p>
<div style="margin-left: 2em" class="pList1"><a name="wp919313" id=
"wp919313"></a>
<div class="pList1">
<ul>
<li>Associate the newly instantiated <em class=
"cEmphasis">Applet</em> with the appropriate <em class=
"cEmphasis">AppletContext</em>.</li>
</ul>
</div>
<a name="wp919314" id="wp919314"></a>
<div class="pList1Plus">
<ul>
<li>Instantiate an <em class="cEmphasis">AppletStub</em>() and
associate that <em class="cEmphasis">AppletStub</em> with the
<em class="cEmphasis">Applet</em> via</li>
</ul>
</div>
<div style="margin-left: 2em" class="pList1"><a name="wp919318" id=
"wp919318"></a>
<div class="pList1">
<ul>
<li>an invocation of <em class="cEmphasis">setStub</em>().</li>
</ul>
</div>
<a name="wp919319" id="wp919319"></a>
<div class="pList1Last">
<ul>
<li>If <em class="cEmphasis">BeanContext</em> parameter is null,
then it shall associate the <em class="cEmphasis">Applet</em> with
its appropriate <em class="cEmphasis">Container</em> by adding that
<em class="cEmphasis">Applet</em> to its <em class=
"cEmphasis">Container</em> via an invocation of <em class=
"cEmphasis">add</em>(). If the <em class=
"cEmphasis">BeanContext</em> parameter is non-null, then it is the
responsibility of the <em class="cEmphasis">BeanContext</em> to
associate the <em class="cEmphasis">Applet</em> with its <em class=
"cEmphasis">Container</em> during the subsequent invocation of its
<em class="cEmphasis">addChildren</em>() method.</li>
</ul>
</div>
</div>
</div>
<a name="wp919343" id="wp919343"></a>
<p class="pBody">Compliant implementations of <em class=
"cEmphasis">AppletInitializer.activate()</em> shall mark the
<em class="cEmphasis">Applet</em> as active, and may optionally
also invoke the <em class="cEmphasis">Applet</em>&#8217;s
<em class="cEmphasis">start()</em> method.</p>
<a name="wp919310" id="wp919310"></a>
<p class="pBody">Note that if the newly instantiated JavaBean is
not an instance of <em class="cEmphasis">Applet</em>, then the
<em class="cEmphasis">AppletInitializer</em> interface is
ignored.</p>
<a name="wp916944" id="wp916944"></a>
<h2 class="pHeading1">5.0 Standard/Suggested Conventions for
BeanContext Services</h2>
<a name="wp916806" id="wp916806"></a>
<h3 class="pHeading3">5.1 BeanContexts that support InfoBus.</h3>
<a name="wp919684" id="wp919684"></a>
<p class="pBody">The InfoBus technology is a standard extension
package that is intended to facilitate the rendezvous and exchange
of dynamic self describing data, based upon a publish and subscribe
abstraction, between JavaBean Components within a single Java
Virtual Machine.</p>
<a name="wp919685" id="wp919685"></a>
<p class="pBody">A <em class="cEmphasis">BeanContext</em> that
exposes an <em class="cEmphasis">InfoBus</em> to its nested
<em class="cEmphasis">BeanContextChild</em> shall do so by exposing
a service via the <em class="cEmphasis">hasService</em>() and
<em class="cEmphasis">getService</em>() methods of type <em class=
"cEmphasis">javax.infobus.InfoBus.</em></p>
<a name="wp919734" id="wp919734"></a>
<p class="pBody">Thus <em class="cEmphasis">BeanContextChild</em>
implementations may locate a common <em class=
"cEmphasis">InfoBus</em> implementation for their current
<em class="cEmphasis">BeanContext</em> by using this mechanism to
rendezvous with that <em class="cEmphasis">InfoBus</em>
instance.</p>
<a name="wp920853" id="wp920853"></a>
<p class="pBody">The Infobus 1.2 specification shall define a
convenience mechanism provided by the <em class=
"cEmphasis">InfoBus</em> class to simplify the discovery mechanism
for <em class="cEmphasis">BeanContextChild</em> instances nested
within a particular instance of <em class=
"cEmphasis">BeanContextServices</em>.</p>
<a name="wp919683" id="wp919683"></a>
<h3 class="pHeading3">5.2 BeanContexts that support printing</h3>
<a name="wp916925" id="wp916925"></a>
<p class="pBody">A <em class="cEmphasis">BeanContext</em> that
wishes to expose printing facilities to its descendants may
delegate a reference of (sub)type <em class=
"cEmphasis">java.awt.PrintJob</em>.</p>
<a name="wp920856" id="wp920856"></a>
<p class="pBody">As the Java Network Printing Interface evolves
additional specifications will be provided to expose it&#8217;s
facilities via the services mechanism.</p>
<a name="wp916934" id="wp916934"></a>
<h3 class="pHeading3">5.3 BeanContext Design/Runtime mode
support.</h3>
<a name="wp916957" id="wp916957"></a>
<p class="pBody">JavaBeans support the concepts of
&#8220;design&#8221;-mode, when JavaBeans are being manipulated and
composed by a developer in an Application Builder or IDE, and
&#8220;Run&#8221;-mode, when the resulting JavaBeans are
instantiated at runtime as part of an <em class=
"cEmphasis">Applet</em>, Application or some other executable
abstraction.</p>
<a name="wp916960" id="wp916960"></a>
<p class="pBody">In the first version of the specification, the
&#8220;mode&#8221; or state, that is &#8220;design&#8221;-time or
&#8220;run&#8221;-time was a JVM global attribute. This is
insufficient since, for example, in an Application Builder
environment, there may be JavaBeans that function, in
&#8220;run&#8221;-mode, as part of the Application Builder
environment itself, as well as the JavaBeans that function, in
&#8220;design&#8221;-mode, under construction by the developer
using the Application Builder to compose an application.</p>
<a name="wp916961" id="wp916961"></a>
<p class="pBody">Therefore we require the ability to scope this
&#8220;mode&#8221; at a granularity below that of JVM global.</p>
<a name="wp916962" id="wp916962"></a>
<p class="pBody">The <em class="cEmphasis">BeanContext</em>
abstraction, as a &#8220;Container&#8221; or &#8220;Context&#8221;
for one or more JavaBeans provides appropriate mechanism to better
scope this &#8220;mode&#8221;.</p>
<a name="wp916966" id="wp916966"></a>
<p class="pBody">Thus <em class=
"cEmphasis">BeanContext</em>&#8217;s that wish to expose and
propagate this &#8220;mode&#8221; to its descendants may delegate a
reference of type <em class=
"cEmphasis">java.beans.DesignMode</em>:</p>
<div class="pPreformatted">
<pre class="pPreformatted">
public interface java.beans.DesignMode {<a name="wp916973" id=
"wp916973"> </a>
        void    setDesignTime(boolean isDesignTime);<a name=
"wp917784" id="wp917784"> </a>
        boolean isDesignTime();<a name="wp916975" id=
"wp916975"> </a>
}<a name="wp916974" id="wp916974"> </a>
</pre></div>
<a name="wp916977" id="wp916977"></a>
<p class="pBody">Additionally, <em class=
"cEmphasis">BeanContext</em>s delegating such a reference shall be
required to fire the appropriate <em class=
"cEmphasis">java.beans.propertyChangeEvent,</em> with propertyName
= &#8220;designTime&#8221;, with the appropriate values for
<em class="cEmphasis">oldValue</em> and <em class=
"cEmphasis">newValue,</em> when the &#8220;mode&#8221; changes
value.</p>
<a name="wp917788" id="wp917788"></a>
<p class="pBody">Note that it is illegal for instances of
<em class="cEmphasis">BeanContextChild</em> to call <em class=
"cEmphasis">setDesignTime()</em> on instances of <em class=
"cEmphasis">BeanContext</em> that they are nested within.</p>
<a name="wp917054" id="wp917054"></a>
<h3 class="pHeading3">5.4 BeanContext Visibility support.</h3>
<a name="wp917055" id="wp917055"></a>
<p class="pBody">JavaBeans with associated presentation, or GUI,
may be instantiated in environments where the ability to present
that GUI is either not physically possible (when the hardware is
not present), or is not appropriate under the current conditions
(running in a server context instead of a client).</p>
<a name="wp917056" id="wp917056"></a>
<p class="pBody">The first version of the JavaBeans Specification
introduced the <em class="cEmphasis">java.beans.Visibility</em>
interface in order to provide a mechanism for JavaBeans to have
their &#8220;visible&#8221; state, or ability to render a GUI,
controlled from their environment.</p>
<a name="wp917035" id="wp917035"></a>
<p class="pBody"><em class="cEmphasis">BeanContext</em>s that wish
to enforce a particular policy regarding the ability of their
children to present GUI, shall use the <em class=
"cEmphasis">java.beans.Visibility</em> interface to control their
children.</p>
<a name="wp917487" id="wp917487"></a>
<h3 class="pHeading3">5.5 Determining Locale from a
BeanContext</h3>
<a name="wp917488" id="wp917488"></a>
<p class="pBody"><em class="cEmphasis">BeanContext</em>s may have a
locale associated with them, in order to associate and propagate
this important attribute across the JavaBeans nested therein.</p>
<a name="wp918652" id="wp918652"></a>
<p class="pBody">Therefore, <em class=
"cEmphasis">BeanContext</em>s, shall be required to fire the
appropriate <em class=
"cEmphasis">java.beans.PropertyChangeEvent</em>, with propertyName
= &#8220;locale&#8221;, <em class="cEmphasis">oldValue</em> = the
reference to the previous value of the <em class=
"cEmphasis">Locale</em> delegate, and <em class=
"cEmphasis">newValue</em> = the reference to the new value of the
<em class="cEmphasis">Locale</em> delegate, in order to notify its
Listeners of any change in <em class="cEmphasis">Locale</em>.</p>
<a name="wp917536" id="wp917536"></a>
<p class="pBody">Setting and getting the value of the <em class=
"cEmphasis">Locale</em> on the <em class=
"cEmphasis">BeanContext</em> is implementation dependent.</p>
<a name="wp918648" id="wp918648"></a>
<h2 class="pHeading1">6.0 Support classes</h2>
<a name="wp918649" id="wp918649"></a>
<p class="pBody">In order to ease the implementation of this
relatively complex protocol a &#8220;helper&#8221; classes are
provided; <em class=
"cEmphasis">java.beans.beancontext.BeanContextChildSupport,
java.beans.beancontext.BeanContextSupport</em>, and <em class=
"cEmphasis">java.beans.beancontext.BeanContextServicesSupport</em>.
These classes are designed to either be subclassed, or delegated
implicitly by another object, and provides fully compliant
(extensible) implementations of the protocols embodied herein.</p>
<a name="wp919546" id="wp919546"></a>
<div class="pFootNote"><a href="#wp918237"><span class=
"Footnote">1</span></a>Note, if the remove() was invoked as a
result of the BeanContext receiving an unexpected PropertyChan-
geEvent notification as a result of a 3rd party invoking
setBeanContext() then the remove implementation shall not invoke
setBeanContext(null) on that child as part of the remove()
semantics, since to do so would overwrite the value previously set
by the 3rd party.</div>
<a name="wp920835" id="wp920835"></a>
<div class="pFootNote"><a href="#wp919985"><span class=
"Footnote">2</span></a>Unfortunately because of method name
collisions between Component and Collection a Component can- not
implement BeanContext or Collection directly and must model the
capability with a &#8220;HasA&#8221; rather than an
&#8220;IsA&#8221; relationship.</div>
<a name="wp916664" id="wp916664"></a>
<div class="pFootNote"><a href="#wp916435"><span class=
"Footnote">3</span></a>I don&#8217;t like this name much but I am
struggling for a better alternative! (we are stuck with it)</div>
<a name="wp917026" id="wp917026"></a>
<div class="pFootNote"><a href="#wp916586"><span class=
"Footnote">4</span></a>Note: Since simple JavaBeans have no
knowledge of a BeanContext, it is not advisable to introduce such
instances into the hierarchy since there is no mechanism for these
simple JavaBeans to remove them- selves from the hierarchy and thus
subsequently be garbage collected.</div>
<a name="wp916719" id="wp916719"></a>
<div class="pFootNote"><a href="#wp916596"><span class=
"Footnote">5</span></a>AppletContext objects expose a list of
Applet objects they &#8220;contain&#8221;, unfortunately the
current Applet or AppletStub API&#8217;s as defined, provide no
mechanism for the AppletContext to discover its Applets from its
AppletStubs, or for an AppletStub to inform its AppletContext of
its Applet. Therefore we will have to assume that this
binding/discovery can occur in order for this mechanism to be
worthwhile in java.beans.instantiate().</div>
<p>&#160;</p>
<hr class="pHr" />
<table width="100%" summary="">
<tr>
<td align="left"><a accesskey="c" href=
"beancontextTOC.html">Contents</a></td>
</tr>
</table>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
