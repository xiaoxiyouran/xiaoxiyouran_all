<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en">
<head>
<title>JNI Functions</title>
<meta name="collection" content="api" />
<link rel="Table of Contents" href="jniTOC.html" />
<link rel="Previous" href="types.html" />
<link rel="Next" href="invocation.html" />
<link rel="Index" href="backcover.html" />
<link rel="stylesheet" type="text/css" href="../../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<a href="#skip" title="Skip navigation bar"></a>
<table width="100%" summary="">
<tbody>
<tr>
<td><a accesskey="c" href="jniTOC.html">Contents</a> |
<a accesskey="p" href="types.html">Previous</a> | <a accesskey="n"
href="invocation.html">Next</a></td>
</tr>
</tbody>
</table>
<a name="skip"></a>

<h1>Chapter 4: JNI Functions</h1>

<p>This chapter serves as the reference section for
the JNI functions. It provides a complete listing of all the JNI
functions. It also presents the exact layout of the JNI function
table.</p>

<p>Note the use of the term &#8220;must&#8221; to
describe restrictions on JNI programmers. For example, when you see
that a certain JNI function <em>must</em> receive
a non-NULL object, it is your responsibility to ensure that NULL is
not passed to that JNI function. As a result, a JNI implementation
does not need to perform NULL pointer checks in that JNI
function.</p>

<p>A portion of this chapter is adapted from
Netscape&#8217;s JRI documentation.</p>

<p>The reference material groups functions by their
usage. The reference section is organized by the following
functional areas:</p>

<ul>
    <li><a href="#interface_function_table">Interface Function Table</a>
    <li><a href="#version_information">Version Information</a><ul>
        <li><a href="#GetVersion">GetVersion</a></li>
        <li><a href="#Constants">Constants</a></li>
    </ul></li>
    <li><a href="#class_operations">Class Operations</a><ul>
        <li><a href="#DefineClass">DefineClass</a></li>
        <li><a href="#FindClass">FindClass</a></li>
        <li><a href="#GetSuperclass">GetSuperclass</a></li>
        <li><a href="#IsAssignableFrom">IsAssignableFrom</a></li>
    </ul></li>
    <li><a href="#exceptions">Exceptions</a><ul>
        <li><a href="#Throw">Throw</a></li>
        <li><a href="#ThrowNew">ThrowNew</a></li>
        <li><a href="#ExceptionOccurred">ExceptionOccurred</a></li>
        <li><a href="#ExceptionDescribe">ExceptionDescribe</a></li>
        <li><a href="#ExceptionClear">ExceptionClear</a></li>
        <li><a href="#FatalError">FatalError</a></li>
        <li><a href="#ExceptionCheck">ExceptionCheck</a></li>
    </ul></li>
    <li><a href="#global_and_local_references">Global and Local References</a><ul>
        <li><a href="#global_references">Global References</a></li>
        <li><a href="#NewGlobalRef">NewGlobalRef</a></li>
        <li><a href="#DeleteGlobalRef">DeleteGlobalRef</a></li>
        <li><a href="#local_references">Local References</a></li>
        <li><a href="#DeleteLocalRef">DeleteLocalRef</a></li>
        <li><a href="#EnsureLocalCapacity">EnsureLocalCapacity</a></li>
        <li><a href="#PushLocalFrame">PushLocalFrame</a></li>
        <li><a href="#PopLocalFrame">PopLocalFrame</a></li>
        <li><a href="#NewLocalRef">NewLocalRef</a></li>
    </ul></li>
    <li><a href="#weak_global_references">Weak Global References</a><ul>
        <li><a href="#NewWeakGlobalRef">NewWeakGlobalRef</a></li>
        <li><a href="#DeleteWeakGlobalRef">DeleteWeakGlobalRef</a></li>
    </ul></li>
    <li><a href="#object_operations">Object Operations</a><ul>
        <li><a href="#AllocObject">AllocObject</a></li>
        <li><a href="#NewObject">NewObject, NewObjectA, NewObjectV</a></li>
        <li><a href="#GetObjectClass">GetObjectClass</a></li>
        <li><a href="#GetObjectRefType">GetObjectRefType</a></li>
        <li><a href="#IsInstanceOf">IsInstanceOf</a></li>
        <li><a href="#IsSameObject">IsSameObject</a></li>
    </ul></li>
    <li><a href="#accessing_fields_of_objects">Accessing Fields of Objects</a><ul>
        <li><a href="#GetFieldID">GetFieldID</a></li>
        <li><a href="#Get_type_Field_routines">Get&lt;type&gt;Field Routines</a></li>
        <li><a href="#Set_type_Field_routines">Set&lt;type&gt;Field Routines</a></li>
    </ul></li>
    <li><a href="#calling_instance_methods">Calling Instance Methods</a><ul>
        <li><a href="#GetMethodID">GetMethodID</a></li>
        <li><a href="#Call_type_Method_routines">Call&lt;type&gt;Method Routines, Call&lt;type&gt;MethodA Routines, Call&lt;type&gt;MethodV Routines</a></li>
        <li><a href="#CallNonvirtual_type_Method_routines">CallNonvirtual&lt;type&gt;Method Routines, CallNonvirtual&lt;type&gt;MethodA Routines, CallNonvirtual&lt;type&gt;MethodV Routines</a></li>
    </ul></li>
    <li><a href="#accessing_static_fields">Accessing Static Fields</a><ul>
        <li><a href="#GetStaticFieldID">GetStaticFieldID</a></li>
        <li><a href="#GetStatic_type_Field_routines">GetStatic&lt;type&gt;Field Routines</a></li>
        <li><a href="#SetStatic_type_Field_routines">SetStatic&lt;type&gt;Field Routines</a></li>
    </ul></li>
    <li><a href="#calling_static_methods">Calling Static Methods</a><ul>
        <li><a href="#GetStaticMethodID">GetStaticMethodID</a></li>
        <li><a href="#CallStatic_type_Method_routines">CallStatic&lt;type&gt;Method Routines, CallStatic&lt;type&gt;MethodA Routines, CallStatic&lt;type&gt;MethodV Routines</a></li>
    </ul></li>
    <li><a href="#string_operations">String Operations</a><ul>
        <li><a href="#NewString">NewString</a></li>
        <li><a href="#GetStringLength">GetStringLength</a></li>
        <li><a href="#GetStringChars">GetStringChars</a></li>
        <li><a href="#ReleaseStringChars">ReleaseStringChars</a></li>
        <li><a href="#NewStringUTF">NewStringUTF</a></li>
        <li><a href="#GetStringUTFLength">GetStringUTFLength</a></li>
        <li><a href="#GetStringUTFChars">GetStringUTFChars</a></li>
        <li><a href="#ReleaseStringUTFChars">ReleaseStringUTFChars</a></li>
        <li><a href="#GetStringRegion">GetStringRegion</a></li>
        <li><a href="#GetStringUTFRegion">GetStringUTFRegion</a></li>
        <li><a href="#GetStringCritical_ReleaseStringCritical">GetStringCritical, ReleaseStringCritical</a></li>
    </ul></li>
    <li><a href="#array_operations">Array Operations</a><ul>
        <li><a href="#GetArrayLength">GetArrayLength</a></li>
        <li><a href="#NewObjectArray">NewObjectArray</a></li>
        <li><a href="#GetObjectArrayElement">GetObjectArrayElement</a></li>
        <li><a href="#SetObjectArrayElement">SetObjectArrayElement</a></li>
        <li><a href="#New_PrimitiveType_Array_routines">New&lt;PrimitiveType&gt;Array Routines</a></li>
        <li><a href="#Get_PrimitiveType_ArrayElements_routines">Get&lt;PrimitiveType&gt;ArrayElements Routines</a></li>
        <li><a href="#Release_PrimitiveType_ArrayElements_routines">Release&lt;PrimitiveType&gt;ArrayElements Routines</a></li>
        <li><a href="#Get_PrimitiveType_ArrayRegion_routines">Get&lt;PrimitiveType&gt;ArrayRegion Routines</a></li>
        <li><a href="#Set_PrimitiveType_ArrayRegion_routines">Set&lt;PrimitiveType&gt;ArrayRegion Routines</a></li>
        <li><a href="#GetPrimitiveArrayCritical_ReleasePrimitiveArrayCritical">GetPrimitiveArrayCritical, ReleasePrimitiveArrayCritical</a></li>
    </ul></li>
    <li><a href="#registering_native_methods">Registering Native Methods</a><ul>
        <li><a href="#RegisterNatives">RegisterNatives</a></li>
        <li><a href="#UnregisterNatives">UnregisterNatives</a></li>
    </ul></li>
    <li><a href="#monitor_operations">Monitor Operations</a><ul>
        <li><a href="#MonitorEnter">MonitorEnter</a></li>
        <li><a href="#MonitorExit">MonitorExit</a></li>
    </ul></li>
    <li><a href="#nio_support">NIO Support</a><ul>
        <li><a href="#NewDirectByteBuffer">NewDirectByteBuffer</a></li>
        <li><a href="#GetDirectBufferAddress">GetDirectBufferAddress</a></li>
        <li><a href="#GetDirectBufferCapacity">GetDirectBufferCapacity</a></li>
    </ul></li>
    <li><a href="#reflection_support">Reflection Support</a><ul>
        <li><a href="#FromReflectedMethod">FromReflectedMethod</a></li>
        <li><a href="#FromReflectedField">FromReflectedField</a></li>
        <li><a href="#ToReflectedMethod">ToReflectedMethod</a></li>
        <li><a href="#ToReflectedField">ToReflectedField</a></li>
    </ul></li>
    <li><a href="#java_vm_interface">Java VM Interface</a><ul>
        <li><a href="#GetJavaVM">GetJavaVM</a></li>
    </ul></li>
</ul>


<!-- ******************************************************** -->
<h2><a name="interface_function_table">Interface Function Table</a></h2>

<p>Each function is accessible at a fixed offset
through the <em>JNIEnv</em> argument. The
<em>JNIEnv</em> type is a pointer to a structure
storing all JNI function pointers. It is defined as follows:</p>

<pre class="codeblock">typedef const struct JNINativeInterface *JNIEnv;</pre>

<p>The VM initializes the function table, as shown by the following code example. Note that the first three
entries are reserved for future compatibility with COM. In
addition, we reserve a number of additional <code>NULL</code> entries near the beginning of the function
table, so that, for example, a future class-related JNI operation
can be added after FindClass, rather than at the end of the
table.</p>

<p>Note that the function table can be shared among
all JNI interface pointers.</p>

<pre class="codeblock">const struct JNINativeInterface ... = {

    NULL,
    NULL,
    NULL,
    NULL,
    GetVersion,

    DefineClass,
    FindClass,

    FromReflectedMethod,
    FromReflectedField,
    ToReflectedMethod,

    GetSuperclass,
    IsAssignableFrom,

    ToReflectedField,

    Throw,
    ThrowNew,
    ExceptionOccurred,
    ExceptionDescribe,
    ExceptionClear,
    FatalError,

    PushLocalFrame,
    PopLocalFrame,

    NewGlobalRef,
    DeleteGlobalRef,
    DeleteLocalRef,
    IsSameObject,
    NewLocalRef,
    EnsureLocalCapacity,

    AllocObject,
    NewObject,
    NewObjectV,
    NewObjectA,

    GetObjectClass,
    IsInstanceOf,

    GetMethodID,

    CallObjectMethod,
    CallObjectMethodV,
    CallObjectMethodA,
    CallBooleanMethod,
    CallBooleanMethodV,
    CallBooleanMethodA,
    CallByteMethod,
    CallByteMethodV,
    CallByteMethodA,
    CallCharMethod,
    CallCharMethodV,
    CallCharMethodA,
    CallShortMethod,
    CallShortMethodV,
    CallShortMethodA,
    CallIntMethod,
    CallIntMethodV,
    CallIntMethodA,
    CallLongMethod,
    CallLongMethodV,
    CallLongMethodA,
    CallFloatMethod,
    CallFloatMethodV,
    CallFloatMethodA,
    CallDoubleMethod,
    CallDoubleMethodV,
    CallDoubleMethodA,
    CallVoidMethod,
    CallVoidMethodV,
    CallVoidMethodA,

    CallNonvirtualObjectMethod,
    CallNonvirtualObjectMethodV,
    CallNonvirtualObjectMethodA,
    CallNonvirtualBooleanMethod,
    CallNonvirtualBooleanMethodV,
    CallNonvirtualBooleanMethodA,
    CallNonvirtualByteMethod,
    CallNonvirtualByteMethodV,
    CallNonvirtualByteMethodA,
    CallNonvirtualCharMethod,
    CallNonvirtualCharMethodV,
    CallNonvirtualCharMethodA,
    CallNonvirtualShortMethod,
    CallNonvirtualShortMethodV,
    CallNonvirtualShortMethodA,
    CallNonvirtualIntMethod,
    CallNonvirtualIntMethodV,
    CallNonvirtualIntMethodA,
    CallNonvirtualLongMethod,
    CallNonvirtualLongMethodV,
    CallNonvirtualLongMethodA,
    CallNonvirtualFloatMethod,
    CallNonvirtualFloatMethodV,
    CallNonvirtualFloatMethodA,
    CallNonvirtualDoubleMethod,
    CallNonvirtualDoubleMethodV,
    CallNonvirtualDoubleMethodA,
    CallNonvirtualVoidMethod,
    CallNonvirtualVoidMethodV,
    CallNonvirtualVoidMethodA,

    GetFieldID,

    GetObjectField,
    GetBooleanField,
    GetByteField,
    GetCharField,
    GetShortField,
    GetIntField,
    GetLongField,
    GetFloatField,
    GetDoubleField,
    SetObjectField,
    SetBooleanField,
    SetByteField,
    SetCharField,
    SetShortField,
    SetIntField,
    SetLongField,
    SetFloatField,
    SetDoubleField,

    GetStaticMethodID,

    CallStaticObjectMethod,
    CallStaticObjectMethodV,
    CallStaticObjectMethodA,
    CallStaticBooleanMethod,
    CallStaticBooleanMethodV,
    CallStaticBooleanMethodA,
    CallStaticByteMethod,
    CallStaticByteMethodV,
    CallStaticByteMethodA,
    CallStaticCharMethod,
    CallStaticCharMethodV,
    CallStaticCharMethodA,
    CallStaticShortMethod,
    CallStaticShortMethodV,
    CallStaticShortMethodA,
    CallStaticIntMethod,
    CallStaticIntMethodV,
    CallStaticIntMethodA,
    CallStaticLongMethod,
    CallStaticLongMethodV,
    CallStaticLongMethodA,
    CallStaticFloatMethod,
    CallStaticFloatMethodV,
    CallStaticFloatMethodA,
    CallStaticDoubleMethod,
    CallStaticDoubleMethodV,
    CallStaticDoubleMethodA,
    CallStaticVoidMethod,
    CallStaticVoidMethodV,
    CallStaticVoidMethodA,

    GetStaticFieldID,

    GetStaticObjectField,
    GetStaticBooleanField,
    GetStaticByteField,
    GetStaticCharField,
    GetStaticShortField,
    GetStaticIntField,
    GetStaticLongField,
    GetStaticFloatField,
    GetStaticDoubleField,

    SetStaticObjectField,
    SetStaticBooleanField,
    SetStaticByteField,
    SetStaticCharField,
    SetStaticShortField,
    SetStaticIntField,
    SetStaticLongField,
    SetStaticFloatField,
    SetStaticDoubleField,

    NewString,

    GetStringLength,
    GetStringChars,
    ReleaseStringChars,

    NewStringUTF,
    GetStringUTFLength,
    GetStringUTFChars,
    ReleaseStringUTFChars,

    GetArrayLength,

    NewObjectArray,
    GetObjectArrayElement,
    SetObjectArrayElement,

    NewBooleanArray,
    NewByteArray,
    NewCharArray,
    NewShortArray,
    NewIntArray,
    NewLongArray,
    NewFloatArray,
    NewDoubleArray,

    GetBooleanArrayElements,
    GetByteArrayElements,
    GetCharArrayElements,
    GetShortArrayElements,
    GetIntArrayElements,
    GetLongArrayElements,
    GetFloatArrayElements,
    GetDoubleArrayElements,

    ReleaseBooleanArrayElements,
    ReleaseByteArrayElements,
    ReleaseCharArrayElements,
    ReleaseShortArrayElements,
    ReleaseIntArrayElements,
    ReleaseLongArrayElements,
    ReleaseFloatArrayElements,
    ReleaseDoubleArrayElements,

    GetBooleanArrayRegion,
    GetByteArrayRegion,
    GetCharArrayRegion,
    GetShortArrayRegion,
    GetIntArrayRegion,
    GetLongArrayRegion,
    GetFloatArrayRegion,
    GetDoubleArrayRegion,
    SetBooleanArrayRegion,
    SetByteArrayRegion,
    SetCharArrayRegion,
    SetShortArrayRegion,
    SetIntArrayRegion,
    SetLongArrayRegion,
    SetFloatArrayRegion,
    SetDoubleArrayRegion,

    RegisterNatives,
    UnregisterNatives,

    MonitorEnter,
    MonitorExit,

    GetJavaVM,

    GetStringRegion,
    GetStringUTFRegion,

    GetPrimitiveArrayCritical,
    ReleasePrimitiveArrayCritical,

    GetStringCritical,
    ReleaseStringCritical,

    NewWeakGlobalRef,
    DeleteWeakGlobalRef,

    ExceptionCheck,

    NewDirectByteBuffer,
    GetDirectBufferAddress,
    GetDirectBufferCapacity,

    GetObjectRefType
  };
</pre>



<!-- ******************************************************** -->
<h2><a name="version_information">Version Information</a></h2>

<h3><a name="GetVersion">GetVersion</a></h3>

<p><code>jint GetVersion(JNIEnv
*env);</code></p>

<p>Returns the version of the native method
interface.</p>

<h4>LINKAGE:</h4>
<p>Index 4 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<h4>RETURNS:</h4>

<p>Returns the major version number in the higher 16
bits and the minor version number in the lower 16 bits.</p>

<p>In JDK/JRE 1.1, <code class=
"cCode">GetVersion()</code> returns <code>0x00010001</code>.</p>
<p>In JDK/JRE 1.2, <code>GetVersion()</code> returns
<code>0x00010002</code>.</p>
<p>In JDK/JRE 1.4, <code>GetVersion()</code> returns
<code>0x00010004</code>.</p>
<p>In JDK/JRE 1.6, <code>GetVersion()</code> returns
<code>0x00010006</code>.</p>
<h3><a name="Constants">Constants</a></h3>
<h4>SINCE JDK/JRE 1.2:</h4>
<pre class="codeblock">
#define JNI_VERSION_1_1 0x00010001
#define JNI_VERSION_1_2 0x00010002

/* Error codes */
#define JNI_EDETACHED    (-2)              /* thread detached from the VM */
#define JNI_EVERSION     (-3)              /* JNI version error 
</pre>
<h4>SINCE JDK/JRE 1.4:</h4>
<pre class="codeblock">
    #define JNI_VERSION_1_4 0x00010004
</pre>
<h4>SINCE JDK/JRE 1.6:</h4>
<pre class="codeblock">
    #define JNI_VERSION_1_6 0x00010006
</pre>
<!-- ******************************************************** -->
<h2><a name="class_operations">Class Operations</a></h2>

<h3><a name="DefineClass">DefineClass</a></h3>

<p><code>jclass DefineClass(JNIEnv
*env, const char *name, jobject loader,<br />
const jbyte *buf, jsize bufLen);</code></p>

<p>Loads a class from a buffer of raw class data. The
buffer containing the raw class data is not referenced by the VM
after the DefineClass call returns, and it may be discarded if
desired.</p>

<h4>LINKAGE:</h4>
<p>Index 5 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>
<p><code>name</code>: the name of the
class or interface to be defined. The string is encoded in modified
UTF-8.</p>

<p><code>loader</code>: a class loader
assigned to the defined class.</p>

<p><code>buf</code>: buffer containing
the <code>.class</code> file data.</p>

<p><code>bufLen</code>: buffer
length.</p>

<h4>RETURNS:</h4>

<p>Returns a Java class object or <code class=
"cCode">NULL</code> if an error occurs.</p>

<h4>THROWS:</h4>

<p><code>ClassFormatError</code>: if
the class data does not specify a valid class.</p>

<p><code>ClassCircularityError</code>:
if a class or interface would be its own superclass or
superinterface.</p>

<p><code>OutOfMemoryError</code>: if
the system runs out of memory.</p>
<a name="secExDefineClass"></a>
<p><code>SecurityException</code>: if
the caller attempts to define a class in the "java" package
tree.</p>

<h3><a name="FindClass">FindClass</a></h3>

<p><code>jclass FindClass(JNIEnv *env,
const char *name);</code></p>

<p>In JDK release 1.1, this function loads a
locally-defined class. It searches the directories and zip files
specified by the <code>CLASSPATH</code> environment
variable for the class with the specified name.</p>
<p>Since Java 2 SDK release 1.2, the Java security model allows
non-system classes to load and call native methods.
<code>FindClass</code> locates the class loader associated with the
current native method; that is, the class loader of the class that
declared the native method. If the native method belongs to a
system class, no class loader will be involved. Otherwise, the
proper class loader will be invoked to load and link the named
class.</p>
<p>Since Java 2 SDK release 1.2, when <code>FindClass</code> is
called through the Invocation Interface, there is no current native
method or its associated class loader. In that case, the result of
<code>ClassLoader.getSystemClassLoader</code> is used. This is the
class loader the virtual machine creates for applications, and is
able to locate classes listed in the <code>java.class.path</code>
property.</p>
<p>The <code>name</code> argument is a fully-qualified class name
or an array type signature . For example, the fully-qualified class
name for the <code>java.lang.String</code> class is:</p>
<pre class="codeblock">
<a name="a69011" id=
"a69011"> </a>                  "java/lang/String"

</pre>
<p>The array type signature of the array class
<code>java.lang.Object[]</code> is:</p>
<pre class="codeblock">
<a name="a69010" id=
"a69010"> </a>                  "[Ljava/lang/Object;"


</pre>

<h4>LINKAGE:</h4>
<p>Index 6 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>name</code>: a fully-qualified
class name (that is, a package name, delimited by
&#8220;<code>/</code>&#8221;, followed by the class
name). If the name begins with &#8220;<code class=
"cCode">[</code>&#8220; (the array signature character), it returns
an array class. The string is encoded in modified UTF-8.</p>

<h4>RETURNS:</h4>

<p>Returns a class object from a fully-qualified
name, or <code>NULL</code> if the class cannot be
found.</p>

<h4>THROWS:</h4>

<p><code>ClassFormatError</code>: if
the class data does not specify a valid class.</p>

<p><code>ClassCircularityError</code>:
if a class or interface would be its own superclass or
superinterface.</p>

<p><code>NoClassDefFoundError</code>:
if no definition for a requested class or interface can be
found.</p>

<p><code>OutOfMemoryError</code>: if
the system runs out of memory.</p>
<h3><a name="GetSuperclass">GetSuperclass</a></h3>

<p><code>jclass GetSuperclass(JNIEnv
*env, jclass clazz);</code></p>

<p>If <code>clazz</code> represents any
class other than the class <code>Object</code>, then
this function returns the object that represents the superclass of
the class specified by <code>clazz</code>.</p>

<p>If <code>clazz</code> specifies the
class <code>Object</code>, or <code class=
"cCode">clazz</code> represents an interface, this function returns
<code>NULL</code>.</p>

<h4>LINKAGE:</h4>
<p>Index 10 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>

<h4>RETURNS:</h4>

<p>Returns the superclass of the class represented by
<code>clazz</code>, or <code class=
"cCode">NULL</code>.</p>

<h3><a name="IsAssignableFrom">IsAssignableFrom</a></h3>

<p><code>jboolean
IsAssignableFrom(JNIEnv *env, jclass clazz1,<br />
jclass clazz2);</code></p>

<p>Determines whether an object of <code class=
"cCode">clazz1</code> can be safely cast to <code class=
"cCode">clazz2</code>.</p>

<h4>LINKAGE:</h4>
<p>Index 11 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz1</code>: the first class
argument.</p>

<p><code>clazz2</code>: the second
class argument.</p>

<h4>RETURNS:</h4>

<p>Returns <code>JNI_TRUE</code> if
either of the following is true:</p>


<ul>
<li>The first and second class arguments refer to the same Java
class.</li>
<li>The first class is a subclass of the second class.</li>
<li>The first class has the second class as one of its
interfaces.</li>
</ul>



<!-- ******************************************************** -->
<h2><a name="exceptions">Exceptions</a></h2>

<h3><a name="Throw">Throw</a></h3>

<p><code>jint Throw(JNIEnv *env,
jthrowable obj);</code></p>

<p>Causes a <code class=
"cCode">java.lang.Throwable</code> object to be thrown.</p>

<h4>LINKAGE:</h4>
<p>Index 13 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>obj</code>: a <code class=
"cCode">java.lang.Throwable</code> object.</p>

<h4>RETURNS:</h4>

<p>Returns 0 on success; a negative value on
failure.</p>

<h4>THROWS:</h4>

<p>the <code>java.lang.Throwable</code>
<code>object</code> <code class=
"cCode">obj</code><code>.</code></p>

<h3><a name="ThrowNew">ThrowNew</a></h3>

<p><code>jint ThrowNew(JNIEnv *env,
jclass clazz,<br />
const char *message);</code></p>

<p>Constructs an exception object from the specified
class with the message specified by <code class=
"cCode">message</code> and causes that exception to be thrown.</p>

<h4>LINKAGE:</h4>
<p>Index 14 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a subclass of
<code>java.lang.Throwable</code>.</p>

<p><code>message</code>: the message
used to construct the <code class=
"cCode">java.lang.Throwable</code> object. The string is encoded in
modified UTF-8.</p>

<h4>RETURNS:</h4>

<p>Returns 0 on success; a negative value on
failure.</p>

<h4>THROWS:</h4>

<p>the newly constructed <code class=
"cCode">java.lang.Throwable</code> object.</p>

<h3><a name="ExceptionOccurred">ExceptionOccurred</a></h3>

<p><code>jthrowable
ExceptionOccurred(JNIEnv *env);</code></p>

<p>Determines if an exception is being thrown. The
exception stays being thrown until either the native code calls
<code>ExceptionClear()</code>, or the Java code
handles the exception.</p>

<h4>LINKAGE:</h4>
<p>Index 15 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<h4>RETURNS:</h4>

<p>Returns the exception object that is currently in
the process of being thrown, or <code>NULL</code> if
no exception is currently being thrown.</p>

<h3><a name="ExceptionDescribe">ExceptionDescribe</a></h3>

<p><code>void ExceptionDescribe(JNIEnv
*env);</code></p>

<p>Prints an exception and a backtrace of the stack
to a system error-reporting channel, such as <code class=
"cCode">stderr</code>. This is a convenience routine provided for
debugging.</p>

<h4>LINKAGE:</h4>
<p>Index 16 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<h3><a name="ExceptionClear">ExceptionClear</a></h3>

<p><code>void ExceptionClear(JNIEnv
*env);</code></p>

<p>Clears any exception that is currently being
thrown. If no exception is currently being thrown, this routine has
no effect.</p>

<h4>LINKAGE:</h4>
<p>Index 17 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<h3><a name="FatalError">FatalError</a></h3>

<p><code>void FatalError(JNIEnv *env,
const char *msg);</code></p>

<p>Raises a fatal error and does not expect the VM to
recover. This function does not return.</p>

<h4>LINKAGE:</h4>
<p>Index 18 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>msg</code>: an error message.
The string is encoded in modified UTF-8.</p>

<h3><a name="ExceptionCheck">ExceptionCheck</a></h3>
We introduce a convenience function to check for pending exceptions
without creating a local reference to the exception object.
<p><code>jboolean
ExceptionCheck(JNIEnv *env);</code></p>
<p>Returns <code>JNI_TRUE</code> when there is a pending exception;
otherwise, returns <code>JNI_FALSE</code>.</p>
<h4>LINKAGE:</h4>
Index 228 in the JNIEnv interface function table.
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<a name="weakrefs"></a>

<!-- ******************************************************** -->
<h2><a name="global_and_local_references">Global and Local References</a></h2>

<h3><a name="global_references">Global References</a></h3>

<h3><a name="NewGlobalRef">NewGlobalRef</a></h3>

<p><code>jobject NewGlobalRef(JNIEnv
*env, jobject obj);</code></p>

<p>Creates a new global reference to the object
referred to by the <code>obj</code> argument. The
<code>obj</code> argument may be a global or local
reference. Global references must be explicitly disposed of by
calling <code>DeleteGlobalRef()</code>.</p>

<h4>LINKAGE:</h4>
<p>Index 21 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>obj</code>: a global or local
reference.</p>

<h4>RETURNS:</h4>

<p>Returns a global reference, or <code class=
"cCode">NULL</code> if the system runs out of memory.</p>

<h3><a name="DeleteGlobalRef">DeleteGlobalRef</a></h3>

<p><code>void DeleteGlobalRef(JNIEnv
*env, jobject globalRef);</code></p>

<p>Deletes the global reference pointed to by
<code>globalRef</code>.</p>

<h4>LINKAGE:</h4>
<p>Index 22 in the JNIEnv interface function
table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>globalRef</code>: a global
reference.</p>

<h3><a name="local_references">Local References</a></h3>

<p>Local references are valid for the duration of a native method
call. They are freed automatically after the native method returns.
Each local reference costs some amount of Java Virtual Machine
resource. Programmers need to make sure that native methods do not
excessively allocate local references. Although local references
are automatically freed after the native method returns to Java,
excessive allocation of local references may cause the VM to run
out of memory during the execution of a native method.</p>

<h3><a name="DeleteLocalRef">DeleteLocalRef</a></h3>

<p><code>void DeleteLocalRef(JNIEnv
*env, jobject localRef);</code></p>

<p>Deletes the local reference pointed to by
<code>localRef</code>.</p>

<h4>LINKAGE:</h4>
<p>Index 23 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>localRef</code>: a local
reference.</p>

<p><strong>Note</strong>: JDK/JRE 1.1 provides the <code>DeleteLocalRef</code> function
above so that programmers can manually delete local references. For
example, if native code iterates through a potentially large array
of objects and uses one element in each iteration, it is a good
practice to delete the local reference to the no-longer-used array
element before a new local reference is created in the next
iteration.</p>
<p>As of JDK/JRE 1.2 an additional set of functions are provided
for local reference lifetime management. They are the four
functions listed below.</p>

<h3><a name="EnsureLocalCapacity">EnsureLocalCapacity</a></h3>

<p><code>jint EnsureLocalCapacity(JNIEnv *env, jint
capacity);</code></p>
<p>Ensures that <em>at least</em> a given number of local
references can be created in the current thread. Returns 0 on
success; otherwise returns a negative number and throws an
<code>OutOfMemoryError</code>.</p>
<p>Before it enters a native method, the VM automatically ensures
that at least <strong>16</strong> local references can be
created.</p>
<p>For backward compatibility, the VM allocates local references
beyond the ensured capacity. (As a debugging support, the VM may
give the user warnings that too many local references are being
created. In the JDK, the programmer can supply the
<code>-verbose:jni</code> command line option to turn on these
messages.) The VM calls <code>FatalError</code> if no more local
references can be created beyond the ensured capacity.</p>
<h4>LINKAGE:</h4>
Index 26 in the JNIEnv interface function table.
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<h3><a name="PushLocalFrame">PushLocalFrame</a></h3>
<p><code>jint
PushLocalFrame(JNIEnv *env, jint capacity);</code></p>
<p>Creates a new local reference frame, in which at least a given
number of local references can be created. Returns 0 on success, a
negative number and a pending <code>OutOfMemoryError</code> on
failure.</p>
<p>Note that local references already created in previous local
frames are still valid in the current local frame.</p>
<h4>LINKAGE:</h4>
Index 19 in the JNIEnv interface function table.
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<h3><a name="PopLocalFrame">PopLocalFrame</a></h3>
<p><code>jobject
PopLocalFrame(JNIEnv *env, jobject result);</code></p>
<p>Pops off the current local reference frame, frees all the local
references, and returns a local reference in the previous local
reference frame for the given <code>result</code> object.</p>
<p>Pass <code>NULL</code> as <code>result</code> if you do not need
to return a reference to the previous frame.</p>
<h4>LINKAGE:</h4>
Index 20 in the JNIEnv interface function table.
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<h3><a name="NewLocalRef">NewLocalRef</a></h3>
<p><code>jobject
NewLocalRef(JNIEnv *env, jobject ref);</code></p>
<p>Creates a new local reference that refers to the same object as
<code>ref</code>. The given <code>ref</code> may be a global or
local reference. Returns <code>NULL</code> if <code>ref</code>
refers to <code>null</code>.</p>
<h4>LINKAGE:</h4>
Index 25 in the JNIEnv interface function table.
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<!-- ******************************************************** -->
<h2><a name="weak_global_references">Weak Global References</a></h2>
Weak global references are a special kind of global reference.
Unlike normal global references, a weak global reference allows the
underlying Java object to be garbage collected. Weak global
references may be used in any situation where global or local
references are used. When the garbage collector runs, it frees the
underlying object if the object is only referred to by weak
references. A weak global reference pointing to a freed object is
functionally equivalent to <code>NULL</code>. Programmers can
detect whether a weak global reference points to a freed object by
using <code>IsSameObject</code> to compare the weak reference
against <code>NULL</code>.
<p>Weak global references in JNI are a simplified version of the
Java Weak References, available as part of the Java 2 Platform API
( <code>java.lang.ref</code> package and its classes). <a name=
"weakrefs__clarification"></a></p>
<p><strong>Clarification</strong> &nbsp;&nbsp;&nbsp;<i>(added June
2001)</i></p>
<p><i>Since garbage collection may occur while native methods are
running, objects referred to by weak global references can be freed
at any time. While weak global references can be used where global
references are used, it is generally inappropriate to do so, as
they may become functionally equivalent to</i> <code>NULL</code>
<i>without notice.</i></p>
<p><i>While</i> <code>IsSameObject</code> <i>can be used to
determine whether a weak global reference refers to a freed object,
it does not prevent the object from being freed immediately
thereafter. Consequently, programmers may not rely on this check to
determine whether a weak global reference may used (as a
non-</i><code>NULL</code> <i>reference) in any future JNI function
call.</i></p>
<p><i>To overcome this inherent limitation, it is recommended that
a standard (strong) local or global reference to the same object be
acquired using the JNI functions</i> <code>NewLocalRef</code>
<i>or</i> <code>NewGlobalRef</code><i>, and that this strong
reference be used to access the intended object. These functions
will return</i> <code>NULL</code> <i>if the object has been freed,
and otherwise will return a strong reference (which will prevent
the object from being freed). The new reference should be
explicitly deleted when immediate access to the object is no longer
required, allowing the object to be freed.</i></p>
<p><i>The weak global reference is weaker than other types of weak
references (Java objects of the SoftReference or WeakReference
classes). A weak global reference to a specific object will not
become functionally equivalent to</i> <code>NULL</code> <i>until
after SoftReference or WeakReference objects referring to that same
specific object have had their references cleared.</i></p>
<p><i>The weak global reference is weaker than Java's internal
references to objects requiring finalization. A weak global
reference will not become functionally equivalent to</i>
<code>NULL</code> <i>until after the completion of the finalizer
for the referenced object, if present.</i></p>
<p><i>Interactions between weak global references and
PhantomReferences are undefined. In particular, implementations of
a Java VM may (or may not) process weak global references after
PhantomReferences, and it may (or may not) be possible to use weak
global references to hold on to objects which are also referred to
by PhantomReference objects. This undefined use of weak global
references should be avoided.</i></p>
<h3><a name="NewWeakGlobalRef">NewWeakGlobalRef</a></h3>
<p><code>jweak NewWeakGlobalRef(JNIEnv *env, jobject
obj);</code></p>
<p>Creates a new weak global reference. Returns <code>NULL</code>
if <code>obj</code> refers to <code>null</code>, or if the VM runs
out of memory. If the VM runs out of memory, an
<code>OutOfMemoryError</code> will be thrown.</p>
<h4>LINKAGE:</h4>
Index 226 in the JNIEnv interface function table.
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<h3><a name="DeleteWeakGlobalRef">DeleteWeakGlobalRef</a></h3>
<p><code>void DeleteWeakGlobalRef(JNIEnv *env, jweak
obj);</code></p>
<p>Delete the VM resources needed for the given weak global
reference.</p>
<h4>LINKAGE:</h4>
Index 227 in the JNIEnv interface function table.
<h4>SINCE:</h4>
<p>JDK/JRE 1.2<a name="arrayops"></a></p>
<!-- ******************************************************** -->
<h2><a name="object_operations">Object Operations</a></h2>

<h3><a name="AllocObject">AllocObject</a></h3>

<p><code>jobject AllocObject(JNIEnv
*env, jclass clazz);</code></p>

<p>Allocates a new Java object without invoking any
of the constructors for the object. Returns a reference to the
object.</p>

<p>The clazz argument must not refer to an array
class.</p>

<h4>LINKAGE:</h4>
<p>Index 27 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>

<h4>RETURNS:</h4>

<p>Returns a Java object, or <code class=
"cCode">NULL</code> if the object cannot be constructed.</p>

<h4>THROWS:</h4>

<p><code>InstantiationException</code>:
if the class is an interface or an abstract class.</p>

<p><code>OutOfMemoryError</code>: if
the system runs out of memory.</p>

<h3><a name="NewObject">NewObject, NewObjectA, NewObjectV</a></h3>

<p><code>jobject NewObject(JNIEnv *env,
jclass clazz,<br />
jmethodID methodID, ...);</code></p>

<p><code>jobject NewObjectA(JNIEnv
*env, jclass clazz,<br />
jmethodID methodID, const jvalue *args);</code></p>

<p><code>jobject NewObjectV(JNIEnv
*env, jclass clazz,<br />
jmethodID methodID, va_list args);</code></p>

<p>Constructs a new Java object. The method ID
indicates which constructor method to invoke. This ID must be
obtained by calling <code>GetMethodID()</code> with
<code>&lt;init&gt;</code> as the method name and
<code>void</code> (<code>V</code>) as
the return type.</p>

<p>The <code>clazz</code> argument must
not refer to an array class.</p>

<h4>NewObject</h4>

<p>Programmers place all arguments that are to be
passed to the constructor immediately following the <code class=
"cCode">methodID</code> argument. <code class=
"cCode">NewObject()</code> accepts these arguments and passes them
to the Java method that the programmer wishes to invoke.</p>

<h4>LINKAGE:</h4>
<p>Index 28 in the JNIEnv interface function table.</p>
<h4>NewObjectA</h4>

<p>Programmers place all arguments that are to be
passed to the constructor in an <code>args</code>
array of <code>jvalues</code> that immediately
follows the <code>methodID</code> argument.
<code>NewObjectA()</code> accepts the arguments in
this array, and, in turn, passes them to the Java method that the
programmer wishes to invoke.</p>

<h4>LINKAGE:</h4>
<p>Index 30 in the JNIEnv interface function table.</p>
<h4>NewObjectV</h4>

<p>Programmers place all arguments that are to be
passed to the constructor in an <code>args</code>
argument of type <code>va_list</code> that
immediately follows the <code>methodID</code>
argument. <code>NewObjectV()</code> accepts these
arguments, and, in turn, passes them to the Java method that the
programmer wishes to invoke.</p>

<h4>LINKAGE:</h4>
<p>Index 29 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>

<p><code>methodID</code>: the method ID
of the constructor.</p>

<h4>Additional Parameter for NewObject:</h4>

<p>arguments to the constructor.</p>

<h4>Additional Parameter for NewObjectA:</h4>

<p><code>args</code>: an array of
arguments to the constructor.</p>

<h4>Additional Parameter for NewObjectV:</h4>

<p><code>args</code>: a va_list of
arguments to the constructor.</p>

<h4>RETURNS:</h4>

<p>Returns a Java object, or <code class=
"cCode">NULL</code> if the object cannot be constructed.</p>

<h4>THROWS:</h4>

<p><code>InstantiationException</code>:
if the class is an interface or an abstract class.</p>

<p><code>OutOfMemoryError</code>: if
the system runs out of memory.</p>

<p>Any exceptions thrown by the constructor.</p>

<h3><a name="GetObjectClass">GetObjectClass</a></h3>

<p><code>jclass GetObjectClass(JNIEnv
*env, jobject obj);</code></p>
<p>Returns the class of an object.</p>

<h4>LINKAGE:</h4>
<p>Index 31 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>obj</code>: a Java object
(must not be <code>NULL</code>).</p>

<h4>RETURNS:</h4>

<p>Returns a Java class object.</p>
<!-- ******** added 9.30.05. works in j6.0 -->
<a name="objreftype"></a>
<h3><a name="GetObjectRefType">GetObjectRefType</a></h3>

<p><code>jobjectRefType
GetObjectRefType(JNIEnv* env, jobject obj);</code></p>


<p>Returns the type of the object referred to by the
<code>obj</code> argument. The argument <code>obj</code> can either
be a local, global or weak global reference.</p>
<h4>LINKAGE:</h4>
<p>Index 232 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>
<p><code>env</code>: the JNI interface
pointer.</p>
<p><code>obj</code>: a local, global or
weak global reference.<br />
<br />
<code>vm</code>: the virtual machine instance from
which the interface will be retrieved.<br />
<br />
<code>env</code>: pointer to the location where the
JNI interface pointer for the current thread will be placed.<br />
<br />
<code>version</code>: the requested JNI version.</p>
<h4>RETURNS:</h4>

<p>The function <code>GetObjectRefType</code> returns
one of the following enumerated values defined as a <code class=
"cCode">jobjectRefType</code>:</p>
<code>JNIInvalidRefType = 0,</code><br />
<code>JNILocalRefType = 1,</code><br />
<code>JNIGlobalRefType = 2,</code><br />
<code>JNIWeakGlobalRefType = 3</code>
<p>If the argument <code>obj</code> is a weak global reference
type, the return will be <code class=
"cCode">JNIWeakGlobalRefType</code>.</p>
<p>If the argument <code>obj</code> is a global reference type, the
return value will be <code class=
"cCode">JNIGlobalRefType</code>.</p>
<p>If the argument <code>obj</code> is a local reference type, the
return will be <code>JNILocalRefType</code>.</p>
<p>If the <code>obj</code> argument is not a valid reference, the
return value for this function will be <code class=
"cCode">JNIInvalidRefType</code>.</p>
<p>An invalid reference is a reference which is not a valid handle.
That is, the <code>obj</code> pointer address does not point to a
location in memory which has been allocated from one of the Ref
creation functions or returned from a JNI function.</p>
<p>As such, <code>NULL</code> would be an invalid
reference and <code>GetObjectRefType(env,NULL)</code>
would return <code>JNIInvalidRefType</code>.</p>
<p>On the other hand, a null reference, which is a reference that
points to a null, would return the type of reference that the null
reference was originally created as.</p>
<p><code>GetObjectRefType</code> cannot be used on
deleted references.</p>
<p>Since references are typically implemented as pointers to memory
data structures that can potentially be reused by any of the
reference allocation services in the VM, once deleted, it is not
specified what value the <code class=
"cCode">GetObjectRefType</code> will return.</p>
<h4>SINCE:</h4>
<p>JDK/JRE 1.6</p>
<!-- ********** end getobjectreftype v6 stuff ************** -->

<h3><a name="IsInstanceOf">IsInstanceOf</a></h3>

<p><code>jboolean IsInstanceOf(JNIEnv
*env, jobject obj,<br />
jclass clazz);</code></p>

<p>Tests whether an object is an instance of a
class.</p>

<h4>LINKAGE:</h4>
<p>Index 32 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>obj</code>: a Java object.</p>

<p><code>clazz</code>: a Java class
object.</p>

<h4>RETURNS:</h4>

<p>Returns <code>JNI_TRUE</code> if
<code>obj</code> can be cast to <code class=
"cCode">clazz</code>; otherwise, returns <code class=
"cCode">JNI_FALSE</code>. A <code>NULL</code> object
can be cast to any class.</p>

<h3><a name="IsSameObject">IsSameObject</a></h3>

<p><code>jboolean IsSameObject(JNIEnv
*env, jobject ref1,<br />
jobject ref2);</code></p>

<p>Tests whether two references refer to the same
Java object.</p>

<h4>LINKAGE:</h4>
<p>Index 24 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>ref1</code>: a Java
object.</p>

<p><code>ref2</code>: a Java
object.</p>

<h4>RETURNS:</h4>

<p>Returns <code>JNI_TRUE</code> if
<code>ref1</code> and <code>ref2</code>
refer to the same Java object, or are both <code class=
"cCode">NULL</code>; otherwise, returns <code class=
"cCode">JNI_FALSE</code>.</p>

<!-- ******************************************************** -->
<h2><a name="accessing_fields_of_objects">Accessing Fields of Objects</a></h2>

<h3><a name="GetFieldID">GetFieldID</a></h3>

<p><code>jfieldID GetFieldID(JNIEnv
*env, jclass clazz,<br />
const char *name, const char *sig);</code></p>

<p>Returns the field ID for an instance (nonstatic)
field of a class. The field is specified by its name and signature.
The <em>Get&lt;type&gt;Field</em> and <em class=
"cEmphasis">Set&lt;type&gt;Field</em> families of accessor
functions use field IDs to retrieve object fields.</p>

<p><code>GetFieldID()</code> causes an
uninitialized class to be initialized.</p>

<p><code>GetFieldID()</code> cannot be
used to obtain the length field of an array. Use <code class=
"cCode">GetArrayLength()</code> instead.</p>

<h4>LINKAGE:</h4>
<p>Index 94 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>

<p><code>name</code>: the field name in
a 0-terminated modified UTF-8 string.</p>

<p><code>sig</code>: the field
signature in a 0-terminated modified UTF-8 string.</p>

<h4>RETURNS:</h4>

<p>Returns a field ID, or <code class=
"cCode">NULL</code> if the operation fails.</p>

<h4>THROWS:</h4>

<p><code>NoSuchFieldError</code>: if
the specified field cannot be found.</p>

<p><code class=
"cCode">ExceptionInInitializerError</code>: if the class
initializer fails due to an exception.</p>

<p><code>OutOfMemoryError</code>: if
the system runs out of memory.</p>

<h3><a name="Get_type_Field_routines">Get&lt;type&gt;Field Routines</a></h3>

<p><em>NativeType</em> <em class=
"cEmphasis">Get&lt;type&gt;Field</em><code>(JNIEnv
*env, jobject obj,<br />
jfieldID fieldID);</code></p>

<p>This family of accessor routines returns the value
of an instance (nonstatic) field of an object. The field to access
is specified by a field ID obtained by calling <code class=
"cCode">GetFieldID()</code>.</p>

<p>The following table describes the
Get&lt;type&gt;Field routine name and result type. You should
replace <em>type</em> in <em class=
"cEmphasis">Get&lt;type&gt;Field</em> with the Java type of the
field, or use one of the actual routine names from the table, and
replace <em>NativeType</em> with the
corresponding native type for that routine.</p>

<table border="1" summary="Get &lt;type&gt;Field Family of Accessor Routine">
<caption>Get&lt;type&gt;Field Family of Accessor Routines</caption>
<thead>
<tr>
<th id="h101">

Get&lt;type&gt;Field Routine Name
</th>
<th id="h102">
Native Type
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h101">
<code class=
"cCode">GetObjectField()</code>
</td>
<td headers="h102">
jobject
</td>
</tr>
<tr>
<td headers="h101">
<code class=
"cCode">GetBooleanField()</code>
</td>
<td headers="h102">
jboolean
</td>
</tr>
<tr>
<td headers="h101">
<code class=
"cCode">GetByteField()</code>
</td>
<td headers="h102">
jbyte
</td>
</tr>
<tr>
<td headers="h101">
<code class=
"cCode">GetCharField()</code>
</td>
<td headers="h102">
jchar
</td>
</tr>
<tr>
<td headers="h101">
<code class=
"cCode">GetShortField()</code>
</td>
<td headers="h102">
jshort
</td>
</tr>
<tr>
<td headers="h101">
<code class=
"cCode">GetIntField()</code>
</td>
<td headers="h102">
jint
</td>
</tr>
<tr>
<td headers="h101">
<code class=
"cCode">GetLongField()</code>
</td>
<td headers="h102">
jlong
</td>
</tr>
<tr>
<td headers="h101">
<code class=
"cCode">GetFloatField()</code>
</td>
<td headers="h102">
jfloat
</td>
</tr>
<tr>
<td headers="h101">
<code class=
"cCode">GetDoubleField()</code>
</td>
<td headers="h102">
jdouble
</td>
</tr>
</tbody>
</table>



<h4>LINKAGE:</h4>

<p>Indices in the JNIEnv interface function table:</p>

<table border="1" summary=
"Get &lt;type&gt;Field Family of Accessor Routine">
<caption>Get&lt;type&gt;Field
Family of Accessor Routines</caption>
<thead>
<tr>
<th id="h201">

Get&lt;type&gt;Field Routine Name
</th>
<th id="h202">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h201">
<code class=
"cCode">GetObjectField()</code>
</td>
<td headers="h202">95</td>
</tr>
<tr>
<td headers="h201">
<code class=
"cCode">GetBooleanField()</code>
</td>
<td headers="h202">96</td>
</tr>
<tr>
<td headers="h201">
<code class=
"cCode">GetByteField()</code>
</td>
<td headers="h202">97</td>
</tr>
<tr>
<td headers="h201">
<code class=
"cCode">GetCharField()</code>
</td>
<td headers="h202">98</td>
</tr>
<tr>
<td headers="h201">
<code class=
"cCode">GetShortField()</code>
</td>
<td headers="h202">99

</td>
</tr>
<tr>
<td headers="h201">
<code class=
"cCode">GetIntField()</code>
</td>
<td headers="h202">100</td>
</tr>
<tr>
<td headers="h201">
<code class=
"cCode">GetLongField()</code>
</td>
<td headers="h202">101</td>
</tr>
<tr>
<td headers="h201">
<code class=
"cCode">GetFloatField()</code>
</td>
<td headers="h202">102

</td>
</tr>
<tr>
<td headers="h201">
<code class=
"cCode">GetDoubleField()</code>
</td>
<td headers="h202">103

</td>
</tr>
</tbody>
</table>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>obj</code>: a Java object
(must not be <code>NULL</code>).</p>

<p><code>fieldID</code>: a valid field
ID.</p>

<h4>RETURNS:</h4>

<p>Returns the content of the field.</p>

<h3><a name="Set_type_Field_routines">Set&lt;type&gt;Field Routines</a></h3>

<p><code>void</code> <em class=
"cEmphasis">Set&lt;type&gt;Field</em><code>(JNIEnv
*env, jobject obj, jfieldID fieldID,<br /></code> <em class=
"cEmphasis">NativeType</em> <code>value);</code></p>

<p>This family of accessor routines sets the value of
an instance (nonstatic) field of an object. The field to access is
specified by a field ID obtained by calling <code class=
"cCode">GetFieldID()</code>.</p>

<p>The following table describes the
Set&lt;type&gt;Field routine name and value type. You should
replace <em>type</em> in <em class=
"cEmphasis">Set&lt;type&gt;Field</em> with the Java type of the
field, or use one of the actual routine names from the table, and
replace <em>NativeType</em> with the
corresponding native type for that routine.</p>

<table border="1" summary=
"Set &lt;type&gt;Fielf Family of Accessor Routine">
<caption>Set&lt;type&gt;Field
Family of Accessor Routines</caption>
<thead>
<tr>
<th id="h301">

Set&lt;type&gt;Field Routine
</th>
<th id="h302">
Native Type
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h301">
<code class=
"cCode">SetObjectField()</code>
</td>
<td headers="h302">
jobject
</td>
</tr>
<tr>
<td headers="h301">
S<code class=
"cCode">etBooleanField()</code>
</td>
<td headers="h302">
jboolean
</td>
</tr>
<tr>
<td headers="h301">
<code class=
"cCode">SetByteField()</code>
</td>
<td headers="h302">
jbyte
</td>
</tr>
<tr>
<td headers="h301">
<code class=
"cCode">SetCharField()</code>
</td>
<td headers="h302">
jchar
</td>
</tr>
<tr>
<td headers="h301">
<code class=
"cCode">SetShortField()</code>
</td>
<td headers="h302">
jshort
</td>
</tr>
<tr>
<td headers="h301">
<code class=
"cCode">SetIntField()</code>
</td>
<td headers="h302">
jint
</td>
</tr>
<tr>
<td headers="h301">
<code class=
"cCode">SetLongField()</code>
</td>
<td headers="h302">
jlong
</td>
</tr>
<tr>
<td headers="h301">
<code class=
"cCode">SetFloatField()</code>
</td>
<td headers="h302">
jfloat
</td>
</tr>
<tr>
<td headers="h301">
<code class=
"cCode">SetDoubleField()</code>
</td>
<td headers="h302">
jdouble
</td>
</tr>
</tbody>
</table>



<h4>LINKAGE:</h4>

<p>Indices in the JNIEnv interface function table.</p>

<table border="1" summary=
"Set &lt;type&gt;Fielf Family of Accessor Routine">
<caption>Set&lt;type&gt;Field
Family of Accessor Routines</caption>
<thead>
<tr>
<th id="h401">

Set&lt;type&gt;Field Routine
</th>
<th id="h402">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h401">
<code class=
"cCode">SetObjectField()</code>
</td>
<td headers="h402">104</td>
</tr>
<tr>
<td headers="h401">
S<code class=
"cCode">etBooleanField()</code>
</td>
<td headers="h402">105</td>
</tr>
<tr>
<td headers="h401">
<code class=
"cCode">SetByteField()</code>
</td>
<td headers="h402">106</td>
</tr>
<tr>
<td headers="h401">
<code class=
"cCode">SetCharField()</code>
</td>
<td headers="h402">107

</td>
</tr>
<tr>
<td headers="h401">
<code class=
"cCode">SetShortField()</code>
</td>
<td headers="h402">108</td>
</tr>
<tr>
<td headers="h401">
<code class=
"cCode">SetIntField()</code>
</td>
<td headers="h402">109</td>
</tr>
<tr>
<td headers="h401">
<code class=
"cCode">SetLongField()</code>
</td>
<td headers="h402">110</td>
</tr>
<tr>
<td headers="h401">
<code class=
"cCode">SetFloatField()</code>
</td>
<td headers="h402">111

</td>
</tr>
<tr>
<td headers="h401">
<code class=
"cCode">SetDoubleField()</code>
</td>
<td headers="h402">112</td>
</tr>
</tbody>
</table>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>obj</code>: a Java object
(must not be <code>NULL</code>).</p>

<p><code>fieldID</code>: a valid field
ID.</p>

<p><code>value</code>: the new value of
the field.</p>

<!-- ******************************************************** -->
<h2><a name="calling_instance_methods">Calling Instance Methods</a></h2>

<h3><a name="GetMethodID">GetMethodID</a></h3>

<p><code>jmethodID GetMethodID(JNIEnv
*env, jclass clazz,<br />
const char *name, const char *sig);</code></p>

<p>Returns the method ID for an instance (nonstatic)
method of a class or interface. The method may be defined in one of
the <code>clazz</code>&#8217;s superclasses and
inherited by <code>clazz</code>. The method is
determined by its name and signature.</p>

<p><code>GetMethodID()</code> causes an
uninitialized class to be initialized.</p>

<p>To obtain the method ID of a constructor, supply
<code>&lt;init&gt;</code> as the method name and
<code>void</code> (<code>V</code>) as
the return type.</p>

<h4>LINKAGE:</h4>
<p>Index 33 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>
<p><code>name</code>: the method name
in a 0-terminated modified UTF-8 string.</p>

<p><code>sig</code>: the method
signature in 0-terminated modified UTF-8 string.</p>

<h4>RETURNS:</h4>

<p>Returns a method ID, or <code class=
"cCode">NULL</code> if the specified method cannot be found.</p>

<h4>THROWS:</h4>

<p><code>NoSuchMethodError</code>: if
the specified method cannot be found.</p>

<p><code class=
"cCode">ExceptionInInitializerError</code>: if the class
initializer fails due to an exception.</p>

<p><code>OutOfMemoryError</code>: if
the system runs out of memory.</p>

<h3><a name="Call_type_Method_routines">Call&lt;type&gt;Method Routines, Call&lt;type&gt;MethodA Routines, Call&lt;type&gt;MethodV Routines</a></h3>

<p><em>NativeType</em> <em class=
"cEmphasis">Call&lt;type&gt;Method</em><code>(JNIEnv
*env, jobject obj,<br />
jmethodID methodID, ...);</code></p>

<p><em>NativeType</em> <em class=
"cEmphasis">Call&lt;type&gt;MethodA</em><code>(JNIEnv
*env, jobject obj,<br />
jmethodID methodID, const jvalue *args);</code></p>

<p><em>NativeType</em> <em class=
"cEmphasis">Call&lt;type&gt;MethodV</em><code>(JNIEnv
*env, jobject obj,<br />
jmethodID methodID, va_list args);</code></p>

<p>Methods from these three families of operations
are used to call a Java instance method from a native method.They
only differ in their mechanism for passing parameters to the
methods that they call.</p>

<p>These families of operations invoke an instance
(nonstatic) method on a Java object, according to the specified
method ID. The <code>methodID</code> argument must be
obtained by calling <code class=
"cCode">GetMethodID</code><code>()</code>.</p>

<p>When these functions are used to call private
methods and constructors, the method ID must be derived from the
real class of <code>obj</code>, not from one of its
superclasses.</p>

<h4>Call&lt;type&gt;Method Routines</h4>

<p>Programmers place all arguments that are to be
passed to the method immediately following the <code class=
"cCode">methodID</code> argument. The <em class=
"cEmphasis">Call&lt;type&gt;Method</em> routine accepts these
arguments and passes them to the Java method that the programmer
wishes to invoke.</p>

<h4>Call&lt;type&gt;MethodA Routines</h4>

<p>Programmers place all arguments to the method in
an <code>args</code> array of <code class=
"cCode">jvalues</code> that immediately follows the <code class=
"cCode">methodID</code> argument. The <em class=
"cEmphasis">Call&lt;type&gt;MethodA</em> routine accepts the
arguments in this array, and, in turn, passes them to the Java
method that the programmer wishes to invoke.</p>

<h4>Call&lt;type&gt;MethodV Routines</h4>

<p>Programmers place all arguments to the method in
an <code>args</code> argument of type <code class=
"cCode">va_list</code> that immediately follows the <code class=
"cCode">methodID</code> argument. The <em class=
"cEmphasis">Call&lt;type&gt;MethodV</em> routine accepts the
arguments, and, in turn, passes them to the Java method that the
programmer wishes to invoke.</p>

<p>The following table describes each of the method
calling routines according to their result type. You should replace
<em>type</em> in <em class=
"cEmphasis">Call&lt;type&gt;Method</em> with the Java type of the
method you are calling (or use one of the actual method calling
routine names from the table) and replace <em class=
"cEmphasis">NativeType</em> with the corresponding native type for
that routine.</p>

<table border="1" summary=
"Instance Method Calling Routines">
<caption>Instance Method Calling
Routines</caption>
<thead>
<tr>
<th id="h501">

Call&lt;type&gt;Method Routine Name
</th>
<th id="h502">
Native Type
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h501">
<code class=
"cCode">CallVoidMethod()</code>

<code class=
"cCode">CallVoidMethodA()</code>

<code class=
"cCode">CallVoidMethodV()</code>
</td>
<td headers="h502">
void
</td>
</tr>
<tr>
<td headers="h501">
<code class=
"cCode">CallObjectMethod()</code>

<code class=
"cCode">CallObjectMethodA()</code>

<code class=
"cCode">CallObjectMethodV()</code>
</td>
<td headers="h502">
jobject
</td>
</tr>
<tr>
<td headers="h501">
<code class=
"cCode">CallBooleanMethod()</code>

<code class=
"cCode">CallBooleanMethodA()</code>

<code class=
"cCode">CallBooleanMethodV()</code>
</td>
<td headers="h502">
jboolean
</td>
</tr>
<tr>
<td headers="h501">
<code class=
"cCode">CallByteMethod()</code>

<code class=
"cCode">CallByteMethodA()</code>

<code class=
"cCode">CallByteMethodV()</code>
</td>
<td headers="h502">
jbyte
</td>
</tr>
<tr>
<td headers="h501">
<code class=
"cCode">CallCharMethod()</code>

<code class=
"cCode">CallCharMethodA()</code>

<code class=
"cCode">CallCharMethodV()</code>
</td>
<td headers="h502">
jchar
</td>
</tr>
<tr>
<td headers="h501">
<code class=
"cCode">CallShortMethod()</code>

<code class=
"cCode">CallShortMethodA()</code>

<code class=
"cCode">CallShortMethodV()</code>
</td>
<td headers="h502">
jshort
</td>
</tr>
<tr>
<td headers="h501">
<code class=
"cCode">CallIntMethod()</code>

<code class=
"cCode">CallIntMethodA()</code>

<code class=
"cCode">CallIntMethodV()</code>
</td>
<td headers="h502">
jint
</td>
</tr>
<tr>
<td headers="h501">
<code class=
"cCode">CallLongMethod()</code>

<code class=
"cCode">CallLongMethodA()</code>

<code class=
"cCode">CallLongMethodV()</code>
</td>
<td headers="h502">
jlong
</td>
</tr>
<tr>
<td headers="h501">
<code class=
"cCode">CallFloatMethod()</code>

<code class=
"cCode">CallFloatMethodA()</code>

<code class=
"cCode">CallFloatMethodV()</code>
</td>
<td headers="h502">
jfloat
</td>
</tr>
<tr>
<td headers="h501">
<code class=
"cCode">CallDoubleMethod()</code>

<code class=
"cCode">CallDoubleMethodA()</code>

<code class=
"cCode">CallDoubleMethodV()</code>
</td>
<td headers="h502">
jdouble
</td>
</tr>
</tbody>
</table>

<h4>LINKAGE:</h4>
<p>Indices in the JNIEnv interface function table:</p>

<table border="1" summary=
"Instance Method Calling Routines">
<caption>Instance Method Calling
Routines</caption>
<thead>
<tr>
<th id="h601">

Call&lt;type&gt;Method Routine Name
</th>
<th id="h602">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h601">
<code class=
"cCode">CallVoidMethod()</code>
<code class=
"cCode">CallVoidMethodA()</code>
<code class=
"cCode">CallVoidMethodV()</code>
</td>
<td headers="h602">

<p>61<br />
63<br />
62</p>

</td>
</tr>
<tr>
<td headers="h601">
<code class=
"cCode">CallObjectMethod()</code>
<code class=
"cCode">CallObjectMethodA()</code>
<code class=
"cCode">CallObjectMethodV()</code>
</td>
<td headers="h602">
<p>34<br />
36<br />
35</p>
</td>
</tr>
<tr>
<td headers="h601">
<code class=
"cCode">CallBooleanMethod()</code>
<code class=
"cCode">CallBooleanMethodA()</code>
<code class=
"cCode">CallBooleanMethodV()</code>
</td>
<td headers="h602">
<p>37<br />
39<br />
38</p>
</td>
</tr>
<tr>
<td headers="h601">
<code class=
"cCode">CallByteMethod()</code>
<code class=
"cCode">CallByteMethodA()</code>
<code class=
"cCode">CallByteMethodV()</code>
</td>
<td headers="h602">
<p>40<br />
42<br />
41</p>
</td>
</tr>
<tr>
<td headers="h601">
<code class=
"cCode">CallCharMethod()</code>
<code class=
"cCode">CallCharMethodA()</code>
<code class=
"cCode">CallCharMethodV()</code>
</td>
<td headers="h602">
<p>43<br />
45<br />
44</p>
</td>
</tr>
<tr>
<td headers="h601">
<code class=
"cCode">CallShortMethod()</code>
<code class=
"cCode">CallShortMethodA()</code>
<code class=
"cCode">CallShortMethodV()</code>
</td>
<td headers="h602">
<p>46<br />
48<br />
47</p>
</td>
</tr>
<tr>
<td headers="h601">
<code class=
"cCode">CallIntMethod()</code>
<code class=
"cCode">CallIntMethodA()</code>
<code class=
"cCode">CallIntMethodV()</code>
</td>
<td headers="h602">
<p>49<br />
51<br />
50</p>
</td>
</tr>
<tr>
<td headers="h601">
<code class=
"cCode">CallLongMethod()</code>
<code class=
"cCode">CallLongMethodA()</code>
<code class=
"cCode">CallLongMethodV()</code>
</td>
<td headers="h602">
<p>52<br />
54<br />
53</p>
</td>
</tr>
<tr>
<td headers="h601">
<code class=
"cCode">CallFloatMethod()</code>
<code class=
"cCode">CallFloatMethodA()</code>
<code class=
"cCode">CallFloatMethodV()</code>
</td>
<td headers="h602">
<p>55<br />
57<br />
56</p>
</td>
</tr>
<tr>
<td headers="h601">
<code class=
"cCode">CallDoubleMethod()</code>
<code class=
"cCode">CallDoubleMethodA()</code>
<code class=
"cCode">CallDoubleMethodV()</code>
</td>
<td headers="h602">
<p>58<br />
60<br />
59</p>
</td>
</tr>
</tbody>
</table>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>obj</code>: a Java object.</p>

<p><code>methodID</code>: a method
ID.</p>

<h4>Additional Parameter for
Call&lt;type&gt;Method Routines:</h4>

<p>arguments to the Java method.</p>

<h4>Additional Parameter for
Call&lt;type&gt;MethodA Routines:</h4>

<p><code>args</code>: an array of
arguments.</p>

<h4>Additional Parameter for
Call&lt;type&gt;MethodV Routines:</h4>

<p><code>args</code>: a va_list of
arguments.</p>

<h4>RETURNS:</h4>

<p>Returns the result of calling the Java method.</p>

<h4>THROWS:</h4>

<p><code>Exceptions raised during the
execution of the Java method.</code></p>

<h3><a name="CallNonvirtual_type_Method_routines">CallNonvirtual&lt;type&gt;Method Routines, CallNonvirtual&lt;type&gt;MethodA Routines, CallNonvirtual&lt;type&gt;MethodV Routines</a></h3>

<p><em>NativeType</em> <em class=
"cEmphasis">CallNonvirtual&lt;type&gt;Method</em><code class=
"cCode">(JNIEnv *env, jobject obj,<br />
jclass clazz, jmethodID methodID, ...);</code></p>

<p><em>NativeType</em> <em class=
"cEmphasis">CallNonvirtual&lt;type&gt;MethodA</em><code class=
"cCode">(JNIEnv *env, jobject obj,<br />
jclass clazz, jmethodID methodID, const jvalue *args);</code></p>

<p><em>NativeType</em> <em class=
"cEmphasis">CallNonvirtual&lt;type&gt;MethodV</em><code class=
"cCode">(JNIEnv *env, jobject obj,<br />
jclass clazz, jmethodID methodID, va_list args);</code></p>

<p>These families of operations invoke an instance
(nonstatic) method on a Java object, according to the specified
class and method ID. The <code>methodID</code>
argument must be obtained by calling <code class=
"cCode">GetMethodID</code><code>()</code> on the
class <code>clazz</code>.</p>

<p>The <em class=
"cEmphasis">CallNonvirtual&lt;type&gt;Method</em> families of
routines and the <em>Call&lt;type&gt;Method</em>
families of routines are different. <em class=
"cEmphasis">Call&lt;type&gt;Method</em> routines invoke the method
based on the class of the object, while <em class=
"cEmphasis">CallNonvirtual&lt;type&gt;Method</em> routines invoke
the method based on the class, designated by the <code class=
"cCode">clazz</code> parameter, from which the method ID is
obtained. The method ID must be obtained from the real class of the
object or from one of its superclasses.</p>

<h4>CallNonvirtual&lt;type&gt;Method
Routines</h4>

<p>Programmers place all arguments that are to be
passed to the method immediately following the <code class=
"cCode">methodID</code> argument. The <em class=
"cEmphasis">CallNonvirtual&lt;type&gt;Method</em> routine accepts
these arguments and passes them to the Java method that the
programmer wishes to invoke.</p>

<h4>CallNonvirtual&lt;type&gt;MethodA
Routines</h4>

<p>Programmers place all arguments to the method in
an <code>args</code> array of <code class=
"cCode">jvalues</code> that immediately follows the <code class=
"cCode">methodID</code> argument. The <em class=
"cEmphasis">CallNonvirtual&lt;type&gt;MethodA</em> routine accepts
the arguments in this array, and, in turn, passes them to the Java
method that the programmer wishes to invoke.</p>

<h4>CallNonvirtual&lt;type&gt;MethodV
Routines</h4>

<p>Programmers place all arguments to the method in
an <code>args</code> argument of type <code class=
"cCode">va_list</code> that immediately follows the <code class=
"cCode">methodID</code> argument. The <em class=
"cEmphasis">CallNonvirtualMethodV</em> routine accepts the
arguments, and, in turn, passes them to the Java method that the
programmer wishes to invoke.</p>

<p>The following table describes each of the method
calling routines according to their result type. You should replace
<em>type</em> in <em class=
"cEmphasis">CallNonvirtual&lt;type&gt;Method</em> with the Java
type of the method, or use one of the actual method calling routine
names from the table, and replace <em class=
"cEmphasis">NativeType</em> with the corresponding native type for
that routine.</p>

<table border="1" summary=
"CallNonvirtual&lt;type&gt; Method Routines">
<caption>CallNonvirtual&lt;type&gt;Method Routines</caption>
<thead>
<tr>
<th id="h701">

CallNonvirtual&lt;type&gt;Method Routine Name
</th>
<th id="h702">
Native Type
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h701">
<code class=
"cCode">CallNonvirtualVoidMethod()</code>

<code class=
"cCode">CallNonvirtualVoidMethodA()</code>

<code class=
"cCode">CallNonvirtualVoidMethodV()</code>
</td>
<td headers="h702">
void
</td>
</tr>
<tr>
<td headers="h701">
<code class=
"cCode">CallNonvirtualObjectMethod()</code>

<code class=
"cCode">CallNonvirtualObjectMethodA()</code>

<code class=
"cCode">CallNonvirtualObjectMethodV()</code>
</td>
<td headers="h702">
jobject
</td>
</tr>
<tr>
<td headers="h701">
<code class=
"cCode">CallNonvirtualBooleanMethod()</code>

<code class=
"cCode">CallNonvirtualBooleanMethodA()</code>

<code class=
"cCode">CallNonvirtualBooleanMethodV()</code>
</td>
<td headers="h702">
jboolean
</td>
</tr>
<tr>
<td headers="h701">
<code class=
"cCode">CallNonvirtualByteMethod()</code>

<code class=
"cCode">CallNonvirtualByteMethodA()</code>

<code class=
"cCode">CallNonvirtualByteMethodV()</code>
</td>
<td headers="h702">
jbyte
</td>
</tr>
<tr>
<td headers="h701">
<code class=
"cCode">CallNonvirtualCharMethod()</code>

<code class=
"cCode">CallNonvirtualCharMethodA()</code>

<code class=
"cCode">CallNonvirtualCharMethodV()</code>
</td>
<td headers="h702">
jchar
</td>
</tr>
<tr>
<td headers="h701">
<code class=
"cCode">CallNonvirtualShortMethod()</code>

<code class=
"cCode">CallNonvirtualShortMethodA()</code>

<code class=
"cCode">CallNonvirtualShortMethodV()</code>
</td>
<td headers="h702">
jshort
</td>
</tr>
<tr>
<td headers="h701">
<code class=
"cCode">CallNonvirtualIntMethod()</code>

<code class=
"cCode">CallNonvirtualIntMethodA()</code>

<code class=
"cCode">CallNonvirtualIntMethodV()</code>
</td>
<td headers="h702">
jint
</td>
</tr>
<tr>
<td headers="h701">
<code class=
"cCode">CallNonvirtualLongMethod()</code>

<code class=
"cCode">CallNonvirtualLongMethodA()</code>

<code class=
"cCode">CallNonvirtualLongMethodV()</code>
</td>
<td headers="h702">
jlong
</td>
</tr>
<tr>
<td headers="h701">
<code class=
"cCode">CallNonvirtualFloatMethod()</code>

<code class=
"cCode">CallNonvirtualFloatMethodA()</code>

<code class=
"cCode">CallNonvirtualFloatMethodV()</code>
</td>
<td headers="h702">
jfloat
</td>
</tr>
<tr>
<td headers="h701">
<code class=
"cCode">CallNonvirtualDoubleMethod()</code>

<code class=
"cCode">CallNonvirtualDoubleMethodA()</code>

<code class=
"cCode">CallNonvirtualDoubleMethodV()</code>
</td>
<td headers="h702">
jdouble
</td>
</tr>
</tbody>
</table>



<h4>LINKAGE:</h4>
<p>Indices in the JNIEnv interface function table.</p>

<table border="1" summary=
"CallNonvirtual&lt;type&gt; Method Routines">
<caption>CallNonvirtual&lt;type&gt;Method Routines</caption>
<thead>
<tr>
<th id="h801">

CallNonvirtual&lt;type&gt;Method Routine Name
</th>
<th id="h802">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h801">
<code class=
"cCode">CallNonvirtualVoidMethod()</code>
<code class=
"cCode">CallNonvirtualVoidMethodA()</code>
<code class=
"cCode">CallNonvirtualVoidMethodV()</code>
</td>
<td headers="h802">91<br />
93<br />
92</td>
</tr>
<tr>
<td headers="h801">
<code class=
"cCode">CallNonvirtualObjectMethod()</code>
<code class=
"cCode">CallNonvirtualObjectMethodA()</code>
<code class=
"cCode">CallNonvirtualObjectMethodV()</code>
</td>
<td headers="h802">64<br />
66<br />
65</td>
</tr>
<tr>
<td headers="h801">
<code class=
"cCode">CallNonvirtualBooleanMethod()</code>
<code class=
"cCode">CallNonvirtualBooleanMethodA()</code>
<code class=
"cCode">CallNonvirtualBooleanMethodV()</code>
</td>
<td headers="h802">67<br />
69<br />
68</td>
</tr>
<tr>
<td headers="h801">
<code class=
"cCode">CallNonvirtualByteMethod()</code>
<code class=
"cCode">CallNonvirtualByteMethodA()</code>
<code class=
"cCode">CallNonvirtualByteMethodV()</code>
</td>
<td headers="h802">70<br />
72<br />
71</td>
</tr>
<tr>
<td headers="h801">
<code class=
"cCode">CallNonvirtualCharMethod()</code>
<code class=
"cCode">CallNonvirtualCharMethodA()</code>
<code class=
"cCode">CallNonvirtualCharMethodV()</code>
</td>
<td headers="h802">73<br />
75<br />
74</td>
</tr>
<tr>
<td headers="h801">
<code class=
"cCode">CallNonvirtualShortMethod()</code>
<code class=
"cCode">CallNonvirtualShortMethodA()</code>
<code class=
"cCode">CallNonvirtualShortMethodV()</code>
</td>
<td headers="h802">76<br />
78<br />
77</td>
</tr>
<tr>
<td headers="h801">
<code class=
"cCode">CallNonvirtualIntMethod()</code>
<code class=
"cCode">CallNonvirtualIntMethodA()</code>
<code class=
"cCode">CallNonvirtualIntMethodV()</code>
</td>
<td headers="h802">79<br />
81<br />
80</td>
</tr>
<tr>
<td headers="h801">
<code class=
"cCode">CallNonvirtualLongMethod()</code>
<code class=
"cCode">CallNonvirtualLongMethodA()</code>
<code class=
"cCode">CallNonvirtualLongMethodV()</code>
</td>
<td headers="h802">82<br />
84<br />
83</td>
</tr>
<tr>
<td headers="h801">
<code class=
"cCode">CallNonvirtualFloatMethod()</code>
<code class=
"cCode">CallNonvirtualFloatMethodA()</code>
<code class=
"cCode">CallNonvirtualFloatMethodV()</code>
</td>
<td headers="h802">85<br />
87<br />
86</td>
</tr>
<tr>
<td headers="h801">
<code class=
"cCode">CallNonvirtualDoubleMethod()</code>
<code class=
"cCode">CallNonvirtualDoubleMethodA()</code>
<code class=
"cCode">CallNonvirtualDoubleMethodV()</code>
</td>
<td headers="h802">88<br />
90<br />
89</td>
</tr>
</tbody>
</table>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz:</code> <code class=
"cCode">a</code> Java class.</p>

<p><code>obj</code>: a Java object.</p>

<p><code>methodID</code>: a method
ID.</p>

<h4>Additional Parameter for
CallNonvirtual&lt;type&gt;Method Routines:</h4>

<p>arguments to the Java method.</p>

<h4>Additional Parameter for
CallNonvirtual&lt;type&gt;MethodA Routines:</h4>

<p><code>args</code>: an array of
arguments.</p>

<h4>Additional Parameter for
CallNonvirtual&lt;type&gt;MethodV Routines:</h4>

<p><code>args</code>: a <code class=
"cCode">va_list</code> of arguments.</p>

<h4>RETURNS:</h4>

<p>Returns the result of calling the Java
method.</p>

<h4>THROWS:</h4>

<p>Exceptions raised during the execution of the Java
method.</p>

<!-- ******************************************************** -->
<h2><a name="accessing_static_fields">Accessing Static Fields</a></h2>

<h3><a name="GetStaticFieldID">GetStaticFieldID</a></h3>

<p><code>jfieldID
GetStaticFieldID(JNIEnv *env, jclass clazz,<br />
const char *name, const char *sig);</code></p>

<p>Returns the field ID for a static field of a
class. The field is specified by its name and signature. The
<em>GetStatic&lt;type&gt;Field</em> and
<em>SetStatic&lt;type&gt;Field</em> families of
accessor functions use field IDs to retrieve static fields.</p>

<p><code>GetStaticFieldID()</code>
causes an uninitialized class to be initialized.</p>

<h4>LINKAGE:</h4>
<p>Index 144 in the JNIEnv interface function table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>

<p><code>name</code>: the static field
name in a 0-terminated modified UTF-8 string.</p>

<p><code>sig</code>: the field
signature in a 0-terminated modified UTF-8 string.</p>

<h4>RETURNS:</h4>

<p>Returns a field ID, or <code class=
"cCode">NULL</code> if the specified static field cannot be
found.</p>

<h4>THROWS:</h4>

<p><code>NoSuchFieldError</code>: if
the specified static field cannot be found.</p>

<p><code class=
"cCode">ExceptionInInitializerError</code>: if the class
initializer fails due to an exception.</p>

<p><code>OutOfMemoryError</code>: if
the system runs out of memory.</p>

<h3><a name="GetStatic_type_Field_routines">GetStatic&lt;type&gt;Field Routines</a></h3>

<p><em>NativeType</em> <em class=
"cEmphasis">GetStatic&lt;type&gt;Field</em><code class=
"cCode">(JNIEnv *env, jclass clazz,<br />
jfieldID fieldID);</code></p>

<p>This family of accessor routines returns the value
of a static field of an object. The field to access is specified by
a field ID, which is obtained by calling <code class=
"cCode">GetStaticFieldID()</code>.</p>

<p>The following table describes the family of get
routine names and result types. You should replace <em class=
"cEmphasis">type</em> in <em class=
"cEmphasis">GetStatic&lt;type&gt;Field</em> with the Java type of
the field, or one of the actual static field accessor routine names
from the table, and replace <em>NativeType</em>
with the corresponding native type for that routine.</p>



<table border="1" summary=
"GetStatic&lt;type&gt;Field Family of Accessor Routines">
<caption>GetStatic&lt;type&gt;Field Family of Accessor Routines</caption>
<thead>
<tr>
<th id="h901">

GetStatic&lt;type&gt;Field Routine Name
</th>
<th id="h902">
Native Type
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h901">
<code class=
"cCode">GetStaticObjectField</code><code class=
"cCode">()</code>
</td>
<td headers="h902">
jobject
</td>
</tr>
<tr>
<td headers="h901">
<code class=
"cCode">GetStaticBooleanField</code><code class=
"cCode">()</code>
</td>
<td headers="h902">
jboolean
</td>
</tr>
<tr>
<td headers="h901">
<code class=
"cCode">GetStaticByteField</code><code class=
"cCode">()</code>
</td>
<td headers="h902">
jbyte
</td>
</tr>
<tr>
<td headers="h901">
<code class=
"cCode">GetStaticCharField</code><code class=
"cCode">()</code>
</td>
<td headers="h902">
jchar
</td>
</tr>
<tr>
<td headers="h901">
<code class=
"cCode">GetStaticShortField</code><code class=
"cCode">()</code>
</td>
<td headers="h902">
jshort
</td>
</tr>
<tr>
<td headers="h901">
<code class=
"cCode">GetStaticIntField</code><code>()</code>
</td>
<td headers="h902">
jint
</td>
</tr>
<tr>
<td headers="h901">
<code class=
"cCode">GetStaticLongField</code><code class=
"cCode">()</code>
</td>
<td headers="h902">
jlong
</td>
</tr>
<tr>
<td headers="h901">
<code class=
"cCode">GetStaticFloatField</code><code class=
"cCode">()</code>
</td>
<td headers="h902">
jfloat
</td>
</tr>
<tr>
<td headers="h901">
<code class=
"cCode">GetStaticDoubleField</code><code class=
"cCode">()</code>
</td>
<td headers="h902">
jdouble
</td>
</tr>
</tbody>
</table>



<h4>LINKAGE:</h4>
<p>Indices in the JNIEnv interface function table.</p>

<table border="1" summary=
"GetStatic&lt;type&gt;Field Family of Accessor Routines">
<caption>GetStatic&lt;type&gt;Field Family of Accessor Routines</caption>
<thead>
<tr>
<th id="h1001">

GetStatic&lt;type&gt;Field Routine Name
</th>
<th id="h1002">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1001">
<code class=
"cCode">GetStaticObjectField</code><code class=
"cCode">()</code>
</td>
<td headers="h1002">145</td>
</tr>
<tr>
<td headers="h1001">
<code class=
"cCode">GetStaticBooleanField</code><code class=
"cCode">()</code>
</td>
<td headers="h1002">146</td>
</tr>
<tr>
<td headers="h1001">
<code class=
"cCode">GetStaticByteField</code><code class=
"cCode">()</code>
</td>
<td headers="h1002">147</td>
</tr>
<tr>
<td headers="h1001">
<code class=
"cCode">GetStaticCharField</code><code class=
"cCode">()</code>
</td>
<td headers="h1002">148</td>
</tr>
<tr>
<td headers="h1001">
<code class=
"cCode">GetStaticShortField</code><code class=
"cCode">()</code>
</td>
<td headers="h1002">149</td>
</tr>
<tr>
<td headers="h1001">
<code class=
"cCode">GetStaticIntField</code><code>()</code>
</td>
<td headers="h1002">150</td>
</tr>
<tr>
<td headers="h1001">
<code class=
"cCode">GetStaticLongField</code><code class=
"cCode">()</code>
</td>
<td headers="h1002">151</td>
</tr>
<tr>
<td headers="h1001">
<code class=
"cCode">GetStaticFloatField</code><code class=
"cCode">()</code>
</td>
<td headers="h1002">152</td>
</tr>
<tr>
<td headers="h1001">
<code class=
"cCode">GetStaticDoubleField</code><code class=
"cCode">()</code>
</td>
<td headers="h1002">153</td>
</tr>
</tbody>
</table>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>

<p><code>fieldID</code>: a static field
ID.</p>

<h4>RETURNS:</h4>

<p>Returns the content of the static field.</p>

<h3><a name="SetStatic_type_Field_routines">SetStatic&lt;type&gt;Field Routines</a></h3>

<p><code>void</code> <em class=
"cEmphasis">SetStatic&lt;type&gt;Field</em><code class=
"cCode">(JNIEnv *env, jclass clazz,<br />
jfieldID fieldID,</code> <em>NativeType</em>
<code>value);</code></p>

<p>This family of accessor routines sets the value of
a static field of an object. The field to access is specified by a
field ID, which is obtained by calling <code class=
"cCode">GetStaticFieldID()</code>.</p>

<p>The following table describes the set routine name
and value types. You should replace <em>type</em>
in <em>SetStatic&lt;type&gt;Field</em> with the
Java type of the field, or one of the actual set static field
routine names from the table, and replace <em class=
"cEmphasis">NativeType</em> with the corresponding native type for
that routine.</p>


<table border="1" summary=
"SetStatic&lt;type&gt;Field Family of Accessor Routines">
<caption>SetStatic&lt;type&gt;Field Family of Accessor Routines</caption>
<thead>
<tr>
<th id="h1101">

SetStatic&lt;type&gt;Field Routine Name
</th>
<th id="h1102">
NativeType
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1101">
<code class=
"cCode">SetStaticObjectField</code><code class=
"cCode">()</code>
</td>
<td headers="h1102">
jobject
</td>
</tr>
<tr>
<td headers="h1101">
<code class=
"cCode">SetStaticBooleanField</code><code class=
"cCode">()</code>
</td>
<td headers="h1102">
jboolean
</td>
</tr>
<tr>
<td headers="h1101">
<code class=
"cCode">SetStaticByteField</code><code class=
"cCode">()</code>
</td>
<td headers="h1102">
jbyte
</td>
</tr>
<tr>
<td headers="h1101">
<code class=
"cCode">SetStaticCharField</code><code class=
"cCode">()</code>
</td>
<td headers="h1102">
jchar
</td>
</tr>
<tr>
<td headers="h1101">
<code class=
"cCode">SetStaticShortField</code><code class=
"cCode">()</code>
</td>
<td headers="h1102">
jshort
</td>
</tr>
<tr>
<td headers="h1101">
<code class=
"cCode">SetStaticIntField</code><code>()</code>
</td>
<td headers="h1102">
jint
</td>
</tr>
<tr>
<td headers="h1101">
<code class=
"cCode">SetStaticLongField</code><code class=
"cCode">()</code>
</td>
<td headers="h1102">
jlong
</td>
</tr>
<tr>
<td headers="h1101">
<code class=
"cCode">SetStaticFloatField</code><code class=
"cCode">()</code>
</td>
<td headers="h1102">
jfloat
</td>
</tr>
<tr>
<td headers="h1101">
<code class=
"cCode">SetStaticDoubleField</code><code class=
"cCode">()</code>
</td>
<td headers="h1102">
jdouble
</td>
</tr>
</tbody>
</table>



<h4>LINKAGE:</h4>
<p>Indices in the JNIEnv interface function table.</p>


<table border="1" summary=
"SetStatic&lt;type&gt;Field Family of Accessor Routines">
<caption>SetStatic&lt;type&gt;Field Family of Accessor Routines</caption>
<thead>
<tr>
<th id="h1201">

SetStatic&lt;type&gt;Field Routine Name
</th>
<th id="h1202">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1201">
<code class=
"cCode">SetStaticObjectField</code><code class=
"cCode">()</code>
</td>
<td headers="h1202">154</td>
</tr>
<tr>
<td headers="h1201">
<code class=
"cCode">SetStaticBooleanField</code><code class=
"cCode">()</code>
</td>
<td headers="h1202">155</td>
</tr>
<tr>
<td headers="h1201">
<code class=
"cCode">SetStaticByteField</code><code class=
"cCode">()</code>
</td>
<td headers="h1202">156</td>
</tr>
<tr>
<td headers="h1201">
<code class=
"cCode">SetStaticCharField</code><code class=
"cCode">()</code>
</td>
<td headers="h1202">157</td>
</tr>
<tr>
<td headers="h1201">
<code class=
"cCode">SetStaticShortField</code><code class=
"cCode">()</code>
</td>
<td headers="h1202">158</td>
</tr>
<tr>
<td headers="h1201">
<code class=
"cCode">SetStaticIntField</code><code>()</code>
</td>
<td headers="h1202">159</td>
</tr>
<tr>
<td headers="h1201">
<code class=
"cCode">SetStaticLongField</code><code class=
"cCode">()</code>
</td>
<td headers="h1202">160</td>
</tr>
<tr>
<td headers="h1201">
<code class=
"cCode">SetStaticFloatField</code><code class=
"cCode">()</code>
</td>
<td headers="h1202">161</td>
</tr>
<tr>
<td headers="h1201">
<code class=
"cCode">SetStaticDoubleField</code><code class=
"cCode">()</code>
</td>
<td headers="h1202">162</td>
</tr>
</tbody>
</table>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>

<p><code>fieldID</code>: a static field
ID.</p>

<p><code>value</code>: the new value of
the field.</p>

<!-- ******************************************************** -->
<h2><a name="calling_static_methods">Calling Static Methods</a></h2>

<h3><a name="GetStaticMethodID">GetStaticMethodID</a></h3>

<p><code>jmethodID
GetStaticMethodID(JNIEnv *env, jclass clazz,<br />
const char *name, const char *sig);</code></p>

<p>Returns the method ID for a static method of a
class. The method is specified by its name and signature.</p>

<p><code>GetStaticMethodID()</code>
causes an uninitialized class to be initialized.</p>

<h4>LINKAGE:</h4>
Index 113 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>

<p><code>name</code>: the static method
name in a 0-terminated modified UTF-8 string.</p>

<p><code>sig</code>: the method
signature in a 0-terminated modified UTF-8 string.</p>

<h4>RETURNS:</h4>

<p>Returns a method ID, or <code class=
"cCode">NULL</code> if the operation fails.</p>

<h4>THROWS:</h4>

<p><code>NoSuchMethodError</code>: if
the specified static method cannot be found.</p>

<p><code class=
"cCode">ExceptionInInitializerError</code>: if the class
initializer fails due to an exception.</p>

<p><code>OutOfMemoryError</code>: if
the system runs out of memory.</p>

<h3><a name="CallStatic_type_Method_routines">CallStatic&lt;type&gt;Method Routines, CallStatic&lt;type&gt;MethodA Routines, CallStatic&lt;type&gt;MethodV Routines</a></h3>

<p><em>NativeType</em> <em class=
"cEmphasis">CallStatic&lt;type&gt;Method</em><code class=
"cCode">(JNIEnv *env, jclass clazz,<br />
jmethodID methodID, ...);</code></p>

<p><em>NativeType</em> <em class=
"cEmphasis">CallStatic&lt;type&gt;MethodA</em><code class=
"cCode">(JNIEnv *env, jclass clazz,<br />
jmethodID methodID, jvalue *args);</code></p>

<p><em>NativeType</em> <em class=
"cEmphasis">CallStatic&lt;type&gt;MethodV</em><code class=
"cCode">(JNIEnv *env, jclass clazz,<br />
jmethodID methodID, va_list args);</code></p>

<p>This family of operations invokes a static method
on a Java object, according to the specified method ID. The
<code>methodID</code> argument must be obtained by
calling <code>GetStaticMethodID</code><code class=
"cCode">()</code>.</p>

<p>The method ID must be derived from <code class=
"cCode">clazz</code>, not from one of its superclasses.</p>

<h4>CallStatic&lt;type&gt;Method Routines</h4>

<p>Programmers should place all arguments that are to
be passed to the method immediately following the <code class=
"cCode">methodID</code> argument. The <em class=
"cEmphasis">CallStatic&lt;type&gt;Method</em> routine accepts these
arguments and passes them to the Java method that the programmer
wishes to invoke.</p>

<h4>CallStatic&lt;type&gt;MethodA Routines</h4>

<p>Programmers should place all arguments to the
method in an <code>args</code> array of <code class=
"cCode">jvalues</code> that immediately follows the <code class=
"cCode">methodID</code> argument. The <em class=
"cEmphasis">CallStaticMethodA</em> routine accepts the arguments in
this array, and, in turn, passes them to the Java method that the
programmer wishes to invoke.</p>

<h4>CallStatic&lt;type&gt;MethodV Routines</h4>

<p>Programmers should place all arguments to the
method in an <code>args</code> argument of type
<code>va_list</code> that immediately follows the
<code>methodID</code> argument. The <em class=
"cEmphasis">CallStaticMethodV</em> routine accepts the arguments,
and, in turn, passes them to the Java method that the programmer
wishes to invoke.</p>

<p>The following table describes each of the method
calling routines according to their result types. You should
replace <em>type</em> in <em class=
"cEmphasis">CallStatic&lt;type&gt;Method</em> with the Java type of
the method, or one of the actual method calling routine names from
the table, and replace <em>NativeType</em> with
the corresponding native type for that routine.</p>


<table border="1" summary=
"CallStatic&lt;type&gt;Method Calling Routines">
<caption>CallStatic&lt;type&gt;Method Calling Routines</caption>
<thead>
<tr>
<th id="h1301">

CallStatic&lt;type&gt;Method Routine Name
</th>
<th id="h1302">
Native Type
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1301">
<code class=
"cCode">CallStaticVoidMethod</code><code class=
"cCode">()</code>

<code class=
"cCode">CallStaticVoidMethodA</code><code class=
"cCode">()</code>

<code class=
"cCode">CallStaticVoidMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1302">
void
</td>
</tr>
<tr>
<td headers="h1301">
<code class=
"cCode">CallStaticObjectMethod</code><code class=
"cCode">()</code>

<code class=
"cCode">CallStaticObjectMethod</code><code class=
"cCode">A()</code>

<code class=
"cCode">CallStaticObjectMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1302">
jobject
</td>
</tr>
<tr>
<td headers="h1301">
<code class=
"cCode">CallStaticBooleanMethod</code><code class=
"cCode">()</code>

<code class=
"cCode">CallStaticBooleanMethod</code><code class=
"cCode">A()</code>

<code class=
"cCode">CallStaticBooleanMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1302">
jboolean
</td>
</tr>
<tr>
<td headers="h1301">
<code class=
"cCode">CallStaticByteMethod</code><code class=
"cCode">()</code>

<code class=
"cCode">CallStaticByteMethod</code><code class=
"cCode">A()</code>

<code class=
"cCode">CallStaticByteMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1302">
jbyte
</td>
</tr>
<tr>
<td headers="h1301">
<code class=
"cCode">CallStaticCharMethod</code><code class=
"cCode">()</code>

<code class=
"cCode">CallStaticCharMethod</code><code class=
"cCode">A()</code>

<code class=
"cCode">CallStaticCharMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1302">
jchar
</td>
</tr>
<tr>
<td headers="h1301">
<code class=
"cCode">CallStaticShortMethod</code><code class=
"cCode">()</code>

<code class=
"cCode">CallStaticShortMethod</code><code class=
"cCode">A()</code>

<code class=
"cCode">CallStaticShortMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1302">
jshort
</td>
</tr>
<tr>
<td headers="h1301">
<code class=
"cCode">CallStaticIntMethod</code><code class=
"cCode">()</code>

<code class=
"cCode">CallStaticIntMethod</code><code class=
"cCode">A()</code>

<code class=
"cCode">CallStaticIntMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1302">
jint
</td>
</tr>
<tr>
<td headers="h1301">
<code class=
"cCode">CallStaticLongMethod</code><code class=
"cCode">()</code>

<code class=
"cCode">CallStaticLongMethod</code><code class=
"cCode">A()</code>

<code class=
"cCode">CallStaticLongMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1302">
jlong
</td>
</tr>
<tr>
<td headers="h1301">
<code class=
"cCode">CallStaticFloatMethod</code><code class=
"cCode">()</code>

<code class=
"cCode">CallStaticFloatMethod</code><code class=
"cCode">A()</code>

<code class=
"cCode">CallStaticFloatMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1302">
jfloat
</td>
</tr>
<tr>
<td headers="h1301">
<code class=
"cCode">CallStaticDoubleMethod</code><code class=
"cCode">()</code>

<code class=
"cCode">CallStaticDoubleMethod</code><code class=
"cCode">A()</code>

<code class=
"cCode">CallStaticDoubleMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1302">
jdouble
</td>
</tr>
</tbody>
</table>



<h4>LINKAGE:</h4>
<p>Indices in the JNIEnv interface function table.</p>

<table border="1" summary=
"CallStatic&lt;type&gt;Method Calling Routines">
<caption>CallStatic&lt;type&gt;Method Calling Routines</caption>
<thead>
<tr>
<th id="h1401">

CallStatic&lt;type&gt;Method Routine Name
</th>
<th id="h1402">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1401">
<code class=
"cCode">CallStaticVoidMethod</code><code class=
"cCode">()</code>
<code class=
"cCode">CallStaticVoidMethodA</code><code class=
"cCode">()</code>
<code class=
"cCode">CallStaticVoidMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1402">141<br />
143<br />
142</td>
</tr>
<tr>
<td headers="h1401">
<code class=
"cCode">CallStaticObjectMethod</code><code class=
"cCode">()</code>
<code class=
"cCode">CallStaticObjectMethod</code><code class=
"cCode">A()</code>
<code class=
"cCode">CallStaticObjectMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1402">114<br />
116<br />
115</td>
</tr>
<tr>
<td headers="h1401">
<code class=
"cCode">CallStaticBooleanMethod</code><code class=
"cCode">()</code>
<code class=
"cCode">CallStaticBooleanMethod</code><code class=
"cCode">A()</code>
<code class=
"cCode">CallStaticBooleanMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1402">117<br />
119<br />
118</td>
</tr>
<tr>
<td headers="h1401">
<code class=
"cCode">CallStaticByteMethod</code><code class=
"cCode">()</code>
<code class=
"cCode">CallStaticByteMethod</code><code class=
"cCode">A()</code>
<code class=
"cCode">CallStaticByteMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1402">120<br />
122<br />
121</td>
</tr>
<tr>
<td headers="h1401">
<code class=
"cCode">CallStaticCharMethod</code><code class=
"cCode">()</code>
<code class=
"cCode">CallStaticCharMethod</code><code class=
"cCode">A()</code>
<code class=
"cCode">CallStaticCharMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1402">123<br />
125<br />
124</td>
</tr>
<tr>
<td headers="h1401">
<code class=
"cCode">CallStaticShortMethod</code><code class=
"cCode">()</code>
<code class=
"cCode">CallStaticShortMethod</code><code class=
"cCode">A()</code>
<code class=
"cCode">CallStaticShortMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1402">126<br />
128<br />
127</td>
</tr>
<tr>
<td headers="h1401">
<code class=
"cCode">CallStaticIntMethod</code><code class=
"cCode">()</code>
<code class=
"cCode">CallStaticIntMethod</code><code class=
"cCode">A()</code>
<code class=
"cCode">CallStaticIntMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1402">129<br />
131<br />
130</td>
</tr>
<tr>
<td headers="h1401">
<code class=
"cCode">CallStaticLongMethod</code><code class=
"cCode">()</code>
<code class=
"cCode">CallStaticLongMethod</code><code class=
"cCode">A()</code>
<code class=
"cCode">CallStaticLongMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1402">132<br />
134<br />
133</td>
</tr>
<tr>
<td headers="h1401">
<code class=
"cCode">CallStaticFloatMethod</code><code class=
"cCode">()</code>
<code class=
"cCode">CallStaticFloatMethod</code><code class=
"cCode">A()</code>
<code class=
"cCode">CallStaticFloatMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1402">135<br />
137<br />
136</td>
</tr>
<tr>
<td headers="h1401">
<code class=
"cCode">CallStaticDoubleMethod</code><code class=
"cCode">()</code>
<code class=
"cCode">CallStaticDoubleMethod</code><code class=
"cCode">A()</code>
<code class=
"cCode">CallStaticDoubleMethod</code><code class=
"cCode">V()</code>
</td>
<td headers="h1402">138<br />
140<br />
139</td>
</tr>
</tbody>
</table>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>

<p><code>methodID</code>: a static
method ID.</p>

<h4>Additional Parameter for
CallStatic&lt;type&gt;Method Routines:</h4>

<p>arguments to the static method.</p>

<h4>Additional Parameter for
CallStatic&lt;type&gt;MethodA Routines:</h4>

<p><code>args</code>: an array of
arguments.</p>

<h4>Additional Parameter for
CallStatic&lt;type&gt;MethodV Routines:</h4>

<p><code>args</code>: a <code class=
"cCode">va_list</code> of arguments.</p>

<h4>RETURNS:</h4>

<p>Returns the result of calling the static Java
method.</p>

<h4>THROWS:</h4>

<p><code>Exceptions raised during the
execution of the Java method.</code></p>
<!-- ******************************************************** -->
<h2><a name="string_operations">String Operations</a></h2>

<h3><a name="NewString">NewString</a></h3>

<p><code>jstring NewString(JNIEnv *env,
const jchar *unicodeChars,<br />
jsize len);</code></p>

<p>Constructs a new <code class=
"cCode">java.lang.String</code> object from an array of Unicode
characters.</p>

<h4>LINKAGE:</h4>
Index 163 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>unicodeChars</code>: pointer
to a Unicode string.</p>

<p><code>len</code>: length of the
Unicode string.</p>

<h4>RETURNS:</h4>

<p>Returns a Java string object, or <code class=
"cCode">NULL</code> if the string cannot be constructed.</p>

<h4>THROWS:</h4>

<p><code>OutOfMemoryError</code>: if
the system runs out of memory.</p>

<h3><a name="GetStringLength">GetStringLength</a></h3>

<p><code>jsize GetStringLength(JNIEnv
*env, jstring string);</code></p>

<p>Returns the length (the count of Unicode
characters) of a Java string.</p>

<h4>LINKAGE:</h4>
Index 164 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>string</code>: a Java string
object.</p>

<h4>RETURNS:</h4>

<p>Returns the length of the Java string.</p>

<h3><a name="GetStringChars">GetStringChars</a></h3>

<p><code>const jchar *
GetStringChars(JNIEnv *env, jstring string,<br />
jboolean *isCopy);</code></p>

<p>Returns a pointer to the array of Unicode
characters of the string. This pointer is valid until <code class=
"cCode">ReleaseStringChars()</code> is called.</p>

<p>If <code>isCopy</code> is not
<code>NULL</code>, then <code class=
"cCode">*isCopy</code> is set to <code class=
"cCode">JNI_TRUE</code> if a copy is made; or it is set to
<code>JNI_FALSE</code> if no copy is made.</p>

<h4>LINKAGE:</h4>
Index 165 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>string</code>: a Java string
object.</p>

<p><code>isCopy</code>: a pointer to a
boolean.</p>

<h4>RETURNS:</h4>

<p>Returns a pointer to a Unicode string, or
<code>NULL</code> if the operation fails.</p>

<h3><a name="ReleaseStringChars">ReleaseStringChars</a></h3>

<p><code>void ReleaseStringChars(JNIEnv
*env, jstring string,<br />
const jchar *chars);</code></p>

<p>Informs the VM that the native code no longer
needs access to <code>chars</code>. The <code class=
"cCode">chars</code> argument is a pointer obtained from
<code>string</code> using <code class=
"cCode">GetStringChars()</code>.</p>

<h4>LINKAGE:</h4>
Index 166 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>string</code>: a Java string
object.</p>

<p><code>chars</code>: a pointer to a
Unicode string.</p>

<h3><a name="NewStringUTF">NewStringUTF</a></h3>

<p><code>jstring NewStringUTF(JNIEnv
*env, const char *bytes);</code></p>

<p>Constructs a new <code class=
"cCode">java.lang.String</code> object from an array of characters
in modified UTF-8 encoding.</p>

<h4>LINKAGE:</h4>
Index 167 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>bytes</code>: the pointer to a
modified UTF-8 string.</p>

<h4>RETURNS:</h4>

<p>Returns a Java string object, or <code class=
"cCode">NULL</code> if the string cannot be constructed.</p>

<h4>THROWS:</h4>

<p><code>OutOfMemoryError</code>: if
the system runs out of memory.</p>

<h3><a name="GetStringUTFLength">GetStringUTFLength</a></h3>

<p><code>jsize
GetStringUTFLength(JNIEnv *env, jstring string);</code></p>

<p>Returns the length in bytes of the modified UTF-8
representation of a string.</p>

<h4>LINKAGE:</h4>
Index 168 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>string</code>: a Java string
object.</p>

<h4>RETURNS:</h4>

<p>Returns the UTF-8 length of the string.</p>

<h3><a name="GetStringUTFChars">GetStringUTFChars</a></h3>

<p><code>const char *
GetStringUTFChars(JNIEnv *env, jstring string,<br />
jboolean *isCopy);</code></p>

<p>Returns a pointer to an array of bytes
representing the string in modified UTF-8 encoding. This array is
valid until it is released by <code class=
"cCode">ReleaseStringUTFChars()</code>.</p>

<p>If <code>isCopy</code> is not
<code>NULL</code>, then <code class=
"cCode">*isCopy</code> is set to <code class=
"cCode">JNI_TRUE</code> if a copy is made; or it is set to
<code>JNI_FALSE</code> if no copy is made.</p>

<h4>LINKAGE:</h4>
Index 169 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>string</code>: a Java string
object.</p>

<p><code>isCopy</code>: a pointer to a
boolean.</p>

<h4>RETURNS:</h4>

<p>Returns a pointer to a modified UTF-8 string, or
<code>NULL</code> if the operation fails.</p>

<h3><a name="ReleaseStringUTFChars">ReleaseStringUTFChars</a></h3>

<p><code>void
ReleaseStringUTFChars(JNIEnv *env, jstring string,<br />
const char *utf);</code></p>

<p>Informs the VM that the native code no longer
needs access to <code>utf</code>. The <code class=
"cCode">utf</code> argument is a pointer derived from <code class=
"cCode">string</code> using <code class=
"cCode">GetStringUTFChars()</code>.</p>

<h4>LINKAGE:</h4>
Index 170 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>string</code>: a Java string
object.</p>

<p><code>utf</code>: a pointer to a
modified UTF-8 string.</p>


<p><strong>Note</strong>: In JDK/JRE 1.1, programmers can get primitive array elements in
a user-supplied buffer. As of JDK/JRE 1.2 additional set of
functions are provided allowing native code to obtain characters in
Unicode (UTF-16) or modified UTF-8 encoding in a user-supplied
buffer. See the functions below.</p>

<h3><a name="GetStringRegion">GetStringRegion</a></h3>
<p><code>void GetStringRegion(JNIEnv *env, jstring str, jsize
start, jsize len, jchar *buf);</code></p>
<p>Copies <code>len</code> number of Unicode characters beginning
at offset <code>start</code> to the given buffer
<code>buf</code>.</p>
<p>Throws <code>StringIndexOutOfBoundsException</code> on index
overflow.</p>
<h4>LINKAGE:</h4>
Index 220 in the JNIEnv interface function table.
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<h3><a name="GetStringUTFRegion">GetStringUTFRegion</a></h3>
<p>&lt; <code>void GetStringUTFRegion(JNIEnv *env, jstring str,
jsize start, jsize len, char *buf);</code></p>
<p>Translates <code>len</code> number of Unicode characters
beginning at offset <code>start</code> into modified UTF-8 encoding
and place the result in the given buffer <code>buf</code>.</p>
<p>Throws <code>StringIndexOutOfBoundsException</code> on index
overflow.</p>
<h4>LINKAGE:</h4>
Index 221 in the JNIEnv interface function table.
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<h3><a name="GetStringCritical_ReleaseStringCritical">GetStringCritical, ReleaseStringCritical</a></h3>
<p><code>const jchar * GetStringCritical(JNIEnv *env, jstring
string, jboolean *isCopy);<br />
void ReleaseStringCritical(JNIEnv *env, jstring string, const jchar
*carray);</code></p>
<p>The semantics of these two functions are similar to the existing
<code>Get/ReleaseStringChars</code> functions. If possible, the VM
returns a pointer to string elements; otherwise, a copy is made.
<strong>However, there are significant restrictions on how these
functions can be used.</strong> In a code segment enclosed by
<code>Get/ReleaseStringCritical</code> calls, the native code must
not issue arbitrary JNI calls, or cause the current thread to
block.</p>
<p>The restrictions on <code>Get/ReleaseStringCritical</code> are
similar to those on
<code>Get/ReleasePrimitiveArrayCritical</code>.</p>
<h4>LINKAGE (GetStringCritical):</h4>
Index 224 in the JNIEnv interface function table.
<h4>LINKAGE (ReleaseStingCritical):</h4>
Index 225 in the JNIEnv interface function table.
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<a name="reflection"></a>
<!-- ******************************************************** -->
<h2><a name="array_operations">Array Operations</a></h2>

<h3><a name="GetArrayLength">GetArrayLength</a></h3>

<p><code>jsize GetArrayLength(JNIEnv
*env, jarray array);</code></p>

<p>Returns the number of elements in the array.</p>

<h4>LINKAGE:</h4>
Index 171 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>array</code>: a Java array
object.</p>

<h4>RETURNS:</h4>

<p>Returns the length of the array.</p>

<h3><a name="NewObjectArray">NewObjectArray</a></h3>

<p><code>jobjectArray
NewObjectArray(JNIEnv *env, jsize length,<br />
jclass elementClass, jobject initialElement);</code></p>

<p>Constructs a new array holding objects in class
<code>elementClass</code>. All elements are initially
set to <code>initialElement</code>.</p>

<h4>LINKAGE:</h4>
Index 172 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>length</code>: array size.</p>

<p><code>elementClass</code>: array
element class.</p>

<p><code>initialElement</code>:
initialization value.</p>

<h4>RETURNS:</h4>

<p>Returns a Java array object, or <code class=
"cCode">NULL</code> if the array cannot be constructed.</p>

<h4>THROWS:</h4>

<p><code>OutOfMemoryError</code>: if
the system runs out of memory.</p>

<h3><a name="GetObjectArrayElement">GetObjectArrayElement</a></h3>

<p><code>jobject
GetObjectArrayElement(JNIEnv *env,<br />
jobjectArray array, jsize index);</code></p>

<p>Returns an element of an <code class=
"cCode">Object</code> array.</p>

<h4>LINKAGE:</h4>
Index 173 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>array</code>: a Java
array.</p>

<p><code>index</code>: array index.</p>

<h4>RETURNS:</h4>

<p>Returns a Java object.</p>

<h4>THROWS:</h4>

<p><code class=
"cCode">ArrayIndexOutOfBoundsException</code>: if <code class=
"cCode">index</code> does not specify a valid index in the
array.</p>

<h3><a name="SetObjectArrayElement">SetObjectArrayElement</a></h3>

<p><code>void
SetObjectArrayElement(JNIEnv *env, jobjectArray array,<br />
jsize index, jobject value);</code></p>

<p>Sets an element of an <code class=
"cCode">Object</code> array.</p>

<h4>LINKAGE:</h4>
Index 174 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>array</code>: a Java
array.</p>

<p><code>index</code>: array index.</p>

<p><code>value</code>: the new
value.</p>

<h4>THROWS:</h4>

<p><code class=
"cCode">ArrayIndexOutOfBoundsException</code>: if <code class=
"cCode">index</code> does not specify a valid index in the
array.</p>

<p><code>ArrayStoreException</code>: if
the class of <code>value</code> is not a subclass of
the element class of the array.</p>

<h3><a name="New_PrimitiveType_Array_routines">New&lt;PrimitiveType&gt;Array Routines</a></h3>

<p><em>ArrayType</em> <em class=
"cEmphasis">New&lt;PrimitiveType&gt;Array</em><code class=
"cCode">(JNIEnv *env, jsize length);</code></p>

<p>A family of operations used to construct a new
primitive array object. The following table
describes the specific primitive array constructors. You should
replace <em>New&lt;PrimitiveType&gt;Array</em>
with one of the actual primitive array constructor routine names
from this table, and replace ArrayType with the
corresponding array type for that routine.</p>



<table border="1" summary=
"New&lt;PrimitiveType&gt;Array Family of Array Constructors">
<caption>New&lt;PrimitiveType&gt;Array Family of Array Constructors</caption>
<thead>
<tr>
<th id="h1501">

New&lt;PrimitiveType&gt;Array Routines
</th>
<th id="h1502">
Array Type
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1501">
<code class=
"cCode">NewBooleanArray()</code>
</td>
<td headers="h1502">
jbooleanArray
</td>
</tr>
<tr>
<td headers="h1501">
<code class=
"cCode">NewByteArray()</code>
</td>
<td headers="h1502">
jbyteArray
</td>
</tr>
<tr>
<td headers="h1501">
<code class=
"cCode">NewCharArray()</code>
</td>
<td headers="h1502">
jcharArray
</td>
</tr>
<tr>
<td headers="h1501">
<code class=
"cCode">NewShortArray()</code>
</td>
<td headers="h1502">
jshortArray
</td>
</tr>
<tr>
<td headers="h1501">
<code class=
"cCode">NewIntArray()</code>
</td>
<td headers="h1502">
jintArray
</td>
</tr>
<tr>
<td headers="h1501">
<code class=
"cCode">NewLongArray()</code>
</td>
<td headers="h1502">
jlongArray
</td>
</tr>
<tr>
<td headers="h1501">
<code class=
"cCode">NewFloatArray()</code>
</td>
<td headers="h1502">
jfloatArray
</td>
</tr>
<tr>
<td headers="h1501">
<code class=
"cCode">NewDoubleArray()</code>
</td>
<td headers="h1502">
jdoubleArray
</td>
</tr>
</tbody>
</table>



<h4>LINKAGE:</h4>
<p>Indices in the JNIEnv interface function table.</p>
<table border="1" summary=
"New&lt;PrimitiveType&gt;Array Family of Array Constructors">
<caption>New&lt;PrimitiveType&gt;Array Family of Array Constructors</caption>
<thead>
<tr>
<th id="h1601">

New&lt;PrimitiveType&gt;Array Routines
</th>
<th id="h1602">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1601">
<code class=
"cCode">NewBooleanArray()</code>
</td>
<td headers="h1602">
175
</td>
</tr>
<tr>
<td headers="h1601">
<code class=
"cCode">NewByteArray()</code>
</td>
<td headers="h1602">
176
</td>
</tr>
<tr>
<td headers="h1601">
<code class=
"cCode">NewCharArray()</code>
</td>
<td headers="h1602">
177
</td>
</tr>
<tr>
<td headers="h1601">
<code class=
"cCode">NewShortArray()</code>
</td>
<td headers="h1602">
178
</td>
</tr>
<tr>
<td headers="h1601">
<code class=
"cCode">NewIntArray()</code>
</td>
<td headers="h1602">
179
</td>
</tr>
<tr>
<td headers="h1601">
<code class=
"cCode">NewLongArray()</code>
</td>
<td headers="h1602">
180
</td>
</tr>
<tr>
<td headers="h1601">
<code class=
"cCode">NewFloatArray()</code>
</td>
<td headers="h1602">
181
</td>
</tr>
<tr>
<td headers="h1601">
<code class=
"cCode">NewDoubleArray()</code>
</td>
<td headers="h1602">
182
</td>
</tr>
</tbody>
</table>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>length</code>: the array
length.</p>

<h4>RETURNS:</h4>

<p>Returns a Java array, or <code class=
"cCode">NULL</code> if the array cannot be constructed.</p>

<h3><a name="Get_PrimitiveType_ArrayElements_routines">Get&lt;PrimitiveType&gt;ArrayElements Routines</a></h3>

<p><em>NativeType</em> <code class=
"cCode">*</code><em class=
"cEmphasis">Get&lt;PrimitiveType&gt;ArrayElements</em><code style=
"font-style: normal;">(JNIEnv *env,<br /></code>
<code style="font-style: italic;">ArrayType</code>
<code>array, jboolean *isCopy);</code></p>

<p>A family of functions that returns the body of the
primitive array. The result is valid until the corresponding
<em style="font-style: italic;" class=
"cEmphasis">Release</em><code style="font-style: italic;" class=
"cCode">&lt;</code><em style="font-style: italic;" class=
"cEmphasis">PrimitiveType</em><code style="font-style: italic;"
class="cCode">&gt;</code><em>ArrayElements()</em>
function is called. S<em>ince the returned array
may be a copy of the Java array, changes made to the returned array
will not necessarily be reflected in the original</em> <code style=
"font-style: normal;">array</code> <em style=
"font-style: italic;">until</em> <code style=
"font-style: italic;" class=
"cCode">Release&lt;PrimitiveType&gt;ArrayElements()</code>
<em>is called.</em></p>

<p>If <code>isCopy</code> is not
<code>NULL</code>, then <code class=
"cCode">*isCopy</code> is set to <code class=
"cCode">JNI_TRUE</code> if a copy is made; or it is set to
<code>JNI_FALSE</code> if no copy is made.</p>

<p>The following table describes the specific
primitive array element accessors. You should make the following
substitutions:</p>


<ul>
<li>Replace <em class=
"cEmphasis">Get&lt;PrimitiveType&gt;ArrayElements</em> with one of
the actual primitive element accessor routine names from the following
table.</li>
<li>Replace ArrayType with the corresponding array type.</li>
<li>Replace <em>NativeType</em> with the
corresponding native type for that routine.</li>
</ul>



<p>Regardless of how boolean arrays are represented
in the Java VM, <code class=
"cCode">GetBooleanArrayElements()</code> always returns a pointer
to <code>jbooleans</code>, with each byte denoting an
element (the unpacked representation). All arrays of other types
are guaranteed to be contiguous in memory.</p>


<table border="1" summary=
"Get&lt;PrimitiveType&gt;ArrayElements Family of Accessor Routines">
<caption>Get&lt;PrimitiveType&gt;ArrayElements Family of Accessor
Routines</caption>
<thead>
<tr>
<th id="h1701">

Get&lt;PrimitiveType&gt;ArrayElements Routines
</th>
<th id="h1702">
Array Type
</th>
<th id="h1703">
Native Type
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1701">
<code class=
"cCode">GetBooleanArrayElements()</code>
</td>
<td headers="h1702">
jbooleanArray
</td>
<td headers="h1703">
jboolean
</td>
</tr>
<tr>
<td headers="h1701">
<code class=
"cCode">GetByteArrayElements()</code>
</td>
<td headers="h1702">
jbyteArray
</td>
<td headers="h1703">
jbyte
</td>
</tr>
<tr>
<td headers="h1701">
<code class=
"cCode">GetCharArrayElements()</code>
</td>
<td headers="h1702">
jcharArray
</td>
<td headers="h1703">
jchar
</td>
</tr>
<tr>
<td headers="h1701">
<code class=
"cCode">GetShortArrayElements()</code>
</td>
<td headers="h1702">
jshortArray
</td>
<td headers="h1703">
jshort
</td>
</tr>
<tr>
<td headers="h1701">
<code class=
"cCode">GetIntArrayElements()</code>
</td>
<td headers="h1702">
jintArray
</td>
<td headers="h1703">
jint
</td>
</tr>
<tr>
<td headers="h1701">
<code class=
"cCode">GetLongArrayElements()</code>
</td>
<td headers="h1702">
jlongArray
</td>
<td headers="h1703">
jlong
</td>
</tr>
<tr>
<td headers="h1701">
<code class=
"cCode">GetFloatArrayElements()</code>
</td>
<td headers="h1702">
jfloatArray
</td>
<td headers="h1703">
jfloat
</td>
</tr>
<tr>
<td headers="h1701">
<code class=
"cCode">GetDoubleArrayElements()</code>
</td>
<td headers="h1702">
jdoubleArray
</td>
<td headers="h1703">
jdouble
</td>
</tr>
</tbody>
</table>



<h4>LINKAGE:</h4>
<p>Indices in the JNIEnv interface function table.</p>
<table border="1" summary="Get&lt;PrimitiveType&gt;ArrayElements Family of Accessor Routines">
<caption>Get&lt;PrimitiveType&gt;ArrayElements Family of Accessor
Routines</caption>
<thead>
<tr>
<th id="h1801">

Get&lt;PrimitiveType&gt;ArrayElements Routines
</th>
<th id="h1802">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1801">
<code class=
"cCode">GetBooleanArrayElements()</code>
</td>
<td headers="h1802">
183
</td>
</tr>
<tr>
<td headers="h1801">
<code class=
"cCode">GetByteArrayElements()</code>
</td>
<td headers="h1802">
184
</td>
</tr>
<tr>
<td headers="h1801">
<code class=
"cCode">GetCharArrayElements()</code>
</td>
<td headers="h1802">
185
</td>
</tr>
<tr>
<td headers="h1801">
<code class=
"cCode">GetShortArrayElements()</code>
</td>
<td headers="h1802">
186
</td>
</tr>
<tr>
<td headers="h1801">
<code class=
"cCode">GetIntArrayElements()</code>
</td>
<td headers="h1802">
187
</td>
</tr>
<tr>
<td headers="h1801">
<code class=
"cCode">GetLongArrayElements()</code>
</td>
<td headers="h1802">
188
</td>
</tr>
<tr>
<td headers="h1801">
<code class=
"cCode">GetFloatArrayElements()</code>
</td>
<td headers="h1802">
189
</td>
</tr>
<tr>
<td headers="h1801">
<code class=
"cCode">GetDoubleArrayElements()</code>
</td>
<td headers="h1802">
190
</td>
</tr>
</tbody>
</table>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>array</code>: a Java string
object.</p>

<p><code>isCopy</code>: a pointer to a
boolean.</p>

<h4>RETURNS:</h4>

<p>Returns a pointer to the array elements, or
<code>NULL</code> if the operation fails.</p>

<h3><a name="Release_PrimitiveType_ArrayElements_routines">Release&lt;PrimitiveType&gt;ArrayElements Routines</a></h3>

<p><code>void</code> <em class=
"cEmphasis">Release&lt;PrimitiveType&gt;ArrayElements</em><code style="font-style: normal;"
class="cCode">(JNIEnv *env,<br /></code> <code style=
"font-style: italic;">ArrayType</code> <code class=
"cCode">array,</code> <em>NativeType</em>
<code>*elems, jint mode);</code></p>

<p>A family of functions that informs the VM that the
native code no longer needs access to <code class=
"cCode">elems</code>. The <code>elems</code> argument
is a pointer derived from <code>array</code> using
the corresponding <em>Get</em><code class=
"cCode">&lt;</code><em class=
"cEmphasis">PrimitiveType</em><code class=
"cCode">&gt;</code><em>ArrayElements()</em>
function. If necessary, this function copies back all changes made
to <code>elems</code> to the original array.</p>

<p>The <code>mode</code> argument
provides information on how the array buffer should be released.
<code>mode</code> has no effect if <code class=
"cCode">elems</code> is not a copy of the elements in <code class=
"cCode">array</code>. Otherwise, <code>mode</code>
has the following impact, as shown in the following table:</p>

<table border="1" summary=
"Primitive Array Release Modes">
<caption>Primitive Array Release
Modes</caption>
<thead>
<tr>
<th id="h1901">
mode
</th>
<th id="h1902">
actions
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1901">
<code>0</code>
</td>
<td headers="h1902">
copy back the content and free the
<code>elems</code> buffer
</td>
</tr>
<tr>
<td headers="h1901">
<code>JNI_COMMIT</code>
</td>
<td headers="h1902">
copy back the content but do not free the
<code>elems</code> buffer
</td>
</tr>
<tr>
<td headers="h1901">
<code>JNI_ABORT</code>
</td>
<td headers="h1902">
free the buffer without copying back the
possible changes
</td>
</tr>
</tbody>
</table>



<p>In most cases, programmers pass &#8220;0&#8221; to
the <code>mode</code> argument to ensure consistent
behavior for both pinned and copied arrays. The other options give
the programmer more control over memory management and should be
used with extreme care.</p>

<p>The next table describes the specific routines
that comprise the family of primitive array disposers. You should
make the following substitutions:</p>


<ul>
<li>Replace <em>Release&lt;PrimitiveType&gt;ArrayElements</em> with one
of the actual primitive array disposer routine names from the following table.</li>
<li>Replace ArrayType with the corresponding array type.</li>
<li>Replace <em>NativeType</em> with the
corresponding native type for that routine.</li>
</ul>

<table border="1" summary=
"Release&lt;PrimitiveType&gt;ArrayElements Family of Array Routines">
<caption>Release&lt;PrimitiveType&gt;ArrayElements Family of Array
Routines</caption>
<thead>
<tr>
<th id="h2001">

Release&lt;PrimitiveType&gt;ArrayElements Routines
</th>
<th id="h2002">
Array Type
</th>
<th id="h2003">
Native Type
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h2001">
<code class=
"cCode">ReleaseBooleanArrayElements()</code>
</td>
<td headers="h2002">
jbooleanArray
</td>
<td headers="h2003">
jboolean
</td>
</tr>
<tr>
<td headers="h2001">
<code class=
"cCode">ReleaseByteArrayElements()</code>
</td>
<td headers="h2002">
jbyteArray
</td>
<td headers="h2003">
jbyte
</td>
</tr>
<tr>
<td headers="h2001">
<code class=
"cCode">ReleaseCharArrayElements()</code>
</td>
<td headers="h2002">
jcharArray
</td>
<td headers="h2003">
jchar
</td>
</tr>
<tr>
<td headers="h2001">
<code class=
"cCode">ReleaseShortArrayElements()</code>
</td>
<td headers="h2002">
jshortArray
</td>
<td headers="h2003">
jshort
</td>
</tr>
<tr>
<td headers="h2001">
<code class=
"cCode">ReleaseIntArrayElements()</code>
</td>
<td headers="h2002">
jintArray
</td>
<td headers="h2003">
jint
</td>
</tr>
<tr>
<td headers="h2001">
<code class=
"cCode">ReleaseLongArrayElements()</code>
</td>
<td headers="h2002">
jlongArray
</td>
<td headers="h2003">
jlong
</td>
</tr>
<tr>
<td headers="h2001">
<code class=
"cCode">ReleaseFloatArrayElements()</code>
</td>
<td headers="h2002">
jfloatArray
</td>
<td headers="h2003">
jfloat
</td>
</tr>
<tr>
<td headers="h2001">
<code class=
"cCode">ReleaseDoubleArrayElements()</code>
</td>
<td headers="h2002">
jdoubleArray
</td>
<td headers="h2003">
jdouble
</td>
</tr>
</tbody>
</table>



<h4>LINKAGE:</h4>
<p>Indices in the JNIEnv interface function table.</p>
<table border="1" summary="Release&lt;PrimitiveType&gt;ArrayElements Family of Array Routines">
<caption>Release&lt;PrimitiveType&gt;ArrayElements Family of Array
Routines</caption>
<thead>
<tr>
<th id="h2101">

Release&lt;PrimitiveType&gt;ArrayElements Routines
</th>
<th id="h2102">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h2101">
<code class=
"cCode">ReleaseBooleanArrayElements()</code>
</td>
<td headers="h2102">
191
</td>
</tr>
<tr>
<td headers="h2101">
<code class=
"cCode">ReleaseByteArrayElements()</code>
</td>
<td headers="h2102">
192
</td>
</tr>
<tr>
<td headers="h2101">
<code class=
"cCode">ReleaseCharArrayElements()</code>
</td>
<td headers="h2102">
193
</td>
</tr>
<tr>
<td headers="h2101">
<code class=
"cCode">ReleaseShortArrayElements()</code>
</td>
<td headers="h2102">
194
</td>
</tr>
<tr>
<td headers="h2101">
<code class=
"cCode">ReleaseIntArrayElements()</code>
</td>
<td headers="h2102">
195
</td>
</tr>
<tr>
<td headers="h2101">
<code class=
"cCode">ReleaseLongArrayElements()</code>
</td>
<td headers="h2102">
196
</td>
</tr>
<tr>
<td headers="h2101">
<code class=
"cCode">ReleaseFloatArrayElements()</code>
</td>
<td headers="h2102">
197
</td>
</tr>
<tr>
<td headers="h2101">
<code class=
"cCode">ReleaseDoubleArrayElements()</code>
</td>
<td headers="h2102">
198
</td>
</tr>
</tbody>
</table>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>array</code>: a Java array
object.</p>

<p><code>elems</code>: a pointer to
array elements.</p>

<p><code>mode</code>: the release
mode.</p>

<h3><a name="Get_PrimitiveType_ArrayRegion_routines">Get&lt;PrimitiveType&gt;ArrayRegion Routines</a></h3>

<p><em>void</em> <em class=
"cEmphasis">Get&lt;PrimitiveType&gt;ArrayRegion</em><code class=
"cCode">(JNIEnv *env,</code> <em>ArrayType</em>
<code>array,<br />
jsize start, jsize len,</code> <em class=
"cEmphasis">NativeType</em> <code>*buf);</code></p>

<p>A family of functions that copies a region of a
primitive array into a buffer.</p>

<p>The following table describes the specific
primitive array element accessors. You should do the following
substitutions:</p>


<ul>
<li>Replace <em>Get&lt;PrimitiveType&gt;ArrayRegion</em> with one of
the actual primitive element accessor routine names from the following table.</li>
<li>Replace <em>ArrayType</em> with the
corresponding array type.</li>
<li>Replace <em>NativeType</em> with the
corresponding native type for that routine.</li>
</ul>




<table border="1" summary="Get&lt;PrimitiveType&gt;ArrayRegion Family of Array Accessor Routines">
  <caption>Get&lt;PrimitiveType&gt;ArrayRegion Family of Array Accessor Routines</caption>
  <thead>
    <tr>
      <th id="h2201">Get&lt;PrimitiveType&gt;ArrayRegion Routine</th>
      <th id="h2202">Array Type</th>
      <th id="h2203">Native Type</th>
     </tr>
  </thead>
  <tbody>
    <tr>
      <td headers="h2201"><code>GetBooleanArrayRegion()</code></td>
      <td headers="h2202">jbooleanArray</td>
      <td headers="h2203">jboolean</td>
    </tr>
    <tr>
      <td headers="h2201"><code>GetByteArrayRegion()</code>
</td>
<td headers="h2202">
jbyteArray
</td>
<td headers="h2203">
jbyte
</td>
</tr>
<tr>
<td headers="h2201">
<code class=
"cCode">GetCharArrayRegion()</code>
</td>
<td headers="h2202">
jcharArray
</td>
<td headers="h2203">
jchar
</td>
</tr>
<tr>
<td headers="h2201">
<code class=
"cCode">GetShortArrayRegion()</code>
</td>
<td headers="h2202">
jshortArray
</td>
<td headers="h2203">
jhort
</td>
</tr>
<tr>
<td headers="h2201">
<code class=
"cCode">GetIntArrayRegion()</code>
</td>
<td headers="h2202">
jintArray
</td>
<td headers="h2203">
jint
</td>
</tr>
<tr>
<td headers="h2201">
<code class=
"cCode">GetLongArrayRegion()</code>
</td>
<td headers="h2202">
jlongArray
</td>
<td headers="h2203">
jlong
</td>
</tr>
<tr>
<td headers="h2201">
<code class=
"cCode">GetFloatArrayRegion()</code>
</td>
<td headers="h2202">
jfloatArray
</td>
<td headers="h2203">
jloat
</td>
</tr>
<tr>
<td headers="h2201">
<code class=
"cCode">GetDoubleArrayRegion()</code>
</td>
<td headers="h2202">
jdoubleArray
</td>
<td headers="h2203">
jdouble
</td>
</tr>
</tbody>
</table>



<h4>LINKAGE:</h4>
<p>Indices in the JNIEnv interface function table.</p>
<table border="1" summary=
"Get&lt;PrimitiveType&gt;ArrayRegion Family of Array Accessor Routines"<caption>Get&lt;PrimitiveType&gt;ArrayRegion Family of Array Accessor
Routines</caption>
<thead>
<tr>
<th id="h2301">

Get&lt;PrimitiveType&gt;ArrayRegion Routine
</th>
<th id="h2302">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h2301">
<code class=
"cCode">GetBooleanArrayRegion()</code>
</td>
<td headers="h2302">
199
</td>
</tr>
<tr>
<td headers="h2301">
<code class=
"cCode">GetByteArrayRegion()</code>
</td>
<td headers="h2302">
200
</td>
</tr>
<tr>
<td headers="h2301">
<code class=
"cCode">GetCharArrayRegion()</code>
</td>
<td headers="h2302">
201
</td>
</tr>
<tr>
<td headers="h2301">
<code class=
"cCode">GetShortArrayRegion()</code>
</td>
<td headers="h2302">
202
</td>
</tr>
<tr>
<td headers="h2301">
<code class=
"cCode">GetIntArrayRegion()</code>
</td>
<td headers="h2302">
203
</td>
</tr>
<tr>
<td headers="h2301">
<code class=
"cCode">GetLongArrayRegion()</code>
</td>
<td headers="h2302">
204
</td>
</tr>
<tr>
<td headers="h2301">
<code class=
"cCode">GetFloatArrayRegion()</code>
</td>
<td headers="h2302">
205
</td>
</tr>
<tr>
<td headers="h2301">
<code class=
"cCode">GetDoubleArrayRegion()</code>
</td>
<td headers="h2302">
206
</td>
</tr>
</tbody>
</table>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>array</code>: a Java
array.</p>

<p><code>start</code>: the starting
index.</p>

<p><code>len</code>: the number of
elements to be copied.</p>

<p><code>buf</code>: the destination
buffer.</p>

<h4>THROWS:</h4>

<p><code class=
"cCode">ArrayIndexOutOfBoundsException</code>: if one of the
indexes in the region is not valid.</p>

<h3><a name="Set_PrimitiveType_ArrayRegion_routines">Set&lt;PrimitiveType&gt;ArrayRegion Routines</a></h3>

<p><code>void</code> <em class=
"cEmphasis">Set&lt;PrimitiveType&gt;ArrayRegion</em><code class=
"cCode">(JNIEnv *env,</code> <em>ArrayType</em>
<code>array,<br />
jsize start, jsize len,</code> const <em class=
"cEmphasis">NativeType</em> <code>*buf);</code></p>

<p>A family of functions that copies back a region of
a primitive array from a buffer.</p>

<p>The following table describes the specific
primitive array element accessors. You should make the following
replacements:</p>


<ul>
  <li>Replace <em>Set&lt;PrimitiveType&gt;ArrayRegion</em> with one of the actual primitive element accessor routine names from the following table.</li>
  <li>Replace ArrayType with the corresponding array type.</li>
  <li>Replace <em>NativeType</em> with the corresponding native type for that routine.</li>
</ul>

<table border="1" summary=
"Set&lt;PrimitiveType&gt;ArrayRegion Family of Array Accessor Routines"<caption>Set&lt;PrimitiveType&gt;ArrayRegion Family of Array Accessor
Routines</caption>
<thead>
<tr>
<th id="h2401">

Set&lt;PrimitiveType&gt;ArrayRegion Routine
</th>
<th id="h2402">
Array Type
</th>
<th id="h2403">
Native Type
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h2401">
<code class=
"cCode">SetBooleanArrayRegion()</code>
</td>
<td headers="h2402">
jbooleanArray
</td>
<td headers="h2403">
jboolean
</td>
</tr>
<tr>
<td headers="h2401">
<code class=
"cCode">SetByteArrayRegion()</code>
</td>
<td headers="h2402">
jbyteArray
</td>
<td headers="h2403">
jbyte
</td>
</tr>
<tr>
<td headers="h2401">
<code class=
"cCode">SetCharArrayRegion()</code>
</td>
<td headers="h2402">
jcharArray
</td>
<td headers="h2403">
jchar
</td>
</tr>
<tr>
<td headers="h2401">
<code class=
"cCode">SetShortArrayRegion()</code>
</td>
<td headers="h2402">
jshortArray
</td>
<td headers="h2403">
jshort
</td>
</tr>
<tr>
<td headers="h2401">
<code class=
"cCode">SetIntArrayRegion()</code>
</td>
<td headers="h2402">
jintArray
</td>
<td headers="h2403">
jint
</td>
</tr>
<tr>
<td headers="h2401">
<code class=
"cCode">SetLongArrayRegion()</code>
</td>
<td headers="h2402">
jlongArray
</td>
<td headers="h2403">
jlong
</td>
</tr>
<tr>
<td headers="h2401">
<code class=
"cCode">SetFloatArrayRegion()</code>
</td>
<td headers="h2402">
jfloatArray
</td>
<td headers="h2403">
jfloat
</td>
</tr>
<tr>
<td headers="h2401">
<code class=
"cCode">SetDoubleArrayRegion()</code>
</td>
<td headers="h2402">
jdoubleArray
</td>
<td headers="h2403">
jdouble
</td>
</tr>
</tbody>
</table>

<h4>LINKAGE:</h4>
<p>Indices in the JNIEnv interface function table.</p>

<table border="1" summary=
"Set&lt;PrimitiveType&gt;ArrayRegion Family of Array Accessor Routines"<caption>Set&lt;PrimitiveType&gt;ArrayRegion Family of Array Accessor Routines</caption>
<thead>
<tr>
<th id="h2501">

Set&lt;PrimitiveType&gt;ArrayRegion Routine
</th>
<th id="h2502">
Index
</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h2501">
<code class=
"cCode">SetBooleanArrayRegion()</code>
</td>
<td headers="h2502">
207
</td>
</tr>
<tr>
<td headers="h2501">
<code class=
"cCode">SetByteArrayRegion()</code>
</td>
<td headers="h2502">
208
</td>
</tr>
<tr>
<td headers="h2501">
<code class=
"cCode">SetCharArrayRegion()</code>
</td>
<td headers="h2502">
209
</td>
</tr>
<tr>
<td headers="h2501">
<code class=
"cCode">SetShortArrayRegion()</code>
</td>
<td headers="h2502">
210
</td>
</tr>
<tr>
<td headers="h2501">
<code class=
"cCode">SetIntArrayRegion()</code>
</td>
<td headers="h2502">
211
</td>
</tr>
<tr>
<td headers="h2501">
<code class=
"cCode">SetLongArrayRegion()</code>
</td>
<td headers="h2502">
212
</td>
</tr>
<tr>
<td headers="h2501">
<code class=
"cCode">SetFloatArrayRegion()</code>
</td>
<td headers="h2502">
213
</td>
</tr>
<tr>
<td headers="h2501">
<code class=
"cCode">SetDoubleArrayRegion()</code>
</td>
<td headers="h2502">
214
</td>
</tr>
</tbody>
</table>
<p>PARAMETERS:</p>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>array</code>: a Java
array.</p>

<p><code>start</code>: the starting
index.</p>
<p><code>len</code>: the number of
elements to be copied.</p>

<p><code>buf</code>: the source
buffer.</p>

<h4>THROWS:</h4>

<p><code class=
"cCode">ArrayIndexOutOfBoundsException</code>: if one of the
indexes in the region is not valid.</p>

<table width="80%" border="1" cellpadding="5"
cellspacing="0" summary="">
<tbody>
<tr>
<td headers="h2601" bgcolor="#FFFFCC">

<p><strong>Note</strong>: As of JDK/JRE 1.1, programmers can use
<code>Get/Release&lt;primitivetype&gt;ArrayElements</code>
functions to obtain a pointer to primitive array elements. If the
VM supports pinning, the pointer to the original data is returned;
otherwise, a copy is made.</p>
<p>New functions introduced as of JDK/JRE 1.3 allow native code to
obtain a direct pointer to array elements even if the VM does not
support pinning.</p>
</td>
</tr>
</tbody>
</table>
<h3><a name="GetPrimitiveArrayCritical_ReleasePrimitiveArrayCritical">GetPrimitiveArrayCritical, ReleasePrimitiveArrayCritical</a></h3>
<p><code>void * GetPrimitiveArrayCritical(JNIEnv *env, jarray
array, jboolean *isCopy);<br />
<a name="ReleasePrimitiveArrayCritical" id=
"ReleasePrimitiveArrayCritical"></a> void
ReleasePrimitiveArrayCritical(JNIEnv *env, jarray array, void
*carray, jint mode);</code></p>
<p>The semantics of these two functions are very similar to the
existing <code>Get/Release&lt;primitivetype&gt;ArrayElements</code>
functions. If possible, the VM returns a pointer to the primitive
array; otherwise, a copy is made. <strong>However, there are
significant restrictions on how these functions can be
used.</strong></p>
<p>After calling <code>GetPrimitiveArrayCritical</code>, the native
code should not run for an extended period of time before it calls
<code>ReleasePrimitiveArrayCritical</code>. We must treat the code
inside this pair of functions as running in a "critical region."
Inside a critical region, native code must not call other JNI
functions, or any system call that may cause the current thread to
block and wait for another Java thread. (For example, the current
thread must not call <code>read</code> on a stream being written by
another Java thread.)</p>
<p><strong>These restrictions make it more likely that the native
code will obtain an uncopied version of the array, even if the VM
does not support pinning.</strong> For example, a VM may
temporarily disable garbage collection when the native code is
holding a pointer to an array obtained via
<code>GetPrimitiveArrayCritical</code>.</p>
<p>Multiple pairs of <code>GetPrimtiveArrayCritical</code> and
<code>ReleasePrimitiveArrayCritical</code> may be nested. For
example:</p>
<pre class="codeblock">
  jint len = (*env)-&gt;GetArrayLength(env, arr1);
  jbyte *a1 = (*env)-&gt;GetPrimitiveArrayCritical(env, arr1, 0);
  jbyte *a2 = (*env)-&gt;GetPrimitiveArrayCritical(env, arr2, 0);
  /* We need to check in case the VM tried to make a copy. */
  if (a1 == NULL || a2 == NULL) {
    ... /* out of memory exception thrown */
  }
  memcpy(a1, a2, len);
  (*env)-&gt;ReleasePrimitiveArrayCritical(env, arr2, a2, 0);
  (*env)-&gt;ReleasePrimitiveArrayCritical(env, arr1, a1, 0);
</pre>
<p>Note that <code>GetPrimitiveArrayCritical</code> might still
make a copy of the array if the VM internally represents arrays in
a different format. Therefore we need to check its return value
against <code>NULL</code> for possible out of memory situations.
<a name="stringops"></a></p>
<h4>LINKAGE (GetPrimitiveArrayCritical):</h4>
<p>Linkage Index 222 in the JNIEnv interface
function table.</p>
<h4>LINKAGE (ReleasePrimitiveArrayCritical):</h4>
<p>Linkage Index 223 in the JNIEnv interface
function table.</p>
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<!-- ******************************************************** -->
<h2><a name="registering_native_methods">Registering Native Methods</a></h2>

<h3><a name="RegisterNatives">RegisterNatives</a></h3>

<p><code>jint RegisterNatives(JNIEnv
*env, jclass clazz,<br />
const JNINativeMethod *methods, jint nMethods);</code></p>

<p>Registers native methods with the class specified
by the <code>clazz</code> argument. The <code class=
"cCode">methods</code> parameter specifies an array of <code class=
"cCode">JNINativeMethod</code> structures that contain the names,
signatures, and function pointers of the native methods. The
<code>name</code> and <code class=
"cCode">signature</code> fields of the JNINativeMethod structure
are pointers to modified UTF-8 strings. The <code class=
"cCode">nMethods</code> parameter specifies the number of native
methods in the array. The <code class=
"cCode">JNINativeMethod</code> structure is defined as follows:</p>

<pre class="codeblock">
typedef struct {

    char *name;

    char *signature;

    void *fnPtr;

} JNINativeMethod;

</pre>

<p>The function pointers nominally must have the
following signature:</p>

<pre class="codeblock">
<code class=
"cCode">ReturnType (*fnPtr)(JNIEnv *env, jobject objectOrClass, ...);</code>

</pre>

<h4>LINKAGE:</h4>
<p>Index 215 in the JNIEnv interface function
table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>

<p><code>methods</code>: the native
methods in the class.</p>

<p><code>nMethods</code>: the number of
native methods in the class.</p>

<h4>RETURNS:</h4>

<p>Returns &#8220;0&#8221; on success; returns a
negative value on failure.</p>

<h4>THROWS:</h4>

<p><code>NoSuchMethodError</code>: if a
specified method cannot be found or if the method is not
native.</p>

<h3><a name="UnregisterNatives">UnregisterNatives</a></h3>

<p><code>jint UnregisterNatives(JNIEnv
*env, jclass clazz);</code></p>

<p>Unregisters native methods of a class. The class
goes back to the state before it was linked or registered with its
native method functions.</p>

<p>This function should not be used in normal native
code. Instead, it provides special programs a way to reload and
relink native libraries.</p>

<h4>LINKAGE:</h4>
Index 216 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>clazz</code>: a Java class
object.</p>

<h4>RETURNS:</h4>

<p>Returns &#8220;0&#8221; on success; returns a
negative value on failure.</p>

<!-- ******************************************************** -->
<h2><a name="monitor_operations">Monitor Operations</a></h2>

<h3><a name="MonitorEnter">MonitorEnter</a></h3>

<p><code>jint MonitorEnter(JNIEnv *env,
jobject obj);</code></p>

<p>Enters the monitor associated with the underlying
Java object referred to by <code>obj</code>.</p>
Enters the monitor associated with the object referred to by obj.
The <code>obj</code> reference must not be <code>NULL</code>.
<p>Each Java object has a monitor associated with it.
If the current thread already owns the monitor associated with
<code>obj</code>, it increments a counter in the
monitor indicating the number of times this thread has entered the
monitor. If the monitor associated with <code class=
"cCode">obj</code> is not owned by any thread, the current thread
becomes the owner of the monitor, setting the entry count of this
monitor to 1. If another thread already owns the monitor associated
with <code>obj</code>, the current thread waits until
the monitor is released, then tries again to gain ownership.</p>
<p>A monitor entered through a <code>MonitorEnter</code> JNI
function call cannot be exited using the <code>monitorexit</code>
Java virtual machine instruction or a synchronized method return. A
<code>MonitorEnter</code> JNI function call and a
<code>monitorenter</code> Java virtual machine instruction may race
to enter the monitor associated with the same object.</p>
<p>To avoid deadlocks, a monitor entered through a
<code>MonitorEnter</code> JNI function call must be exited using
the <code>MonitorExit</code> JNI call, unless the
<code>DetachCurrentThread</code> call is used to implicitly release
JNI monitors.</p>

<h4>LINKAGE:</h4>
Index 217 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>obj</code>: a normal Java
object or class object.</p>

<h4>RETURNS:</h4>

<p>Returns &#8220;0&#8221; on success; returns a
negative value on failure.</p>

<h3><a name="MonitorExit">MonitorExit</a></h3>

<p><code>jint MonitorExit(JNIEnv *env,
jobject obj);</code></p>

<p>The current thread must be the owner of the
monitor associated with the underlying Java object referred to by
<code>obj</code>. The thread decrements the counter
indicating the number of times it has entered this monitor. If the
value of the counter becomes zero, the current thread releases the
monitor.</p>
<p>Native code must not use <code>MonitorExit</code> to exit a
monitor entered through a synchronized method or a
<code>monitorenter</code> Java virtual machine instruction.</p>

<h4>LINKAGE:</h4>
Index 218 in the JNIEnv interface function table.
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>obj</code>: a normal Java
object or class object.</p>

<h4>RETURNS:</h4>

<p>Returns &#8220;0&#8221; on success; returns a
negative value on failure.</p>

<h4>EXCEPTIONS:</h4>

<p><code>IllegalMonitorStateException</code>: if the
current thread does not own the monitor.</p>

<!-- ******************************************************** -->
<h2><a name="nio_support">NIO Support</a></h2>
<p>The NIO-related entry points allow native code to access
<code>java.nio</code> <em>direct buffers</em>. The contents of a
direct buffer can, potentially, reside in native memory outside of
the ordinary garbage-collected heap. For information about direct
buffers, please see <a href="../../io/index.html">New I/O APIs</a>
and the specification of the <a href=
"../../../../api/java/nio/ByteBuffer.html"><tt>java.nio.ByteBuffer</tt></a>
class.</p>
Three new functions introduced in JDK/JRE 1.4 allow JNI code to
create, examine, and manipulate direct buffers:
<ul>
<li><a href=
"#NewDirectByteBuffer"><code>NewDirectByteBuffer</code></a></li>
<li><a href=
"#GetDirectBufferAddress"><code>GetDirectBufferAddress</code></a></li>
<li><a href=
"#GetDirectBufferCapacity"><code>GetDirectBufferCapacity</code></a></li>
</ul>
<p>Every implementation of the Java virtual machine must support
these functions, but not every implementation is required to
support JNI access to direct buffers. If a JVM does not support
such access then the <tt>NewDirectByteBuffer</tt> and
<tt>GetDirectBufferAddress</tt> functions must always return
<tt>NULL</tt>, and the <tt>GetDirectBufferCapacity</tt> function
must always return <tt>-1</tt>. If a JVM <em>does</em> support such
access then these three functions must be implemented to return the
appropriate values.</p>

<h3><a name="NewDirectByteBuffer">NewDirectByteBuffer</a></h3>

<p><tt>jobject NewDirectByteBuffer(JNIEnv* env, void* address,
jlong capacity);</tt></p>
<p>Allocates and returns a direct <tt>java.nio.ByteBuffer</tt>
referring to the block of memory starting at the memory address
<tt>address</tt> and extending <tt>capacity</tt> bytes.</p>
<p>Native code that calls this function and returns the resulting
byte-buffer object to Java-level code should ensure that the buffer
refers to a valid region of memory that is accessible for reading
and, if appropriate, writing. An attempt to access an invalid
memory location from Java code will either return an arbitrary
value, have no visible effect, or cause an unspecified exception to
be thrown.</p>
<h4>LINKAGE:</h4>
<p>Index 229 in the JNIEnv interface function
table.</p>
<h4>PARAMETERS:</h4>
<p><tt>env</tt>: the <tt>JNIEnv</tt> interface pointer</p>
<p><tt>address</tt>: the starting address of the memory region
(must not be <tt>NULL</tt>)</p>
<p><tt>capacity</tt>: the size in bytes of the memory region (must
be positive)</p>
<h4>RETURNS:</h4>
<p>Returns a local reference to the newly-instantiated
<tt>java.nio.ByteBuffer</tt> object. Returns <tt>NULL</tt> if an
exception occurs, or if JNI access to direct buffers is not
supported by this virtual machine.</p>
<h4>EXCEPTIONS:</h4>
<p><tt>OutOfMemoryError</tt>: if allocation of the
<tt>ByteBuffer</tt> object fails</p>
<h4>SINCE:</h4>
<p>JDK/JRE 1.4</p>

<h3><a name="GetDirectBufferAddress">GetDirectBufferAddress</a></h3>
<p><tt>void* GetDirectBufferAddress(JNIEnv* env, jobject
buf);</tt></p>


<p>Fetches and returns the starting address of the memory region
referenced by the given direct <tt>java.nio.Buffer</tt>.</p>
<p>This function allows native code to access the same memory
region that is accessible to Java code via the buffer object.</p>
<h4>LINKAGE:</h4>
<p>Index 230 in the JNIEnv interface function table.</p>


<h4>PARAMETERS:</h4>


<p><tt>env</tt>: the <tt>JNIEnv</tt> interface pointer</p>
<p><tt>buf</tt>: a direct <tt>java.nio.Buffer</tt> object (must not
be <tt>NULL</tt>)</p>


<h4>RETURNS:</h4>


<p>Returns the starting address of the memory region referenced by
the buffer. Returns <tt>NULL</tt> if the memory region is
undefined, if the given object is not a direct
<tt>java.nio.Buffer</tt>, or if JNI access to direct buffers is not
supported by this virtual machine.</p>
<h4>SINCE:</h4>
<p>JDK/JRE 1.4</p>

<h3><a name="GetDirectBufferCapacity">GetDirectBufferCapacity</a></h3>
<p><tt>jlong GetDirectBufferCapacity(JNIEnv* env, jobject
buf);</tt></p>
<p>Fetches and returns the capacity of the memory region referenced
by the given direct <tt>java.nio.Buffer</tt>. The capacity is the
number of <i>elements</i> that the memory region contains.</p>
<h4>LINKAGE:</h4>
<p>Index 231 in the JNIEnv interface function
table.</p>


<h4>PARAMETERS:</h4>


<p><tt>env</tt>: the <tt>JNIEnv</tt> interface pointer</p>
<p><tt>buf</tt>: a direct <tt>java.nio.Buffer</tt> object (must not
be <tt>NULL</tt>)</p>


<h4>RETURNS:</h4>


<p>Returns the capacity of the memory region associated with the
buffer. Returns <tt>-1</tt> if the given object is not a direct
<tt>java.nio.Buffer</tt>, if the object is an unaligned view buffer
and the processor architecture does not support unaligned access,
or if JNI access to direct buffers is not supported by this virtual
machine.</p>
<h4>SINCE:</h4>
<p>JDK/JRE 1.4</p>
<!-- ******************************************************** -->
<h2><a name="reflection_support">Reflection Support</a></h2>
<p>Programmers can use the JNI to call Java methods or access Java
fields if they know the name and type of the methods or fields. The
Java Core Reflection API allows programmers to introspect Java
classes at runtime. JNI provides a set of conversion functions
between field and method IDs used in the JNI to field and method
objects used in the Java Core Reflection API.</p>

<h3><a name="FromReflectedMethod">FromReflectedMethod</a></h3>
<p><code>jmethodID FromReflectedMethod(JNIEnv *env, jobject
method);</code></p>
<p>Converts a <code>java.lang.reflect.Method</code> or
<code>java.lang.reflect.Constructor</code> object to a method
ID.</p>
<h4>LINKAGE:</h4>
<p>Index 7 in the JNIEnv interface function
table.</p>
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<h3><a name="FromReflectedField">FromReflectedField</a></h3>
<p><code>jfieldID FromReflectedField(JNIEnv *env, jobject
field);</code></p>
<p>Converts a <code>java.lang.reflect.Field</code> to a field
ID.</p>
<h4>LINKAGE:</h4>
<p>Index 8 in the JNIEnv interface function table.</p>
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<h3><a name="ToReflectedMethod">ToReflectedMethod</a></h3>
<p><code>jobject ToReflectedMethod(JNIEnv *env, jclass cls,<br />
&nbsp;&nbsp; jmethodID methodID, jboolean isStatic);</code></p>
<p>Converts a method ID derived from <code>cls</code> to a
<code>java.lang.reflect.Method</code> or
<code>java.lang.reflect.Constructor</code> object.
<code>isStatic</code> must be set to <code class=
"cCode">JNI_TRUE</code> if the method ID refers to a static field,
and <code>JNI_FALSE</code> otherwise.</p>
<p>Throws <code>OutOfMemoryError</code> and returns 0 if fails.</p>
<h4>LINKAGE:</h4>
<p>Index 9 in the JNIEnv interface function
table.</p>
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<h3><a name="ToReflectedField">ToReflectedField</a></h3>
<p><code>jobject ToReflectedField(JNIEnv *env, jclass cls,<br />
&nbsp;&nbsp; jfieldID fieldID, jboolean isStatic);</code></p>
<p>Converts a field ID derived from <code>cls</code> to a
<code>java.lang.reflect.Field</code> object. <code>isStatic</code>
must be set to <code>JNI_TRUE</code> if
<code>fieldID</code> refers to a static field, and <code class=
"cCode">JNI_FALSE</code> otherwise.</p>
<p>Throws <code>OutOfMemoryError</code> and returns 0 if fails.</p>
<h4>LINKAGE:</h4>
<p>Index 12 in the JNIEnv interface function
table.</p>
<h4>SINCE:</h4>
<p>JDK/JRE 1.2</p>
<a name="invo"></a>
<!-- ******************************************************** -->
<h2><a name="java_vm_interface">Java VM Interface</a></h2>

<h3><a name="GetJavaVM">GetJavaVM</a></h3>

<p><code>jint GetJavaVM(JNIEnv *env,
JavaVM **vm);</code></p>

<p>Returns the Java VM interface (used in the
Invocation API) associated with the current thread. The result is
placed at the location pointed to by the second argument,
<code>vm</code>.</p>

<h4>LINKAGE:</h4>
<p>Index 219 in the JNIEnv interface function
table.</p>
<h4>PARAMETERS:</h4>

<p><code>env</code>: the JNI interface
pointer.</p>

<p><code>vm</code>: a pointer to where
the result should be placed.</p>

<h4>RETURNS:</h4>

<p>Returns &#8220;0&#8221; on success; returns a
negative value on failure.</p>

<table width="100%" summary="">
<tbody>
<tr>
<td><a accesskey="c" href=
"../../jni/spec/jniTOC.html">Contents</a> | <a accesskey="p" href=
"../../jni/spec/types.html">Previous</a> | <a accesskey="n" href=
"../../jni/spec/invocation.html">Next</a></td>
<td></td>
</tr>
</tbody>
</table>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
