<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>Pack200: Packed Class Archive Specification</title>
<link rel="stylesheet" type="text/css" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>Pack200: A Packed Class Deployment Format For Java
Applications</h1>
<h2>Contents</h2>
<div class="a1"><a href="#tocIntrod" class="skiplink">Skip Navigation Links</a></div>
<!-- &TOC; -->
<ul>
<li><a href="#tocIntrod">1. Introduction</a></li>
<li><a href="#tocArcInp">2. Archive Inputs</a></li>
<li><a href="#tocArFiStSu">3. Archive File Structure
Summary</a></li>
<li><a href="#tocInInEn">4. Introduction to Integer
Encodings</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocInEnSc">4.1. Integer Encoding Schema</a></li>
</ul>
</li>
<li><a href="#tocBanDef">5. Band Definitions</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocArcSeg">5.1. Archive Segmentation</a></li>
<li><a href="#tocArcHea">5.2. Archive Header</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocArOpFiPr">5.2.1. Archive Options and File
Properties</a></li>
<li><a href="#tocArEnCoClFo">5.2.2. Archive Entity Counts and Class
Format</a></li>
</ul>
</li>
<li><a href="#tocConPoo">5.3. Constant Pools</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocScaCon">5.3.1. Scalar Constants</a></li>
<li><a href="#tocUtfCon">5.3.2. Utf8 Constants</a></li>
<li><a href="#tocTypSig">5.3.3. Type Signatures</a></li>
<li><a href="#tocTupCon">5.3.4. Tuple Constants</a></li>
<li><a href="#tocExtCon">5.3.5. Extra Constants</a></li>
</ul>
</li>
<li><a href="#tocFilAtt">5.4. File Attributes</a></li>
<li><a href="#tocFlaAtt">5.5. Flags and Attributes</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocAsFlBiAt">5.5.1. Assignment of Flag Bits to
Attributes</a></li>
<li><a href="#tocAtLaDe">5.5.2. Attribute Layout
Definitions</a></li>
<li><a href="#tocRecLay">5.5.3. Recursive Layouts</a></li>
<li><a href="#tocDeAtLa">5.5.4. Default Attribute Layouts</a></li>
<li><a href="#tocStMaLa">5.5.5. Stack Map Layouts</a></li>
<li><a href="#tocMetLay">5.5.6. Metadata Layouts</a></li>
<li><a href="#tocUnLaUs">5.5.7. Unusual Layout Usages</a></li>
</ul>
</li>
<li><a href="#tocSoFiAb">5.6. Source File Abbreviation</a></li>
<li><a href="#tocNesCla">5.7. Nested Classes</a></li>
<li><a href="#tocClaSch">5.8. Class Schema</a></li>
<li><a href="#tocAttBan">5.9. Attribute Bands</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocMetTra">5.9.1. Metadata Transmission</a></li>
</ul>
</li>
<li><a href="#tocBytIns">5.10. Bytecode Instructions</a></li>
</ul>
</li>
<li><a href="#tocSpBaCo">6. Specification of Band Coding</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocEnSmWhNu">6.1. Encoding of Small Whole
Numbers</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocScMuCo">6.1.1. Scheme of Multiple Codings</a></li>
<li><a href="#tocDeEnBySe">6.1.2. Definition of Encoding Byte
Sequences</a></li>
<li><a href="#tocDeDeWhNuVa">6.1.3. Definition of Decoded Whole
Number Values</a></li>
</ul>
</li>
<li><a href="#tocEnSiIn">6.2. Encoding of Signed Integers</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocFuDiSiCo">6.2.1. Further Discussion of Sign
Conversion</a></li>
</ul>
</li>
<li><a href="#tocAttCod">6.3. Attributes of Codings</a></li>
<li><a href="#tocEnCoSe">6.4. Encoding of Correlated
Sequences</a></li>
<li><a href="#tocEnUnVa">6.5. Encodings of Uncorrelated
Values</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocTabFav">6.5.1. Table of Favorites</a></li>
<li><a href="#tocSeqTok">6.5.2. Sequence of Tokens</a></li>
<li><a href="#tocSeUnVa">6.5.3. Sequence of Unfavored
Values</a></li>
</ul>
</li>
<li><a href="#tocAdaEnc">6.6. Adaptive Encodings</a></li>
<li><a href="#tocMetCod">6.7. Meta-Coding</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocCoSpSt">6.7.1. Coding Specifier Structure</a></li>
<li><a href="#tocCoSpSe">6.7.2. Coding Specifier Semantics</a></li>
<li><a href="#tocCoSpMeEn">6.7.3. Coding Specifier
Meta-Encoding</a></li>
<li><a href="#tocCanCod">6.7.4. Canonical BHSD Codings</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#tocStDeOu">7. Stability of Decompressor
Output</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocOrAtLi">7.1. Ordering of Attribute Lists</a></li>
<li><a href="#tocOrCoPo">7.2. Ordering of Constant Pools</a></li>
</ul>
</li>
<li><a href="#tocAppend">8. Appendixes</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocApLiBa">8.1. Appendix: List of Bands</a></li>
<li><a href="#tocApPsCoIl">8.2. Appendix: Pseudo-Code
Illustrations</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocReUtCoPo">8.2.1. Representation of
<tt>cp_Utf8</tt> Constant Pool</a></li>
<li><a href="#tocReSiCoPo">8.2.2. Representation of
<tt>cp_Signature</tt> Constant Pool</a></li>
<li><a href="#tocReByOf">8.2.3. Representation of Byte
Offsets</a></li>
<li><a href="#tocRePrNeClNa">8.2.4. Representation of Predictable
Nested Class Names</a></li>
</ul>
</li>
<li><a href="#tocAppDes">8.3. Appendix: Design FAQ</a></li>
<li style="list-style: none; display: inline">
<ul>
<li><a href="#tocGenQue">8.3.1. General Questions</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!--
-->
<h2>Revision History</h2>
<h3>Changes made to support JSR-308 Mar-2013</h3>
<ul>
<li>Added RuntimeVisibleTypeAnnotation and RuntimeInvisibleTypeAnnotation.</li>
</ul>
<h3>Changes made to support JSR-335 Feb-2013</h3>
<ul>
<li>Added two new pseudo-instructions "invokespecial_int" and
"invokestatic_int" referencing cp_Imethod operands.</li>
</ul>
<h3>MethodParameters Flag changed Feb-2013</h3>
<ul>
<li>Changed flag from u4 to u2</li>
</ul>
<h3>Changes made to support MethodParameters Dec-2012</h3>
<ul>
<li>Increment the version number from 170.0 to 171.0</li> 
<li>Added attribute structure</li> 
</ul>
<h3>Changes made for JSR 292 support Aug-2011</h3>
<ul>
<li>Bump the pack200 file format version number from 160.* to
170.0</li>
<li>Add optional cp_extra_counts to the archive header.</li>
<li>Add 4 extra constant pools: cp_MethodHandle, cp_MethodType,
cp_BootstrapMethod, cp_InvokeDynamic.</li>
<li>Defined the combined constant pool cp_AnyMember, comprising
cp_{Field,Method,Imethod}.</li>
<li>Defined the combined constant pool cp_LoadableValue, comprising
valid ldc operands.</li>
<li>Add new attribute layout codes for new constants: KM, KT, RY,
RB.</li>
<li>Add combined layout codes KL (any ldc-able value) and RN
(AnyMember), supplementing RQ.</li>
<li>Change the pseudo-instruction name "aldc" to "sldc", and add
"qldc".</li>
</ul>
<h3>Changes made for MR #1 01-Jun-2005</h3>
<ul>
<li>Adjust StackMapTable based on JSR-202 changes.</li>
<li>Bump the pack200 file format version number from 160.0 to
160.1</li>
<li>Clarify inconsistent tie-breaker rule in centrality
comparisons.</li>
</ul>
<h3>Changes made for MR #1 20-Apr-2005</h3>
<ul>
<li>Reinstate StackMap as StackMapTable JSR-202.</li>
</ul>
<!-- BEGIN CODE FOLD ==
<h3>Changes made for PFD #4</h3>
<ul>
 <li>Clarify primary vs. secondary band encodings.
 <li>Clarify uniqueness of the empty string in cp_String.
 <li>Fix some typos and minor errors in explanatory text.
 <li>Remove "dot notation" for class file parts.
 <li>Rename ClassFile_version to file_version.
 <li>Explain rationale for 'SB' layout.
 <li>Add examples of 'P', 'PO', and 'O' layout element encoding.  (JK)
 <li>Add priority list for layout element codings.  (JK)
 <li>Clarify priority of SIGNED5 for 'SB' layouts.
 <li>Add FAQ about JEFF.
 <li>Incorporate corrections and comments from EG
 (Joel Kamentz 7/27,28).
</ul>
<h3>Changes made for PFD #3</h3>
<ul>
 <li>Add LocalVariableTypeTable, same layout as LocalVariableTable.
 <li>Bump package version number to 150.7 from 150.6.
 <li>Clarify explanatory text where it conflicts with recent metadata changes.
 <li>Comment out "Note To Reviewers".
</ul>
<h3>Changes made for PFD #2</h3>
<ul>
 <li>Change all metadata references to classes from RCH or RUH to RSH.
 <li>Bump package version number to 150.6 from 150.5.
</ul>
<h3>Changes made on Mar 25 post public review</h3>
<ul>
 <li>Minor corrections from Public Review feedback.
 <li>Moved pseudo-code to the Appendix.
</ul>
<h3>Changes made before public review 3Q2003</h3>
<ul>
 <li>Bump package version number to 150.5 from 150.4.
 <li>Simplify size limit for constant pools.
 <li>Compress SourceFile ad hoc: ClassName.java transmits as zero.
 <li>Make empty string implicitly defined in cp_Utf8.
 <li>Make some header fields optional (cuts header size).
 <li>Add an optional flag bits word for attributes (for future-proofing).
 <li>Change band name "class_flags" to "class_flags_lo", etc.
 <li>Require that optional #archive_size be exact when present.
 <li>Adjust indexes (hence band order) of predefined attributes.
 <li>Allow 'O' layouts to have signed variants (e.g., 'OSH').
 <li>Clarify transmission of NaN values in constant pool.
 <li>Correct coding of cp_Descr_name/type.
 <li>Correct format of EnclosingMethod.
 <li>Make "call" layouts self-relative.
 <li>Remove StackMap bands, for now.
 <li>Remove generic attributes.  (Not proven to be profitable.)
 <li>Split predefined metadata attributes into (9) separate band groups.
 </ul>

<h3>Changes in draft of September 5-6, 2003</h3>
<ul>
 <li>Bump package version number to 150.4 from 150.1.
 <li>Simplify and generalize IC name demangling rules.
 <li>Provide for IC punctuation besides '$' (Tiger sometimes uses '#').
 <li>Allow customized local InnerClasses attributes (ic_local_bands).
 <li>Do not let predefined attributes conflict with flags.  (It's simpler.)
 <li>Simplify handling of recursive calls; add "class_attr_calls", etc.
 <li>Allow union cases in layouts to have several tags (1,2,3)[...].
 <li>Allow "generic" attribute layouts with a variable name (for metadata).
 <li>Clarify 'pop' coding, that unused F elements are illegal.
 <li>Rewrite CP ordering rules for decompressor, for better clarity.
 </ul>

<h3>Changes in draft of July 30, 2003</h3>
<ul>
 <li>Retitle.
 <li>Incorporate corrections and comments from EG
 (Joel Kamentz 7/21, Bill Pugh 7/09).
 <li>Add optional #archive_size and #archive_next_count header
fields.
 <li>Add CP element uniqueness requirement, to simplify output
determinism rules.
 <li>Extend attribute layout spec. language to include unions,
recursion, and 'V' elements.
 <li>Add placeholders for StackMap and metadata attributes.
 <li>Add output determinism rules for synthesized constants
(e.g., implicit IC names), and specify ordering in the CP.
 <li>Simplify discussion of code headers.
 <li>Rename class_ClassFile_version_H1/H2 to
class_ClassFile_version_minor/major_H
 <li>Add band-length pseudocode for code_flags and code_attr_count.
 <li>Adjust and correct table of multi-byte instructions.
 <li>Add implementation note on centrality comparison.
 <li>Add constraint against zero-length runs in meta-coding.
 <li>Adjust X/XB encoding to take a maximum of two bytes.
 <li>Add constraints against crazy 'arb' meta-codings.
 <li>Add predefined bands for Signature attributes.
 <li>Remove some old inline questions to early reviewers.
 <li>Remove some web lint and various typos.
 </ul>
<h3>Changes in draft of July 11, 2003</h3>
<ul>
 <li>Incorporate corrections and comments from EG
 (Joel Kamentz 6/23 and 7/01, Bill Pugh 7/09).
 <li>Integrate resource and class files, so we can
 transmit a total ordering of JAR elements.
 <li>Move file-related bands to the end of the archive.
 <li>Add archive segmentation feature (cat x.pack y.pack > xy.pack).
 <li>Add band lengths comments to the grammar.
 <li>Ensure that all codings with Card>=2^32 have full 32-bit ranges,
for all S in [0..2].
 <li>Clarify 'pop' coding method; remove useless and hazy defaulting rule.
 <li>Add a band summary appendix.
 <li>Give flag bit 12 to Signature, not the less-frequent Deprecated.
 <li>Change band name "resource" to "file" everywhere.
 <li>Change band name "class_attr_layout" to "class_attr_indexes", etc.
 <li>Change "compression_hint" to "deflate_hint".
 <li>Bump package version number to 150.1 (following Tiger numbering).
 <li>Add "no overflow" restriction to sum of all CP sizes.
 <li>Clarify flexibility of cp_Signature constants (for GJC support).
 <li>Clarify context-specificity of attribute logic.
 <li>Clarify semantics of "release" and "redefinition" of attribute indexes.
 <li>Fix various typos observed by reviewers.
 </ul>
<h3>Changes in draft of June 20, 2003</h3>
<ul>
 <li>Incorporated corrections and comments from EG (Joel Kamentz 6/06/03).
 <li>Change "Archive" in title to more distinctive "Deployment".
 <li>Mark scalar terminals in band grammar with leading "#".
 <li>Mark band terminals in band grammar with leading "*".
 <li>Small terminology changes (e.g., s/file_flags/file_options/).
 <li>Add file_size_hi, for 64-bit-clean file sizes (!).
 <li>Add code_flags, for bit-encoding of Code attribute indicators.
 <li>Clarify interactions in the flag words between attribute
indicators and modifier bits.
 <li>Clarify the process for releasing a predefined attribute bit.
 <li>Adjust (reduce) assigned flag bits for predefined attributes.
 <li>Note coming changes regarding file ordering.
 <li>Define instruction boundaries used by renumber_bci.
 <li>Clarify numbering of untyped references (cp_All).
 <li>Clarify reconstruction of InnerClasses attributes.
 <li>Clarify encoding and meaning of code_header bytes.
 <li>Clarify encoding of BCIs in Code exception handlers.
 <li>Add mechanism for escaping arbitrary bytes and refs into code.
 <li>Add ('arb') for meta-coding arbitrary BHSD codes (EG suggestion).
 <li>Clarify meta-coding of 'pop' and 'run' methods.
 <li>Add section to define output stability (idempotence, for signable JARs).
 <li>Small tweaks to spelling, diction, grammar, style.
 <li>Adjusted meta-data format definitions to the JSR 175 format changes bug:5020908.
 </ul>

<!== END CODE FOLD -->
<hr />
<!-- &BODY; -->
<br />
<a name="tocIntrod" id="tocIntrod"></a>
<h2>1. Introduction</h2>
This document specifies an archive format called "Pack200". It is
optimized for applications written in the Java programming language. Such applications are
usually delivered as collections of classes, sometimes with
associated resource files.
<p>This format allows any number (from one to hundreds of
thousands) of Java classes to be encoded by a compressor,
transmitted compactly in a single block of bytes, and decoded by a
decompressor into equivalent Java class files. Because it can also
represent class resources and other "side files", it can serve as
an alternative to the JAR archive for some deployment tasks,
notably downloading Java applications.</p>
<p>The Pack200 format can decrease the size of a Java application
by a factor of seven to nine, compared with an equivalent JAR
containing uncompressed ("stored") class files. By contrast, using
the zip DEFLATE algorithm integral to JAR and ZIP archives gains a
factor of two. The undocumented "crunch" mechanism, used to deploy
JDK downloads in the past, gains a corresponding factor of five to
six. Note that all these figures assume and incorporate the effects
of a post-pass with DEFLATE or a similar off-the-shelf compression
algorithm. (See <a href="https://www.ietf.org/rfc/rfc1951.txt">DEFLATE Compressed Data Format Specification</a> for more information.)</p>
<p>The main motivation for this format is to decrease disk and
bandwidth requirements for Java application packaging,
transmission, and delivery. An earlier version has been used to
package the downloads for Java SE 1.4.1 and
1.4.2 (code names "Hopper" and "Mantis").</p>
<p>This format is not intended for fast loading into a virtual
machine, and does not attempt to improve start-up speed or memory
footprint in running Java applications. The heavy engineering
requirements on a directly loadable file format would make optimal
compression impossible. The decompressor of an aggressively
compressed file will have a complex job to do, and must be allowed
memory and CPU time to do this job. We assume that Pack200 archives
will be unpacked on the same classes of machine that run Java SE
and Java EE applications.</p>
<p>This format is batch-oriented, optimized for packaging and
transmission of Java classes. It does not support random access of
individually stored classes. In order to emphasize the sequential
nature of this archive format, we will use the verb
<em>transmit</em>, rather than <em>store</em>, to refer to the
formatting of data produced by a compressor and accepted by a
decompressor.</p>
<p>This format does not attempt to duplicate work performed by
DEFLATE or other byte-oriented compression algorithms. Typically,
tools using Pack200 will further compress archives by storing them
in ZIP files or using some other compression technique. The
presence of such a post-pass compressor is an assumption made by
the design of Pack200.</p>
<p>This specification is complex, and may seen to some readers
needlessly complex. The design decisions reflected here have been
motivated by extensive testing and experimentation with actual Java
class files found in real products. An attempt to remove complexity
from this specification is likely also to remove measurably
significant compression efficiency.</p>
<a name="tocArcInp" id="tocArcInp"></a>
<h2>2. Archive Inputs</h2>
A Pack200 archive, like a JAR file, carries images of class files
and other ("resource") files arranged in a hierarchical directory
structure.
<p>No special compression or transformation is performed on any
file other than class files, other than (possibly) reordering them
by file type. The post-pass compressor is assumed to provide
adequate compression on those spans of the archive which carry
images of non-class files.</p>
<p>Classes are represented in a form which suppresses their
individual constant pools, in favor of a large constant pool that
serves the entire archive. Thus, when a class file is extracted
from a Pack200 archive, a new constant pool will be created for it,
and all constant pool references adjusted. This does not change the
semantics of the class, but it will generally modify the bitwise
image of the file, and perhaps even its size, as unused constant
pool entries are deleted.</p>
<p>Note that every class file must be fully parsed by the
compressor, so that all constant pool indexes may be found and
(later) renumbered. This requirement applies to any class, field,
method, or code attribute which refers to the constant. The Pack200
format supports a moderate range of attributes. A modest variety of
new attribute layouts may be declared to the
compressor, and the Pack200 format provides a place to transmit
such layouts for use by decompressors. See the section <a href="#layouts">Attribute Layout Definitions</a> for more information.</p>
<a name="tocArFiStSu" id="tocArFiStSu"></a>
<h2>3. Archive File Structure Summary</h2>
The archive file consists of a short <em>archive header</em>,
followed by a number of independent file sections called
<em>bands</em>. (There are about 100 of them; this number can
vary.) Each band transmits an array of small integers, called the
<em>elements</em> of the band. After the archive header, the
archive consists only of bands.
<p>Logically, a band is an implicitly sized array of 32-bit
unsigned integers. However, it is rare for a band to physically
require more than one or two bytes per element, since element
encodings are chosen to transmit the actual band values more
compactly.</p>
<p>A band has no fixed header, not even an indication of its size.
The count of band elements is deduced by the decompressor from the
contents of previous bands, or (ultimately) from the archive
header.</p>
<p>The elements of any given band have a common meaning and role.
For example, the names of all transmitted classes are in a single
band, while all the class field counts are in a different band.
Each band is transmitted as a contiguous segment of bytes within
the archive. This contiguity is the main reason that a Pack200
archive, while compact to begin with, is very compressible by
utilities like zip.</p>
<p>In some bands, each element helps describe one object. For
example, each class is associated with a count of fields, which is
given in the archive as a corresponding value in the
<tt>class_field_count</tt> band. In other bands, one object may be
described by a <em>run</em> of zero or more elements in a band. For
example, the interfaces implemented by a class are given in the
archive as a corresponding run of zero or more values in the
<tt>class_interface</tt> band; each such value is an index
referring to a single class.</p>
<p>A very few bands (less than 10) contain non-homogeneous bytes,
such as the images of resource files. These few are called <em>byte
bands</em>. Many of the bands contain references into the constant
pool. Some contain access modifier flags and related bits. One
band, called the <em>char band</em>, contains string characters in
a specially chosen encoding called "CHAR3" (somewhat akin to UTF8,
but not identical). The rest of the bands transmit integers with a
variety of other interpretations.</p>
<p>One of the integer bands (cp_Utf8_big_chars) carries the
characters of a single CONSTANT_Utf8 string selected for special
treatment. Uniquely, this band is repeated zero or more times,
depending on how many strings are selected for this special
treatment. (These specially-transmitted "big strings" are explained in the section
<a href="#big_string">Utf8 Constants</a>.)</p>
<p>Most bands have an easily understood function, such as
transmitting the number of methods in a class, or the name of a
field, or the operand of a "getfield" bytecode instruction.</p>
<p>Except for the special case of byte bands, a band is never
considered as a sized span of bytes, but rather as a counted series
of elements which are encoded integers. Since integer encodings are
typically variable-sized (when regarded as byte sequences), there
is no firm rule for deriving a band's byte size from its element
count. Indeed, finding the end of a band requires that it be parsed
byte-by-byte.</p>
<a name="tocInInEn" id="tocInInEn"></a>
<h2>4. Introduction to Integer Encodings</h2>
Each band uses one or more coding tactics to encode its elements as
sequences of bytes. (The post-pass compressor is expected to turn
these bytes into bit sequences, but its actions are not specified
by this document.) The Pack200 compressor is free to choose and
vary encoding tactics used by a band. The encoding tactics used in
one band are independent of those used in other bands. The space of
supported encoding tactics is an important part of the Pack200
specification. The present section introduces these encodings,
which are defined in detail in the section <a href="#encodings">Specification of Band Coding</a>.
<p>As one might expect, byte bands (which encode bytewise data such
as the resource file images) encode their integers as unsigned
8-bit bytes. This encoding is named BYTE1 in this specification.
(Compare the type "u1" in the class file definition.)</p>
<p>Other bands have values with a much larger dynamic range,
including (in a few cases) negative numbers, and/or values all the
way up to the 32-bit unsigned maximum. Most of these encodings are
variable-length, in the expectation that the typical band element
will be relatively small in magnitude, even though some elements
may be large and require more bytes to represent. Some bands that
are expected to exhibit strong correlations in their element
sequences are encoded as successive differences (delta encoding)
rather than absolute numeric values.</p>
<p>Each band is associated with a <em>primary encoding</em> which
the compressor and decompressor agree to use when transmitting
elements of that band. For any band after the end of the segment
header, except for the byte bands, the compressor can optionally
specify a <em>secondary encoding</em> to use instead of the primary
encoding. In essence, the band's encoding defaults to the primary,
unless there is an explicitly declared secondary. This allows the
Pack200 format to adapt more closely to the actual statistics of
band elements.</p>
<p>For example, most bands, such as those holding counts and sizes,
have a primary encoding called UNSIGNED5. This is a general-purpose
unsigned encoding which represents values in the range [0..191] as
a single byte, and scales up to a maximum size of five bytes for
numbers larger than about fifty million. However, if a band
contains only numbers in the range [0,255], the BYTE1 encoding is
more compact, and the compressor is allowed to instruct the
decompressor to use this instead.</p>
<p>When the compressor specifies a secondary encoding, it must emit
an optional <em>band coding specifier</em>, which is described in the section
<a href="#band_coding">Meta-Coding</a>. A customized encoding method
often saves many bytes, if it matches more precisely the actual
dynamic range of the band's element values.</p>
<a name="tocInEnSc" id="tocInEnSc"></a>
<h3>4.1. Integer Encoding Schema</h3>
The Pack200 format is based on a schema of integer encoding
systems, parameterized by four numbers (B,H,S,D). From this
infinite set, about 10 selected encodings serve as primary
encodings for bands, and about 100 more serve as optional
encodings. The system of (B,H,S,D) encodings is explained at length
in the section <a href="#encodings">Specification of Band Coding</a>. For the present
purposes, a brief introduction will suffice.
<p>The parameter B (1&lt;=B&lt;=5) is the maximum length in bytes
of the encoding of a single integer. Less significant bits are
always encoded in earlier bytes.</p>
<p>The parameter H (1&lt;=H&lt;=256) is the radix of the encoding.
it also determines the conditions under which the encoding's byte
sequences terminate. The co-parameter L (0&lt;=L&lt;=255) is
defined as (256-H). Encoded byte sequences are allowed to contain
only one byte with a value less than L, and that byte must be the
last in the sequence. Thus, larger H values make for longer average
encoding lengths. If H is 256 and L is zero, then the encoding
method is fixed-length, because all encodings must be exactly B
bytes long.</p>
<p>The parameter S (0&lt;=S&lt;=2) determines whether and how the
encoding represents signed numbers. (More precisely, since band
elements are conventionally regarded as unsigned 32-bit integers, S
determines the coding of band elements larger than the largest
31-bit unsigned number, 2147483647. But we shall continue to refer
to such numbers as negative, where the distinction is irrelevant.)
S denotes the number of least-significant bits which serve as a
sign bit. If S is zero, the numbers are unsigned. If S is one, the
LSB of the unsigned number is exclusive-ored into the right-shifted
remainder of the unsigned number to produce a corresponding signed
number. If S is more than one, the signed number produced is
negative only if all S least-significant bits are set, and
otherwise these low bits contribute to the positive magnitude of
the integer. This representation is efficient for bands containing
mostly-positive numbers, such as bytecode branch offsets. The
interpretation of sign bits is more precisely described in the section <a href=
"#tocEnSiIn">Encoding of Signed Integers</a>.</p>
<p>The parameter D (0&lt;=D&lt;=1) determines whether the band
transmits its data via successive differences (i.e., delta
encoding). In writing these encodings, the parameters S and D may
be omitted if both are zero, and D may be omitted if zero.</p>
<p>Thus, the encoding (1,256,0,0), also written as (1,256),
represents numbers as unsigned bytes, while (4,256) represents
numbers as unsigned little-endian 32-bit integers. The encoding
(1,256,1) maps single bytes to numbers in the range [-128,127]. The
encoding (1,256,1,1) expresses any sequence of numbers whose
successive differences are in the range [-128,127] (and whose first
number is in that range).</p>
<p>The very common encoding UNSIGNED5 can represent the full
unsigned range of 32-bit integers. A byte sequence in this encoding
consists either of four bytes less than 192 followed by an
arbitrary byte, or else from zero to three bytes less than 192
followed by a byte greater than or equal to 192. The unsigned value
is formed by scaling each succeeding byte by successive powers of
the radix 64, and adding all the scaled byte values together.</p>
<table border="1" summary="integer encoding scheme">
<tr align="right">
<th id="integer_encoding_scheme_v">value</th>
<th id="integer_encoding_scheme_b0">byte 0</th>
<th id="integer_encoding_scheme_b1">byte 1</th>
<th id="integer_encoding_scheme_b2">byte 2</th>
<th id="integer_encoding_scheme_b3">byte 3</th>
<th id="integer_encoding_scheme_b4">byte 4</th>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">1</td>
<td headers="integer_encoding_scheme_b0">1</td>
<td headers="integer_encoding_scheme_b1">&nbsp;</td>
<td headers="integer_encoding_scheme_b2">&nbsp;</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">191</td>
<td headers="integer_encoding_scheme_b0">191</td>
<td headers="integer_encoding_scheme_b1">&nbsp;</td>
<td headers="integer_encoding_scheme_b2">&nbsp;</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">192</td>
<td headers="integer_encoding_scheme_b0">192</td>
<td headers="integer_encoding_scheme_b1">0</td>
<td headers="integer_encoding_scheme_b2">&nbsp;</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">193</td>
<td headers="integer_encoding_scheme_b0">193</td>
<td headers="integer_encoding_scheme_b1">0</td>
<td headers="integer_encoding_scheme_b2">&nbsp;</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">255</td>
<td headers="integer_encoding_scheme_b0">255</td>
<td headers="integer_encoding_scheme_b1">0</td>
<td headers="integer_encoding_scheme_b2">&nbsp;</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">256</td>
<td headers="integer_encoding_scheme_b0">192</td>
<td headers="integer_encoding_scheme_b1">1</td>
<td headers="integer_encoding_scheme_b2">&nbsp;</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">512</td>
<td headers="integer_encoding_scheme_b0">192</td>
<td headers="integer_encoding_scheme_b1">5</td>
<td headers="integer_encoding_scheme_b2">&nbsp;</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">1024</td>
<td headers="integer_encoding_scheme_b0">192</td>
<td headers="integer_encoding_scheme_b1">13</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_v">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">2048</td>
<td headers="integer_encoding_scheme_b0">192</td>
<td headers="integer_encoding_scheme_b1">29</td>
<td headers="integer_encoding_scheme_b2">&nbsp;</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">12479</td>
<td headers="integer_encoding_scheme_b0">255</td>
<td headers="integer_encoding_scheme_b1">191</td>
<td headers="integer_encoding_scheme_b2">&nbsp;</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">12480</td>
<td headers="integer_encoding_scheme_b0">192</td>
<td headers="integer_encoding_scheme_b1">192</td>
<td headers="integer_encoding_scheme_b2">0</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">798911</td>
<td headers="integer_encoding_scheme_b0">255</td>
<td headers="integer_encoding_scheme_b1">255</td>
<td headers="integer_encoding_scheme_b2">191</td>
<td headers="integer_encoding_scheme_b3">&nbsp;</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">798912</td>
<td headers="integer_encoding_scheme_b0">192</td>
<td headers="integer_encoding_scheme_b1">192</td>
<td headers="integer_encoding_scheme_b2">192</td>
<td headers="integer_encoding_scheme_b3">0</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">51130559</td>
<td headers="integer_encoding_scheme_b0">255</td>
<td headers="integer_encoding_scheme_b1">255</td>
<td headers="integer_encoding_scheme_b2">255</td>
<td headers="integer_encoding_scheme_b3">191</td>
<td headers="integer_encoding_scheme_b4">&nbsp;</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">51130560</td>
<td headers="integer_encoding_scheme_b0">192</td>
<td headers="integer_encoding_scheme_b1">192</td>
<td headers="integer_encoding_scheme_b2">192</td>
<td headers="integer_encoding_scheme_b3">192</td>
<td headers="integer_encoding_scheme_b4">0</td>
</tr>
<tr align="right">
<td headers="integer_encoding_scheme_v">0xFFFFFFFF</td>
<td headers="integer_encoding_scheme_b0">255</td>
<td headers="integer_encoding_scheme_b1">252</td>
<td headers="integer_encoding_scheme_b2">252</td>
<td headers="integer_encoding_scheme_b3">252</td>
<td headers="integer_encoding_scheme_b4">252</td>
</tr>
</table>
<p>Here is the set of primary encodings used by at least one
band:</p>
<table border="1" summary="set of primary encodings">
<tr>
<th id="set_of_primary_encodings_t">Type</th>
<th id="set_of_primary_encodings_n">Name</th>
<th id="set_of_primary_encodings_p">Purpose</th>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">(1,256)</td>
<td headers="set_of_primary_encodings_n">BYTE1</td>
<td headers="set_of_primary_encodings_p">bytes</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">(3,128)</td>
<td headers="set_of_primary_encodings_n">CHAR3</td>
<td headers="set_of_primary_encodings_p">Java characters</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">(5,4)</td>
<td headers="set_of_primary_encodings_n">BCI5</td>
<td headers="set_of_primary_encodings_p">bytecode positions</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">(5,4,2)</td>
<td headers="set_of_primary_encodings_n">BRANCH5</td>
<td headers="set_of_primary_encodings_p">bytecode branch
offsets</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">(5,64)</td>
<td headers="set_of_primary_encodings_n">UNSIGNED5</td>
<td headers="set_of_primary_encodings_p">general unsigned ints</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">(5,64,1)</td>
<td headers="set_of_primary_encodings_n">SIGNED5</td>
<td headers="set_of_primary_encodings_p">general signed ints</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">(5,64,0,1)</td>
<td headers="set_of_primary_encodings_n">UDELTA5</td>
<td headers="set_of_primary_encodings_p">monotonic sequences</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">(5,64,1,1)</td>
<td headers="set_of_primary_encodings_n">DELTA5</td>
<td headers="set_of_primary_encodings_p">autocorrelated
sequences</td>
</tr>
<tr>
<td headers="set_of_primary_encodings_t">(5,64,2,1)</td>
<td headers="set_of_primary_encodings_n">MDELTA5</td>
<td headers="set_of_primary_encodings_p">mostly monotonic
sequences</td>
</tr>
</table>
<a name="tocBanDef" id="tocBanDef"></a>
<h2>5. Band Definitions</h2>
The file as a whole consists of about 200 bands in four major
groups. After a header, the constant pool contents come first,
followed by most of the class schema, followed by a consolidation
of all attribute information (for classes, fields, methods, codes,
and the archive as a whole), and ending with bytecodes for all
methods.
<p>Rather than describe the bands in a long and dull sequence, we
use a simple, non-recursive grammar to present them in an organized
fashion. This grammar roughly parallels the grammar of a class
file:</p>
<pre class="codeblock">
  pack200_segment:
        segment_header
        *band_headers :BYTE1
        cp_bands
        attr_definition_bands
        ic_bands
        class_bands
        bc_bands
        file_bands
 
</pre>
<p>The terminals of this grammar are scalars and bands. To make the
terminals easier to recognize, scalar names begin with pound sign
"#" and band names begin with a star "*". A scalar is an encoded
integer (or a small fixed number of them) which appears within the
header of the archive file. When a scalar is mentioned in the
grammar, it is followed by a colon and the encoding and bracketed
count of the scalar value(s). Whenever a band is mentioned, it is
followed by a colon and its primary encoding, followed by a comment
in square brackets indicating its length. If the band encodes
references into some other data structure, such as a constant pool,
that structure is mentioned as a comment in parentheses. If the
references are allowed to be null, that fact is mentioned also.</p>
<p>Here is an example:</p>
<pre class="codeblock">
  example_non_terminal:
        other_non_terminal
        #single_scalar_integer :UNSIGNED5[1]
        #four_byte_scalar :BYTE1[4]
        *band_of_integers :UNSIGNED5 [#integer_count]
        *band_of_method_references :UNSIGNED5 [SUM(*ref_counts)] (cp_Method)
        *band_of_strings_and_nulls :UNSIGNED5 [...] (null or cp_String)
 
</pre>
<p>Many of the band lengths are simply references to previous
scalars (such as <tt>[#class_count]</tt>) or sums of previous bands
which transmit counts (e.g., <tt>[SUM(*class_method_count)]</tt>).
These bracketed lengths must be regarded as comments in the
grammar, since the text of the specification defines band lengths
verbally. Band counts which cannot be briefly summarized as
sometimes specified in a partial expression which contains an
ellipsis.</p>
<p>Occasionally we use additional grammatical notations. We use the
ordinary regular expression operators <tt>(X | Y)</tt> means a
match for either X or Y, <tt>(X)*</tt> means any number of matches
for X, <tt>(X)+</tt> means one or more matches for X, and
<tt>(X)?</tt> means either a match for X or nothing. In one case described in the section <a href="#band_replicated">Utf8 Constants</a>, where a band may have several
instances, the expression
<em>(band1)</em><tt>&nbsp;**&nbsp;</tt><em>length(band2)</em> means
that there are as many instances of <em>band1</em> as there are
elements in <em>band2</em>. Likewise, in three cases, the
expression <em>(band1)</em><tt>&nbsp;**&nbsp;</tt><em>#scalar</em>
indicates that there are zero or one instances of <em>band1</em>
according to the value (zero or one, respectively) of the boolean
scalar value.</p>
<a name="tocArcSeg" id="tocArcSeg"></a>
<h3>5.1. Archive Segmentation</h3>
The entire Pack200 archive format may be repeated one or more times
in a transmission to the decompressor. In this case, each complete
set of transmitted bands bands is viewed as a <em>segment</em> of
the whole transmission. The decompressor is required to accept
multiple segments, and to process each segment independently in
order. The output files resulting from each segment are accumulated
in order. If the decompressor is producing a JAR file, multiple
segments must be accumulated into one output JAR file, whose
elements are made up of the respective elements transmitted in each
segment, in order.
<pre class="codeblock">
  pack200_archive:
        (pack200_segment)+
 
</pre>
Note that each segment begins anew with the Pack200 magic number
and version numbers.
<p>(With one caveat, this means that Pack200 archives may be
concatenated with the natural meaning of combining the archives
they represent. As will be seen below, if the
<tt>#archive_size</tt> field is not present in each segment header,
it must be inserted before another segment is appended, so that the
decompressor can find the end of each segment. The segment header
format is such that this adjustment can be made easily.)</p>
<p>When combined with a streaming transport layer, segmentation
provides a way for a compressor to decrease latency or to decrease
the decompressor's memory requirements, at a cost in compressor
efficiency.</p>
<p>Segmentation can also help solve a scaling problem with very
large archives (of many tens of megabytes), in which the width of
indexes into the combined global constant pools can grow beyond the
benefits of global constant sharing. By starting a new segment, the
compressor resets the decompressor's constant pools, clearing out
useless constants, at the cost of restating constants that are
still in use. (The trade-offs are similar in flavor to the design
of copying garbage collectors.)</p>
<a name="tocArcHea" id="tocArcHea"></a>
<h3>5.2. Archive Header</h3>
The header consists of a magic number and version information, in a
format exactly parallel to the Java class file format. However,
besides the magic number, there are no other big-endian integers in
the Pack200 format. All integer encodings in bands present
arithmetically less-significant bits first.
<p>Only the archive magic numbers (the first four bytes of the
segment header) are fixed in size. All other archive structures are
variable in size and must therefore be parsed sequentially.
Generally speaking, decompressors must perform two passes over each
segment of the archive, one to size and parse the bands, and one to
sequentially extract information from the bands into each JAR
element in the output.</p>
<pre class="codeblock">
  segment_header:
        archive_magic archive_header

  archive_magic:
        #archive_magic_word :BYTE1[4]

  archive_header:
        #archive_minver :UNSIGNED5[1]
        #archive_majver :UNSIGNED5[1]
        #archive_options :UNSIGNED5[1]
        (archive_file_counts) ** (#have_file_headers)
        (archive_special_counts) ** (#have_special_formats)
        cp_counts
        class_counts

  archive_file_counts:
        #archive_size_hi :UNSIGNED5[1]
        #archive_size_lo :UNSIGNED5[1]
        #archive_next_count :UNSIGNED5[1]
        #archive_modtime :UNSIGNED5[1]
        #file_count :UNSIGNED5[1]
 
</pre>
<p>The <tt>archive_magic_word</tt> consists of the four bytes 0xCA,
0xFE, 0xD0, 0x0D. The <tt>#archive_minver</tt> must be the number
1. The <tt>#archive_majver</tt> must be the number 170. Both of the
latter two values may be incremented in the future to reflect small
revisions in this file format. Note that in previous versions of
this standard, the minor and major version numbers were 7 and 150,
or 1 and 160.</p>
<p>The header also contains initial counts of constant pool entries
and other "top-level" entities. All of these counts are given in
UNSIGNED5 format. Some of these counts are conditionally present,
controlled by bits in the <tt>#archive_options</tt> word. The rule
for a missing header value (and for missing values in general
unless otherwise specified) is that the decompressor must behave as
if it had received an explicit zero value.</p>
<a name="tocArOpFiPr" id="tocArOpFiPr"></a>
<h4>5.2.1. Archive Options and File Properties</h4>
The <tt>#archive_options</tt> word is interpreted bitwise. Certain
bits are given symbolic names as follows, where the LSB is numbered
as bit zero:
<table border="1" summary="bits used in archive_options word">
<tr>
<th id="archive_options_b">Bit</th>
<th id="archive_options_n">Name</th>
<th id="archive_options_m">Meaning if set in
<tt>#archive_options</tt></th>
</tr>
<tr>
<td headers="archive_options_b">0</td>
<td headers="archive_options_n"><tt>have_special_formats</tt></td>
<td headers="archive_options_m"><tt>archive_special_counts</tt>
contains counts</td>
</tr>
<tr>
<td headers="archive_options_b">1</td>
<td headers="archive_options_n"><tt>have_cp_numbers</tt></td>
<td headers="archive_options_m"><tt>cp_number_counts</tt> contains
counts</td>
</tr>
<tr>
<td headers="archive_options_b">2</td>
<td headers="archive_options_n"><tt>have_all_code_flags</tt></td>
<td headers="archive_options_m"><tt>code_flags_lo</tt> contains an
element for every code</td>
</tr>
<tr>
<td headers="archive_options_b">3</td>
<td headers="archive_options_n"><tt>have_cp_extra_counts</tt></td>
<td headers="archive_options_m"><tt>cp_extra_counts</tt> contains
counts</td>
</tr>
<tr>
<td headers="archive_options_b">4</td>
<td headers="archive_options_n"><tt>have_file_headers</tt></td>
<td headers="archive_options_m"><tt>archive_file_counts</tt>
contains counts</td>
</tr>
<tr>
<td headers="archive_options_b">5</td>
<td headers="archive_options_n"><tt>deflate_hint</tt></td>
<td headers="archive_options_m">request compressed JAR file for all
elements</td>
</tr>
<tr>
<td headers="archive_options_b">6</td>
<td headers="archive_options_n"><tt>have_file_modtime</tt></td>
<td headers="archive_options_m"><tt>file_modtime</tt> contains
modtimes</td>
</tr>
<tr>
<td headers="archive_options_b">7</td>
<td headers="archive_options_n"><tt>have_file_options</tt></td>
<td headers="archive_options_m"><tt>file_options</tt> contains
option bits</td>
</tr>
<tr>
<td headers="archive_options_b">8</td>
<td headers="archive_options_n"><tt>have_file_size_hi</tt></td>
<td headers="archive_options_m"><tt>file_size_hi</tt> contains
high-order size words</td>
</tr>
<tr>
<td headers="archive_options_b">9</td>
<td headers="archive_options_n"><tt>have_class_flags_hi</tt></td>
<td headers="archive_options_m"><tt>class_flags_hi</tt> contains
extra attribute flags</td>
</tr>
<tr>
<td headers="archive_options_b">10</td>
<td headers="archive_options_n"><tt>have_field_flags_hi</tt></td>
<td headers="archive_options_m"><tt>field_flags_hi</tt> contains
extra attribute flags</td>
</tr>
<tr>
<td headers="archive_options_b">11</td>
<td headers="archive_options_n"><tt>have_method_flags_hi</tt></td>
<td headers="archive_options_m"><tt>method_flags_hi</tt> contains
extra attribute flags</td>
</tr>
<tr>
<td headers="archive_options_b">12</td>
<td headers="archive_options_n"><tt>have_code_flags_hi</tt></td>
<td headers="archive_options_m"><tt>code_flags_hi</tt> contains
extra attribute flags</td>
</tr>
<tr>
<td headers="archive_options_b">13</td>
<td headers="archive_options_n">&nbsp;</td>
<td headers="archive_options_m">(unused, must be zero)</td>
</tr>
<tr>
<td headers="archive_options_b">...</td>
<td headers="archive_options_n">&nbsp;</td>
<td headers="archive_options_m">(unused, must be zero)</td>
</tr>
<tr>
<td headers="archive_options_b">31</td>
<td headers="archive_options_n">&nbsp;</td>
<td headers="archive_options_m">(unused, must be zero)</td>
</tr>
</table>
<p>If <tt>have_special_formats</tt> (the LSB) is set, the band
<tt>archive_special_counts</tt> will have two elements, as
specified in the grammar. Otherwise this band will have zero
elements. Similarly, if <tt>have_cp_numbers</tt> is set, the band
<tt>cp_number_counts</tt> will have four elements, as specified in
the grammar. Otherwise this band will have zero elements. If
<tt>have_all_code_flags</tt> is set, the band <tt>code_flags</tt>
must contain one element for every <tt>Code</tt> attribute.
Otherwise this band may have fewer elements. (This option is useful
when <tt>Code</tt> attributes are rich in sub-attributes, perhaps
because the JAR contains large amounts of debugging
information.)</p>
<p>If <tt>have_cp_extra_counts</tt> is set, the band
<tt>cp_extra_counts</tt> will contain four elements, as specified
in the grammar. Otherwise this band will have zero elements. (The
flag may only be set when <tt>#archive_majver</tt> is 170 or
higher. These extra counts correspond to additional constant pool
types introduced in recent revisions of the classfile format.)</p>
<p>If <tt>have_file_headers</tt> is set, the band
<tt>archive_file_counts</tt> will have five elements, as specified
in the grammar. Otherwise this band will have zero elements. If
<tt>deflate_hint</tt> is set, the decompressor is requested (but
not required) to reduce the size of its output. For example, if it
produces a JAR file, it may deflate the JAR elements. If the option
<tt>have_file_modtime</tt> (or <tt>have_file_options</tt>,
<tt>have_file_size_hi</tt>, <tt>have_class_flags_hi</tt>,
<tt>have_field_flags_hi</tt>, <tt>have_method_flags_hi</tt>,
<tt>have_code_flags_hi</tt>, respectively) is set, the
corresponding band <tt>file_modtime</tt> (or <tt>file_options</tt>,
<tt>file_size_hi</tt>, <tt>class_flags_hi</tt>,
<tt>field_flags_hi</tt>, <tt>method_flags_hi</tt>,
<tt>code_flags_hi</tt>, respectively) may be non-empty, as
specified below. Otherwise that band will have zero elements. Other
bits in the archive options must be zero and are reserved for
future use.</p>
<p>Immediately after the <tt>#archive_options</tt> word is a pair
of 32-bit numbers which together form a 64-bit length that helps
decompressors easily buffer incoming data up to the end of the
archive segment without reading beyond the segment. The value
<tt>#archive_size</tt> is the unsigned 64-bit value composed of the
unsigned 32-bit words <tt>#archive_size_lo</tt> and
<tt>#archive_size_hi</tt>, where the former value is the low-order
32-bit word and the latter value is the high-order 32-bit word. The
value <tt>#archive_size</tt> is either zero or declares the number
of bytes in the archive segment, starting immediately after
<tt>#archive_size_lo</tt> and before <tt>#archive_next_count</tt>
and ending with the last band, the <tt>*file_bits</tt> band. (That
is, a non-zero size includes the size of
<tt>#archive_next_count</tt>, <tt>*file_bits</tt>, and everything
in between.) This value is redundant, but if non-zero must be
correctly supplied by any compressor. If the archive segment is
transmitted as part of a stream, and if other data (such as
additional segments) follow the archive, the <tt>#archive_size</tt>
value must not be zero. Although it may be completely ignored by
the decompressor, this value may help some decompressors to buffer
their inputs more efficiently.</p>
<p>Immediately after <tt>#archive_size</tt> is another value
<tt>#archive_next_count</tt> which estimates the number of archive
segments immediately following the current one. This number need
not be correct, and may always be zero. It is intended to provide
decompressors with a hint as to the amount of remaining
decompression work to do. (Such hints are routinely displayed in
progress bars.)</p>
<p>If the <tt>#archive_modtime</tt> value is non-zero, the
decompressor is requested (but not required) to adjust the
system-specific modification time for its output. For example, if
the decompressor produces a JAR file, it may set the modification
date of each JAR element, or of the JAR file itself, to that date,
in the absence of any more specific directive, such a non-zero
<tt>file_modtime</tt> value. The <tt>#archive_modtime</tt> value is
interpreted as the number of seconds since the epoch used by
<tt>System.currentTimeMillis</tt>, which is 1/1/1970, 00:00:00 GMT.
However, the special value zero is reserved to indicate the absence
of any modification time for the archive as a whole. A decompressor
may supply an arbitrary value in place of a missing archive
modification time. If this is done, and if <tt>file_modtime</tt>
values are present, those values are interpreted relative to
modification time supplied for <tt>#archive_modtime</tt> by the
compressor.</p>
<p>The <tt>#file_count</tt> value gives the number of files which
are described in detail by the archive. Note that a class file
which is simple enough (as described below) does not need to be
described as a file, because it is enough that the class itself is
transmitted. Therefore, <tt>#file_count</tt> may be less than the
number of transmitted classes. (This latter number is called
<tt>#class_count</tt>.) On the other hand, transmitted files do not
need to contain classes, so that <tt>#file_count</tt> can also be
greater than the number of classes.</p>
<a name="tocArEnCoClFo" id="tocArEnCoClFo"></a>
<h4>5.2.2. Archive Entity Counts and Class Format</h4>
The archive file contains up to sixteen sets of constants called
"constant pools". (These structures are analogous, but not
identical, to a similarly named structure in class files.) These
constant pools are described in detail in the next section.
<p>The cardinality of each constant pool is given in UNSIGNED5
format in elements of the <tt>cp_counts</tt> structure of the
archive header:</p>
<pre class="codeblock">
  cp_counts:
        #cp_Utf8_count :UNSIGNED5[1]
        (cp_number_counts) ** (#have_cp_numbers)
        #cp_String_count :UNSIGNED5[1]
        #cp_Class_count :UNSIGNED5[1]
        #cp_Signature_count :UNSIGNED5[1]
        #cp_Descr_count :UNSIGNED5[1]
        #cp_Field_count :UNSIGNED5[1]
        #cp_Method_count :UNSIGNED5[1]
        #cp_Imethod_count :UNSIGNED5[1]
        (cp_extra_counts) ** (#have_cp_extra_counts)

  cp_number_counts:
        #cp_Int_count :UNSIGNED5[1]
        #cp_Float_count :UNSIGNED5[1]
        #cp_Long_count :UNSIGNED5[1]
        #cp_Double_count :UNSIGNED5[1]

  cp_extra_counts:
        #cp_MethodHandle_count :UNSIGNED5[1]
        #cp_MethodType_count :UNSIGNED5[1]
        #cp_BootstrapMethod_count :UNSIGNED5[1]
        #cp_InvokeDynamic_count :UNSIGNED5[1]

  archive_special_counts:
        #band_headers_size :UNSIGNED5[1]
        #attr_definition_count :UNSIGNED5[1]

  class_counts:
        #ic_count :UNSIGNED5[1]
        #default_class_minver :UNSIGNED5[1]
        #default_class_majver :UNSIGNED5[1]
        #class_count :UNSIGNED5[1]

</pre>
The order in which these counts occur parallels the order in which
the constant pools themselves are transmitted in the archive. This
order is called the <em>definition order</em> of the constant
pools.
<p>The four numeric constant pools are sized by
<tt>cp_number_counts</tt>. They specify numbers used occasionally
by <tt>ldc</tt> bytecodes. Because a minority of classes actually
use such bytecodes, the sizes are optional, under the control of
<tt>#have_cp_numbers</tt>.</p>
<p>Likewise, the last four constant pools are sized by
<tt>cp_extra_counts</tt>. They specify linkage information for the
<tt>invokedynamic</tt> instruction, and certain types of constants
(method handles and method types). As with the numeric entries,
these sizes are optional, under the control of
<tt>#have_cp_extra_counts</tt>.</p>
<p>Every class file has a header that includes magic number and a
minor and major version numbers. The magic number (0xCAFEBABE),
being a fixed constant, is not transmitted in the Pack200 archive.
However, the version numbers, which can vary somewhat, must be
recorded.</p>
<p>In the expectation that particular version numbers will be
prevalent, the archive header transmits default major and minor
version numbers. Both of these numbers are given in UNSIGNED5
format.</p>
<p>Individual classes in the archive (as described in the section <a href=
"#special_version_number">Attribute Bands</a>) may optionally specify their
own version numbers in a pseudo-attribute which overrides the
<tt>#default_class_minver</tt> and <tt>#default_class_majver</tt>
given in the archive header.</p>
<p>The count <tt>#band_headers_size</tt> gives the size in bytes of
<tt>band_headers</tt>. The format of these bytes, which help define
band coding specifiers for secondary codings, will be discussed
much later, in the section <a href="#band_coding">Meta-Coding</a>.</p>
<p>The archive header also specifies the number of attribute types
(<tt>#attr_definition_count</tt>), class definitions
(<tt>#class_count</tt>), nested class declarations
(<tt>#ic_count</tt>). These numbers are used to size various other
bands, as noted in the definition of those bands.</p>
<p>The arithmetic sum of all numbers in <tt>cp_counts</tt> must be
less than the value <tt>536870912</tt> (<tt>2^29</tt>). A
compressor is forbidden to transmit an archive for which the sum
reaches or exceeds this limit. This constraint is intended to allow
decompressors to use, internally, a unified numbering of constants,
even if certain constants (such as demangled inner class names or
implicit <tt>SourceFile</tt> names) must be added on the fly during
decompression to the constant pool.</p>
<p>Note on implementation: The <tt>archive_header</tt> directly
contains 3 numbers, while <tt>cp_counts</tt> contains at least 8
numbers and <tt>class_counts</tt> contains exactly 4. Therefore,
the minimum size of the <tt>archive_header</tt> is 15 bytes, and
this is always preceded by 4 bytes of <tt>archive_magic</tt>. A
decompressor which wished to avoid any spurious read-ahead could
read and buffer an initial block of 19 bytes, which would be
certain to contain the <tt>#archive_size</tt> fields. (This assumes
that the version numbers are small, as they are.) It could then
immediately parse enough information to determine how many
additional bytes of buffer storage would be required to scan the
rest of the archive, at least up to the resource file images. By
the time the resource file images in <tt>*file_bits</tt> must be
parsed, the decompressor will have already read the
<tt>*file_size</tt> bands, and will be able to remove any
uncertainty originally present in <tt>#archive_size</tt>. (If the
<tt>#archive_size</tt> fields are zero, the decompressor may be
forced to read blindly up to the end of all data on the input
channel in order to parse the archive.)</p>
<a name="tocConPoo" id="tocConPoo"></a>
<h4>5.3. Constant Pools</h4>
The format defines sixteen independent constant pools, eleven of
which correspond directly to the eleven basic types of constants
found in Java class files. In the Pack200 archive format, they are
organized in a fixed logical ordering called their <em>definition
order</em>. This order determines their presentation in the
archive's band structure, and also the construction of certain
constant numberings.
<p>The constant pools consolidate the information in the constant
pools of all input class files. Each constant pool contains a
single type of constant value. Each of the eleven constant pool
types found in Java 6 class files is placed in its own constant
pool. A twelfth pool holds <em>signatures</em>, which in class
files are UTF8 strings that represent method and field types, but
in Pack200 archives are a separately compressed data type.</p>
<p>Three more constant pools hold constants defined as part of the
Java 7 classfile format (major version 51 or later). One more
constant pool holds constants to be assembled into the
<tt>BootstrapMethods</tt> attribute, which may be viewed as an
appendix to the classfile constant pool.</p>
<p>The following table gives the sixteen predefined constant pools
in their definition order. It also defines their correspondence
with the constant types found in the Java class file format.</p>
<table border="1" summary="Constant pools in definition order">
<tr>
<th id="definition_order_n">Name</th>
<th id="definition_order_e">class file element</th>
<th id="definition_order_t">class file tag</th>
<th id="definition_order_p">Purpose</th>
</tr>
<tr>
<td headers="definition_order_n">cp_Utf8</td>
<td headers="definition_order_e">CONSTANT_Utf8_info</td>
<td headers="definition_order_t">CONSTANT_Utf8</td>
<td headers="definition_order_p">basic string data</td>
</tr>
<tr>
<td headers="definition_order_n">cp_Int</td>
<td headers="definition_order_e">CONSTANT_Integer_info</td>
<td headers="definition_order_t">CONSTANT_Integer</td>
<td headers="definition_order_p">int constant</td>
</tr>
<tr>
<td headers="definition_order_n">cp_Float</td>
<td headers="definition_order_e">CONSTANT_Float_info</td>
<td headers="definition_order_t">CONSTANT_Float</td>
<td headers="definition_order_p">float constant</td>
</tr>
<tr>
<td headers="definition_order_n">cp_Long</td>
<td headers="definition_order_e">CONSTANT_Long_info</td>
<td headers="definition_order_t">CONSTANT_Long</td>
<td headers="definition_order_p">long constant</td>
</tr>
<tr>
<td headers="definition_order_n">cp_Double</td>
<td headers="definition_order_e">CONSTANT_Double_info</td>
<td headers="definition_order_t">CONSTANT_Double</td>
<td headers="definition_order_p">double constant</td>
</tr>
<tr>
<td headers="definition_order_n">cp_String</td>
<td headers="definition_order_e">CONSTANT_String_info</td>
<td headers="definition_order_t">CONSTANT_String</td>
<td headers="definition_order_p">String constant</td>
</tr>
<tr>
<td headers="definition_order_n">cp_Class</td>
<td headers="definition_order_e">CONSTANT_Class_info</td>
<td headers="definition_order_t">CONSTANT_Class</td>
<td headers="definition_order_p">class reference</td>
</tr>
<tr>
<td headers="definition_order_n">cp_Signature</td>
<td headers="definition_order_e">(see below)</td>
<td headers="definition_order_t">(none)</td>
<td headers="definition_order_p">method, field, or variable
type</td>
</tr>
<tr>
<td headers="definition_order_n">cp_Descr</td>
<td headers="definition_order_e">CONSTANT_NameAndType_info</td>
<td headers="definition_order_t">CONSTANT_NameAndType</td>
<td headers="definition_order_p">pair of (name, type)</td>
</tr>
<tr>
<td headers="definition_order_n">cp_Field</td>
<td headers="definition_order_e">CONSTANT_Fieldref_info</td>
<td headers="definition_order_t">CONSTANT_Fieldref</td>
<td headers="definition_order_p">field reference</td>
</tr>
<tr>
<td headers="definition_order_n">cp_Method</td>
<td headers="definition_order_e">CONSTANT_Methodref_info</td>
<td headers="definition_order_t">CONSTANT_Methodref</td>
<td headers="definition_order_p">method call</td>
</tr>
<tr>
<td headers="definition_order_n">cp_Imethod</td>
<td headers="definition_order_e">
CONSTANT_InterfaceMethodref_info</td>
<td headers="definition_order_t">CONSTANT_InterfaceMethodref</td>
<td headers="definition_order_p">interface call</td>
</tr>
<tr>
<td headers="definition_order_n">cp_MethodHandle</td>
<td headers="definition_order_e">CONSTANT_MethodHandle_info</td>
<td headers="definition_order_t">CONSTANT_MethodHandle</td>
<td headers="definition_order_p">method handle constant</td>
</tr>
<tr>
<td headers="definition_order_n">cp_MethodType</td>
<td headers="definition_order_e">CONSTANT_MethodType_info</td>
<td headers="definition_order_t">CONSTANT_MethodType</td>
<td headers="definition_order_p">method type constant</td>
</tr>
<tr>
<td headers="definition_order_n">cp_BootstrapMethod</td>
<td headers="definition_order_e">
BootstrapMethods_attribute.bootstrap_methods[i]</td>
<td headers="definition_order_t">(none; side table to constant
pool)</td>
<td headers="definition_order_p">bootstrap method specifier</td>
</tr>
<tr>
<td headers="definition_order_n">cp_InvokeDynamic</td>
<td headers="definition_order_e">CONSTANT_InvokeDynamic_info</td>
<td headers="definition_order_t">CONSTANT_InvokeDynamic</td>
<td headers="definition_order_p">invokedynamic call</td>
</tr>
</table>
<p>(Note that the definition order for these constant pools
is similar to the numeric ordering of the corresponding class file
tag. For example, CONSTANT_Utf8 is the first tag, and cp_Utf8
is the first constant pool in the definition order.
However, there are differences in detail.  In particular,
note that cp_String comes before cp_Class, even though
the corresponding class file tags are in the reverse order.)</p>

<p>Each constant pool is logically a set of symbolic or numeric
values, all of one type. In the Pack200 archive, it is structured
as a sequence of such values, each with a unique index within the
sequence. Elsewhere in the archive, whenever a constant must be
mentioned, its index within the appropriate constant pool (or
within a subset of a pool, or within a group of pools) is
given.</p>
<p>Unlike the class file format, constant pool indexing in the
Pack200 archive format starts at zero. In the rare places where
null references are expected, the possibility is documented, and
the null references themselves are encoded by a zero index, while
all other index values are incremented by one. Where null
references are not expected, they may still be encoded by the
32-bit index value -1.</p>
<p>Also unlike class files, there are no "gaps" or unused indexes
associated with long or double values. Occasionally, we will refer
formally to an element of a constant pool by using array notation.
For example, the first three integers in the <tt>cp_Int</tt>
constant pool are <tt>cp_Int[0]</tt>, <tt>cp_Int[1]</tt>, and
<tt>cp_Int[2]</tt>, and the last integer is
<tt>cp_Int[cp_Int_count-1]</tt>. Note that both bands and constant
pools are treated in this specification as arrays with zero
origin.</p>
<p>It is illegal for a compressor to transmit the same constant
twice. That is, all constant pool entries must be unique.</p>
<p>In a class file, with a few exceptions, constant pool references
are strongly typed, in that every reference either is null or
refers to a constant pool entry of a fixed tag associated with the
context of the reference. The exceptions are <tt>ConstantValue</tt>
attributes and operand fields of the <tt>ldc</tt>, <tt>ldc_w</tt>,
and <tt>ldc2_w</tt> instructions.</p>
<p>However, because constant pools in a Pack200 archive are
separately indexed, all constant references must be strongly typed,
so that there is only one constant pool (or subset of a pool) into
which any given index applies. This is accomplished either by
deducing the constant type from context (in the case of
<tt>ConstantValue</tt> attributes) or adding extra information to
the context of the reference. (Within the bytecode stream,
<tt>ldc</tt> is split out by constant type into distinct
instructions <tt>sldc</tt>, <tt>ildc</tt>, etc.)</p>
<p>The layout of constant pool bands in the archive follows the
definition order of the constant pools themselves. Each constant
pool is represented in its turn by a sequence of one or more bands.
The sequence of constant pool bands is therefore structured as
follows:</p>
<pre class="codeblock">
  cp_bands:
        cp_Utf8
        *cp_Int :UDELTA5 [#cp_Int_count]
        *cp_Float :UDELTA5 [#cp_Float_count]
        cp_Long
        cp_Double
        *cp_String :UDELTA5 [#cp_String_count] (cp_Utf8)
        *cp_Class :UDELTA5 [#cp_Class_count] (cp_Utf8)
        cp_Signature
        cp_Descr
        cp_Field
        cp_Method
        cp_Imethod
        cp_MethodHandle
        *cp_MethodType :UDELTA5 [#cp_MethodType_count] (cp_Signature)
        cp_BootstrapMethod
        cp_InvokeDynamic

</pre>
<p>As can be seen here, constant pools whose entries can be derived
from a single 32-bit integer or a single reference are represented
as single bands. The other constant pools are represented as groups
of bands. Each constant pool gives its name to a corresponding
grammar element. The production of <tt>cp_bands</tt> declares the
order of each band or group of bands that transmits the constants
in the eponymous constant pool.</p>
<p>Note the use of UDELTA5 as primary encodings for several bands.
Although the Pack200 file format does not require any particular
ordering of values in constant pools, it is generally advantageous
to order them so that the encoded values in bands using UDELTA5 are
monotonically increasing. (Negative deltas can be encoded, although
expensively, by UDELTA5. Also, a signed secondary encoding may be
chosen by the compressor instead of UDELTA5.) The choice of primary
encodings in this specification reflects an expectation that
high-quality compressors, when presented with a choice of output
orderings, will make choices that result in good use of primary
band encodings.</p>
<p>In a few cases, several of the sixteen constant pools are
combined into a group, so that indexes can be formed to refer to
elements of the group as a whole. Such a group is completely
defined by its constituent constant pools. An index into a constant
pool group is always formed consistently with the overall order of
the constituent constant pools, as well as with the internal order
of each pool. For example, if a group <tt>cp_ABC</tt> is formed of
three pools <tt>cp_A</tt>, <tt>cp_B</tt>, and <tt>cp_C</tt> of
sizes <tt>COUNT(cp_A)</tt>, <tt>COUNT(cp_B)</tt>, and
<tt>COUNT(cp_C)</tt>, respectively, then a group index selects from
one of the three pools depending on whether it is in the range
<tt>0 .. COUNT(cp_A)-1</tt>, <tt>COUNT(cp_A) ..
COUNT(cp_A)+COUNT(cp_B)-1</tt>, or <tt>COUNT(cp_A)+COUNT(cp_B) ..
COUNT(cp_ABC)-1</tt>, respectively. The size of the pool group is
of course the sum of the constituent pools.</p>
<p>In some other cases, subsets of constant pools are indexed in an
abbreviated fashion. An index into a constant pool subset is always
formed consistently with the order of the pool itself. For example,
the index <tt>0</tt> always refers to the first element of the
subset, the index <tt>1</tt> refers to the second, and so on.</p>
<p>Here are definitions of the pool groups used in this
specification.</p>
<table border="1" summary="Constant pool groups">
<tr>
<th id="cp_groups_n">Name</th>
<th id="cp_groups_c">Constituents</th>
<th id="cp_groups_p">Purpose</th>
</tr>
<tr>
<td headers="cp_groups_n">cp_All</td>
<td headers="cp_groups_c">(all sixteen pools)</td>
<td headers="cp_groups_p">generic references</td>
</tr>
<tr>
<td headers="cp_groups_n">cp_LoadableValue</td>
<td headers="cp_groups_c">cp_Int, cp_Float, cp_Long, cp_Double, cp_String,
    cp_Class, cp_MethodHandle, cp_MethodType</td>
<td headers="cp_groups_p"><tt>qldc</tt> operand, bootstrap method
argument</td>
</tr>
<tr>
<td headers="cp_groups_n">cp_AnyMember</td>
<td headers="cp_groups_c">cp_Field, cp_Method, cp_Imethod</td>
<td headers="cp_groups_p"><tt>get</tt> or <tt>invoke</tt> operand,
method handle component</td>
</tr>
</table>
The group <tt>cp_All</tt> comprises the sequence of all constants,
in their natural order of occurrence within the Pack200 archive.
Thus, an index into <tt>cp_All</tt> is in effect an untyped
reference to any constant. <a name="tocScaCon" id="tocScaCon"></a>
<h5>5.3.1. Scalar Constants</h5>
The encoding of the <tt>cp_Utf8</tt> constant pool will be
described shortly. First we will describe the coding of the
numeric, string, and class constant pools.
<p>The values in the <tt>cp_Int</tt> constant pool are directly
represented by the values encoded in its band. The values in the
<tt>cp_Float</tt> constant pool are obtained as if by applying
<tt>java.lang.Float.intBitsToFloat</tt> to the 32-bit values
encoded in its band.</p>
<p>The 64-bit values of the <tt>cp_Long</tt> band are obtained by
adjoining, as high and low words, corresponding 32-bit values from
the two bands <tt>cp_Long_hi</tt> and <tt>cp_Long_lo</tt>. (They
contain the high and low words, respectively.) Likewise, the values
of the <tt>cp_Double</tt> band are obtained by first adjoining high
and low words from two other bands, and then retyping the resulting
64-bit integers as if by applying
<tt>java.lang.Double.longBitsToDouble</tt>. The high and low words
are in the bands <tt>cp_Double_hi</tt> and <tt>cp_Double_lo</tt>,
respectively.</p>
<pre class="codeblock">
  cp_Long:
        *cp_Long_hi :UDELTA5 [#cp_Long_count]
        *cp_Long_lo :DELTA5 [#cp_Long_count]

  cp_Double:
        *cp_Double_hi :UDELTA5 [#cp_Double_count]
        *cp_Double_lo :DELTA5 [#cp_Double_count]
 
</pre>
<p>When floating point values are eventually written to class
files, their bits must be accurately stored, as if they were
processed by <tt>java.lang.Float.floatToRawIntBits</tt> or
<tt>java.lang.Double.doubleToRawLongBits</tt>. In this way "NaN"
values are transmitted faithfully, without normalization.</p>
<p>(Note: Although it would be possible to extend the band-coding
techniques of Pack200 to encode 64-bit values directly, this file
format always transmits 64-bit values as pairs of 32-bit values,
transmitted in pairs of bands. This simplifies implementations,
allowing them to process band data with 32-bit data paths.)</p>
<p>Each string in a <tt>cp_String</tt> constant pool is represented
in its band by a reference to the string's spelling, as a
<tt>cp_Utf8</tt> constant.</p>
<p>Likewise, each class in a <tt>cp_Class</tt> constant pool is
represented in its band by a reference to the class's spelling, as
a <tt>cp_Utf8</tt> constant. (As in the class file and the VM, the
spelling uses the slash character to delimit package prefix
components.)</p>
<a name="str_psc_ref" id="str_psc_ref"></a> <a name="tocUtfCon" id=
"tocUtfCon"></a>
<h5>5.3.2. Utf8 Constants</h5>
Each value in the <tt>cp_Utf8</tt> constant pool is an array of
zero or more 16-bit Java characters. (The name "Utf8" is an
anachronism, referring only to the basic character string type in
Java class files. No part of the Pack200 file format uses any UTF
encoding, but the term "Utf8" is retained to emphasize the
connection with class files.) As in the class file format, all
character string data is transmitted in this one kind of constant
pool entry. When the context is clear enough, we loosely refer to
these arrays as "strings", even though they are distinct from the
Java constants in the cp_String constant pool.
<p>If <tt>cp_Utf8</tt> is not empty, its first value is always the
empty string. Thus, the empty string is always given an index of
zero. No band values are transmitted to represent this empty
string. (Values in the bands <tt>cp_Utf8_prefix</tt> and
<tt>cp_Utf8_suffix</tt> pertain to strings after the empty string
in <tt>cp_Utf8</tt>.) Because constants cannot be duplicated, all
other elements of <tt>cp_Utf8</tt> contain at least one
character.</p>
<p>Each string in the <tt>cp_Utf8</tt> constant pool is represented
in the archive file in two parts, a prefix and a suffix. The suffix
is represented both by a count and a sequence of character codes.
The prefix is represented only by a count; the characters of the
prefix are duplicated from the previous string. This technique
allows the compressor (if it chooses) to represent strings by means
of their successive differences. The first suffix value and the
first two prefix values are suppressed in the transmitted archive.
The values, if transmitted, would always be zero, since the first
<tt>cp_Utf8</tt> string is always empty, and the second string can
never share a non-empty prefix with the first string.</p>
<p>Each suffix is transmitted in exactly one of two ways, as a
<em>small suffix</em> or a <em>big suffix</em>. Small suffixes are
transmitted contiguously in one large band. Big suffixes are rare;
they are intended as a way to compactly transmit strings with
unusual statistics, such as strings which are really tables of
numeric data. Each big suffix is transmitted in its own band. This
allows the compressor the option to choose an efficiently
customized secondary coding for the characters in each large,
unusual string.</p>
<a name="band_replicated" id="band_replicated"></a>
<pre class="codeblock">
  cp_Utf8:
        *cp_Utf8_prefix :DELTA5      [MAX(0,#cp_Utf8_count-2)]
        *cp_Utf8_suffix :UNSIGNED5   [MAX(0,#cp_Utf8_count-1)]
        *cp_Utf8_chars :CHAR3        [SUM( *cp_Utf8_suffix )]
        *cp_Utf8_big_suffix :DELTA5  [COUNT(0, *cp_Utf8_suffix )]
        (*cp_Utf8_big_chars :DELTA5)
          ** length(cp_Utf8_big_suffix)  [SUM( *cp_Utf8_big_suffix )]
 
</pre>
(Note: It is helpful, but not required by this specification, to
order the strings lexicographically and find maximal common
prefixes between adjacent strings. It is permissible to ignore the
prefix sharing feature and declare all prefixes to be zero.)
<p>The band <tt>cp_Utf8_suffix</tt> contains one less than
<tt>#cp_Utf8_count</tt> elements. It specifies, in order, the small
suffix length of each constant pool string (except the implicit
first string, which is empty). The band <tt>cp_Utf8_prefix</tt>
contains two less than <tt>#cp_Utf8_count</tt> elements. It
specifies, in order, the prefix length of each constant pool string
(except the first two strings, which always have zero prefix
lengths). The prefix length encodes the length of a prefix
substring shared by both <tt>cp_Utf8[i-1]</tt> and
<tt>cp_Utf8[i]</tt>. If there are fewer than three strings in
<tt>cp_Utf8</tt>, then <tt>cp_Utf8_prefix</tt> is empty. The prefix
length is typically a large proportion (sometimes half) of the
total length.</p>
<p>Each value in the band <tt>cp_Utf8_chars</tt> is a 16-bit number
expressing a Java character. This band contains the characters of
all small suffixes, in order. For each successive string,
<tt>cp_Utf8_chars</tt> contains an additional run of values
encoding the characters of its small suffix, if any. Therefore, the
total length of this band is the sum of all values in the
<tt>cp_Utf8_suffix</tt> band.</p>

<a name="big_string" id="big_string"></a>

<p>Whenever a small suffix length for a constant pool entry is
zero, the string has no small suffix, but a big suffix instead. The
length of each big suffix is given by an element of the
<tt>cp_Utf8_big_suffix</tt> band. (Therefore, the length of this
band is precisely the count of zero values in the
<tt>cp_Utf8_suffix</tt> band.) Each big suffix is transmitted as a
separate band of 16-bit character values, one band element per
character. There is one such band per big suffix. These bands
immediately follow the <tt>cp_Utf8_big_suffix</tt> band, and are
collectively called the <tt>cp_Utf8_big_chars</tt> bands. Although
normally data of the same type are collected into a single band,
these strings are placed in separate bands so that they may be
independently encoded. These strings typically encode arrays of
binary data, rather than true Java characters.</p>

<p>A big suffix can have a length of zero, which means that the
constant pool entry is a non-empty prefix of the previous string.
In such a case, the corresponding suffix band will occupy no space
in the archive file, since bands of zero length occupy no bytes at
all.</p>

<p>Please see the Appendix section <a href=
"#str_psc">Representation of <code>cp_Utf8</code> Constant Pool</a> for pseudo-code explaining this concept. <a name=
"sig_psc_ref" id="sig_psc_ref"></a></p>
<a name="tocTypSig" id="tocTypSig"></a>
<h5>5.3.3. Type Signatures</h5>
Each <tt>cp_Signature</tt> constant pool entry represents a type
string, exactly as field and method types are declared in the class
file format. Although the class file format uses simple
<tt>Utf8</tt> constant pool entries for such strings, the Pack200
file format allocates a separate constant pool for them, in order
to use more compact representation than for general strings.
<p>Signature constants are special in that they can contain
embedded references to <tt>cp_Class</tt> constants. The signature
constant is equivalent to a Utf8 constant, once the embedded class
references are expanded into their spellings. Signature constants
are flexible enough to represent arbitrary strings, but are
intended for strings that often contain class names following the
capital letter ell <tt>'L'</tt>. These include field, method, and
local variables types, and generic <tt>Signature</tt>
attributes.</p>
<p>Each signature string is decomposed into a <em>form</em> and a
sequence of zero or more class references. The class references are
obtained by locating in the original signature string all sequences
that match the pattern "<tt>L</tt><em>classname</em>", removing the
<em>classname</em> part, and treating it as a reference into the
<tt>cp_Class</tt> constant pool. The form is defined as the residue
after the class names have been removed from the original
string.</p>
<p>The form is not allowed to contain any occurrences of the letter
ell ('<tt>L</tt>'), other than those which mark removed class
names.</p>
<p>Thus, the form will contain the character '<tt>L</tt>' wherever
the original type string refers to a class. By counting the number
of these characters in a form, the decompressor may deduce the
number of classes to which the original type string refers. This
number is called the <em>class length</em> of the form.</p>
<p>Note that <tt>cp_Class</tt> constants are not required to refer
to existing classes, nor are they even required to have valid class
name spellings. Therefore, the compressor has considerable latitude
in choosing which class names (if any) it will extract from
signature strings. In an extreme case, the compressor can make each
form identical to its corresponding signature string, and simply
satisfy its class length by emitting references to a fictitious
class with an empty name. (This class length would have to include
any occurrences of <tt>'L'</tt> in the class names themselves.)</p>
<p>Note also that these encoding rules do not require a class name
to be followed by any particular character, although it will
generally be a semicolon, or perhaps a left-angle bracket, in the
case of an instance of a generic type in a <tt>Signature</tt>
attribute.</p>
<p>The rules also allow the compressor to decide, arbitrarily, how
many characters (if any) after each letter ell <tt>'L'</tt> will be
transmitted as part of a class name. Therefore, a given signature
string may be representable by several forms, any of which the
decompressor must be prepared to process.</p>
<p>Here are some examples:</p>
<table border="1" summary="sample decompressions">
<tr align="center">
<th id="sample_decompressions_t">Type Signature String</th>
<th id="sample_decompressions_f">Form</th>
<th id="sample_decompressions_c">Class<br />
Len.</th>
<th id="sample_decompressions_c2">Class...</th>
</tr>
<tr>
<td headers="sample_decompressions_t"><tt>F</tt></td>
<td headers="sample_decompressions_f"><tt>F</tt></td>
<td headers="sample_decompressions_c">0</td>
<td headers="sample_decompressions_c2">&nbsp;</td>
</tr>
<tr>
<td headers="sample_decompressions_t"><tt>[Z</tt></td>
<td headers="sample_decompressions_f"><tt>[Z</tt></td>
<td headers="sample_decompressions_c">0</td>
<td headers="sample_decompressions_c2">&nbsp;</td>
</tr>
<tr>
<td headers="sample_decompressions_t"><tt>[[[LLL;</tt></td>
<td headers="sample_decompressions_f"><tt>[[[L;</tt></td>
<td headers="sample_decompressions_c">1</td>
<td headers="sample_decompressions_c2"><tt>LL</tt></td>
</tr>
<tr>
<td headers="sample_decompressions_t"><tt>[[[LLL;</tt></td>
<td headers="sample_decompressions_f"><tt>[[[LLL;</tt></td>
<td headers="sample_decompressions_c">3</td>
<td headers="sample_decompressions_c2"><tt>(empty), (empty),
(empty)</tt></td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<tt>([Ljava/lang/String;)V</tt></td>
<td headers="sample_decompressions_f"><tt>([L;)V</tt></td>
<td headers="sample_decompressions_c">1</td>
<td headers="sample_decompressions_c2">
<tt>java/lang/String</tt></td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<tt>Ljava/util/List&lt;Lpkg/Item;&gt;;</tt></td>
<td headers="sample_decompressions_f"><tt>L&lt;L;&gt;;</tt></td>
<td headers="sample_decompressions_c">2</td>
<td headers="sample_decompressions_c2"><tt>java/util/List,
pkg/Item</tt></td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<tt>(Ljava/lang/String;II)Lpkg/Item;</tt></td>
<td headers="sample_decompressions_f"><tt>(L;II)L;</tt></td>
<td headers="sample_decompressions_c">2</td>
<td headers="sample_decompressions_c2"><tt>java/lang/String,
pkg/Item</tt></td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<tt>Ljava/util/List&lt;Ljava/lang/Byte;&gt;;</tt></td>
<td headers="sample_decompressions_f"><tt>L&lt;L;&gt;;</tt></td>
<td headers="sample_decompressions_c">2</td>
<td headers="sample_decompressions_c2"><tt>java/util/List,
java/lang/Byte</tt></td>
</tr>
<tr>
<td headers="sample_decompressions_t">
<tt>&lt;ELEM:&gt;(Ljava/util/List&lt;TELEM;&gt;;)TELEM;</tt></td>
<td headers="sample_decompressions_f">
<tt>&lt;EL:&gt;(L&lt;TEL;&gt;;)TEL;</tt></td>
<td headers="sample_decompressions_c">1</td>
<td headers="sample_decompressions_c2"><tt>EM, java/util/List, EM,
EM</tt></td>
</tr>
<tr>
<td headers="sample_decompressions_t"><tt>ALLOWABLE</tt></td>
<td headers="sample_decompressions_f"><tt>ALLOWABLE</tt></td>
<td headers="sample_decompressions_c">3</td>
<td headers="sample_decompressions_c2"><tt>(empty), (empty),
(empty)</tt></td>
</tr>
<tr>
<td headers="sample_decompressions_t"><tt>ALLOWABLE</tt></td>
<td headers="sample_decompressions_f"><tt>AL</tt></td>
<td headers="sample_decompressions_c">1</td>
<td headers="sample_decompressions_c2"><tt>LOWABLE</tt></td>
</tr>
<tr>
<td headers="sample_decompressions_t"><tt>ALLOWABLE</tt></td>
<td headers="sample_decompressions_f"><tt>ALABL</tt></td>
<td headers="sample_decompressions_c">2</td>
<td headers="sample_decompressions_c2"><tt>LOW, E</tt></td>
</tr>
</table>
<p>The forms of all strings in the <tt>cp_Signature</tt> constant
pool are given in order in the <tt>cp_Signature_form</tt> band, as
one <tt>cp_Utf8</tt> reference per signature string. For each form,
the class-length sequence of classes required to reconstitute the
signature string is transmitted as a run of <tt>cp_Class</tt>
references in the <tt>cp_Signature_classes</tt> band. As a
consequence of these definitions, the length of the
<tt>cp_Signature_classes</tt> band is the total number of letter
ell <tt>'L'</tt> occurrences in the sequence of spellings of forms
mentioned in <tt>cp_Signature_form</tt>.</p>
<pre class="codeblock">
  cp_Signature:
        *cp_Signature_form :DELTA5 [#cp_Signature_count](cp_Utf8)
        *cp_Signature_classes :UDELTA5 [COUNT('L',...)] (cp_Class)
 
</pre>
<p>Please see the Appendix section for <a href=
"#sig_psc">Representation of <code>cp_Signature</code> Constant Pool</a> pseudo-code explaining this concept.</p>
<a name="tocTupCon" id="tocTupCon"></a>
<h5>5.3.4. Tuple Constants</h5>
The next four constant pools contain ordered pairs of various kinds
of values (types, names, strings, or classes). Each
<tt>cp_Descr</tt> constant is an ordered pair of a name
(represented as a <tt>cp_Utf8</tt> reference) and a type
(represented as a <tt>cp_Signature</tt> reference). These
references are transmitted in corresponding elements of the
<tt>cp_Descr_name</tt> and <tt>cp_Descr_type</tt> bands.
<p>Likewise, each <tt>cp_Field</tt>, <tt>cp_Method</tt>, or
<tt>cp_Imethod</tt> constant is an ordered pair of a class
(represented as a <tt>cp_Class</tt> reference) and a name-and-type
descriptor (represented as a <tt>cp_Descr</tt> reference). Again,
these references are transmitted in corresponding elements of the
associated bands.</p>
<pre class="codeblock">
  cp_Descr:
        *cp_Descr_name :DELTA5 [#cp_Descr_count] (cp_Utf8)
        *cp_Descr_type :UDELTA5 [#cp_Descr_count] (cp_Signature)
  cp_Field:
        *cp_Field_class :DELTA5 [#cp_Field_count] (cp_Class)
        *cp_Field_desc :UDELTA5 [#cp_Field_count] (cp_Descr)
  cp_Method:
        *cp_Method_class :DELTA5 [#cp_Method_count] (cp_Class)
        *cp_Method_desc :UDELTA5 [#cp_Method_count] (cp_Descr)
  cp_Imethod:
        *cp_Imethod_class :DELTA5 [#cp_Imethod_count] (cp_Class)
        *cp_Imethod_desc :UDELTA5 [#cp_Imethod_count] (cp_Descr)
 
</pre>
<a name="tocExtCon" id="tocExtCon"></a>
<h5>5.3.5. Extra Constants</h5>
For additional constant pools define symbolic references for
<tt>invokedynamic</tt> instructions and related entities. (These
constant pools are only non-empty if their corresponding counts are
non-zero, which in turn can only be true if
<tt>cp_extra_counts</tt> is present.) Each <tt>cp_MethodHandle</tt>
is an ordered pair of a reference kind (a small integer) and a
reference to an element of <tt>cp_Field</tt>, <tt>cp_Method</tt>,
or <tt>cp_Imethod</tt>. (This reference is transmitted as an index
into <tt>cp_AnyMember</tt>, which is defined above as a pool group
containing those three pools.) Each <tt>cp_MethodType</tt> is
represented as a <tt>cp_Signature</tt> reference. Each
<tt>cp_InvokeDynamic</tt> is an ordered pair of a bootstrap method
specifier (represented as a <tt>cp_BootstrapMethod</tt>) and a type
(represented as a <tt>cp_Signature</tt> reference). Each
<tt>cp_BootstrapMethod</tt> specifier is an ordered pair of a
bootstrap method reference (represented as a
<tt>cp_MethodHandle</tt>) and a counted series of zero or more
constant pool references to constants which can be loaded onto the
JVM stack. (These references are transmitted as indexes into the
pool group <tt>cp_LoadableValue</tt>.) All these values and
references are transmitted in associated bands as described below.
<pre class="codeblock">
  cp_MethodHandle:
        *cp_MethodHandle_refkind :DELTA5 [#cp_MethodHandle_count]
        *cp_MethodHandle_member :UDELTA5 [#cp_MethodHandle_count] (cp_AnyMember)
  cp_BootstrapMethod:
        *cp_BootstrapMethod_ref :DELTA5 [#cp_BootstrapMethod_count] (cp_MethodHandle)
        *cp_BootstrapMethod_arg_count :UDELTA5 [#cp_BootstrapMethod_count]
        *cp_BootstrapMethod_arg :DELTA5 [SUM(*BootstrapMethod_arg_count)] (cp_LoadableValue)
  cp_InvokeDynamic:
        *cp_InvokeDynamic_spec :DELTA5 [#cp_InvokeDynamic_count] (cp_BootstrapMethod)
        *cp_InvokeDynamic_descr :UDELTA5 [#cp_InvokeDynamic_count] (cp_Descr)
</pre>
<a name="tocFilAtt" id="tocFilAtt"></a>
<h4>5.4. File Attributes</h4>
Since a JAR archive consists of a sequence of files, each with
contents and a few other attributes, the Pack200 archive can also
represent a sequence of files with their attributes. Of course, the
contents of class files are specially transmitted, but whether a
file (i.e., a JAR archive element) contains a class or another
resource, the Pack200 archive is able to transmit the following
attributes:
<ul>
<li>name of file <em>(optional for classes)</em></li>
<li>contents of file <em>(optional for classes)</em></li>
<li>modification time of file <em>(optional)</em></li>
<li>deflation hint for file <em>(optional)</em></li>
<li>order of file in archive <em>(optional for classes)</em></li>
</ul>
<p>A class file whose contents are compressed by Pack200 is marked
as a "stub" with a special option bit. A class stub file must be
declared to have a length of zero. It may be declared to have the
empty string for its name. If there are not enough class stub files
transmitted to match with the number of classes transmitted, the
decompressor must act as if the compressor had transmitted an
additional series of trivial stubs, with no name or contents, and
modification time and deflation hint copied from the archive
header.</p>
<p>Each resource file is transmitted in the Pack200 archive as a
simple bytewise image, under a relative pathname using slash '/' as
a directory separator. (This is the same pathname convention as is
used in ZIP archives.) Each file (both resource files and class
files) can optionally be associated with a deflation hint and a
modification date.</p>
<pre class="codeblock">
  file_bands:
        *file_name :UNSIGNED5 [#file_count] (cp_Utf8)
        *file_size_hi :UNSIGNED5 [#file_count*(#have_file_size_hi)]
        *file_size_lo :UNSIGNED5 [#file_count]
        *file_modtime :DELTA5 [#file_count*(#have_file_modtime)]
        *file_options :UNSIGNED5 [#file_count*(#have_file_options)]
        *file_bits :BYTE1 [SUM(*file_size)]
 
</pre>
<p>There are no additional file attributes, such as comments, extra
attributes, or CRC values. An application which requires such
attributes on some files may encode those files into an appropriate
archive file format (such as ZIP), and transmit those archives as
resource files in a Pack200 archive.</p>
<p>Each file name is transmitted as an element of the
<tt>file_name</tt> band, and each length (in bytes) is transmitted
in the corresponding elements of the <tt>file_size_lo</tt> band and
(if present) the <tt>file_size_hi</tt> band. All three bands are of
length <tt>#file_count</tt>, except that <tt>file_size_hi</tt> has
zero elements if the <tt>have_file_size_hi</tt> bit in the
<tt>#archive_options</tt> is clear.</p>
<p>The length in bytes of each file is the corresponding unsigned
32-bit value taken from the <tt>file_size_lo</tt> band, if the
<tt>file_size_hi</tt> band is empty. Otherwise, the file length is
the unsigned 64-bit value composed of the corresonding unsigned
32-bit elements of the <tt>file_size_lo</tt> and
<tt>file_size_hi</tt> bands, where the former value is the
low-order 32-bit word and the latter value is the high-order 32-bit
word.</p>
<p>The bytes of all non-class (i.e., resource) files follow
immediately in the <tt>file_bits</tt> band. Each file is given as a
corresponding run of byte values.</p>
<p>The optional band <tt>file_modtime</tt>, if not empty, supplies
a modification time for each resource file (and potentially for
class files, if class file stubs are present). Each integer value
gives a difference (in seconds) from the <tt>#archive_modtime</tt>
value. (Therefore, if the <tt>#archive_modtime</tt> value is zero,
the individual file times must be interpreted as absolute values.)
The order of transmission of <tt>file_modtime</tt> is consistent
with <tt>file_name</tt>. This band is empty if the
<tt>have_file_modtime</tt> bit in the <tt>#archive_options</tt> is
clear.</p>
<p>The optional band <tt>file_options</tt>, if not empty, supplies
flag bits for each resource file (and potentially for class files,
if class file stubs are present). This band is empty if the
<tt>have_file_options</tt> bit in the <tt>#archive_options</tt> is
clear. Each <tt>file_options</tt> word is interpreted bitwise.
Certain bits are given symbolic names as follows, where the LSB is
numbered as bit zero:</p>
<table border="1" summary="description of file_options bits">
<tr>
<th id="file_options_b">Bit</th>
<th id="file_options_n">Name</th>
<th id="file_options_p">Purpose</th>
</tr>
<tr>
<td headers="file_options_b">0</td>
<td headers="file_options_n">deflate_hint</td>
<td headers="file_options_p">request compressed JAR file
element</td>
</tr>
<tr>
<td headers="file_options_b">1</td>
<td headers="file_options_n">is_class_stub</td>
<td headers="file_options_p">this file contains class
bytecodes</td>
</tr>
</table>
<p>If <tt>deflate_hint</tt> (the LSB) is set, the decompressor is
requested (but not required) to reduce the size of its output. For
example, if it produces a JAR file, it may deflate the JAR
elements. Since the <tt>deflate_hint</tt> bit in the
<tt>#archive_options</tt> word has the same effect, the two bits
are in effect combined with a logical OR for each file. If
<tt>is_class_stub</tt> (the second LSB) is set, this resource file
description is actually a <em>stub</em>, and the file contents are
defined as the bytecodes of one of the classes defined in the
Pack200 archive. Other bits in the file options must be zero and
are reserved for future use.</p>
<p>If a transmitted file is marked as a class stub, its contents
must be transmitted as if the file were empty. (That is,
<tt>file_size_hi</tt> and <tt>file_size_lo</tt> must both be zero,
and there may not be any corresponding bytes in
<tt>file_bits</tt>.) The decompressor is required to supply
contents for the resource file by reconstituting the contents of a
class file for a class transmitted in <tt>class_this</tt>, etc.
Like any other resource file, the class stub is allowed to have a
name, a modification time and a <tt>deflate_hint</tt>.</p>
<p>The class stubs and classes correspond in order. Define the
derived parameter <tt>#class_stub_count</tt> as the number of files
marked as class stubs. (It is also the count of
<tt>is_class_stub</tt> bits set in <tt>file_options</tt>.) Then
<tt>#class_stub_count</tt> must be no larger than
<tt>#class_count</tt>. The first class stub defines a file which
receives bytecodes for the first class, and so on. Although a class
stub has a name (transmitted in <tt>file_name</tt>), this name may
be the empty string. In this case, the decompressor is required to
use the standard name for the class file, which is created from the
class's bytecode name (using slash '/' for a package separator) by
appending the string ".class". (Thus, a classfile can have an
arbitrary non-standard name, but the compression works best if its
name is derived from its class in the usual way.)</p>
<p>If <tt>#class_count</tt> is larger than
<tt>#class_stub_count</tt>, then the decompressor must behave as if
a sufficient number of trivial extra class stubs were transmitted
after the last explicit file. These trivial stubs have an empty
name string and a zero <tt>deflate_hint</tt> or
<tt>file_modtime</tt>.</p>
<p>Thus, in the simple case where there are no class stubs at all
(perhaps because <tt>have_file_options</tt> is zero), the
decompressor must produce its files in their transmission order,
followed by the transmission order of the classes. Each class file
must have its standard name, and a modification time and deflation
hint inherited from <tt>#archive_modtime</tt> and the
<tt>deflate_hint</tt> bit in <tt>#archive_options</tt>. But at the
cost of extra transmission size, the compressor can direct the
decompressor to present the resources and class files in any fixed
order, with arbitrary names, modification times, and deflation
hints for each output file. The decompressor must honor this
ordering, if its output is in a form (such as a JAR archive) where
order is significant.</p>
<p>Compressors are free, unless otherwise directed, to choose any
ordering of files. It is often advantageous to place files with
similar statistics next to each other, so that the post-pass
compressor (if any) may process their contents together (in the
same window, in the case of the DEFLATE algorithm). It is likely
that a compressor which is able to reorder its input files for
efficient transmission will have a command option which forces it
to retain the order in which input files were presented, because
this order is significant to some (but not all) deployment
applications.</p>
<p>Compressors are free to transmit class files as if they were
resource files. This provides a way to transmit class files which
must be preserved bit-for-bit, or which compressors cannot transmit
compressed with sufficient accuracy. Decompressors are required to
accept class files transmitted "bitwise" as resource files.</p>
<p>Note: The bands controlling files and their attributes are
transmitted last in the archive, in order to ease decompressor
implementation slightly, since the last thing a decompressor does
is to assemble output files. In particular, resource files can be
of arbitrary size, and placing their bits at the end of the archive
allows the decompressor to avoid allocating temporary storage for
them.</p>
<a name="tocFlaAtt" id="tocFlaAtt"></a>
<h4>5.5. Flags and Attributes</h4>
The Pack200 file format directly supports up to 16 modifier bits in
all output flags fields, as defined by the class file format. It
also directly supports certain predefined attributes, such as
<tt>Code</tt>, <tt>InnerClasses</tt>, and <tt>ConstantValue</tt> It
is also possible for the compressor to define additional
attributes, passing enough information to the decompressor to
properly extract their data from bands and reconstitute them in
class files. The presence or absence of all attributes is
controlled by the setting of certain bits in flag bands.
<p>Five sets of <em>flag bands</em> carry modifier bits and/or
attribute control bits. The <tt>ic_flags</tt> band carries modifier
bits for nested classes. Also, modifier and attribute control bits
are carried by <tt>class_flags_lo</tt>, <tt>field_flags_lo</tt>,
<tt>method_flags_lo</tt>, and <tt>code_flags_lo</tt>, and the four
corresponding optional high word bands, <tt>class_flags_hi</tt>,
<tt>field_flags_hi</tt>, <tt>method_flags_hi</tt>, and
<tt>code_flags_hi</tt>. (There is no high word for
<tt>ic_flags</tt>.) Each value in these bands is interpreted as an
unsigned 32-bit binary number. Each bit in these bands
independently specifies the presence of a Java access modifier
(such as <tt>ACC_PRIVATE</tt>), or of a class, field, method, or
code attribute (such as <tt>Deprecated</tt> or
<tt>SourceFile</tt>), or of some other necessary control
information (such as whether a class file has a non-default version
number).</p>
<p>Every class (resp. field, method, <tt>Code</tt> attribute) has a
corresponding flags value of up to 63 bits transmitted in
<tt>class_flags_lo</tt> (resp., <tt>field_flags_lo</tt>,
<tt>method_flags_lo</tt>, <tt>code_flags_lo</tt>) and optionally in
<tt>class_flags_hi</tt> (resp., <tt>field_flags_hi</tt>,
<tt>method_flags_hi</tt>, <tt>code_flags_hi</tt>). These flags
values, assembled into 64-bit numbers, are named
<tt>class_flags</tt> (resp., <tt>field_flags</tt>,
<tt>method_flags</tt>, <tt>code_flags</tt>). Except for
<tt>Code</tt> attributes, each of the low sixteen flag bits may be
used to transmit access flags. The high sixteen bits (or
forty-seven, if the optional high word is transmitted) are used to
indicate the presence of attributes, either predefined or
compressor-defined. The sixty-fourth bit position of a flags value
(if transmitted) is reserved and must be zero.</p>
<p>The flags value for a <tt>Code</tt> attribute is optional and
taken to be zero if missing. A <tt>Code</tt> attribute has a
corresponding flags value transmitted if and only if either the
<tt>have_all_code_flags</tt> bit in the <tt>#archive_options</tt>
is set, or else the element of <tt>code_headers</tt> corresponding
to the <tt>Code</tt> attribute has the special value zero. (See the
discussion of code headers in the section <a href="#code_headers">Class Schema</a>.)</p>
<p>For classes, nested classes, fields, and methods, the assignment
of flag bit positions to modifiers is the same as that in the class
file format. (For example, the LSB always represents
<tt>ACC_PUBLIC</tt>, in both Pack200 archive and class file
formats.) An <em>overflow attribute</em> is an attribute whose
presence is not indicated directly via a flag bit, and but is
instead indicated by a occurrence of its index in a separate band.
For classes, fields, methods, and codes, bit 16 (as set in the mask
0x0001000) indicates the presence of overflow attributes. For
nested classes, flag bit 16 indicates the presence of explicit
outer class and name fields, as explained in the section <a href=
"#explicit_outer">Nested Classes</a>.</p>
<table border="1" summary="Listing of flag bits">
<tr align="center">
<th id="flag_bits_b">Bit</th>
<th id="flag_bits_m">Meaning</th>
</tr>
<tr>
<td headers="flag_bits_b" align="right">0</td>
<td headers="flag_bits_m">ACC_PUBLIC</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">1</td>
<td headers="flag_bits_m">ACC_PRIVATE</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">2</td>
<td headers="flag_bits_m">ACC_PROTECTED</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">3</td>
<td headers="flag_bits_m">ACC_STATIC</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">4</td>
<td headers="flag_bits_m">ACC_FINAL</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">5</td>
<td headers="flag_bits_m">ACC_SYNCHRONIZED (ACC_SUPER)</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">6</td>
<td headers="flag_bits_m">ACC_VOLATILE (ACC_BRIDGE*)</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">7</td>
<td headers="flag_bits_m">ACC_TRANSIENT (ACC_VARARGS*)</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">8</td>
<td headers="flag_bits_m">ACC_NATIVE</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">9</td>
<td headers="flag_bits_m">ACC_INTERFACE</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">10</td>
<td headers="flag_bits_m">ACC_ABSTRACT</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">11</td>
<td headers="flag_bits_m">ACC_STRICT</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">12</td>
<td headers="flag_bits_m">ACC_SYNTHETIC</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">13</td>
<td headers="flag_bits_m">ACC_ANNOTATION</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">14</td>
<td headers="flag_bits_m">ACC_ENUM</td>
</tr>
<tr>
<td headers="flag_bits_b" align="right">16</td>
<td headers="flag_bits_m">overflow (more band data elsewhere)</td>
</tr>
</table>
<a name="tocAsFlBiAt" id="tocAsFlBiAt"></a>
<h5>5.5.1. Assignment of Flag Bits to Attributes</h5>
The assignment of flag bit positions to attributes is done at the
option of the compressor, and is independently specified by the
compressor for the four kinds of flag words that have to do with
attribute-carrying objects (in classes, fields, methods, and
codes). When a flag bit position is assigned to an attribute, if
that bit is visible in the class file, it must be forced clear
before the decompressor writes it to the class file. Therefore, if
the compressor expects the decompressor to reproduce a particular
non-zero flag bit as output, the compressor must refrain from
assigning that bit position to attributes.
<p>In particular, the low-order 16 bits of class, field, and method
flags are visible in the class file, and can thus carry modifier
bits. None of the bits of a code flags word is visible in the class
file; these flag bits are used only for code sub-attributes.</p>
<p>By contrast, the low-order 16 bits of nested class records are
used solely for modifiers, since nested class records do not
contain attributes. In the rest of this section on attributes, we
will disregard the flag words associated with nested class
records.</p>
<p>Any of the 63 bit positions in a flags value can be assigned by
the compressor to indicate to the decompressor the presence of some
particular attribute. The compressor may "take over" a modifier bit
by assigning it an attribute definition. (This is done by emitting
a definition for the attribute, which mentions that bit
position.)</p>
<p>If the compressor "takes over" a bit (modifier or not) that is
being used by default for another purpose, the bit loses its
previous meaning. However, the compressor may not emit an explicit
definition for the same bit twice (in the same context).</p>
<p>Each kind of attribute is defined by four pieces of information:
the entity to which it applies (class, field, method, or code), the
bit position, if any, to which it is assigned, the name of the
attribute (as it appears in the class file), and the layout of the
attribute (which allows the decompressor to properly format
occurrences of the attribute in the class file). It is an error for
the compressor to specify the same name and layout twice in the
same context. It is not an error to repeat a name with a different
layout, or a layout with a different name.</p>
<p>The first two items are bit-encoded into a single-byte "header",
and transmitted in the <tt>attr_definition_headers</tt> band. The
last two items are transmitted as <tt>cp_Utf8</tt> references in
corresponding elements of the <tt>attr_definition_name</tt> and
<tt>attr_definition_layout</tt>. Thus there are three bands by
which the compressor declares attribute types to the decompressor,
and each band is of length <tt>#attr_definition_count</tt>.</p>
<pre class="codeblock">
  attr_definition_bands:
        *attr_definition_headers :BYTE1 [#attr_definition_count]
        *attr_definition_name :UNSIGNED5 [#attr_definition_count] (cp_Utf8)
        *attr_definition_layout :UNSIGNED5 [#attr_definition_count] (cp_Utf8)

</pre>
<p>The least significant two bits of an attribute definition header
byte are treated as an unsigned field, and give the attribute's
<em>context type</em>, which is type of entity to which the
attribute applies:</p>
<table border="1" summary=
"description of least two significant bits of an attribute definition header byte">
<tr align="center">
<th id="l2sb_h"><tt>(h &amp; 0x03)</tt></th>
<th id="l2sb_c">Context Type</th>
</tr>
<tr>
<td headers="l2sb_h" align="right">0</td>
<td headers="l2sb_c">attribute applies to classes</td>
</tr>
<tr>
<td headers="l2sb_h" align="right">1</td>
<td headers="l2sb_c">attribute applies to fields</td>
</tr>
<tr>
<td headers="l2sb_h" align="right">2</td>
<td headers="l2sb_c">attribute applies to methods</td>
</tr>
<tr>
<td headers="l2sb_h" align="right">3</td>
<td headers="l2sb_c">attribute applies to Code attributes</td>
</tr>
</table>
<p>The most significant six bits of an attribute definition header
byte are treated as an unsigned field, and give the optional bit
position to which the attribute is assigned in the flags word.</p>
<table border="1" summary=
"definition of two most significant bits of an attribute definition header byte">
<tr align="center">
<th id="m2sb_h" align="right"><tt>(h &gt;&gt; 2)</tt></th>
<th id="m2sb_f">Flag Bit Assignment</th>
</tr>
<tr>
<td headers="m2sb_h" align="right">0</td>
<td headers="m2sb_f">overflow attribute, not assigned to any
bit</td>
</tr>
<tr>
<td headers="m2sb_h" align="right">1</td>
<td headers="m2sb_f">attribute assigned to bit 0 (LSB of lo
word)</td>
</tr>
<tr>
<td headers="m2sb_h" align="right">2</td>
<td headers="m2sb_f">attribute assigned to bit 1</td>
</tr>
<tr>
<td headers="m2sb_h" align="right">3</td>
<td headers="m2sb_f">attribute assigned to bit 2</td>
</tr>
<tr>
<td headers="m2sb_h" align="center">...</td>
<td headers="m2sb_f"></td>
</tr>
<tr>
<td headers="m2sb_h" align="right">32</td>
<td headers="m2sb_f">attribute assigned to bit 31 (MSB of lo
word)</td>
</tr>
<tr>
<td headers="m2sb_h" align="right">33</td>
<td headers="m2sb_f">attribute assigned to bit 32 (LSB of hi
word)</td>
</tr>
<tr>
<td headers="m2sb_h" align="center">...</td>
<td headers="m2sb_f"></td>
</tr>
<tr>
<td headers="m2sb_h" align="right">63</td>
<td headers="m2sb_f">attribute assigned to bit 62</td>
</tr>
<tr>
<td headers="m2sb_h" align="right">(no value)</td>
<td headers="m2sb_f">bit 63 must be zero (MSB of hi word)</td>
</tr>
</table>
<p>Every class attribute, whether predefined in this specification
or explicitly defined by the compressor, has a unique number called
its <em>attribute index</em>. If the attribute is assigned a flag
bit, then its attribute index is identical to the flag bit's
position (a number in [0..62]). (All predefined attributes are
assigned a flag bit by default.)</p>
<p>If a class attribute is not assigned a flag bit, it is an
overflow attribute, and its index is assigned sequentially in the
order in which class attributes are defined (i.e., transmitted).
The first index to be assigned sequentially in this way is 32 if
<tt>#have_class_flags_hi</tt> is clear, and 63 if it is set. These
indexes are used within the archive to declare attribute
occurrences for individual classes.</p>
<p>Likewise, field, method, and code attributes are assigned their
own attribute indexes, independently of class attributes and of
each other. Therefore, an attribute (i.e., a name and layout pair)
is uniquely specified within the archive by its context type and
attribute index. The field and method attributes may be assigned to
flag bits, or else they are overflow attributes with indexes of 32
or larger. Like other attributes, code attributes may be assigned
explicit numbers or implicitly assigned indexes starting with 32.
(As with class attributes, if the high flag word bands are selected
by the appropriate bit of <tt>#archive_options</tt>, then field,
method, or code overflow attributes have indexes of 63 or
larger.)</p>
<p>Some attributes are predefined, and do not require the
compressor to emit definitions for them. They have implicitly
defined layouts and flag bit assignments (i.e., indexes).</p>
<p>Attribute indexes less than 63 are usable in all cases, but they
may conflict with those assigned to predefined attributes,
including predefined attributes defined (in the range 16 to 62) in
future expansions of the Pack200 format. In the present version,
all predefined attributes have indexes in the range [17..31], so
that modifier flags are not taken over by default, and high flag
words do not need to be used routinely.</p>
<p>Here are the names and index assignments of the predefined
attributes. (The predefined layouts are given below.)</p>
<table border="1" summary=
"Names and index assignments of predefined attributes">
<tr align="center">
<th id="predef_i">Index</th>
<th id="predef_c">Context Type</th>
<th id="predef_n">Name</th>
</tr>
<tr>
<td headers="predef_i" align="right">16</td>
<td headers="predef_c">C,F,M</td>
<td headers="predef_n">(overflow attributes)</td>
</tr>
<tr>
<td headers="predef_i" align="right">17</td>
<td headers="predef_c">Class</td>
<td headers="predef_n">SourceFile</td>
</tr>
<tr>
<td headers="predef_i" align="right">18</td>
<td headers="predef_c">Class</td>
<td headers="predef_n">EnclosingMethod</td>
</tr>
<tr>
<td headers="predef_i" align="right">19</td>
<td headers="predef_c">C,F,M</td>
<td headers="predef_n">Signature</td>
</tr>
<tr>
<td headers="predef_i" align="right">20</td>
<td headers="predef_c">C,F,M</td>
<td headers="predef_n">Deprecated</td>
</tr>
<tr>
<td headers="predef_i" align="right">21</td>
<td headers="predef_c">C,F,M</td>
<td headers="predef_n">RuntimeVisibleAnnotations</td>
</tr>
<tr>
<td headers="predef_i" align="right">22</td>
<td headers="predef_c">C,F,M</td>
<td headers="predef_n">RuntimeInvisibleAnnotations</td>
</tr>
<tr>
<td headers="predef_i" align="right">23</td>
<td headers="predef_c">Class</td>
<td headers="predef_n">InnerClasses</td>
</tr>
<tr>
<td headers="predef_i" align="right">24</td>
<td headers="predef_c">Class</td>
<td headers="predef_n">"class-file version"</td>
</tr>
<tr>
<td headers="predef_i" align="right">17</td>
<td headers="predef_c">Field</td>
<td headers="predef_n">ConstantValue</td>
</tr>
<tr>
<td headers="predef_i" align="right">17</td>
<td headers="predef_c">Method</td>
<td headers="predef_n">Code</td>
</tr>
<tr>
<td headers="predef_i" align="right">18</td>
<td headers="predef_c">Method</td>
<td headers="predef_n">Exceptions</td>
</tr>
<tr>
<td headers="predef_i" align="right">23</td>
<td headers="predef_c">Method</td>
<td headers="predef_n">RuntimeVisibleParameterAnnotations</td>
</tr>
<tr>
<td headers="predef_i" align="right">24</td>
<td headers="predef_c">Method</td>
<td headers="predef_n">RuntimeInvisibleParameterAnnotations</td>
</tr>
<tr>
<td headers="predef_i" align="right">25</td>
<td headers="predef_c">Method</td>
<td headers="predef_n">AnnotationDefault</td>
</tr>
<tr>
<td headers="predef_i" align="right">26</td>
<td headers="predef_c">Method</td>
<td headers="predef_n">MethodParameters</td>
</tr>
<tr>
<td headers="predef_i" align="right">27</td>
<td headers="predef_c">C,F,M,Code</td>
<td headers="predef_n">RuntimeVisibleTypeAnnotations</td>
</tr>
<tr>
<td headers="predef_i" align="right">28</td>
<td headers="predef_c">C,F,M,Code</td>
<td headers="predef_n">RuntimeInvisibleTypeAnnotations</td>
</tr>
<tr>
<td headers="predef_i" align="right">0</td>
<td headers="predef_c">Code</td>
<td headers="predef_n">StackMapTable</td>
</tr>
<tr>
<td headers="predef_i" align="right">1</td>
<td headers="predef_c">Code</td>
<td headers="predef_n">LineNumberTable</td>
</tr>
<tr>
<td headers="predef_i" align="right">2</td>
<td headers="predef_c">Code</td>
<td headers="predef_n">LocalVariableTable</td>
</tr>
<tr>
<td headers="predef_i" align="right">3</td>
<td headers="predef_c">Code</td>
<td headers="predef_n">LocalVariableTypeTable</td>
</tr>
<tr>
<td headers="predef_i" align="right">16</td>
<td headers="predef_c">Code</td>
<td headers="predef_n">(overflow attributes)</td>
</tr>
</table>
<p>Bit 16 is predefined as an indicator of the presence of overflow
attributes for classes, fields, methods, and codes. If an entity
has overflow attributes, it will possess a corresponding count in
an "attr_count" band, and each overflow attribute will be part of a
run of values in an "attr_indexes" band, which specifies the
layouts of the overflow attributes. This processing of overflow
attributes is described more fully in the section <a href=
"#overflow_bits">Attribute Bands</a>.</p>
<p>These predefined attribute indexes determine not only which bit
positions are used to select those attributes, but also the fixed
band order in which the attribute data are transmitted, as
described in the section <a href="#def_order">Attribute Layout Definitions</a>.</p>
<p>Certain bits are predefined to support the five types of
metadata attributes on classes, fields, and methods,
<tt>RuntimeVisibleAnnotations</tt>,
<tt>RuntimeInvisibleAnnotations</tt>,
<tt>RuntimeVisibleParameterAnnotations</tt>,
<tt>RuntimeInvisibleParameterAnnotations</tt>, and
<tt>AnnotationDefault</tt>. (The last three types apply only to
methods.) The meaning and format of these attributes is defined by
JSR 175. Similarly type metadata attributes 
<tt>RuntimeVisibleTypeAnnotations</tt>
and
<tt>RuntimeInvisibleTypeAnnotations</tt>
on classes, fields, methods and code, are predefined. The meaning and format
of these attributes are defined and described by JSR 308.</p>
<p>It is permissible for a compressor to refrain from setting bits
in any flag words except for bit 16, and transmit all attribute
layout indexes explicitly in <tt>class_attr_indexes</tt> or a
similar band. Decompressors are required to process either kind of
occurrence of an attribute index. (It is also permissible, though
useless, for an attribute count to be an explicitly transmitted as
zero.) Compressors are encouraged to make clever choices and clear
bit 16 and set other assigned flag bits when possible.</p>
<p>Note that none of the predefined bits interfere with any present
or future flag bits in the 16-bit flag values stored in the class
file format. However, compressors are free to reuse one of the
low-order 16 bits of the flags word, by binding them to other
attributes, if no file actually sets them.</p>
<p>The <tt>InnerClasses</tt> attribute is treated specially, as
documented in the section <a href="#nested_classes">Nested Classes</a>, and it is an
error for the compressor to emit an attribute definition for it in
the class context. The <tt>Code</tt> attribute is also treated
specially. It is an error to emit an attribute definition for it in
the method context.</p>
<p>This specification does not define how a compressor is informed
of the existence or format of attributes which are not predefined.
It simply assumes that compressors are informed of such attributes,
and it requires that compressors properly transmit this information
to decompressors. As a special case, it is reasonable for any
compressor to transmit an attribute containing no bytes (i.e., of
zero length) as if its layout were known to be the empty
string.</p>
<a name="layouts" id="layouts"></a> <a name="tocAtLaDe" id=
"tocAtLaDe"></a>
<h5>5.5.2. Attribute Layout Definitions</h5>
Attribute layouts govern the compressor as it parses attribute
bodies from class files into collections of scalar values. Layouts
also govern the decompressor as it decodes transmitted bands of
those scalar values, and stores them, correctly formatted, into
class files. For example, when a class file stores an unsigned
integer in two bytes (in big-endian order) in an attribute, the
decompressor uses a layout declaration to this effect, so that it
can take a band element (which is a 32-bit integer that in this
case happens to be less than 65536) and store it correctly into a
class file. The transmission of such an integer is very different
from the transmission of a constant pool reference, even though
they appear as undifferentiated bytes in the class file format.
<p>In what follows, we say that some given element of an attribute
layout <em>governs</em> a scalar value stored in a class file
attribute, if the decompressor must use that element to
reconstitute, into a class file, the representation of that scalar
value. We also say that the given layout element governs the band
in which the scalar value is transmitted.</p>
<p>An attribute layout is defined by a string in a "little
language". The string must be parsed by the decompressor into a
sequence of <em>layout elements</em>, each of which governs the
transmission and storage of attribute values. In particular, the
layout declares the locations of all constant pool references,
allowing their values to be transmitted with appropriate
representations, either as constant pool indexes or else some other
sort of number.</p>
<p>The simplest usable attribute layout would be a sequence of
constant pool reference declarations, intermixed with one-byte
declarations to govern everything else, and compressors are free to
use such layouts to describe attributes. However, more specific
attribute layouts lead to better compression.</p>
<p>Attributes typically contain constant pool references and small
integers. They often contain integers which control the replication
of subsequent patterns. Constant pool references are strongly typed
where possible, and the encoding provision for null references must
be declared also. Small integers which encode flag bits or bytecode
indexes are also declared as such, so that special encoding
techniques may be used on them.</p>
<p>Layout declarations are UTF8 strings formed according to the
following grammar. (This grammar is independent of the grammar
which describes band structure, or any other grammar appearing in
other parts of this specification.)</p>
<pre class="codeblock">
  attribute_layout:
        ( layout_element )* | ( callable )+
  layout_element:
        ( integral | replication | union | call | reference )

  callable:
        '[' body ']'
  body:
        ( layout_element )+

  integral:
        ( unsigned_int | signed_int | bc_index | bc_offset | flag )
  unsigned_int:
        uint_type
  signed_int:
        'S' uint_type
  any_int:
        ( unsigned_int | signed_int )
  bc_index:
        ( 'P' uint_type | 'PO' uint_type )
  bc_offset:
        'O' any_int
  flag:
        'F' uint_type
  uint_type:
        ( 'B' | 'H' | 'I' | 'V' )

  replication:
        'N' uint_type '[' body ']'

  union:
        'T' any_int (union_case)* '(' ')' '[' (body)? ']'
  union_case:
        '(' union_case_tag (',' union_case_tag)* ')' '[' (body)? ']'
  union_case_tag:
        ( numeral | numeral '-' numeral )
  call:
        '(' numeral ')'

  reference:
        reference_type ( 'N' )? uint_type
  reference_type:
        ( constant_ref | schema_ref | utf8_ref | untyped_ref )
  constant_ref:
        ( 'KI' | 'KJ' | 'KF' | 'KD' | 'KS' | 'KQ' | 'KM' | 'KT' | 'KL' )
  schema_ref:
        ( 'RC' | 'RS' | 'RD' | 'RF' | 'RM' | 'RI' | 'RY' | 'RB' | 'RN' )
  utf8_ref:
        'RU'
  untyped_ref:
        'RQ'

  numeral:
        '(' ('-')? (digit)+ ')'
  digit:
        ( '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' )
 
</pre>
<p>Each occurrence of an attribute in a class file is associated
(by the compressor) with a corresponding layout definition which
describes accurately the meaning of that attribute's bytes. The
compressor must assign each format element its own band for
transmitting successive values of that format element. In the case
of the predefined attributes, the bands assigned to their layout
elements are defined by name in this specification.</p>
<p>Each value governed by an attribute layout element is converted
by the compressor into a 32-bit value and transmitted as an element
of a band uniquely created for and governed by that layout element.
For <tt>integral</tt> layout elements, the conversion simply
represents the number stored in the class file under the given
type, while <tt>reference</tt> elements convert a local constant
pool reference (local to the class file, that is) into a global,
typed reference within the archive.</p>
<p>Multiple occurrences of the same kind of layout element are
regarded as distinct layout elements. Also, bands are never shared
by layouts. Therefore, every new layout definition transmitted by
the compressor implicitly defines its own set of bands. Reassigning
an previously defined attribute layout to a new index creates a new
set of bands; it does not reuse the previously defined sets of
bands.</p>
<p>If the compressor defines new attributes, it must also create
the bands they govern. It must transmit these bands, immediately
after the place reserved in the band grammar for predefined
attributes (at the end of <tt>class_attr_bands</tt>, <tt>field_attr_bands</tt>,
<tt>method_attr_bands</tt>, or <tt>code_attr_bands</tt>). The
ordering of these bands must correspond to the definition order of
the attribute layout elements that govern them. In this way, the
decompressor will be able to find those attribute values.</p>
<a name="def_order" id="def_order"></a>
<p>The <em>definition order</em> of two layout elements in the same
attribute layout string corresponds to their order of occurrence
within that string. The definition order of two layout elements not
in the same attribute layout string corresponds to the index order
of their layout definitions in the <tt>attr_definition_layout</tt>
band. (That is, bands for layouts with lower indexes precede bands
for layouts of the same context type but with higher indexes. This
is true even if the lower-indexed layout happens to be defined
later in the <tt>attr_definition_layout</tt> band.) Note that the
bands governed by predefined attributes appear to follow such an
ordering also. However, the bands of predefined class attributes
precede all the other class attribute bands, and likewise for
fields, methods, and code attributes.</p>
<p>Integer values stored in attributes are sized as 1, 2, or 4
bytes, depending on the use of the format character 'B', 'H', or
'I', respectively. A integer type is normally unsigned but prefixed
with 'S' becomes signed. This signing governs the lengthening of
1-byte and 2-byte types to 32-bit values (either sign extension or
zero filling). It also determines the primary encoding used to
transmit the 32-bit values. Because all integers stored in class
files are "big-endian", all integral format elements refer to
integers coded with higher-order bits in earlier bytes.</p>
<p><tt>Integral</tt> layouts (i.e., those elements under the
<tt>integral</tt> nonterminal) govern signed or unsigned integer
values. Integral layouts whose declarations include the 'P' or 'O'
characters use special primary encodings (BCI5 or BRANCH5) as
described below. Any other integral layouts whose declarations
include the 'S' character govern bands with a primary encoding of
SIGNED5. Unsigned integer and flag layout elements govern bands
with a primary encoding of UNSIGNED5, except that the integer
layout 'B' (unsigned byte) governs a band with a primary encoding
of BYTE1.</p>
<p>(Note that there is no special encoding for signed bytes. If an
attribute contains a signed byte field, it may be just as well to
treat that field as if it were unsigned, and give it a plain 'B'
layout element. Besides completeness, the 'SB' layout is intended
to allow small-magnitude one-byte integers to be transmitted using
a byte alphabet in which sign bits are rare. This is desirable when
the post-pass compressor uses Huffman coding to represent bytes;
such codings perform best when a consistent byte alphabet is
presented to the compressor.)</p>
<p>A stored bytecode index is declared with the layout prefix 'P'.
This layout element may only be used on methods or codes. Any
number may be stored in a bytecode index. However, before the
stored numbers are transmitted as band elements, they are
renumbered in the expectation that byte positions not on
instruction boundaries will be rare.</p>
<a name="bci_psc_ref" id="bci_psc_ref"></a> <a name=
"bci_renumbering" id="bci_renumbering"></a>
<p>The <em>BCI renumbering</em> compactly indexes instruction
boundaries, and also provides a coding (somewhat less compact) for
all other 32-bit integers, such as the addresses of bytes inside
instructions or outside the bounds of the bytecodes. In particular,
the first byte of the first instruction is numbered zero, the first
byte of the second instruction is numbered one, and so on through
all instructions. The byte position one past the last instruction
is numbered with the next number (the number of instructions). The
second byte of the first multibyte instruction is numbered with the
next number, which is one more than the number of all instructions.
All remaining unnumbered bytes are assigned subsequent numbers,
without any further disturbances of ordering. For large enough
positive numbers, and for negative numbers, the renumbering is the
identity function.</p>
<p>For purposes of locating instruction boundaries for BCI
renumbering, the _wide bytecode (0xc4) is taken to be part of the
following instruction, whose format it helps determine. If the
compressor transmits byte_escape (254) or ref_escape (253)
pseudo-instructions, the decompressor must accept the bytecode
sequences produced by each of these instructions as integral
instructions, when computing BCI renumberings. Thus, there will be
an instruction boundary for each byte in bc_codes (except _wide
bytecodes), plus an extra boundary for each "aload_0_xxx" variation
(such as "aload_0_getstatic_this"), because these pseudo-opcodes
expand to pairs of bytecode instructions.</p>
<p>Please see the Appendix section <a href=
"#bci_psc">Representation of Byte Offsets</a> for pseudo-code explaining this concept.</p>
<p>If the layout element is prefixed by 'P' and not 'PO', then the
renumbered bytecode index is transmitted. This renumbering is
called the <em>bytecode index renumbering</em>. The primary
encoding for bands containing bytecode indexes is BCI5.</p>
<p>Here is an example of how this works. Imagine a method with 20
bytes of bytecode data and five instructions, at the following
positions: <tt>{ 0, 4, 6, 10, 17 }</tt>. BCI renumbering translates
these particular numbers compactly to <tt>[0..4]</tt>. More
completely, BCI renumbering translates <tt>[0..20]</tt> to the
numbers <tt>{ 0, 6, 7, 8, 1, 9, 2, 10, 11, 12, 3, 13, 14, 15, 16,
17, 18, 4, 19, 20, 5 }</tt>, and anything outside the range
<tt>[0..20]</tt> stays the same after BCI renumbering. If a
attribute of this method has a 'P' layout element, and has the
number 6 stored in the class file, the number 2 will be
transmitted, since 6 is the offset of the third instruction.</p>
<p>If the layout prefix is 'PO', the previous layout element must
also have been a bytecode index of layout type 'P' or 'PO'. (There
must not be intervening structure, such as brackets '[' or ']'.) In
this case, the value transmitted in the band governed by the 'PO'
element is the difference between the renumbered bytecode index
governed by the current 'PO' element, and the renumbered bytecode
index governed by the previous 'P' or 'PO' element. (In the case of
a previous 'P' element, this is in fact the value transmitted at
the corresponding position in the previous band.)</p>
<p>The 'PO' layout elements govern the same kind of attribute data
as 'P' elements, but they use an encoding which expects that
adjacent bytecode indexes are correlated. This renumbering,
including a difference with the previous element, is called the
<em>bytecode offset renumbering</em> The primary encoding for bands
containing bytecode offsets is BRANCH5. This encoding is used even
if the layout element contains the 'S' or the 'B' character.</p>
<p>A bytecode offset is declared with the layout prefix 'O'. This
layout element must immediately follow a previous bytecode index
element (with prefix 'P' and not 'PO'). Any value governed by this
layout element is regarded as an offset, which when applied to the
corresponding previously stored bytecode index, produces another
bytecode index. That is, both the previous value and the sum of the
previous value and the current value are expected to refer to
instruction boundaries. As with the 'PO' layout, the value
transmitted is the difference of the two renumbered bytecode
indexes. Bands governed by 'PO' layouts contain bytecode offsets,
and use the BRANCH5 primary encoding. Unlike the 'PO' layout, the
stored value governed by an 'O' layout is the difference between
two bytecode indexes.</p>
<p>Thus, bands governed by both 'O' and 'PO' layouts contain
bytecode offsets, and use BRANCH5 to encode those offsets. But
attribute values governed by both 'P' and 'PO' layouts store
absolute bytecode indexes; only 'O' layouts govern stored bytecode
offsets. The stored offsets are treated as unsigned fields in the
class file unless the 'S' character is present. By contrast, stored
indexes are always treated as unsigned fields.</p>
<p>If the preceding example attribute for a 20-byte method also has
a 'PO' layout element following its 'P' element, and the number 20
is stored in the class file, the number to be transmitted is found
by renumbering 20 to 5, and then subtracting the previous
transmitted number (5-2). The number 3 will therefore be
transmitted. If instead the stored number is 7 (a BCI inside the
instruction at position 6), the transmitted number will be (10-2)
or 8. The same transmitted values (3, 8), if governed by an 'O'
layout element instead of 'PO', would correspond to stored values
of 14 (20-6) and 1 (7-6), instead of 20 and 7.</p>
<p>A flag element (with prefix 'F') encodes integer values which
are expected to encode short array of bits, rather than arithmetic
values. The bits are not required to be interpreted as access
modifiers. The primary encoding for bands transmitting flag layout
elements is UNSIGNED5, except that 'FB' layouts use a primary
encoding of BYTE1.</p>
<p>Integral values transmitted under the 'V' format character
instead of 'B', 'H', or 'I' occupy no bytes at all in the class
file attribute. These layout elements allow the decompressor to use
counts or tags to control transmission without having them appear
directly in class file attributes. For example, consider an
attribute which is an array of bytes that is not self-sizing but
expands to fill the byte-count mentioned in the attribute header in
the class file. Such an attribute might have a layout specification
of 'NV[B]'. The compressor would be responsible to decide which
values to transmit for a 'V' layout element. (Such decisions would
have to make use of detailed information about attribute formats
that is not part of this specification.) In all cases, the
decompressor must respect these values (when used as counts or
tags) but must not store them in the class file.</p>
<p>A <em>replication</em> is introduced by a prefix 'N', which is
followed by an integer element called the <em>replication
count</em>, and by then a series of elements, called the
<em>replication body</em>, enclosed in square brackets. The
attribute data governed by this layout consists of a replication
count followed by an array of data counted by the replication
count. Each array element is governed by the layouts in the
replication body.</p>
<p>A replication count layout element governs a band transmitting
the replication counts, which has a primary encoding of UNSIGNED5
(or BYTE1, if the layout starts with 'NB'). The bands governed by
the corresponding replication body may be sized by summing the
values transmitted in the band containing the counts.</p>
<p>A <em>union</em> is introduced by a prefix 'T', which is
followed by an integer element called the <em>union tag</em>, and
by then a series of labeled, bracketed groups of elements, called
the <em>union cases</em>. (The numerals can have any number of
digits, but their arithmetic values are truncated to 32-bit
integers before being compared with band values, which also are 32
bits in size.) Each label but the last consists of one or more
parenthesized, possibly signed decimal numerals, called <em>union
tags</em>. The last label (which is the default case) must be an
empty pair of parentheses. (No union may contain two occurrences of
the same case tag.) The attribute data governed by this layout
consists of an integral tag value followed by data whose format is
determined by the tag. The data following the tag is governed by
the (unique) union case whose label matches the tag's value, or
else the default case. The bands governed by each union case may be
sized by counting the number of values in the band governed by the
tag's layout. As with plain integral bands, the primary encoding of
union tag band is SIGNED5, BYTE1, or UNSIGNED5, depending on
whether the layout contains an 'S' character, is 'TB', or
otherwise.</p>
<p>In a union tag, two numerals separated by a hyphen specify an
inclusive range. The second number must be greater than the first.
This is an abbreviation for the list of all numerals from the first
to the second, inclusive. The layout is treated exactly as if the
abbreviation were replaced by the complete list.</p>
<p>Constant pool references in an attribute may be typed strongly,
and transmitted as indexes into one of the archive's constant
pools. The layout types beginning with 'KI', 'KJ', 'KF', 'KD', and
'KS' must govern stored indexes in the local constant pool to
constants of type integer, long, float, double, and string. The
layout types beginnig 'KM' and 'KT' govern indexes to constants of
type MethodHandle and MethodType. Likewise, the layout types
beginning with 'RC', 'RS', 'RD', 'RF', 'RM', 'RI', and 'RU' must
govern stored indexes in the local constant pool to symbols of type
class, signature, descriptor (pair of name and type), field
reference, method reference, interface method reference, and UTF8
string. The layout type 'RY' governs indexes to invokedynamic
descriptors, while the type 'RB' governs indexes to bootstrap
method specifiers (which are elements of the
<tt>BootstrapMethods</tt> attribute, not of the constant pool). All
these references are transmitted as 32-bit indexes into the
corresponding global constant pools, in bands with primary encoding
of UNSIGNED5. (This is true even of layouts which contain 'B'.) See
table below.</p>
<p>Note that signature references (layout 'RS') are identical to
Utf8 references (layout 'RU') within a class file, but lead to
different coding tactics in the archive file, since the
<tt>cp_Utf8</tt> and <tt>cp_Signature</tt> constant pools have
independent indexes and are transmitted differently.</p>
<p>The layout elements beginning 'KQ' may only occur in attributes
on fields. They refer to constants in a constant pool whose
identity is determined by the field's signature. (This layout
element is probably useful only for <tt>ConstantValue</tt>
attributes, which are predefined.) The following table gives field
signatures legal for use with 'KQ' layouts, and the corresponding
constant pools in which the corresponding stored references must be
found.</p>
<table border="1" summary=
"field signatures for use with KQ layouts">
<tr align="center">
<th id="kq_f">Field Signature</th>
<th id="kq_c">'KQ' Constant Pool</th>
</tr>
<tr>
<td headers="kq_f">B</td>
<td headers="kq_c">cp_Int</td>
</tr>
<tr>
<td headers="kq_f">S</td>
<td headers="kq_c">cp_Int</td>
</tr>
<tr>
<td headers="kq_f">C</td>
<td headers="kq_c">cp_Int</td>
</tr>
<tr>
<td headers="kq_f">Z</td>
<td headers="kq_c">cp_Int</td>
</tr>
<tr>
<td headers="kq_f">I</td>
<td headers="kq_c">cp_Int</td>
</tr>
<tr>
<td headers="kq_f">J</td>
<td headers="kq_c">cp_Long</td>
</tr>
<tr>
<td headers="kq_f">F</td>
<td headers="kq_c">cp_Float</td>
</tr>
<tr>
<td headers="kq_f">D</td>
<td headers="kq_c">cp_Double</td>
</tr>
<tr>
<td headers="kq_f">Ljava/lang/String;</td>
<td headers="kq_c">cp_String</td>
</tr>
<tr>
<td headers="kq_f">Ljava/lang/Class;</td>
<td headers="kq_c">cp_Class</td>
</tr>
</table>
<p>Three additional layout types transmit indexes into constant
pool groups, instead of individual constant pools. They may be used
when the compressor elects to use a layout which has references
that are not strongly typed. The combined type 'KL' may be used for
any index that refers to a valid operand of the 'ldc' instruction,
and the transmitted indexes will be renumbered relative to the
<tt>cp_LoadableValue</tt> pool group. Similarly, the combined
layout type 'RN' may be used for any index that refers to a valid
operand of any of the 'get' or 'invoke' instructions (except
'invokedynamic'), and these indexes will renumbered relative to the
<tt>cp_AnyMember</tt> pool group.</p>
<p>Finally, if a constant pool reference cannot be typed at all,
the compressor must use an <tt>untyped_ref</tt> ('RQ'), which
transmits an index into the comprehensive constant pool group
<tt>cp_All</tt>. For example, all the elements of the
<tt>cp_Utf8</tt> pool are numbered the same in the 'RQ' and 'RU'
layouts. But the first element (element zero) of the
<tt>cp_Int</tt> pool is numbered, for untyped references, as
<tt>cp_Utf8_count</tt>, and the first element of the
<tt>cp_Float</tt> pool is numbered, for untyped references, as
<tt>cp_Utf8_count+cp_Int_count</tt>.</p>
<p>If a compressor is faced with an attribute which contains a
constant pool index of an unexpected type, it may either refuse to
transmit the attribute, or elect to transmit the attribute under a
relaxed layout definition using 'RQ' or 'RQN' elements instead of
more strongly-typed elements. (If the unexpected type is a loadable
constant or member reference, the compressor may elect to use 'RN'
or 'KL' elements instead.) Decompressors are required to honor all
legal layout definitions transmitted by compressors, even if they
might produce illegally formatted class files. (In an extreme case,
a compressor may elect to transmit a class file as if it were a
resource file, obtaining no class-specific compression, but
preserving unusually formatted attributes with bit-for-bit
accuracy.)</p>
<p>If a <tt>reference</tt> layout type includes the character 'N',
all band values encoding constant pool entries are incremented by
one, and the null value is encoded as zero. Otherwise, the null
value is encoded as negative one (-1).</p>
<p>The effect on primary band encodings of the rules given above
may be summarized as a list of prioritized rules for layout
elements, where the first applicable rule determines the
encoding:</p>
<ul>
<li>If the layout contains 'O', use BRANCH5.</li>
<li>Otherwise, if the layout contains 'P', use BCI5.</li>
<li>Otherwise, if the layout contains 'S' but not 'KS' or 'RS', use
SIGNED5.</li>
<li>Otherwise, if the layout contains 'B' but not 'RB', use
BYTE1.</li>
<li>For all other layouts use UNSIGNED5.</li>
</ul>
<p>Here is a table summarizing bands and encodings for various
layout elements. (Not all possible combinations of types and
integer sizes are shown.)</p>
<table border="1" summary=
"summary of bands and encodings for various layout elements">
<tr align="center">
<th id="layout_l">Layout<br />
Element</th>
<th id="layout_s">Stored<br />
Value</th>
<th id="layout_t">Transmitted<br />
Value</th>
<th id="layout_p">Primary<br />
Encoding</th>
</tr>
<tr>
<td headers="layout_l">B</td>
<td headers="layout_s">u1</td>
<td headers="layout_t">x</td>
<td headers="layout_p">BYTE1</td>
</tr>
<tr>
<td headers="layout_l">FB</td>
<td headers="layout_s">u1</td>
<td headers="layout_t">x</td>
<td headers="layout_p">BYTE1</td>
</tr>
<tr>
<td headers="layout_l">SB</td>
<td headers="layout_s">u1</td>
<td headers="layout_t">(byte)x</td>
<td headers="layout_p">SIGNED5</td>
</tr>
<tr>
<td headers="layout_l">H</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">x</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">FH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">x</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">SH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">(short)x</td>
<td headers="layout_p">SIGNED5</td>
</tr>
<tr>
<td headers="layout_l">I</td>
<td headers="layout_s">u4</td>
<td headers="layout_t">x</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">FI</td>
<td headers="layout_s">u4</td>
<td headers="layout_t">x</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">SI</td>
<td headers="layout_s">u4</td>
<td headers="layout_t">x</td>
<td headers="layout_p">SIGNED5</td>
</tr>
<tr>
<td headers="layout_l">PH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">renumber_bci(x)</td>
<td headers="layout_p">BCI5</td>
</tr>
<tr>
<td headers="layout_l">POH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">renumber_bci(x) - renumber_bci(x0)</td>
<td headers="layout_p">BRANCH5</td>
</tr>
<tr>
<td headers="layout_l">OH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">renumber_bci(x0+x) - renumber_bci(x0)</td>
<td headers="layout_p">BRANCH5</td>
</tr>
<tr>
<td headers="layout_l">NB[...]</td>
<td headers="layout_s">u1</td>
<td headers="layout_t">x <em>(also serves as size count)</em></td>
<td headers="layout_p">BYTE1</td>
</tr>
<tr>
<td headers="layout_l">NH[...]</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">x <em>(also serves as size count)</em></td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">NI[...]</td>
<td headers="layout_s">u4</td>
<td headers="layout_t">x <em>(also serves as size count)</em></td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">TB...</td>
<td headers="layout_s">u1</td>
<td headers="layout_t">x</td>
<td headers="layout_p">BYTE1</td>
</tr>
<tr>
<td headers="layout_l">TSB...</td>
<td headers="layout_s">u1</td>
<td headers="layout_t">(byte)x</td>
<td headers="layout_p">SIGNED5</td>
</tr>
<tr>
<td headers="layout_l">TH...</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">x</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">TSH...</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">(short)x</td>
<td headers="layout_p">SIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KIB</td>
<td headers="layout_s">u1</td>
<td headers="layout_t">indexOf(lcp[x], cp_Int)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KIH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_Int)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KII</td>
<td headers="layout_s">u4</td>
<td headers="layout_t">indexOf(lcp[x], cp_Int)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KINH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">1+indexOf(lcp[x], cp_Int)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KJH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_Long)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KFH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_Float)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KDH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_Double)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KSH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_String)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KQH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_FieldSpecific)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KMH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_MethodHandle)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KTH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_MethodType)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">KLH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_LoadableValue)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RCH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_Class)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RSH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_Signature)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RDH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_Descr)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RFH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_Field)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RMH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_Method)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RIH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_Imethod)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RUH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_Utf8)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RQH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_All)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RQNH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">1+indexOf(lcp[x], cp_All)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RQNI</td>
<td headers="layout_s">u4</td>
<td headers="layout_t">1+indexOf(lcp[x], cp_All)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RYH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_InvokeDynamic)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RBH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(class.BootstrapMethods[x],
cp_BootstrapMethod)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
<tr>
<td headers="layout_l">RNH</td>
<td headers="layout_s">u2</td>
<td headers="layout_t">indexOf(lcp[x], cp_AnyMember)</td>
<td headers="layout_p">UNSIGNED5</td>
</tr>
</table>
<p>Here, the variable <em>x</em> names a value stored in the
attribute, governed by the layout element. The variable <em>x0</em>
names the stored value governed by the immediately previous layout
element, which must have begun with 'P'. The expression
<em>renumber_bci(x)</em> denotes the renumbering of a bytecode
index <em>x</em> to shorten references to instruction boundaries,
as described above. The expression <em>lcp[x]</em> denotes a local
constant pool reference, with index <em>x</em>, or a distinct null
value if <em>x</em> is zero.</p>
<p>The expression <em>class.BootstrapMethods[x]</em> denotes an
element of the <tt>BootstrapMethods</tt> attribute of the current
class. This attribute contains additional complex constants
required by <tt>CONSTANT_InvokeDynamic</tt> constant pool
entries.</p>
<p>The expression <em>indexOf(lcp[x], cp)</em> denotes the index
(zero-based) in a Pack200 global constant pool <em>cp</em> of the
constant <em>lcp[x]</em>, which is assumed to be of a type
appropriate to <em>cp</em>. This expression has the value -1 if
<em>lcp[x]</em> has the distinct null value.</p>
<p>Note that a null reference can always be transmitted in a band
containing references, by transmitting the value zero (if the band
is specified to accept nulls) or by transmitting the value -1
(otherwise). The UNSIGNED5 encoding can represent -1 in five
bytes.</p>
<p>The name <em>cp_FieldSpecific</em> refers to a global constant
pool selected by the enclosing field's signature, as described
above.</p>
<a name="tocRecLay" id="tocRecLay"></a>
<h5>5.5.3. Recursive Layouts</h5>
The top-level structure of a layout specification may be a series
of bodies which are independently <em>callable</em> layouts. In
such a case, the attribute data governed by the whole layout
specification is governed by the first body in the sequence of
callables. The other callables can govern data, but they only do
this if they are actually called. The effect is to define a
mutually recursive set of layout specifications, and give control
to the first. Note that callables may not be nested inside any
other syntax. This feature is useful for supporting recursively
structured class file attributes, such as metadata.
<p>A <em>call</em> layout element is a parenthesized signed decimal
numeral <em>N</em>. It refers to the <em>N</em>th <em>callable</em>
in the top-level structure of the layout specification, relative to
the callable in which the call appears. (It is illegal for calls to
appear outside of callables.) We will refer to this callable as the
call's <em>callee</em>.</p>
<p>(For example, the layout element '(2)' calls the second callable
layout after the one in which the call appears. There must be a
matching callee for every callable. A call spelled '(1)' must not
appear in the last callable of a layout, and likewise a call
spelled '(-1)' must not occur in the first callable. Note that the
self-call spelled '(0)' is always legal.)</p>
<p>A <em>call</em> layout element indirectly governs the attribute
data more directly governed by the callable that the layout element
calls. As far as class file format is concerned, the effect is the
same as if the text within the callable's body were substituted
instead of the call.</p>
<p>However, this substitution semantics does not describe the
effect of a call layout element on band structure. A call layout
element does not directly govern any bands, but rather specifies
that the data it indirectly governs is to be transmitted in the
bands governed more directly by the callee.</p>
<p>If a call's callee begins textually later than the call itself,
the call is a <em>forward call</em>. The effect of a forward call
is simply to make the bands of the callee sharable by the call and
any other forward calls to the same callee. For example, the
following layout specification has two bands, the latter of which
transmits data indirectly governed by either of the union cases.
(The default union case governs no bands, so that a tag byte other
than ASCII 'A' or 'B' has no following bytes. Whitespace has been
added to the layout for ease of reading.)</p>
<pre class="codeblock">
        [TB
          (65) [(1)]
          (66) [(1)]
          (  ) []
          ]
        [H]
 
</pre>
<p>A call's callee can also begin textually earlier than the call
itself. Such a call, which must have a spelling of the form '(0)'
or '(-<em>N</em>)', is referred to as a <em>backward call</em>. Its
callee is referred to as a <em>backward callable</em>. (Callables
which are the target of no calls or only of forward calls are not
backward callables; all others are.) Backward calls and callables
introduce the possibility of recursion and looping. Here is an
example of an N-ary tree whose leaves are Utf8 strings preceded by
a zero-byte, and whose internal nodes are counted arrays of tree
nodes preceded by a one-byte: In this example, the callee encloses
the call, for a direct recursion. The layout governs three bands,
under the elements 'TB', 'NH', and 'RUH'.</p>
<pre class="codeblock">
        [TB
          (1) [NH[ (0) ]]
          (0) [RUH]
        ]
 
</pre>
<p>The sizing of bands governed by such mutually-recursive layouts
is assisted by explicit counts of backward calls, transmitted
before any of the layout's attribute bands, in
<tt>class_attr_calls</tt> and three similar bands, which are
described later.</p>
<a name="tocDeAtLa" id="tocDeAtLa"></a>
<h5>5.5.4. Default Attribute Layouts</h5>
The layout definitions of the predefined attributes are as follows:
<table border="1" summary=
"layout definitions for predefined attributes">
<tr align="center">
<th id="predef_attr_layout_c">Context Type</th>
<th id="predef_attr_layout_n">Name</th>
<th id="predef_attr_layout_l">Layout Definition</th>
</tr>
<tr>
<td headers="predef_attr_layout_c">Class</td>
<td headers="predef_attr_layout_n">"class-file version"</td>
<td headers="predef_attr_layout_l"><em>(empty) *(see
note)</em></td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Class</td>
<td headers="predef_attr_layout_n">InnerClasses</td>
<td headers="predef_attr_layout_l"><em>(empty) *(see
note)</em></td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Class</td>
<td headers="predef_attr_layout_n">EnclosingMethod</td>
<td headers="predef_attr_layout_l">RCHRDNH</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Class</td>
<td headers="predef_attr_layout_n">SourceFile</td>
<td headers="predef_attr_layout_l">RUNH *(see note)</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Class</td>
<td headers="predef_attr_layout_n">Signature</td>
<td headers="predef_attr_layout_l">RSH</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Class</td>
<td headers="predef_attr_layout_n">(metadata)</td>
<td headers="predef_attr_layout_l">(see <a href="#md_lo">Metadata Layouts</a>)</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Class</td>
<td headers="predef_attr_layout_n">Deprecated</td>
<td headers="predef_attr_layout_l"><em>(empty)</em></td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Class</td>
<td headers="predef_attr_layout_n">(type metadata)</td>
<td headers="predef_attr_layout_l">(see <a href="#md_lo">Metadata Layouts</a>)</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Field</td>
<td headers="predef_attr_layout_n">ConstantValue</td>
<td headers="predef_attr_layout_l">KQH</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Field</td>
<td headers="predef_attr_layout_n">Signature</td>
<td headers="predef_attr_layout_l">RSH</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Field</td>
<td headers="predef_attr_layout_n">(metadata)</td>
<td headers="predef_attr_layout_l">(see <a href="#md_lo">Metadata Layouts</a>)</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Field</td>
<td headers="predef_attr_layout_n">Deprecated</td>
<td headers="predef_attr_layout_l"><em>(empty)</em></td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Field</td>
<td headers="predef_attr_layout_n">(type metadata)</td>
<td headers="predef_attr_layout_l">(see <a href="#md_lo">Metadata Layouts</a>)</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Method</td>
<td headers="predef_attr_layout_n">Code</td>
<td headers="predef_attr_layout_l"><em>(empty) *(see
note)</em></td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Method</td>
<td headers="predef_attr_layout_n">Exceptions</td>
<td headers="predef_attr_layout_l">NH[RCH]</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Method</td>
<td headers="predef_attr_layout_n">Signature</td>
<td headers="predef_attr_layout_l">RSH</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Method</td>
<td headers="predef_attr_layout_n">(metadata)</td>
<td headers="predef_attr_layout_l">(see <a href="#md_lo">Metadata Layouts</a>)</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Method</td>
<td headers="predef_attr_layout_n">Deprecated</td>
<td headers="predef_attr_layout_l"><em>(empty)</em></td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Method</td>
<td headers="predef_attr_layout_n">MethodParameters</td>
<td headers="predef_attr_layout_l">NB[RUNHFH]</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Method</td>
<td headers="predef_attr_layout_n">(type metadata)</td>
<td headers="predef_attr_layout_l">(see <a href="#md_lo">Metadata Layouts</a>)</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Code</td>
<td headers="predef_attr_layout_n">StackMapTable</td>
<td headers="predef_attr_layout_l">(see <a href="#sm_lo">Stack Map Layouts</a>)</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Code</td>
<td headers="predef_attr_layout_n">LineNumberTable</td>
<td headers="predef_attr_layout_l">NH[PHH]</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Code</td>
<td headers="predef_attr_layout_n">LocalVariableTable</td>
<td headers="predef_attr_layout_l">NH[PHOHRUHRSHH]</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Code</td>
<td headers="predef_attr_layout_n">LocalVariableTypeTable</td>
<td headers="predef_attr_layout_l">NH[PHOHRUHRSHH]</td>
</tr>
<tr>
<td headers="predef_attr_layout_c">Code</td>
<td headers="predef_attr_layout_n">(type metadata)</td>
<td headers="predef_attr_layout_l">(see <a href="#md_lo">Metadata Layouts</a>)</td>
</tr>
</table>
<p>The star '*' in the layout definitions of "class-file version",
<tt>InnerClasses</tt>, <tt>SourceFile</tt>, and <tt>Code</tt>
reflects the fact that these attributes are given special
processing. For a class, the "<a href=
"#special_version_number">class-file version</a>" pseudo-attribute
is transmitted as if using the format <tt>VV</tt>, but the
decompressor does not store the result in a class file attribute,
but rather in the class file header. (See the discussion in the section <a href=
"#special_version_number">Attribute Bands</a>.) For a class, the
<tt>InnerClasses</tt> attribute is partially transmitted as if
using the format <tt>NV[RCVTV[(0)[]()[RCNVRUNV]]]</tt>, but the
decompressor processes the received values further before
(possibly) emitting an <tt>InnerClasses</tt> attribute. (See the
discussion in the section <a href="#ic_local_bands">Local InnerClasses Attributes</a>.) When a
<tt>SourceFile</tt> attribute is transmitted using the predefined
layout, a special rule allows it to default to the obvious standard
string. Finally, for a method, the <tt>Code</tt> attribute is
transmitted under the <tt>code_bands</tt>. <!--
 Other known attribute formats:
        class   SourceID                "RUH"
        class   CompilationID           "RUH"
        code    CharacterRangeTable     "NH[PHPOHIIH]"
        code    CoverageTable           "NH[PHHII]"
        method  Code                    "HHNI[B]NH[PHPOHPOHRCNH]NH[RUHNI[B]]"

Special compression tactics on attributes:
 - SourceFile: demangle class name, remove package, add ".java"
 - Code
   * NO: (ACC_NATIVE|ACC_ABSTRACT)
   * I (# bytes) implicit up to _end marker
   * 4 H's (SLHA) treated as one-byte tuple
   * handler rows are positively differenced mod code size
--></p>
<a name="sm_lo" id="sm_lo"></a> <a name="tocStMaLa" id=
"tocStMaLa"></a>
<h5>5.5.5. Stack Map Layouts</h5>
There is a predefined attribute layout for the
<tt>StackMapTable</tt> attribute of a <tt>Code</tt> attribute. With
some whitespace and abbreviation added for readability, it is as
follows:
<pre class="codeblock">
<tt>
  [NH[(1)]]
  [TB
    (64-127)  [(2)]
    (247)     [(1)(2)]
    (248-251) [(1)]
    (252)     [(1)(2)]
    (253)     [(1)(2)(2)]
    (254)     [(1)(2)(2)(2)]
    (255)     [(1)NH[(2)]NH[(2)]]
    ()        []
    ]
  [H]
  [TB
    (7) [RCH]
    (8) [PH]
    ()  []
    ]
 </tt>
</pre>
<p>The following observations may be deduced by comparing this
layout specification with the class file format specification which
defines the <tt>StackMapTable</tt> attribute. The second callable
describes a <tt>stack_map_frame</tt> structure from the class file
format specification. Within the union in the second callable, the
cases stand for the following <tt>stack_map_frame</tt> union
members, respectively: <tt>same_locals_1_stack_item_frame</tt>,
<tt>same_locals_1_stack_item_extended</tt>, <tt>chop_frame</tt>
(and also <tt>same_frame_extended</tt>), <tt>append_frame</tt> (for
three layout union cases), <tt>full_frame</tt>, and (in the default
layout union case) <tt>same_frame</tt>. The third and fourth
callables describe an <tt>offset_delta</tt> value and a
<tt>verification_type_info</tt> structure from the class file
format specification.</p>
<a name="md_lo" id="md_lo"></a> <a name="tocMetLay" id=
"tocMetLay"></a>
<h5>5.5.6. Metadata Layouts</h5>
The predefined attribute layouts for non-parameter metadata
annotations are the same in all three contexts. With some
whitespace added for readability, the layout is as follows:
<pre class="codeblock">
<tt>
  [NH[(1)]]
  [RSH NH[RUH(1)]]
  [TB
    (66,67,73,83,90) [KIH]
    (68)  [KDH]
    (70)  [KFH]
    (74)  [KJH]
    (99)  [RSH]
    (101) [RSH RUH]
    (115) [RUH]
    (91)  [NH[(0)]]
    (64)  [RSH NH[RUH(0)]]
    ()    []
    ]
 </tt>
</pre>
Both visible and invisible annotations use this layout. The second
callable describes an <tt>annotation</tt> structure from the
metadata specification. The third callable describes a
<tt>element_value</tt> structure from the metadata specification.
This last callable, all by itself, is used for the
<tt>AnnotationDefault</tt> attribute on methods. Method parameter
annotations (both visible and invisible) are also predefined using
this layout, with a prepended callable to count the number of
parameters:
<pre class="codeblock">
<tt>
  [NB[(1)]]
  [NH[(1)]]
  [RSH NH[RUH(1)]]
  [TB...]
 </tt>
</pre>
<br />
Additionally RuntimeVisibleTypeAnnotation and RuntimeInvisibleTypeAnnotation
are predefined, using similar strategies as before. Both visible and invisible
type annotations use a common layout. (They were defined by JSR 308).

<pre class="codeblock">
<tt>
  [NH[(1)(2)(3)]]
  [TB
    (0-1)            [B]
    (16)             [FH]
    (17-18)          [BB]
    (19-21)          []
    (22)             [B]
    (23)             [H]
    (64-65)          [NH[PHOHH]]
    (66)             [H]
    (67-70)          [PH]
    (71-75)          [PHB]
    ()               []
    ]
   [NB[BB]]
   [RSH NH[RUH(1)]]
   [TB...]
</tt>
</pre>

The first callable defines the <tt>type_annotation</tt> as a whole.
The second callable refers to <tt>target_type</tt> and <tt>target_info</tt>
union structure, and the third callable refers to <tt>target_path</tt> structure.
The remaining callables are identical with layouts specified above for metadata.
Specifically the fourth and the fifth callables refers to the <tt>annotation</tt>
and <tt>element_value</tt> structures specified for metadata. (These were defined
in the JSR 175 specification). Like the previous metadata layouts, these type
metadata layouts are predefined in the compressor, and are applicable to Class,
Field, Method, and also Code structures.

<a name="tocUnLaUs" id="tocUnLaUs"></a>
<h5>5.5.7. Unusual Layout Usages</h5>
It is possible for the compressor to emit any number of definitions
for the same attribute name. These definitions are assigned
different attribute indexes (and perhaps flag bits), and are
treated as distinct attributes, despite having the same name. If an
attribute is too complex to define in the layout language, each
occurrence of that attribute can be given a separate definition by
the compressor. The minimum requirement is that each layout
accurately declare the size of the corresponding attribute
occurrence, and locate all constant pool references within that
occurrence. <a name="tocSoFiAb" id="tocSoFiAb"></a>
<h4>5.6. Source File Abbreviation</h4>
When a null reference is transmitted in the band governed by the
predefined <tt>SourceFile</tt> attribute, the decompressor is
required to replace it by a reference to a Utf8 string whose
spelling consists of the associated class name string, with the
following modifications made, in order:
<ul>
<li>Every character up to and including the last slash or dot ('/'
or '.') is removed. (This removes any package prefix.)</li>
<li>If there is a character of code 0x2D or lower in the remaining
string, the first such and all following characters are removed.
(This removes any nested class name mangling.)</li>
<li>The suffix characters ".java" are appended.</li>
</ul>
<p>This rule matches the historical behavior of many Java
compilers, and allows the compressor to avoid allocating Utf8
strings for "obvious" derived <tt>SourceFile</tt> names. (If a
compressor needs to transmit an irregular <tt>SourceFile</tt>
attribute with a true null reference, it must use a non-standard
layout.) Here is a table of examples of class names and the
corresponding derived <tt>SourceFile</tt> names.</p>
<table border="1" summary=
"examples of prediction, nonprediction, and misprediction">
<tr align="center">
<th id="derived_names_c">Class</th>
<th id="derived_names_s"><tt>SourceFile</tt></th>
</tr>
<tr>
<td headers="derived_names_c">foo</td>
<td headers="derived_names_s">foo.java</td>
</tr>
<tr>
<td headers="derived_names_c">foo/bar</td>
<td headers="derived_names_s">bar.java</td>
</tr>
<tr>
<td headers="derived_names_c">foo/bar$baz</td>
<td headers="derived_names_s">bar.java</td>
</tr>
<tr>
<td headers="derived_names_c">foo/bar#baz#1</td>
<td headers="derived_names_s">bar.java</td>
</tr>
<tr>
<td headers="derived_names_c">foo.bar.baz#1</td>
<td headers="derived_names_s">baz.java</td>
</tr>
</table>
<a name="nested_classes" id="nested_classes"></a> <a name=
"tocNesCla" id="tocNesCla"></a>
<h4>5.7. Nested Classes</h4>
A nested class record is a four-tuple specifying two classes, a
name, and some flags, as documented for the <tt>InnerClasses</tt>
attribute of class files. It is primarily represented in the
Pack200 archive by four bands, whose contents are applied equally
to all class files in the archive.
<pre class="codeblock">
  ic_bands:
        *ic_this_class :UDELTA5 [#ic_count] (cp_Class)
        *ic_flags :UNSIGNED5 [#ic_count]
        *ic_outer_class :DELTA5 [COUNT(1&lt;&lt;16,...)]  (null or cp_Class)
        *ic_name :DELTA5 [LENGTH(*ic_outer_class)] (null or cp_Utf8)
 
</pre>
These four-tuples are shared globally, like constant pool entries.
In this specification, they are conventionally written
<tt>&lt;C,F,C2,N&gt;</tt>, even though they are stored in a
different order in the class file format. As a set, these globally
defined four-tuples are called <tt>ic_All</tt>. There is usually no
explicit linkage from individual classes in the archive to nested
class records. Instead, when extracting a class file from a Pack200
archive, an subset of nested class records may be selected which is
sufficient to describe all nested classes actually mentioned in the
extracted class file's constant pool. For any class file X to be
extracted, this subset will be called <tt>ic_Relevant(X)</tt>, the
<em>relevant subset</em> for X of <tt>ic_All</tt>. The algorithm
for selecting the relevant subset is described in the section <a href=
"#ic_subset_selection">Ordering of Constant Pools</a>. Optionally, the compressor can
specify, for any given class, an adjustment to its relevant subset,
by transmitting a local <tt>InnerClasses</tt> attribute. This also
is described in the section <a href="#ic_local_bands">Local InnerClasses Attributes</a>.
<p>The <tt>ic_this_class</tt> and <tt>ic_flags</tt> bands are both
of length <tt>#ic_count</tt>, and the corresponding elements of
these bands specify, for each tuple, the nested class identity
(represented as a <tt>cp_Class</tt> reference) and the flags
bitmask.</p>
<a name="explicit_outer" id="explicit_outer"></a>
<p>The nested class flag bit at position 16 (as set in the mask
0x00010000) is inside the archive file to indicate if there are
corresponding entries for the tuple in the <tt>ic_outer_class</tt>
and <tt>ic_name</tt> bands. Thus, the length of both of these bands
is the sum of all flag bits at position 16. Typically, only a few
percent of nested classes need to set this bit and specify outer
and name fields explicitly.</p>
<p>If a tuple has an entry in the <tt>ic_outer_class</tt> and
<tt>ic_name</tt> bands, these specify its outer class and simple
name. (They are represented respectively as a possibly null
<tt>cp_Class</tt> reference and a possibly null <tt>cp_Utf8</tt>
reference.) Otherwise, the tuple's outer class and name are said to
be <em>predicted</em>. In this case, they must be correctly
predictable from the name of the nested class itself, by parsing
its spelling.</p>
<a name="icn_psc_ref" id="icn_psc_ref"></a>
<p>A nested class has a <em>bytecode name</em> which names the
class within class files. The spelling of this name, sometimes
called a "mangled name", has extra punctuation signs and perhaps
digits as well as the name of a containing class. If the bytecode
name can be parsed into an outer class and a class name, and this
class and name are identical with the true outer class and class
name of the nested class, then we say the outer class and class
name are <em>predictable</em>.</p>
<p>The extraction of the predictable outer class and class name
must follow the following grammar for class bytecode names, as
applied to the spelling of the nested class name. (This grammar is
independent of the grammar governing band structure, or any other
grammar appearing in other parts of this specification.) The
terminal DOLLAR refers to any character (such as '$' or '#') whose
code is 0x2D or lower. The terminals SLASH refers to the slash or
dot characters '/' or '.', which have the codes 0x2E and 0x2F. The
terminal DIGIT refers to an ASCII decimal digit, one of the ten
character codes from 0x30 to 0x39 inclusive. The terminal LETTER
refers to any other character. That is, it refers to any character
whose code is 0x3A or higher.</p>
<pre class="codeblock">
  bcn:
        (bcnCase1 | bcnCase2 | bcnCase3 | bcnCase4)
  bcnCase1:
        packageQual (namePart)? DOLLAR number
  bcnCase2:
        packageQual (namePart)? DOLLAR number DOLLAR predictableICName
  bcnCase3:
        predictableOuter DOLLAR predictableICName
  bcnCase4:
        packageQual (namePart)?

  predictableOuter:
        packageQual namePart
  predictableICName:
        LETTER (LETTER | DIGIT)*

  namePart:
        (LETTER | DIGIT | DOLLAR)+
  number:
        (DIGIT)+
  packageQual:
        (namePart SLASH)*
 
</pre>
<p>This grammar ambiguously divides an arbitrary class name into
several parts, which may include an optional
<em>predictedOuter</em> prefix, an optional
<em>predictedICName</em> suffix, and a optional numeric suffix. Any
ambiguity must be resolved by preferring the alternative cases for
<tt>bcn</tt> nonterminal in the order given. E.g., if
<tt>bcnCase1</tt> matches, it is used, even though either or both
other cases may match also.</p>
<p>The predictable nested class name is the string corresponding to
the <tt>predictableICName</tt> nonterminal, if it was parsed.
Otherwise the predictable nested class name is taken to be
null.</p>
<p>If a <tt>predictableOuter</tt> outer nonterminal is parsed, the
corresponding string is the predictable outer class name. Otherwise
the predictable outer class reference is taken to be null. Note
that if a <tt>number</tt> nonterminal is parsed, no
<tt>predictableOuter</tt> can be parsed. Here are some examples of
prediction, nonprediction, and misprediction:</p>
<table border="1" summary="inner class prediction examples">
<tr>
<th id="ic_prediction_ic" colspan="2" align="center">Inner Class
Prediction Examples</th>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">nested class:</td>
<td headers="ic_prediction_ic">member named <tt>Entry</tt> of
<tt>java/util/Map</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">mangled name:</td>
<td headers="ic_prediction_ic"><tt>java/util/Map$Entry</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">outer, name:</td>
<td headers="ic_prediction_ic"><tt>java/util/Map</tt>,
<tt>Entry</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="center">predictable?</td>
<td headers="ic_prediction_ic">yes (since <tt>Map.Entry</tt> is a
member of <tt>Map</tt>)</td>
</tr>
<tr>
<td headers="ic_prediction_ic"></td>
<td headers="ic_prediction_ic"></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">nested class:</td>
<td headers="ic_prediction_ic">anonymous</td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">mangled name:</td>
<td headers="ic_prediction_ic">
<tt>java/util/AbstractList$1</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">outer, name:</td>
<td headers="ic_prediction_ic"><em>(none)</em>,
<em>(none)</em></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="center">predictable?</td>
<td headers="ic_prediction_ic">yes (since the ic_name is null)</td>
</tr>
<tr>
<td headers="ic_prediction_ic"></td>
<td headers="ic_prediction_ic"></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">nested class:</td>
<td headers="ic_prediction_ic">non-member, named
<tt>Local</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">mangled name:</td>
<td headers="ic_prediction_ic">
<tt>java/util/AbstractList$2$Local</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">outer, name:</td>
<td headers="ic_prediction_ic"><em>(none)</em>, <tt>Local</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="center">predictable?</td>
<td headers="ic_prediction_ic">yes (since the ic_name is
<tt>Local</tt>)</td>
</tr>
<tr>
<td headers="ic_prediction_ic"></td>
<td headers="ic_prediction_ic"></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">nested class:</td>
<td headers="ic_prediction_ic">non-member, named
<tt>Local</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">mangled name:</td>
<td headers="ic_prediction_ic">
<tt>java/util/AbstractList#2#Local</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">outer, name:</td>
<td headers="ic_prediction_ic"><em>(none)</em>, <tt>Local</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="center">predictable?</td>
<td headers="ic_prediction_ic">yes (since the ic_name is
<tt>Local</tt>)</td>
</tr>
<tr>
<td headers="ic_prediction_ic"></td>
<td headers="ic_prediction_ic"></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">nested class:</td>
<td headers="ic_prediction_ic">member named <tt>$2$Local</tt> of
<tt>Foo</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">mangled name:</td>
<td headers="ic_prediction_ic"><tt>Foo$$2$Local</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">outer, name:</td>
<td headers="ic_prediction_ic"><em>(none)</em>, <tt>Local</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="center">predictable?</td>
<td headers="ic_prediction_ic">no (outer name missing, ic_name
mispredicted)</td>
</tr>
<tr>
<td headers="ic_prediction_ic"></td>
<td headers="ic_prediction_ic"></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">nested class:</td>
<td headers="ic_prediction_ic">class named
<tt>Red$Herring</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">mangled name:</td>
<td headers="ic_prediction_ic"><tt>Red$Herring</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">outer, name:</td>
<td headers="ic_prediction_ic"><tt>Red</tt>, <tt>Herring</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="center">predictable?</td>
<td headers="ic_prediction_ic">no (the predicted ic_name
Herring)</td>
</tr>
<tr>
<td headers="ic_prediction_ic"></td>
<td headers="ic_prediction_ic"></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">nested class:</td>
<td headers="ic_prediction_ic">member named <tt>Q</tt> of
<tt>X$1</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">mangled name:</td>
<td headers="ic_prediction_ic"><tt>X$1$Q</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">outer, name:</td>
<td headers="ic_prediction_ic"><em>(none)</em>, <tt>Q</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="center">predictable?</td>
<td headers="ic_prediction_ic">no (since <tt>Q</tt> is a member of
<tt>X$1</tt>)</td>
</tr>
<tr>
<td headers="ic_prediction_ic"></td>
<td headers="ic_prediction_ic"></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">nested class:</td>
<td headers="ic_prediction_ic">member named <tt>Z</tt> of
<tt>X$Y</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">mangled name:</td>
<td headers="ic_prediction_ic"><tt>X$Y$Z</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">outer, name:</td>
<td headers="ic_prediction_ic"><tt>X$Y</tt>, <tt>Z</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="center">predictable?</td>
<td headers="ic_prediction_ic">yes (since X$Y.Z is a member of
X$Y)</td>
</tr>
<tr>
<td headers="ic_prediction_ic"></td>
<td headers="ic_prediction_ic"></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">nested class:</td>
<td headers="ic_prediction_ic">member named <tt>Y$Z</tt> of
<tt>X</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">mangled name:</td>
<td headers="ic_prediction_ic"><tt>X$Y$Z</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="right">outer, name:</td>
<td headers="ic_prediction_ic"><tt>X$Y</tt>, <tt>Z</tt></td>
</tr>
<tr>
<td headers="ic_prediction_ic" align="center">predictable?</td>
<td headers="ic_prediction_ic">no (outer name and ic_name are
mispredicted)</td>
</tr>
</table>
<p>When a decompressor is processing a nested class name marked
"predictable", it must parse the nested class's bytecode name into
an enclosing class, an optional number, and an optional name. (The
compressor might choose to always specify outer classes and names
explicitly, in which case the decompressor would not be required to
parse the nested class names at all. However, decompressors must
always be prepared to perform this parsing.)</p>
<p>If the compressor did not transmit an entry in <tt>cp_Utf8</tt>
or <tt>cp_Class</tt> for a predicted name or outer class, the
decompressor must create such a constant internally. It will be
referred to as a <tt>cp_Utf8</tt> or <tt>cp_Class</tt> entry, even
though it is not in the constant transmission sequence
<tt>cp_All</tt>. However, if the compressor did transmit a constant
with the same spelling as the predicted name or outer class, the
decompressor must use that constant rather than creating a new one.
The creation of such internal constants within the decompressor is
detectable in an output file because they are inserted in a special
order in the output file's constant pool. (See discussion of the
output ordering rules in the section <a href="#ordering">Ordering of Constant Pools</a>.)</p>

<p>Please see the Appendix section <a href=
"#icn_psc">Representation of Byte Offsets</a> for pseudo-code explaining this concept.</p>

<p>When the decompressor receives the <tt>ic_this_class</tt>,
<tt>ic_flags</tt>, <tt>ic_name</tt>, and <tt>ic_outer_class</tt>
bands, and performs any required name parsing, it creates the set
<tt>ic_All</tt> of four-tuples. This set is the primary source of
<tt>InnerClasses</tt> attributes synthesized for individual class
files by the decompressor.</p>
<a name="tocClaSch" id="tocClaSch"></a>
<h4>5.8. Class Schema</h4>
The purpose of the Pack200 archive is to transmit a set of classes
in a form which a decompressor can later use to reconstruct class
files. As a rule, each separate kind of data stored in class files
is transmitted in a band dedicated to all values of that kind. Here
is the band structure for all class-specific information except
bytecodes:
<pre class="codeblock">
  class_bands:
        *class_this :DELTA5 [#class_count] (cp_Class)
        *class_super :DELTA5 [#class_count] (cp_Class)
        *class_interface_count :DELTA5 [#class_count]
        *class_interface :DELTA5 [SUM(*class_interface_count)] (cp_Class)
        *class_field_count :DELTA5 [#class_count]
        *class_method_count :DELTA5 [#class_count]

        *field_descr :DELTA5 [SUM(*class_field_count)] (cp_Descr)
        field_attr_bands

        *method_descr :MDELTA5 [SUM(*class_method_count)] (cp_Descr)
        method_attr_bands

        class_attr_bands
        code_bands
 
</pre>
<p>The <tt>class_this</tt>, <tt>class_super</tt>,
<tt>class_flags_lo</tt>, <tt>class_flags_hi</tt> (if present),
<tt>class_interface_count</tt>, <tt>class_field_count</tt>, and
<tt>class_method_count</tt> bands are all of length
<tt>#class_count</tt>, and the corresponding elements of these
bands transmit in turn each class's name and super-class, and the
number of implemented interfaces, declared fields, and declared
methods. (The access modifier bits in each class's flags word are
mixed with attribute indicators, and are transmitted in
<tt>class_flags_lo</tt>, as defined above.)</p>
<p>The <tt>class_interface</tt> band contains runs of class
interface declarations, one run for each element of
<tt>class_interface_count</tt>, and applying to the corresponding
class.</p>
<p>Each element of <tt>class_this</tt>, <tt>class_super</tt>, and
<tt>class_interface</tt> is a reference (in fact, a non-null
reference) to the constant pool <tt>cp_Class</tt>.</p>
<p>In the unique case of <tt>java/lang/Object</tt>, the stored
super-class must be a null reference. Rather than disturbing the
transmission of all other elements of the <tt>class_super</tt>
band, we use the convention that a compressor, when it encounters a
null super-class reference, must transmit in its place a duplicate
of the current class's reference. (Since it is illegal for a class
to inherit from itself, this renumbering of null references is
unambiguous.)</p>
<p>The <tt>field_descr</tt> bands contain one run of elements for
each element of <tt>class_field_count</tt>, and apply to successive
fields in the corresponding class. The <tt>method_descr</tt> bands
contain one run of elements for each element of
<tt>class_method_count</tt>, and apply to successive methods in the
corresponding class.</p>
<p>(Unlike the class file format, field and method descriptors are
stored as single references to a "name-and-type" constant pool,
rather than as pairs of name references and type references.)</p>
<p>The <tt>method_descr</tt> band has a primary encoding which
performs best if the method references are mostly sorted.
Compressors may elect to take advantage of this fact by sorting the
methods in each class. (Note: It is generally acceptable for
compressors to reorder methods for best compression, but fields
must not be reordered, since their order is apparent through
reflection and significant to some facilities, such as
serialization.)</p>
<p>Attribute bands are placed in the positions indicated by the
grammar. They are described below. The attribute bands include
flags bands, which carry both access modifiers and attribute
indicators for the corresponding classes, fields, and methods.</p>
<p>The Pack200 archive ends with bands devoted to method code
blocks and the bytecodes themselves. If a method has a code
attribute, the compressor must mention it in the flags bit (the 6th
LSB) to which it is assigned, or as an overflow attribute (with an
index of 6). The fields of a Code attribute are transmitted in the
bands organized under the <tt>code_bands</tt> nonterminal.</p>
<p>The specification of each Code attribute begins with three key
parameters, which declare the number of stack and local slots, and
the number of handlers. <tt>#Stack</tt> is the number of stack
slots used by the code. <tt>#NALocal</tt> is the number of
non-argument locals used by the code. (The actual number of locals
declared in the class file will be <tt>#NALocal</tt> plus the
number of locals required by method parameters, as determined by
the method's signature.) <tt>#Handler</tt> is the number of
exception handlers.</p>
<a name="code_headers" id="code_headers"></a>
<p>The <tt>code_headers</tt> band contains a series of bytes, each
of which tersely encodes the first three key parameters of a code
attribute: Each of the 255 non-zero byte values encodes a unique
triple of <tt>#NALocal</tt>, <tt>#Stack</tt>, and
<tt>#Handler</tt>. There is (of course) one code header for each
Code attribute transmitted.</p>
<p>The special code header byte zero (0x00) indicates that the code
attribute's three parameters are to be found, instead, in the
<tt>code_max_stack</tt>, <tt>code_max_na_locals</tt>, and
<tt>code_handler_count</tt> bands. If the code header byte is
non-zero, these three bands do not transmit entries for the
corresponding Code attribute.</p>
<p>The <tt>code_flags_lo</tt> band transmits an entry for a
corresponding <tt>Code</tt> attribute if and only if one or both of
the following is true: the Code attribute's code header byte is
zero, or the <tt>have_all_code_flags</tt> bit is set in the
<tt>#archive_options</tt> word. If a <tt>Code</tt> attribute does
not have a transmitted <tt>code_flags_lo</tt> value, its flags word
is taken to be zero, and it has no sub-attributes. The
<tt>code_flags_hi</tt> band transmits a corresponding entry if and
only if the <tt>code_flags_lo</tt> value was transmitted as just
described, and also <tt>#have_code_flags_hi</tt> is set.</p>
<p>Non-zero code header bytes denote code attribute parameters
according to the following scheme:</p>
<table border="1" summary=
"bands that transmit appropriately-typed constant pool references">
<tr align="center">
<th id="typed_cp_h">Header Range</th>
<th id="typed_cp_s">#Stack</th>
<th id="typed_cp_n">#NALocal</th>
<th id="typed_cp_h1">#Handler</th>
</tr>
<tr>
<td headers="typed_cp_h">1 &lt;= x &lt;= 144</td>
<td headers="typed_cp_s">(x-1) % 12</td>
<td headers="typed_cp_n">(x-1) / 12</td>
<td headers="typed_cp_h1">0</td>
</tr>
<tr>
<td headers="typed_cp_h">145 &lt;= x &lt;= 208</td>
<td headers="typed_cp_s">(x-145) % 8</td>
<td headers="typed_cp_n">(x-145) / 8</td>
<td headers="typed_cp_h1">1</td>
</tr>
<tr>
<td headers="typed_cp_h">209 &lt;= x &lt;= 255</td>
<td headers="typed_cp_s">(x-209) % 7</td>
<td headers="typed_cp_n">(x-209) / 7</td>
<td headers="typed_cp_h1">2</td>
</tr>
<tr>
<td headers="typed_cp_h">x = 0</td>
<td headers="typed_cp_s"><tt>code_max_stack</tt></td>
<td headers="typed_cp_n"><tt>code_max_na_locals</tt></td>
<td headers="typed_cp_h1"><tt>code_handler_count</tt></td>
</tr>
</table>
This scheme allows a single byte to describe a Code attribute in
about 95% of all cases. (Note: If debugging attributes are not
stripped, the compressor should probably set the
<tt>have_all_code_flags</tt> bit, so that the presence of these
attributes will not force the use of the special zero code header
byte.)
<p>Regardless of whether the exception handler count is encoded in
the one-byte code header, or whether it is an explicit element of
<tt>code_handler_count</tt>, for each code attribute there is a run
of values in <tt>code_handler_start_P</tt>,
<tt>code_handler_end_PO</tt>, <tt>code_handler_catch_PO</tt>, and
<tt>code_handler_class_RCN</tt>, one for each handler, as if those
bands were governed by an attribute layout
<tt>'NV[PHPOHPOHRCNH]'</tt> (there is no band governed by the
<tt>'NV'</tt> layout element itself; it is the handler count).</p>
<p>That is, each triplet of <tt>Handler.start</tt>,
<tt>Handler.end</tt>, and <tt>Handler.catch</tt> values are
transmitted as renumbered (by <em>renumber_bci</em>). Also,
<tt>Handler.end</tt> is transmitted as a difference of its
renumbering with that of <tt>Handler.start</tt> in the same
triplet, and <tt>Handler.catch</tt> is transmitted as a difference
of its renumbering with that of <tt>Handler.end</tt> in the same
triplet. Finally, <tt>code_handler_class_RCN</tt> is transmitted as
an incremented reference into <tt>cp_Class</tt>, or zero if the
handler class reference is null.</p>
<pre class="codeblock">
  code_bands:
        *code_headers :BYTE1 [COUNT(Code,...)]

        *code_max_stack :UNSIGNED5 [COUNT(0,*code_headers)]
        *code_max_na_locals :UNSIGNED5 [COUNT(0,*code_headers)]

        *code_handler_count :UNSIGNED5 [COUNT(0,*code_headers)]
        *code_handler_start_P :BCI5 [SUM(*code_handler_count)]
        *code_handler_end_PO :BRANCH5 [SUM(*code_handler_count)]
        *code_handler_catch_PO :BRANCH5 [SUM(*code_handler_count)]
        *code_handler_class_RCN :UNSIGNED5 [SUM(*code_handler_count)] (null or cp_Class)

        code_attr_bands
 
</pre>
<a name="tocAttBan" id="tocAttBan"></a>
<h4>5.9. Attribute Bands</h4>
Here, collected in one place, are the bands which transmit
attributes. If the compressor sets bits in the flags word of a
class, field, or method, and those bits are assigned (by the
compressor) to attributes, then the compressor must also retrieve
the stored values governed by each selected attribute layout and
transmit them in the bands governed by that layout. <a name=
"overflow_bits" id="overflow_bits"></a>
<p>If the compressor marks a class (resp. field, method, or code)
as having overflow attributes, it must transmit a corresponding
element in the <tt>class_attr_count</tt> band (resp.
<tt>field_attr_count</tt>, <tt>method_attr_count</tt>, or
<tt>code_attr_count</tt> band). This count, in turn, specifies the
size of a run in <tt>class_attr_indexes</tt> (resp.
<tt>field_attr_indexes</tt>, <tt>method_attr_indexes</tt>, or
<tt>code_attr_indexes</tt>) of indexes of attribute layouts
governing attributes of the class (resp. field, method, or code).
The compressor must transmit a attribute layout definition index
for each overflow attribute.</p>
<p>For each attribute layout selected by a bit in an element of
<tt>class_flags</tt> or by an element of
<tt>class_attr_indexes</tt>, the compressor must retrieve data
governed by the layout elements from the class attribute and
transmit elements encoding this data in the bands governed by the
layout. Similar conditions apply for field, method, and code
attributes.</p>
<p>For each attribute layout that transmits data and contains
backward calls, the compressor must transmit the number of times
each backward callable will be the subject of a backward call as
the decompressor works its way through attribute layouts. These
call counts are transmitted in the <tt>class_attr_calls</tt>,
<tt>field_attr_calls</tt>, <tt>method_attr_calls</tt>, and
<tt>code_attr_calls</tt> bands, according to the context type of
the layouts they apply to. The call counts are transmitted, one per
backward callable, in the definition order of the callables. (See the section
<a href="#def_order">Attribute Layout Definitions</a>.) Call counts are only transmitted
for backward callables which occur within layouts that are used at
least once. Call counts do <em>not</em> count entries to any
callable because of a forward call, nor do they count the initial
call to a callable which initiates attribute processing. A call
count might be zero if a backward callable occurs in a layout that
is used, but which does not happen to reach the backward callable.
These call counts are needed to break a circularity inherent in the
sizing of bands for mutually-recursive layouts. They provide the
minimum information necessary for the decompressor to locate all
the bands in the archive, prior to distributing the band values to
the various output classes. For this reason, the call counts are
supplied one per layout, summed over all attribute occurrences of
that each layout.</p>
<p>The decompressor is responsible for processing any explicit
attribute layout definitions transmitted by the compressor. It must
prepare to receive the additional bands governed by those layouts.
When it reads layout definition indexes, it must prepare to read in
the correct number of values transmitted in each of those
additional bands.</p>
<p>The grammar of bands defined in this specification includes
bands governed by all predefined attribute layouts. For clarity,
some band names mention a part of the layout element that created
them. Note that the Deprecated attributes have no bands, because
their layouts are empty.</p>
<p>Attributes named "Synthetic", although part of the standard
class file format in earlier versions of Java, are not directly
supported in this specification, because that attribute has been
replaced by a new flag bit (ACC_SYNTHETIC, 0x1000) in more recent
versions of Java. However, compressors are encouraged to process
Synthetic attributes, and any other zero-length attributes not
predefined here, by assigning them unused flag bits, and emitting
explicit zero-length layout definitions for decompressors to
follow.</p>
<p>If the compressor elects to define new layouts, the bands
governed by those layouts are added immediately after the bands for
the predefined layouts. (The order and structure of the predefined
attribute bands reflects the predefined layout definitions in a
regular way, as if the compressor had in fact defined them
explicitly.)</p>
<pre class="codeblock">

  class_attr_bands:
        *class_flags_hi :UNSIGNED5 [#class_count*#have_class_flags_hi]
        *class_flags_lo :UNSIGNED5 [#class_count]
        *class_attr_count :UNSIGNED5 [COUNT(1&lt;&lt;16,...)]
        *class_attr_indexes :UNSIGNED5 [SUM(*class_attr_count)]
        *class_attr_calls :UNSIGNED5 [...]
        *class_SourceFile_RUN :UNSIGNED5 [COUNT(SourceFile,...)] (null or cp_Utf8)
        *class_EnclosingMethod_RC :UNSIGNED5 [COUNT(EnclosingMethod,...)] (cp_Class)
        *class_EnclosingMethod_RDN :UNSIGNED5 [COUNT(EnclosingMethod,...)] (null or cp_Descr)
        *class_Signature_RS :UNSIGNED5 [COUNT(Signature,..)] (cp_Signature)
        class_metadata_bands
        ic_local_bands
        *class_file_version_minor_H :UNSIGNED5 [COUNT(version,...)]
        *class_file_version_major_H :UNSIGNED5 [COUNT(version,...)]
        {class_attr_element_bands...}

  field_attr_bands:
        *field_flags_hi :UNSIGNED5 [SUM(*class_field_count)*#have_field_flags_hi]
        *field_flags_lo :UNSIGNED5 [SUM(*class_field_count)]
        *field_attr_count :UNSIGNED5 [COUNT(1&lt;&lt;16,...)]
        *field_attr_indexes :UNSIGNED5 [SUM(*field_attr_count)]
        *field_attr_calls :UNSIGNED5 [...]
        *field_ConstantValue_KQ :UNSIGNED5 [COUNT(ConstantValue,...)] (cp_Int, etc.; see note)
        *field_Signature_RS :UNSIGNED5 [COUNT(Signature,...)] (cp_Signature)
        field_metadata_bands

  method_attr_bands:
        *method_flags_hi :UNSIGNED5 [SUM(*class_method_count)*#have_method_flags_hi]
        *method_flags_lo :UNSIGNED5 [SUM(*class_method_count)]
        *method_attr_count :UNSIGNED5 [COUNT(1&lt;&lt;16,...)]
        *method_attr_indexes :UNSIGNED5 [SUM(*method_attr_count)]
        *method_attr_calls :UNSIGNED5 [...]
        *method_Exceptions_N :UNSIGNED5 [COUNT(Exceptions,...)]
        *method_Exceptions_RC :UNSIGNED5 [SUM(*method_Exceptions_N)] (cp_Class)
        *method_Signature_RS :UNSIGNED5 [COUNT(Signature,...)] (cp_Signature)
        method_metadata_bands
        *method_MethodParameters_NB :BYTE1 [...]
        *method_MethodParameters_name_RUN :UNSIGNED5 [...] (null or cp_Utf8)
        *method_MethodParameters_flag_FH :UNSIGNED5 [...] (flag)
        {method_attr_element_bands...}

  code_attr_bands:
        *code_flags_hi :UNSIGNED5 [...*#have_code_flags_hi]
        *code_flags_lo :UNSIGNED5 [...]
        *code_attr_count :UNSIGNED5 [COUNT(1&lt;&lt;16,...)]
        *code_attr_indexes :UNSIGNED5 [SUM(*code_attr_count)]
        *code_attr_calls :UNSIGNED5 [...]
        *code_StackMapTable_N :UNSIGNED5 [COUNT(StackMapTable,...)]
        *code_StackMapTable_frame_T :BYTE1 [SUM(*code_StackMapTable_N)]
        *code_StackMapTable_local_N :UNSIGNED5 [COUNT(255,*code_StackMapTable_frame_T)]
        *code_StackMapTable_stack_N :UNSIGNED5 [COUNT(255,*code_StackMapTable_frame_T)]
        *code_StackMapTable_offset :UNSIGNED5 [...]
        *code_StackMapTable_T :BYTE1 [...]
        *code_StackMapTable_RC :UNSIGNED5 [COUNT(7,*code_StackMapTable_T)]
        *code_StackMapTable_P :BCI5 [COUNT(8,*code_StackMapTable_T)]
        *code_LineNumberTable_N :UNSIGNED5 [...]
        *code_LineNumberTable_bci_P :BCI5 [...]
        *code_LineNumberTable_line :UNSIGNED5 [...]
        *code_LocalVariableTable_N :UNSIGNED5 [...]
        *code_LocalVariableTable_bci_P :BCI5 [...]
        *code_LocalVariableTable_span_O :BRANCH5 [...]
        *code_LocalVariableTable_name_RU :UNSIGNED5 [...] (cp_Utf8)
        *code_LocalVariableTable_type_RS :UNSIGNED5 [...] (cp_Signature)
        *code_LocalVariableTable_slot :UNSIGNED5 [...]
        *code_LocalVariableTypeTable_N :UNSIGNED5 [...]
        *code_LocalVariableTypeTable_bci_P :BCI5 [...]
        *code_LocalVariableTypeTable_span_O :BRANCH5 [...]
        *code_LocalVariableTypeTable_name_RU :UNSIGNED5 [...] (cp_Utf8)
        *code_LocalVariableTypeTable_type_RS :UNSIGNED5 [...] (cp_Signature)
        *code_LocalVariableTypeTable_slot :UNSIGNED5 [...]
        {code_attr_element_bands...}
 
</pre>
<a name="special_version_number" id="special_version_number"></a>
<p>A class possesses a "class-file version" pseudo-attribute if its
class file's minor or major version differs from the
<tt>#default_class_minver</tt> or <tt>#default_class_majver</tt>,
respectively. This pseudo-attribute is a pair of 16-bit integers
giving the major and minor version numbers of the class's file.
These integers are stored in the header of the class's file, rather
than in an attribute record. As is the convention with classfiles,
the minor version number comes first. Thus minor version numbers
are transmitted in the band <tt>class_file_version_minor_H</tt>,
and major version numbers in <tt>class_file_version_major_H</tt>.
Decompressors are not required to process archives with greater
minor or major version numbers than those of the specification they
were engineered to process. Decompressors are required to process
archives with the same major and smaller or equal minor version
numbers.</p>
<a name="ic_local_bands" id="ic_local_bands"></a>
<h5>Local InnerClasses Attributes</h5>
A transmitted class may possess a local <tt>InnerClasses</tt>
attribute, which is taken to be an <em>adjustment</em> to that
class file's eventually written <tt>InnerClasses</tt> attribute.
Specifically, the local <tt>InnerClasses</tt> attribute specifes a
set of four-tuples which must be combined with a corresponding
relevant subset drawn from <tt>ic_All</tt>. The algorithm for doing
this is described in the section <a href="#ic_subset_selection">Ordering of Constant Pools</a>,
but it amounts to starting with the subset of four-tuples from
<tt>ic_All</tt> which pertain to CONSTANT_Class entries of the
output constant pool (barring CONSTANT_Class entries required only
by the <tt>InnerClasses</tt> attribute itself), and then forming
the set symmetric difference between that relevant set and the
local <tt>InnerClasses</tt> attribute.
<p>The four-tuples of all local <tt>InnerClasses</tt> attributes
are transmitted in five bands:</p>
<pre class="codeblock">
  ic_local_bands:
        *class_InnerClasses_N :UNSIGNED5 [COUNT(InnerClasses,...)]
        *class_InnerClasses_RC :UNSIGNED5 [SUM(*class_InnerClasses_N)] (cp_Class)
        *class_InnerClasses_F :UNSIGNED5 [SUM(*class_InnerClasses_N)]
        *class_InnerClasses_outer_RCN :UNSIGNED5 [COUNT(!=0,*class_InnerClasses_F)]  (null or cp_Class)
        *class_InnerClasses_name_RUN :UNSIGNED5 [COUNT(!=0,*class_InnerClasses_F)] (null or cp_Utf8)
 
</pre>
<p>Each four-tuple <tt>&lt;C,F,C2,N&gt;</tt> transmitted in these
attribute bands is called a <em>local IC tuple</em>. (Note that the
class file format stores the elements of these four-tuples in a
different order, <tt>(C,C2,N,F)</tt>.) For a given class file X,
the sequence of local IC tuples is called <tt>ic_Local(X)</tt>.</p>
<p>For each local IC tuple, the compressor transmits, at minimum, a
<tt>C</tt> value and an <tt>F</tt> value. If a transmitted flags
value <tt>F</tt> is not zero, there are also corresponding
transmitted constant pool references <tt>C2</tt> and <tt>N</tt>. As
a whole, the transmitted local tuple may or may not be equivalent
to a global tuple from <tt>ic_All</tt>.</p>
<p>As an abbreviation, the compressor may transmit only a
<tt>C</tt> and a flags value of zero, if the local IC tuple to be
transmitted is equivalent to a member of <tt>ic_All</tt>, and no
other member of <tt>ic_All</tt> defines the same class <tt>C</tt>.
In this case the decompressor must behave exactly as if all four
tuple components had been explicitly transmitted.</p>
<p>(If all four components of a local tuple are transmitted, and
the flags value to be transmitted is in fact zero, the value
<tt>0x00010000</tt> must be transmitted instead of zero for the
flags.)</p>
<p>Frequently, the compressor will not need to transmit any local
IC tuples at all, since the set of four-tuples to be stored in the
class's <tt>InnerClasses</tt> attribute will be exactly
<tt>ic_Relevant(X)</tt>, with no adjustment required. If extraneous
four-tuples (beyond those required by a minimized constant pool)
are found in the input class file, then some local IC tuples will
be needed (with zero flags), to provide local "roots" for the extra
<tt>InnerClasses</tt> entries. This can occur if a compiler
requires an <tt>InnerClasses</tt> entry for a class mentioned only
in a signature. Compressors are required to predict which classes
require such extra local roots, and transmit only the unexpected
four-tuples.</p>
<a name="tocMetTra" id="tocMetTra"></a>
<h5>5.9.1. Metadata Transmission</h5>
There are nine groups of bands governed by the metadata layouts.
They are summarized here.
<pre class="codeblock">
  class_metadata_bands:
        class_RVA_bands
        class_RIA_bands

  field_metadata_bands:
        field_RVA_bands
        field_RIA_bands

  method_metadata_bands:
        method_RVA_bands
        method_RIA_bands
        method_RVPA_bands
        method_RIPA_bands
        method_AD_bands

  class_RVA_bands:
        *class_RVA_anno_N :UNSIGNED5 [...] 
        *class_RVA_type_RS :UNSIGNED5 [...] (cp_Signature)
        *class_RVA_pair_N :UNSIGNED5 [...] 
        *class_RVA_name_RU :UNSIGNED5 [...] (cp_Utf8)
        *class_RVA_T :BYTE1 [...] 
        *class_RVA_caseI_KI :UNSIGNED5 [...] (cp_Int)
        *class_RVA_caseD_KD :UNSIGNED5 [...] (cp_Double)
        *class_RVA_caseF_KF :UNSIGNED5 [...] (cp_Float)
        *class_RVA_caseJ_KJ :UNSIGNED5 [...] (cp_Long)
        *class_RVA_casec_RS :UNSIGNED5 [...] (cp_Signature)
        *class_RVA_caseet_RS :UNSIGNED5 [...] (cp_Signature)
        *class_RVA_caseec_RU :UNSIGNED5 [...] (cp_Utf8)
        *class_RVA_cases_RU :UNSIGNED5 [...] (cp_Utf8)
        *class_RVA_casearray_N :UNSIGNED5 [...] 
        *class_RVA_nesttype_RS :UNSIGNED5 [...] (cp_Signature)
        *class_RVA_nestpair_N :UNSIGNED5 [...] 
        *class_RVA_nestname_RU :UNSIGNED5 [...] (cp_Utf8)

  class_RIA_bands:
        *class_RIA_anno_N :UNSIGNED5 [...] 
        (analogous to class_RVA_bands)

  field_RVA_bands:
        *field_RVA_anno_N :UNSIGNED5 [...] 
        (analogous to class_RVA_bands)

  field_RIA_bands:
        *field_RIA_anno_N :UNSIGNED5 [...] 
        (analogous to field_RVA_bands)

  method_RVA_bands:
        *method_RVA_anno_N :UNSIGNED5 [...] 
        (analogous to class_RVA_bands)

  method_RIA_bands:
        *method_RIA_anno_N :UNSIGNED5 [...] 
        (analogous to method_RIA_bands)

  method_RVPA_bands:
        *method_RVPA_param_NB :BYTE1 [...] 
        *method_RVPA_anno_N :UNSIGNED5 [...] 
        (analogous to method_RVA_bands)

  method_RIPA_bands:
        *method_RIPA_param_NB :BYTE1 [...] 
        *method_RIPA_anno_N :UNSIGNED5 [...] 
        (analogous to method_RVPA_bands)

  method_AD_bands
        *method_AD_T :BYTE1 [...] 
        *method_AD_caseI_KI :UNSIGNED5 [...] (cp_Int)
        *method_AD_caseD_KD :UNSIGNED5 [...] (cp_Double)
        *method_AD_caseF_KF :UNSIGNED5 [...] (cp_Float)
        *method_AD_caseJ_KJ :UNSIGNED5 [...] (cp_Long)
        *method_AD_casec_RS :UNSIGNED5 [...] (cp_Signature)
        *method_AD_caseet_RS :UNSIGNED5 [...] (cp_Signature)
        *method_AD_caseec_RU :UNSIGNED5 [...] (cp_Utf8)
        *method_AD_cases_RU :UNSIGNED5 [...] (cp_Utf8)
        *method_AD_casearray_N :UNSIGNED5 [...] 
        *method_AD_nesttype_RS :UNSIGNED5 [...] (cp_Signature)
        *method_AD_nestpair_N :UNSIGNED5 [...] 
        *method_AD_nestname_RU :UNSIGNED5 [...] (cp_Utf8)

</pre>
<p>As an aid to understanding the metadata layout, here is a brief
description of each of the method metadata bands, as used by
classfiles which comply with JSR 175. The class and field metadata
bands function in a similar way.</p>
<p>Note that JSR 175 does not allow embedded references to
CONSTANT_Class entries, even where a reference to a class is
required. Instead, JSR 175 requires that references to classes be
encoded as field signatures. (Their names are bracketed by 'L' and
';'.) The Pack200 archive transmits all such values as references
into <tt>cp_Signature</tt>, not <tt>cp_Class</tt>.</p>
<p>For each use of a parameter annotation attribute, the
<tt>method_RVPA_param_NB</tt> band or <tt>method_RIPA_param_NB</tt>
band (for invisible annotations) transmits an unsigned byte
indicating the parameter count. For each use of a non-parameter
annotation attribute, the <tt>method_RVA_anno_N</tt> band or
<tt>method_RIA_anno_N</tt> band (for invisible annotations)
transmits an annotation count. Likewise, for each annotated
parameter, the <tt>method_RVPA_anno_N</tt> band or
<tt>method_RIPA_anno_N</tt> band (for invisible annotations)
transmits an annotation count.</p>
<p>For each visible non-parameter annotation, the
<tt>method_RVA_type_RS</tt> band transmits an annotation's type,
and the <tt>method_RVA_pair_N</tt> band transmits the number of
that annotation's member-value pairs. Analogous values for
invisible annotations and parameter annotations are transmitted in
the bands <tt>method_RIA_type_RS</tt>, <tt>method_RIA_pair_N</tt>,
<tt>method_RVPA_type_RS</tt>, <tt>method_RVPA_pair_N</tt>,
<tt>method_RIPA_type_RS</tt>, and <tt>method_RIPA_pair_N</tt>. For
each member-value pair transmitted as a direct part of a visible
non-parameter annotation, the <tt>method_RVA_name_RU</tt> band
transmits the member name. Analogous values for invisible
annotations and parameter annotations are transmitted in the bands
<tt>method_RIA_name_RU</tt>, <tt>method_RVPA_name_RU</tt>, and
<tt>method_RIPA_name_RU</tt>.</p>
<p>For each value transmitted with a visible non-parameter
annotation, whether directly, or indirectly via a nested value or
annotation, the <tt>method_RVA_T</tt> band transmits a byte which
selects the format of the annotation value, and analogous values
are transmitted in the bands <tt>method_RIA_T</tt>,
<tt>method_RVPA_T</tt>, <tt>method_RIPA_T</tt>, and (for annotation
defaults) <tt>method_AD_T</tt>, Direct uses of these value tag
bands are counted by summing the values of the corresponding
preceding pair-count band (<tt>method_RVA_pair_N</tt>, etc.). This
count also includes the sum of the corresponding following nested
pair-count band (<tt>method_RVA_nestpair_N</tt>, etc.) and nested
array length bands (<tt>method_RVA_casearray_N</tt>, etc.).</p>
<p>Since those latter sums come from backward calls in the
attribute layout, they cannot be directly computed by the
decompressor, but their sum is reported by the compressor as an
element of <tt>method_attr_calls</tt>. (Note that the last callable
in each metadata layout is the target of two backward calls from
inside itself.) That band contains these backward call counts for
<tt>method_RVA_T</tt>, <tt>method_RIA_T</tt>
<tt>method_RVPA_T</tt>, <tt>method_RIPA_T</tt>
<tt>method_AD_T</tt>, in that order. If there are no occurrences of
a method metadata attribute, then the corresponding backward call
is omitted. (Thus, there are up to five backward call counts
transmitted for method metadata.) If there are compressor-defined
recursive layouts used in the archive, their backward call counts
follow the counts for metadata in <tt>method_attr_calls</tt>.</p>
<p>For each value tag of 'B', 'C', 'I', 'S', or 'Z', there is a
corresponding element transmitted in <tt>method_RVA_caseI_KI</tt>
which supplies the value as a <tt>cp_Int</tt> reference. Analogous
integer references within invisible and parameter annotations and
annotation defaults are transmitted in the bands
<tt>method_RIA_caseI_KI</tt>, <tt>method_RVPA_caseI_KI</tt>,
<tt>method_RIPA_caseI_KI</tt>, and <tt>method_AD_caseI_KI</tt>. For
each value tag of 'e', the bands <tt>method_RVA_caseet_RS</tt> and
<tt>method_RVA_caseec_RU</tt> transmit the signature of the class
and name of the member of an enumeration constant, as references
into <tt>cp_Signature</tt> and <tt>cp_Utf8</tt>. For each value tag
of '[', the band <tt>method_RVA_casearray_N</tt> transmits the
length of a nested value array. For each value tag of '@', the
bands <tt>method_RVA_nesttype_RS</tt> and
<tt>method_RVA_nestpair_N</tt> transmit the class signature of a
nested annotation and the number of its pairs. For each pair in
such a nested annotation, the band <tt>method_RVA_nestname_RU</tt>
transmits the name of the pair.</p>
<p>The bands in the following table transmit appropriately-typed
constant pool references for each occurrence of specific tag
characters.</p>
<table border="1" summary="details about escape code">
<tr align="center">
<th id="escape_code_details_t">Tag(s)</th>
<th id="escape_code_details_b">Band</th>
<th id="escape_code_details_r">Reference</th>
</tr>
<tr>
<td headers="escape_code_details_t">
<tt>'B','C','I','S','Z'</tt></td>
<td headers="escape_code_details_b">
<tt>method_RVA_caseI_KI</tt></td>
<td headers="escape_code_details_r">cp_Int</td>
</tr>
<tr>
<td headers="escape_code_details_t"><tt>'D'</tt></td>
<td headers="escape_code_details_b">
<tt>method_RVA_caseD_KD</tt></td>
<td headers="escape_code_details_r">cp_Double</td>
</tr>
<tr>
<td headers="escape_code_details_t"><tt>'F'</tt></td>
<td headers="escape_code_details_b">
<tt>method_RVA_caseF_KF</tt></td>
<td headers="escape_code_details_r">cp_Float</td>
</tr>
<tr>
<td headers="escape_code_details_t"><tt>'J'</tt></td>
<td headers="escape_code_details_b">
<tt>method_RVA_caseJ_KJ</tt></td>
<td headers="escape_code_details_r">cp_Long</td>
</tr>
<tr>
<td headers="escape_code_details_t"><tt>'c'</tt></td>
<td headers="escape_code_details_b">
<tt>method_RVA_casec_RS</tt></td>
<td headers="escape_code_details_r">cp_Signature</td>
</tr>
<tr>
<td headers="escape_code_details_t"><tt>'e'</tt></td>
<td headers="escape_code_details_b">
<tt>method_RVA_caseet_RS</tt><br />
<tt>method_RVA_caseec_RU</tt></td>
<td headers="escape_code_details_r"><tt>cp_Signature</tt><br />
<tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="escape_code_details_t"><tt>'s'</tt></td>
<td headers="escape_code_details_b">
<tt>method_RVA_cases_RU</tt></td>
<td headers="escape_code_details_r">cp_Utf8</td>
</tr>
</table>
<p>Analogous groups of bands transmit values within the other four
method annotation types, and within the visible and invisible
annotations of classes and fields.</p>
<a name="tocBytIns" id="tocBytIns"></a>
<h4>5.10. Bytecode Instructions</h4>
The last part of the Pack200 archive is a series of bands
transmitting the bytecodes themselves. The bytecodes of each method
code are parsed into instructions and operands transmitted in their
own bands. Each method code corresponds to a run of bytecodes which
ends with the distinguished code value 0xFF (255), which serves as
an end marker. (Note that it is unusual for band data to be
delimited by an end marker: Usually it is sized by a count in a
previous band.)
<p>Here are the bands which transmit bytecode instructions:</p>
<pre class="codeblock">
  bc_bands:
        *bc_codes :BYTE1 [...]
        *bc_case_count :UNSIGNED5 [COUNT(switch,*bc_codes)]
        *bc_case_value :DELTA5 [...]
        *bc_byte :BYTE1 [...]
        *bc_short :DELTA5 [...]
        *bc_local :UNSIGNED5 [...]
        *bc_label :BRANCH5 [...]
        *bc_intref :DELTA5 [...] (cp_Int)
        *bc_floatref :DELTA5 [...] (cp_Float)
        *bc_longref :DELTA5 [...] (cp_Long)
        *bc_doubleref :DELTA5 [...] (cp_Double)
        *bc_stringref :DELTA5 [...] (cp_String)
        *bc_loadablevalueref :DELTA5 [...] (cp_LoadableValue)
        *bc_classref :UNSIGNED5 [...] (current class or cp_Class)
        *bc_fieldref :DELTA5 [...] (cp_Field)
        *bc_methodref :UNSIGNED5 [...] (cp_Method)
        *bc_imethodref :DELTA5 [...] (cp_Imethod)
        *bc_indyref :DELTA5 [...] (cp_InvokeDynamic)
        *bc_thisfield :UNSIGNED5 [...] (cp_Field, only for current class)
        *bc_superfield :UNSIGNED5 [...] (cp_Field, only for current super)
        *bc_thismethod :UNSIGNED5 [...] (cp_Method, only for current class)
        *bc_supermethod :UNSIGNED5 [...] (cp_Method, only for current super)
        *bc_initref :UNSIGNED5 [...] (cp_Field, only for most recent new)
        *bc_escref :UNSIGNED5 [COUNT(ref_escape,*bc_codes)] (cp_All)
        *bc_escrefsize :UNSIGNED5 [...]
        *bc_escsize :UNSIGNED5 [...]
        *bc_escbyte :BYTE1 [...]
 
</pre>
<p>In order to transmit bytecode instructions more efficiently,
some instructions may be rewritten into a transmission form. The
ldc, ldc_w, and ldc2_w bytecodes must be rewritten by the
compressor into strongly-typed operations; see below. Some
getstatic, putstatic, getfield, putfield, invokevirtual,
invokespecial, and invokestatic bytecodes <em>may</em> (at the
compressor's option) be rewritten into more specialized and compact
forms which, because they are context sensitive, select their
operands from a smaller set of possibilities.</p>
<p>In all cases, the first byte of each instruction (perhaps
rewritten) is determined by a byte transmitted in
<tt>bc_codes</tt>. All operand bytes are decoded into operands and
transmitted in separate bands according to the type of operand
encoded. The padding bytes of switch instructions and the last two
bytes of invokeinterface instructions are discarded, because they
can be reconstructed by the decompressor.</p>
<p>A "wide" prefix bytecode is transmitted in <tt>bc_codes</tt>.
The instruction following the prefix is decoded in its wide format,
but (except in the case of iinc) it is transmitted in the same way,
and using the same bands, as the normal (non-wide) format. The wide
format of the iinc instruction uses <tt>bc_short</tt> instead of
<tt>bc_byte</tt> to transmit its second operand.</p>
<p>Every branch instruction transmits its target (or targets, in
the case of the switches) in the <tt>bc_label</tt> band, encoded as
the difference between the renumbered BCI of the branch target and
the renumbered BCI of the branch itself. (The renumbering, as
described in the section <a href="#bci_renumbering">Attribute Layout Definition</a>, numbers the first
instruction as zero, the second as one, and so forth.) Differences
between renumbered BCIs are very compact; the primary encoding of
BRANCH5 also takes advantage of the fact that most such differences
are positive, because most branches are forward branches.</p>
<p>The <tt>bc_classref</tt> band carries incremented indexes into
the <tt>cp_Class</tt> constant pool. The incrementing (by unity)
reserves the code zero, which always refers to the current class.
(This provides a a compact form for the most common class
reference, which is a self-reference.)</p>
<p>The <tt>bc_byte</tt> and <tt>bc_short</tt> bands carry
fixed-sized operands. These operands are not transmitted as general
32-bit integers because their instructions, as originally defined,
already serve as specially compressed transmission formats. Integer
values of these bands are treated as unsigned, even when they are
semantically signed as operands. The <tt>bc_byte</tt> band is used
for the last operands of multianewarray and non-wide iinc
instructions, and for the operands of bipush and newarray
instructions. The <tt>bc_short</tt> band is used for the last
operands of wide iinc instructions, and for the operands of sipush
instructions.</p>
<p>The bands <tt>bc_intref</tt>, <tt>bc_floatref</tt>,
<tt>bc_longref</tt>, <tt>bc_doubleref</tt>, <tt>bc_stringref</tt>,
<tt>bc_fieldref</tt>, <tt>bc_methodref</tt>, and
<tt>bc_imethodref</tt> transmit ordinary indexes into the constant
pools <tt>cp_Int</tt>, <tt>cp_Float</tt>, <tt>cp_Long</tt>,
<tt>cp_Double</tt>, <tt>cp_String</tt>, <tt>cp_Field</tt>,
<tt>cp_Method</tt>, and <tt>cp_Imethod</tt>, respectively.</p>
<p>The band <tt>bc_indyref</tt> transmits indexes into
<tt>cp_InvokeDynamic</tt>, for <tt>invokedynamic</tt>
instructions.</p>
<p>The band <tt>bc_loadablevalueref</tt> transmits indexes into the constant
pool group <tt>cp_LoadableValue</tt>, such that zero refers to the
first CONSTANT_Integer constant, and so on. It is transmitted
immediately after <tt>bc_stringref</tt>. (Typically, this band is
used for <tt>cp_MethodHandle</tt> constants.)</p>
<p>(The <tt>invokedynamic</tt> instructions may only appear when
<tt>#archive_majver</tt> is 170 or higher. They and their related
constant pool types were introduced in recent revisions of the
classfile format.)</p>
<p>For every lookupswitch or tableswitch instruction, the number of
cases is transmitted in <tt>bc_case_count</tt>, and the default
label is transmitted in <tt>bc_label</tt>. Each case value and case
target of a lookupswitch is transmitted in <tt>bc_case_value</tt>
and <tt>bc_label</tt>, respectively. The initial case value of a
tableswitch is transmitted in <tt>bc_case_value</tt>, and each of
its case targets is transmitted in <tt>bc_label</tt>.</p>
<p>If the first byte of an instruction has a code in the range
[202..255], or if an instruction's operands cannot be parsed
according to the requirements of this specification, it is a
non-standard instruction. Every byte of a non-standard instruction
must be transmitted in a special envelope in order to warn the
decompressor to accept it literally. The envelope consists of a
series of "byte_escape" and "ref_escape" opcodes in the
<tt>bc_code</tt> band, corresponding sizes in <tt>bc_escsize</tt>
and <tt>bc_escrefsize</tt>, bytes in <tt>bc_escbyte</tt>, and
constant pool references in <tt>bc_escref</tt>. Every constant pool
reference in a non-standard instruction must be escaped and
transmitted in the <tt>bc_escref</tt> band. Each ref_escape wraps
one such constant pool reference, of size up to four bytes. The
transmitted reference is an index into <tt>cp_All</tt>, such that
zero refers to the first CONSTANT_Utf8 constant, and so on.</p>
<table border="1" summary="escape codes">
<tr align="center">
<th id="escape_code_e">Escape<br />
Opcode</th>
<th id="escape_code_so">Size<br />
Operand</th>
<th id="escape_code_os">Operand<br />
Size</th>
<th id="escape_code_sb">Size<br />
Band</th>
<th id="escape_code_d">Data<br />
Band</th>
<th id="escape_code_ov">Opcode<br />
Value</th>
</tr>
<tr>
<td headers="escape_code_e">byte_escape</td>
<td headers="escape_code_so">N&lt;=255</td>
<td headers="escape_code_os">N bytes</td>
<td headers="escape_code_sb"><tt>bc_escsize</tt></td>
<td headers="escape_code_d"><tt>bc_escbyte</tt></td>
<td headers="escape_code_ov">254</td>
</tr>
<tr>
<td headers="escape_code_e">ref_escape</td>
<td headers="escape_code_so">N&lt;=2</td>
<td headers="escape_code_os">N bytes</td>
<td headers="escape_code_sb"><tt>bc_escrefsize</tt></td>
<td headers="escape_code_d"><tt>bc_escref</tt></td>
<td headers="escape_code_ov">253</td>
</tr>
</table>
<p>There is no need for special transmission of any other operand
type within non-standard instructions, because the Pack200 format
exactly preserves all instruction bytes except for constant pool
references. This specification does not address the means by which
compressors adapt to the presence and format of non-standard
instructions. It simply requires decompressors to decode them
correctly. <!--
[Considered defining a pseudo-attribute which allows a
class to fully specify its constant pool ordering.
 This would allow attributes to be passed through without
parsing, at the cost of some bloat.
 Did not seem worth the effort.  Smart compressors can
use 'V' elements to drive an arbitrary layout, and
dumb compressors can just pass the file bytewise.
 --></p>
<p>Here is a table of the specially rewritten transmission forms
for instructions:</p>
<table border="1" summary=
"specially rewritten transmission forms for instructions">
<tr align="center">
<th id="instructions_oi">Original<br />
Instruction</th>
<th id="instructions_op1">Operand</th>
<th id="instructions_ti">Transmission<br />
Instruction</th>
<th id="instructions_rr">Rewrite<br />
Required?</th>
<th id="instructions_op2">Opcode</th>
</tr>
<tr>
<td headers="instructions_oi">ldc</td>
<td headers="instructions_op1">cp_String[i]</td>
<td headers="instructions_ti">sldc</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">18 <em>(=ldc)</em></td>
</tr>
<tr>
<td headers="instructions_oi">ldc</td>
<td headers="instructions_op1">cp_Class[i]</td>
<td headers="instructions_ti">cldc</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">233</td>
</tr>
<tr>
<td headers="instructions_oi">ldc</td>
<td headers="instructions_op1">cp_Int[i]</td>
<td headers="instructions_ti">ildc</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">234</td>
</tr>
<tr>
<td headers="instructions_oi">ldc</td>
<td headers="instructions_op1">cp_Float[i]</td>
<td headers="instructions_ti">fldc</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">235</td>
</tr>
<tr>
<td headers="instructions_oi">ldc_w</td>
<td headers="instructions_op1">cp_String[i]</td>
<td headers="instructions_ti">sldc_w</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">19 <em>(=ldc_w)</em></td>
</tr>
<tr>
<td headers="instructions_oi">ldc_w</td>
<td headers="instructions_op1">cp_Class[i]</td>
<td headers="instructions_ti">cldc_w</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">236</td>
</tr>
<tr>
<td headers="instructions_oi">ldc_w</td>
<td headers="instructions_op1">cp_Int[i]</td>
<td headers="instructions_ti">ildc_w</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">237</td>
</tr>
<tr>
<td headers="instructions_oi">ldc_w</td>
<td headers="instructions_op1">cp_Float[i]</td>
<td headers="instructions_ti">fldc_w</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">238</td>
</tr>
<tr>
<td headers="instructions_oi">ldc2_w</td>
<td headers="instructions_op1">cp_Long[i]</td>
<td headers="instructions_ti">lldc2_w</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">20 <em>(=ldc2_w)</em></td>
</tr>
<tr>
<td headers="instructions_oi">ldc2_w</td>
<td headers="instructions_op1">cp_Double[i]</td>
<td headers="instructions_ti">dldc2_w</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">239</td>
</tr>
<tr>
<td headers="instructions_oi">ldc</td>
<td headers="instructions_op1">cp_LoadableValue[i]</td>
<td headers="instructions_ti">qldc</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">240</td>
</tr>
<tr>
<td headers="instructions_oi">ldc_w</td>
<td headers="instructions_op1">cp_LoadableValue[i]</td>
<td headers="instructions_ti">qldc_w</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">241</td>
</tr>
<tr>
<td headers="instructions_oi">getstatic</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">getstatic_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">202</td>
</tr>
<tr>
<td headers="instructions_oi">putstatic</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">putstatic_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">203</td>
</tr>
<tr>
<td headers="instructions_oi">getfield</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">getfield_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">204</td>
</tr>
<tr>
<td headers="instructions_oi">putfield</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">putfield_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">205</td>
</tr>
<tr>
<td headers="instructions_oi">invokevirtual</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">invokevirtual_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">206</td>
</tr>
<tr>
<td headers="instructions_oi">invokespecial</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">invokespecial_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">207</td>
</tr>
<tr>
<td headers="instructions_oi">invokestatic</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">invokestatic_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">208</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; getstatic</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">aload_0_getstatic_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">209</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; putstatic</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">aload_0_putstatic_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">210</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; getfield</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">aload_0_getfield_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">211</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; putfield</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">aload_0_putfield_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">212</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; invokevirtual</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">aload_0_invokevirtual_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">213</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; invokespecial</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">aload_0_invokespecial_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">214</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; invokestatic</td>
<td headers="instructions_op1"><em>(this class member)</em></td>
<td headers="instructions_ti">aload_0_invokestatic_this</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">215</td>
</tr>
<tr>
<td headers="instructions_oi">getstatic</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">getstatic_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">216</td>
</tr>
<tr>
<td headers="instructions_oi">putstatic</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">putstatic_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">217</td>
</tr>
<tr>
<td headers="instructions_oi">getfield</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">getfield_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">218</td>
</tr>
<tr>
<td headers="instructions_oi">putfield</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">putfield_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">219</td>
</tr>
<tr>
<td headers="instructions_oi">invokevirtual</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">invokevirtual_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">220</td>
</tr>
<tr>
<td headers="instructions_oi">invokespecial</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">invokespecial_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">221</td>
</tr>
<tr>
<td headers="instructions_oi">invokestatic</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">invokestatic_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">222</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; getstatic</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">aload_0_getstatic_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">223</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; putstatic</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">aload_0_putstatic_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">224</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; getfield</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">aload_0_getfield_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">225</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; putfield</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">aload_0_putfield_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">226</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; invokevirtual</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">aload_0_invokevirtual_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">227</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; invokespecial</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">aload_0_invokespecial_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">228</td>
</tr>
<tr>
<td headers="instructions_oi">aload_0; invokestatic</td>
<td headers="instructions_op1"><em>(super class member)</em></td>
<td headers="instructions_ti">aload_0_invokestatic_super</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">229</td>
</tr>
<tr>
<td headers="instructions_oi">invokespecial</td>
<td headers="instructions_op1"><em>(this class
&lt;init&gt;)</em></td>
<td headers="instructions_ti">invokespecial_this_init</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">230</td>
</tr>
<tr>
<td headers="instructions_oi">invokespecial</td>
<td headers="instructions_op1"><em>(super class
&lt;init&gt;)</em></td>
<td headers="instructions_ti">invokespecial_super_init</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">231</td>
</tr>
<tr>
<td headers="instructions_oi">invokespecial</td>
<td headers="instructions_op1"><em>(new class
&lt;init&gt;)</em></td>
<td headers="instructions_ti">invokespecial_new_init</td>
<td headers="instructions_rr">no</td>
<td headers="instructions_op2">232</td>
</tr>
<tr>
<td headers="instructions_oi">invokespecial</td>
<td headers="instructions_op1">cp_Imethod[i]</td>
<td headers="instructions_ti">invokespecial_int</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">242</td>
</tr>
<tr>
<td headers="instructions_oi">invokestatic</td>
<td headers="instructions_op1">cp_Imethod[i]</td>
<td headers="instructions_ti">invokestatic_int</td>
<td headers="instructions_rr">yes</td>
<td headers="instructions_op2">243</td>
</tr>
</table>
<p>The <tt>qldc</tt> and <tt>qldc_w</tt> instructions use indexes
into the constant pool group <tt>cp_LoadableValue</tt> to select
arbitrary loadable constants. (These instructions may only appear
when <tt>#archive_majver</tt> is 170 or higher. Early versions of
the classfile format do not require them.) Decompressors are
required to accept any constant reference as an operand to one of
these instructions, but compressors are encouraged to transmit only
constants which cannot be encoded by other variants of
<tt>ldc</tt>, specifically elements of <tt>cp_MethodHandle</tt> and
<tt>cp_MethodType</tt>.</p>
<p>(Note: A previous version of this specification referred to the
string-bearing variants of <tt>ldc</tt>, <tt>sldc</tt> and
<tt>sldc_w</tt>, as <tt>aldc</tt> and <tt>aldc_w</tt>. Despite the
new names, the code points and their interpretation have not
changed. The old names are deprecated.)</p>
<p>Every bytecode instruction is contained by a class, called the
<em>current class</em>. The superclass (if any) of the current
class is the <em>current super class</em>. The operand of the
textually most recent "new" instruction (in the same method) is
called the <em>current new class</em>.</p>
<p>If an instruction refers to a field or method in the current
class, it may (at the compressor's option) be rewritten for
transmission as a corresponding opcode spelled with "_this".
Likewise, an instruction referring to a field or method in the
current super class may be rewritten as a corresponding opcode
spelled with "_super". In either case, if the immediately preceding
instruction is aload_0 (opcode 42), the transmission of that
instruction may be suppressed by the compressor, and the
corresponding opcode spelled with "aload_0_" selected instead;
otherwise the "aload_0_" variant may not be selected.</p>
<p>If an invokespecial instruction refers to a method named
&lt;init&gt; in the current class, the current super class, or the
current new class, the compressor may choose to rewrite it as an
invokespecial_this_init, invokespecial_super_init, or
invokespecial_new_init, respectively.</p>
<p>If an invokespecial or an invokestatic instruction has an operand
of type CONSTANT_InterfaceMethodref, then the compressor must transmit
those methods using the pseudo-instructions invokespecial_int and
invokestatic_int respectively. These instructions may only appear
when <tt>#archive_majver</tt> is 171 or higher.
<p>Field (resp. method) operands of rewritten instructions spelled
with "_this" (but not "_init") are transmitted in the special band
<tt>bc_thisfield</tt> (resp. <tt>bc_thismethod</tt>). The numbering
of these operands is defined by taking the sequence of symbols in
<tt>cp_Field</tt> (resp. <tt>cp_Method</tt>) and selecting only
members of the current class. The resulting subset, without
changing its order, is renumbered starting with zero. This provides
a compact mapping of small integers to members of the current
class.</p>
<p>Likewise, operands of rewritten instructions spelled with
"_super" (but not "_init") are transmitted in the
<tt>bc_superfield</tt> or <tt>bc_supermethod</tt> band, and
renumbered as a subset of <tt>cp_Field</tt> or <tt>cp_Method</tt>,
selecting only members of the current super class.</p>
<p>Finally, operands of the rewritten instructions spelled with
"_init" are transmitted in the band <tt>bc_initref</tt>, and
renumbered as a subset of <tt>cp_Method</tt>, selected according to
the appropriate class (current, current super, or current new), and
also selected to have the name &lt;init&gt;. (The index transmitted
is usually very small; in effect it selects only the signature of
the invoked method, and most classes possess only a few
constructors.)</p>
<p>Here is a table summarizing the transmission of instructions of
more than one byte.</p>
<table border="1" summary=
"transmission instructions of more than one byte">
<tr align="center">
<th id="instructions_plus1_i">Instruction</th>
<th id="instructions_plus1_o">Operand</th>
<th id="instructions_plus1_t">Transmitted<br />
Value</th>
<th id="instructions_plus1_b">Band</th>
</tr>
<tr>
<td headers="instructions_plus1_i">bipush</td>
<td headers="instructions_plus1_o">(byte)&nbsp;x</td>
<td headers="instructions_plus1_t">x&nbsp;&amp;&nbsp;0xFF</td>
<td headers="instructions_plus1_b"><tt>bc_byte</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">sipush</td>
<td headers="instructions_plus1_o">(short)&nbsp;x</td>
<td headers="instructions_plus1_t">x&nbsp;&amp;&nbsp;0xFFFF</td>
<td headers="instructions_plus1_b"><tt>bc_short</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">ildc</td>
<td headers="instructions_plus1_o">cp_Int[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_intref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">fldc</td>
<td headers="instructions_plus1_o">cp_Float[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_floatref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">sldc</td>
<td headers="instructions_plus1_o">cp_String[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_stringref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">qldc</td>
<td headers="instructions_plus1_o">cp_LoadableValue[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_loadablevalueref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">cldc</td>
<td headers="instructions_plus1_o">current&nbsp;class</td>
<td headers="instructions_plus1_t">0</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">cldc</td>
<td headers="instructions_plus1_o">cp_Class[i]</td>
<td headers="instructions_plus1_t">i+1</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">ildc_w</td>
<td headers="instructions_plus1_o">cp_Int[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_intref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">fldc_w</td>
<td headers="instructions_plus1_o">cp_Float[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_floatref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">sldc_w</td>
<td headers="instructions_plus1_o">cp_String[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_stringref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">qldc_w</td>
<td headers="instructions_plus1_o">cp_LoadableValue[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_loadablevalueref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">cldc_w</td>
<td headers="instructions_plus1_o">current&nbsp;class</td>
<td headers="instructions_plus1_t">0</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">cldc_w</td>
<td headers="instructions_plus1_o">cp_Class[i]</td>
<td headers="instructions_plus1_t">i+1</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">lldc2_w</td>
<td headers="instructions_plus1_o">cp_Long[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_long</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">dldc2_w</td>
<td headers="instructions_plus1_o">cp_Double[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_double</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">*load</td>
<td headers="instructions_plus1_o">locals[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_local</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">*store</td>
<td headers="instructions_plus1_o">locals[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_local</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">ret</td>
<td headers="instructions_plus1_o">locals[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_local</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">iinc</td>
<td headers="instructions_plus1_o">locals[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_local</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">iinc&nbsp;(not&nbsp;wide)</td>
<td headers="instructions_plus1_o">(byte)&nbsp;x</td>
<td headers="instructions_plus1_t">x&nbsp;&amp;&nbsp;0xFF</td>
<td headers="instructions_plus1_b"><tt>bc_byte</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">iinc&nbsp;(wide)</td>
<td headers="instructions_plus1_o">(short)&nbsp;x</td>
<td headers="instructions_plus1_t">x&nbsp;&amp;&nbsp;0xFFFF</td>
<td headers="instructions_plus1_b"><tt>bc_short</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">if**</td>
<td headers="instructions_plus1_o">pc</td>
<td headers="instructions_plus1_t"><em>(delta/renumbered)</em></td>
<td headers="instructions_plus1_b"><tt>bc_label</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">if_**</td>
<td headers="instructions_plus1_o">pc</td>
<td headers="instructions_plus1_t"><em>(delta/renumbered)</em></td>
<td headers="instructions_plus1_b"><tt>bc_label</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">goto</td>
<td headers="instructions_plus1_o">pc</td>
<td headers="instructions_plus1_t"><em>(delta/renumbered)</em></td>
<td headers="instructions_plus1_b"><tt>bc_label</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">jsr</td>
<td headers="instructions_plus1_o">pc</td>
<td headers="instructions_plus1_t"><em>(delta/renumbered)</em></td>
<td headers="instructions_plus1_b"><tt>bc_label</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">goto_w</td>
<td headers="instructions_plus1_o">pc</td>
<td headers="instructions_plus1_t"><em>(delta/renumbered)</em></td>
<td headers="instructions_plus1_b"><tt>bc_label</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">jsr_w</td>
<td headers="instructions_plus1_o">pc</td>
<td headers="instructions_plus1_t"><em>(delta/renumbered)</em></td>
<td headers="instructions_plus1_b"><tt>bc_label</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">tableswitch</td>
<td headers="instructions_plus1_o">case&nbsp;count</td>
<td headers="instructions_plus1_t">count</td>
<td headers="instructions_plus1_b"><tt>bc_case_count</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">tableswitch</td>
<td headers="instructions_plus1_o">default&nbsp;pc</td>
<td headers="instructions_plus1_t"><em>(delta/renumbered)</em></td>
<td headers="instructions_plus1_b"><tt>bc_label</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">tableswitch</td>
<td headers="instructions_plus1_o">first&nbsp;case&nbsp;value</td>
<td headers="instructions_plus1_t">value</td>
<td headers="instructions_plus1_b"><tt>bc_case_value</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">tableswitch</td>
<td headers="instructions_plus1_o">each&nbsp;case&nbsp;pc</td>
<td headers="instructions_plus1_t"><em>(delta/renumbered)</em></td>
<td headers="instructions_plus1_b"><tt>bc_label</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">lookupswitch</td>
<td headers="instructions_plus1_o">case&nbsp;count</td>
<td headers="instructions_plus1_t">count</td>
<td headers="instructions_plus1_b"><tt>bc_case_count</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">lookupswitch</td>
<td headers="instructions_plus1_o">default&nbsp;pc</td>
<td headers="instructions_plus1_t"><em>(delta/renumbered)</em></td>
<td headers="instructions_plus1_b"><tt>bc_label</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">lookupswitch</td>
<td headers="instructions_plus1_o">each&nbsp;case&nbsp;value</td>
<td headers="instructions_plus1_t">value</td>
<td headers="instructions_plus1_b"><tt>bc_case_value</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">lookupswitch</td>
<td headers="instructions_plus1_o">each&nbsp;case&nbsp;pc</td>
<td headers="instructions_plus1_t"><em>(delta/renumbered)</em></td>
<td headers="instructions_plus1_b"><tt>bc_label</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">new</td>
<td headers="instructions_plus1_o">current&nbsp;class</td>
<td headers="instructions_plus1_t">0</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">new</td>
<td headers="instructions_plus1_o">cp_Class[i]</td>
<td headers="instructions_plus1_t">1+i</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">newarray</td>
<td headers="instructions_plus1_o">type&nbsp;code</td>
<td headers="instructions_plus1_t">value</td>
<td headers="instructions_plus1_b"><tt>bc_byte</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">anewarray</td>
<td headers="instructions_plus1_o">current&nbsp;class</td>
<td headers="instructions_plus1_t">0</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">anewarray</td>
<td headers="instructions_plus1_o">cp_Class[i]</td>
<td headers="instructions_plus1_t">1+i</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">checkcast</td>
<td headers="instructions_plus1_o">current&nbsp;class</td>
<td headers="instructions_plus1_t">0</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">checkcast</td>
<td headers="instructions_plus1_o">cp_Class[i]</td>
<td headers="instructions_plus1_t">1+i</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">instanceof</td>
<td headers="instructions_plus1_o">current&nbsp;class</td>
<td headers="instructions_plus1_t">0</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">instanceof</td>
<td headers="instructions_plus1_o">cp_Class[i]</td>
<td headers="instructions_plus1_t">1+i</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">multianewarray</td>
<td headers="instructions_plus1_o">cp_Class[i]</td>
<td headers="instructions_plus1_t">1+i</td>
<td headers="instructions_plus1_b"><tt>bc_classref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">multianewarray</td>
<td headers="instructions_plus1_o">rank</td>
<td headers="instructions_plus1_t">rank&nbsp;&amp;&nbsp;0xFF</td>
<td headers="instructions_plus1_b"><tt>bc_byte</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">getstatic</td>
<td headers="instructions_plus1_o">cp_Field[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_fieldref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">putstatic</td>
<td headers="instructions_plus1_o">cp_Field[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_fieldref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">getfield</td>
<td headers="instructions_plus1_o">cp_Field[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_fieldref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">putfield</td>
<td headers="instructions_plus1_o">cp_Field[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_fieldref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">invokevirtual</td>
<td headers="instructions_plus1_o">cp_Method[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_methodref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">invokespecial</td>
<td headers="instructions_plus1_o">cp_Method[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_methodref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">invokestatic</td>
<td headers="instructions_plus1_o">cp_Method[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_methodref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">invokeinterface</td>
<td headers="instructions_plus1_o">cp_Imethod[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_imethodref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">invokespecial_int</td>
<td headers="instructions_plus1_o">cp_Imethod[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_imethodref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">invokestatic_int</td>
<td headers="instructions_plus1_o">cp_Imethod[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_imethodref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">invokedynamic</td>
<td headers="instructions_plus1_o">cp_InvokeDynamic[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_indyref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">**_this</td>
<td headers="instructions_plus1_o">this_fields[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_thisfield</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">**_this</td>
<td headers="instructions_plus1_o">this_methods[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_thismethod</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">**_super</td>
<td headers="instructions_plus1_o">super_fields[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_superfield</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">**_super</td>
<td headers="instructions_plus1_o">super_methods[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_supermethod</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">invokespecial_this_init</td>
<td headers="instructions_plus1_o">this_constructors[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_initref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">invokespecial_super_init</td>
<td headers="instructions_plus1_o">super_constructors[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_initref</tt></td>
</tr>
<tr>
<td headers="instructions_plus1_i">invokespecial_new_init</td>
<td headers="instructions_plus1_o">new_constructors[i]</td>
<td headers="instructions_plus1_t">i</td>
<td headers="instructions_plus1_b"><tt>bc_initref</tt></td>
</tr>
</table>
<a name="encodings" id="encodings"></a> <a name="tocSpBaCo" id=
"tocSpBaCo"></a>
<h2>6. Specification of Band Coding</h2>
A Pack200 band consists of a sequence of small integers, each of
which is representable in 32 bits. Depending on the intended use of
these numbers, they may be interpreted to possess a twos-complement
sign.
<p>Each integer is coded for transmission as a byte sequence, using
between one and five bytes, according to a previously determined
encoding. The encoding may by a primary encoding for the current
band as specified as part of this Pack200 archive format
specification, or the encoding may depend on information
transmitted before the occurrence of the encoded integer.</p>
<p>(Note: In this account of encodings, bytes are indivisible
octets which express unsigned values in [0,255].)</p>
<a name="tocEnSmWhNu" id="tocEnSmWhNu"></a>
<h3>6.1. Encoding of Small Whole Numbers</h3>
There is a small but flexible set of possible encodings allowed by
the archive. They are all based on a two-parameter scheme of
codings for small unsigned integers, which is further parameterized
by options for sign representation and delta encoding, and by
special modes for slowly varying encodings, and for the compact
renaming of frequent values. <a name="tocScMuCo" id=
"tocScMuCo"></a>
<h4>6.1.1. Scheme of Multiple Codings</h4>
The encoding of a small whole number depends on two independent
parameters B and H, and a derived parameter L:
<table border="1" summary="multiple coding scheme">
<tr align="center">
<th id="multiple_coding_scheme_n">Name</th>
<th id="multiple_coding_scheme_r">Range</th>
<th id="multiple_coding_scheme_m">Meaning</th>
</tr>
<tr>
<td headers="multiple_coding_scheme_n">B</td>
<td headers="multiple_coding_scheme_r">[1..5]</td>
<td headers="multiple_coding_scheme_m">maximum byte length</td>
</tr>
<tr>
<td headers="multiple_coding_scheme_n">H</td>
<td headers="multiple_coding_scheme_r">[1..256]</td>
<td headers="multiple_coding_scheme_m">number of high byte
values</td>
</tr>
<tr>
<td headers="multiple_coding_scheme_n">L</td>
<td headers="multiple_coding_scheme_r">[0..255]</td>
<td headers="multiple_coding_scheme_m">number of low byte values,
defined as (256-H)</td>
</tr>
</table>
<p>Given any two values B and H, there is a coding (B,H) which
establishes a one-to-one correspondence between an initial sequence
of non-negative integers, and an "encoding sets" of short sequences
of bytes.</p>
<p>Moreover, no byte sequence in the encoding set is a proper
prefix of another byte sequence in the same set. prefix. This
means, informally, that encodings are self-sizing, or
"parseable".</p>
<p>Also, the encoding set is as full as possible, so that every
long-enough sequence of bytes begins with a unique prefix of bytes
drawn from the encoding set. In particular, every sequence of B
bytes has a (unique) prefix in the encoding set for the (B,H)
coding.</p>
<a name="tocDeEnBySe" id="tocDeEnBySe"></a>
<h4>6.1.2. Definition of Encoding Byte Sequences</h4>
Relative to a given (B,H) coding, we say that a byte is "high" if
its value is in the range <tt>[256-H..255]</tt>. We also say that a
byte is "low" if L is positive and the byte's value is in the range
<tt>[0..L-1]</tt>
<p>Given a (B,H) coding, a sequence of bytes is in its encoding set
if and only if all of the following are true:</p>
<ul>
<li>the sequence contains at least one and no more than B
bytes</li>
<li>all bytes except the last are "high"</li>
<li>either the last byte is "low", or else the sequence has B
bytes</li>
</ul>
<p>As a consequence of this definition, the encoding set be
regarded as satisfying this regular expression, in terms of high
and low bytes:</p>
<pre class="codblock">
  encoding_set = (high* low) | (high)^B
</pre>
<p>(Note: In this specification the up-caret sign '^' denotes
exponentiation, either of regular expressions as above, or of
numbers.)</p>
<p>If n is less than B then the number of (B,H) encodings of length
exactly n is <tt>(H^(n-1) * L)</tt>. The number of (B,H) encodings
of length exactly B is <tt>(H^(B-1) * (L+H))</tt>. The sum of these
values for all n in <tt>[1..B]</tt> is the total size of the
encoding set for a (B,H) coding. It is called <em>Card(B,H)</em>
and is therefore defined as:</p>
<pre class="codeblock">
  Card(B,H) = (L * (1-H^B)/(1-H)) + H^B
    if H&gt;1, or else
  Card(B,1) = B*255+1
 
</pre>
<p>If H is 256, there are no low bytes, and the encoding set
consists of all possible sequences of exactly B bytes, and
Card(B,H) is <tt>256^B</tt>.</p>
<p>Otherwise, the encoding set consists of sequences of various
lengths, from 1 to B inclusive. In particular, there are L one-byte
sequences. We will use these elsewhere to encode the "favored"
integers of the highest frequency. Note that the encoding rules
specified elsewhere in this document are designed to produce
smaller integers more frequently than larger ones.</p>
<p>Note that L can be viewed as a "sharpness" parameter, expressing
the sharpness of the distribution about zero of the expected values
to be encoded. The larger L is, the more the encoding favors
distributions of values which are close to zero, and rarely far
from it. Larger H values favor "flatter" distributions, up to
H=256, L=0, which favorably encodes completely random data within
the range of the coding.</p>
<a name="tocDeDeWhNuVa" id="tocDeDeWhNuVa"></a>
<h4>6.1.3. Definition of Decoded Whole Number Values</h4>
The range of a (B,H) coding is the integers in
<tt>[0..Card(B,H)-1]</tt>. (Note that this range applies only to
the unsigned codings introduced so far in this section.)
<p>Given the sequence of N byte values b[0] .. b[N-1], the
sorting-based definition given above implies that the decoded
integer value of this byte sequence is the little-endian base-H
scaled sum of the bytes, and is called <em>Decode(B,H; b)</em>:</p>
<pre class="codeblock">
  Decode(B,H; b[*]) = Sum[0&lt;=i&lt;N]( b[i] * H^i )
 
</pre>
<p>As a consequence of this definition, each byte sequence in the
encoding set corresponds uniquely to an arithmetic integer value in
that range. This correspondence may be observed by ordering the
byte sequences first by length, and second according to their
antilexicographic (little-endian) order. Each element in resulting
sequence decodes into its own zero-based index within the
sequence.</p>
<p>Note that the number zero is always encoded by a sequence of B
zero bytes (if H is 256) or else by single zero byte.</p>
<p>The largest encoded arithmetic value is always encoded by a
sequence of B bytes of value 255.</p>
<p>Note that the (B,H) encodings (1,256), (2,256), and (4,256) are
identical with the conventional little-endian representations of
unsigned bytes, unsigned 16-bit integers, and unsigned 32-bit
integers.</p>
<p>Note that some may represent arithmetic values greater than
<tt>2^31-1</tt> or even <tt>2^32-1</tt>. This is a feature of the
(B,H) coding scheme. (But sometimes intermediate 64-bit values are
required when multiple sign bits are being used, as described
below. The rules given below for signed values require the
compressor to emit the simplest encoding that will suffice to
transmit the required 32-bit integer, even if more complex
sequences would produce the same 32-bit value, after
truncation.)</p>
<p>Note that implementations are not always free to truncate
intermediate values when computing (B,H) coding values. However,
the final decoded values (after restoration of signs) will always
fit in 32 bits, as described in the next section.</p>
<a name="tocEnSiIn" id="tocEnSiIn"></a>
<h4>6.2. Encoding of Signed Integers</h4>
In order to encode signed 32-bit numbers we add another parameter
to the (B,H) coding scheme.
<table border="1" summary="encoding of signed integers">
<tr align="center">
<th id="signed_integers_encoding_n">Name</th>
<th id="signed_integers_encoding_r">Range</th>
<th id="signed_integers_encoding_m">Meaning</th>
</tr>
<tr>
<td headers="signed_integers_encoding_n">B</td>
<td headers="signed_integers_encoding_r">[1..5]</td>
<td headers="signed_integers_encoding_m">maximum byte length</td>
</tr>
<tr>
<td headers="signed_integers_encoding_n">H</td>
<td headers="signed_integers_encoding_r">[1..256]</td>
<td headers="signed_integers_encoding_m">number of high byte
values</td>
</tr>
<tr>
<td headers="signed_integers_encoding_n">L</td>
<td headers="signed_integers_encoding_r">[0..255]</td>
<td headers="signed_integers_encoding_m">number of low byte values,
defined as (256-H)</td>
</tr>
<tr>
<td headers="signed_integers_encoding_n">S</td>
<td headers="signed_integers_encoding_r">[0..2]</td>
<td headers="signed_integers_encoding_m">number of sign bits</td>
</tr>
</table>
<p>The whole number U obtained from a (B,H) coding is converted to
a signed 32-bit value X in a manner which depends on the parameter
S. This process is called <em>sign conversion</em>.</p>
<p>Informally, sign conversion is performed by 32-bit truncation if
S=0. Otherwise, the low-order bits of U are collectively treated as
a sign bit, so that X will be negative only if all sign bits are
set. The two conversions from U to positive X and U to negative X
are independently dense and monotonic in opposite directions, as
defined below.</p>
<p>Unlike the (B,H) coding, a (B,H,S) coding represents only
numbers in a specifically defined range, which is never larger than
<tt>[-2^31..2^31-1]</tt>.</p>
<p>In what follows, for each (B,H,S) coding, we define
Range(B,H,S), and the method used to represent 32-bit signed values
with that coding.</p>
<p>A (B,H) encoding byte sequence is not a legal input to a
corresponding (B,H,S) coding if it represents a whole number U
which does not convert into the range of the (B,H,S) coding. Also,
if there are two byte sequences encoding values U1 and U2 which
both map into the same point X in the signed range, only the byte
sequence for the smaller of U1 and U2 is legal.</p>
<p>Thus, a (B,H,S) coding may have a smaller cardinality than the
corresponding (B,H) coding, due to illegal encoding byte
sequences.</p>
<p>The range of a (B,H,S) coding contains all 32-bit signed
integers <tt>[-2^31..2^31-1]</tt> if Card(B,H) is <tt>2^32</tt> or
more. (Negative values are represented by 31-bit unsigned
overflow.) If the coding encodes fewer unsigned values, the top of
its range is clipped to <tt>2^31-1</tt>, and the bottom of its
range is clipped to <tt>-2^31</tt>.</p>
<p>More precisely, the range of a (B,H,S) coding is called
<em>Range(B,H,S)</em> and is defined (partially, for S=0) as:</p>
<pre class="codeblock">
  Range(B,H,S) = [-2^31..2^31-1]
    if S=0, Card(B,H) &gt;= 2^32, or
  Range(B,H,S) = [0..2^31-1]
    if S=0, 2^31 &lt; Card(B,H) &lt; 2^32, or else
  Range(B,H,S) = [0..Card(B,H)-1]
    if S=0, Card(B,H) &lt;= 2^31
 
</pre>
A compressor is not allowed to emit a byte sequence which, when
interpreted according to the current coding, decodes to a value
outside of that coding's range.
<p>(Note that decompressors can produce arbitrary answers for
out-of-range codings, since compressors are not allowed to emit
them. This allows decompressors to use 32-bit arithmetic for most
calculations, ignoring the possibility of undesired wraparond.)</p>
<p>If S&gt;0, the decoding of a byte sequence is performed first by
decoding it as a (B,H) coding, and then by converting the decoded
whole number into a signed 32-bit number. This sign conversion
depends only on the arithmetic value U obtained from the (B,H)
coding, and on the value of S. The arithmetic value must be
preserved beyond 32 bits of precision, if the sign conversion will
produce a value within the range of the coding. If the cardinality
of the (B,H) coding is <tt>2^32</tt> or more, the (B,H,S) coding
produces all possible signed 32-bit negative values, by 32-bit
truncation of the intermediate unsigned whole number. The
intermediate unsigned arithmetic can be carried out (with some
care) using 32-bit unsigned numbers, or it can be carried out on
64-bit signed or unsigned numbers.</p>
<p>More precisely, the sign conversion operation
<em>SignConvert(S;U)</em> is defined as:</p>
<pre class="codeblock">
  SignConvert(S; U) = Cast32(U)
    if S==0; or
  SignConvert(S; U) = U - Floor(U / 2^S)
    if S&gt;0, (U % 2^S) &lt; 2^S-1, Card(B,H) &lt; 2^32
  SignConvert(S; U) = Cast32(U - Floor(U / 2^S))
    if S&gt;0, (U % 2^S) &lt; 2^S-1, Card(B,H) &gt;= 2^32
  SignConvert(S; U) = -Floor(U / 2^S)-1
    if S&gt;0, (U % 2^S) == 2^S-1
 
</pre>
The conversion from a large unsigned number of a negative 32-bit
number via wraparound is simply the familiar down-cast to a signed
32-bit int. It may be defined mathematically as:
<pre class="codeblock">
  Cast32(U) = ((U + 2^31) mod 2^32) - 2^31
 
</pre>
<a name="tocFuDiSiCo" id="tocFuDiSiCo"></a>
<h5>6.2.1. Further Discussion of Sign Conversion</h5>
Note that sign conversion always maps zero to zero. The reader may
also verify that, if S&gt;0, the range of SignConvert includes
[-1..1], and that it is dense and monotonic in any wholly positive
or wholly negative sub-range.
<p>As a consequence of the definition of <tt>SignConvert(S;U)</tt>,
the S low-order bits of U function as a sign bit. In effect, U is
partitioned into a sign field U0 (consisting of the S low-order
bits) and a significand U1 (consisting of all other bits of U).</p>
<p>In this alternative view of the definition of
<tt>SignConvert</tt>, if all S bits of U0 are set, then the decoded
signed value is the ones complement of U1. (Since this includes the
indefinite number of zero high-order bits of U, the resulting value
is arithmetically negative.)</p>
<p>Otherwise, if some of the S bits of U0 are clear, then the
significand U1 is scaled by the number of possible values of U0
(i.e., (2^2)-1 if S is 2) and U0 is added back in.</p>
<p>This provides a one-to-one correspondence between some portion
of the arithmetic interval <tt>[0..Card(B,H)-1]</tt> and
<tt>Range(B,H,S)</tt>.</p>
<p>The integers "favored" by this encoding are those of small
magnitude, but they can have either sign. If S is one, the encoding
has a balanced number of positive and negative favored values. If S
is two (or more), the encoding is skewed toward positive numbers,
but also favors a few negative numbers. We use such codings
elsewhere to encode values, such as branch displacements or deltas
of mostly-sorted data, which are usually positive but sometimes
negative.</p>
<p>Note that if S=1, this definition of sign conversion is
equivalent to an unsigned right shift followed by an exclusive-or
of the sign bit with all remaining bits:</p>
<pre class="codeblock">
  SignConvert(1; U) = (U &gt;&gt;&gt; 1) ^ -(U &amp; 1)
 
</pre>
<p>For S&gt;0, Range(B,H,S) is simply defined as the intersection
of the 32-bit signed range <tt>[-2^31..2^31-1]</tt> with the set
<tt>SignConvert(S; [0..Card(B,H)-1])</tt>, obtained by element-wise
application of sign conversion to every arithmetically
representable value of (B,H). Therefore, we can complete the
definition of <em>Range</em> as follows:</p>
<pre class="codeblock">
  Range(B,H,S) = [-2^31..2^31-1]
    if Card(B,H) &gt;= 2^32, or
  Range(B,H,S) = [0..2^31-1]
    if S=0, 2^31 &lt; Card(B,H) &lt; 2^32, or else
  Range(B,H,S) = [0..Card(B,H)-1]
    if S=0, Card(B,H) &lt;= 2^31

  Range(B,H,S) = [max(  -2^31, min SignConvert(S; Range(B,H,0)) )
               .. min( 2^31-1, max SignConvert(S; Range(B,H,0)) )]
 
</pre>
<p>(Note: When computing the bounds of a signed encoding (B,H,S),
it is useful to start with the largest unsigned value M of (B,H,0)
and perform sign-conversion on M, M-1, M-2, etc., noting the first
positive and the first negative value to be encountered. These will
be the inclusive bounds of the signed encoding's range.)</p>
<a name="tocAttCod" id="tocAttCod"></a>
<h4>6.3. Attributes of Codings</h4>
The cardinality of a (B,H) coding was defined above:
<pre class="codeblock">
  Card(B,H) = (L * (1-H^B)/(1-H)) + H^B
 
</pre>
<p>The cardinality of a (B,H,S) coding is determined by that of its
range:</p>
<pre class="codeblock">
  Card(B,H,S) = Card Range(B,H,S) &lt;= Card(B,H)
 
</pre>
<p>As defined, the range of any coding (B,H,S) is dense about zero
and can therefore be expressed as a closed interval:</p>
<pre class="codeblock">
  Range(B,H,S) = [Min(B,H,S)..Max(B,H,S)]
  -2^31 &lt;= Min(B,H,S) &lt;= 0
  0     &lt;  Max(B,H,S) &lt;= 2^31-1
 
</pre>
<p>Certain additional attributes can be predicated of codings. A
coding can either be signed or not, and it can be a full-range
coding, or a sub-range coding (or neither).</p>
<p>A (B,H,S) coding is <em>signed</em> if it can encode at least
one negative value. This is true if and only if S is non-zero or S
is zero and Card(B,H) is 2^32 or more.</p>
<p>A (B,H,S) coding is <em>full-range</em> if Range(B,H,S) is
<tt>[-2^31..2^31-1]</tt>.</p>
<p>A sub-range coding delivers less than 2^31 distinct values. More
precisely, a coding (B,H,S) is <em>sub-range</em> if Card(B,H,S)
&lt;= <tt>2^31-1</tt>. (Some codings are neither full-range nor
sub-range codings.)</p>
<p>As a consequence of these definitions, any coding for which
B&lt;=3 is a sub-range coding. Longer codings can also be
sub-ranges if they are "sharp" enough. Some examples are (4,192,0),
(5,32,0), and (5,32,1).</p>
<p>Also, the unsigned coding (4,256,0) is full-range, as is the
signed version (4,256,1), but not the doubly-signed version
(4,256,2).</p>
<p>The coding (4,255,0) is neither a sub-range nor a full-range
coding, since its cardinality is 2^31. It represents only
non-negative 32-bit integers, but its cardinality cannot be so
represented.</p>
<a name="tocEnCoSe" id="tocEnCoSe"></a>
<h4>6.4. Encoding of Correlated Sequences</h4>
Every single integer in the archive format is encoded according to
some coding in the scheme of (B,H,S) codings. In addition, special
attention is paid to sequences of integers (in the "bands"
described elsewhere) which show statistical regularity. In
particular, if a sequence of integers is found to exhibit a pattern
of small, regular first-order differences, those differences may be
encoded in place of the values themselves. This is described by a
fourth coding parameter added to the (B,H,S) scheme.
<table border="1" summary="encoding of correlated sequences">
<tr align="center">
<th id="corr_seq_enc_n">Name</th>
<th id="corr_seq_enc_r">Range</th>
<th id="corr_seq_enc_m">Meaning</th>
</tr>
<tr>
<td headers="corr_seq_enc_n">B</td>
<td headers="corr_seq_enc_r">[1..5]</td>
<td headers="corr_seq_enc_m">maximum byte length</td>
</tr>
<tr>
<td headers="corr_seq_enc_n">H</td>
<td headers="corr_seq_enc_r">[1..256]</td>
<td headers="corr_seq_enc_m">number of high byte values</td>
</tr>
<tr>
<td headers="corr_seq_enc_n">L</td>
<td headers="corr_seq_enc_r">[0..255]</td>
<td headers="corr_seq_enc_m">number of low byte values, defined as
(256-H)</td>
</tr>
<tr>
<td headers="corr_seq_enc_n">S</td>
<td headers="corr_seq_enc_r">[0..2]</td>
<td headers="corr_seq_enc_m">number of sign bits</td>
</tr>
<tr>
<td headers="corr_seq_enc_n">D</td>
<td headers="corr_seq_enc_r">[0..1]</td>
<td headers="corr_seq_enc_m">delta encoding order</td>
</tr>
</table>
<p>If D is zero, no differencing is performed, and the (B,H,S,0)
coding is in all ways identical to the corresponding (B,H,S)
coding. If D is one, the values are encoded in terms of their
successive differences.</p>
<p>(Note: Sequences which are mostly monotonically ascending will
often be favorably encoded using unsigned delta codings of the form
(5,H,0,1).)</p>
<p>Suppose a sequence of values X[i] is given, for some range of i
in [0..N-1]. This sequence will be representable by a (B,H,S,1)
coding only if the (B,H,S) coding is a sub-range or a full-range
coding. (If it is neither, there is no legal (B,H,S,1) coding.)</p>
<p>The sequence X[i] will be representable, only if there is a
series of "delta values" D[i] whose partial sums
<tt>Sum[j&lt;=i](D[j])</tt> can represent the values X[i].</p>
<p>Each (B,H,S,1) coding has a range, in which all X[i] values must
lie. This range is defined as <tt>Range(B,H,S,1) =
Range(B,H,0)</tt>. The range of a delta coding (B,H,S,1) contains
negative numbers only if it is based on a full-range coding
(B,H,S). Otherwise, the delta coding can only represent
non-negative numbers. In practice, this is not a severe
restriction, since in practice very few band elements are
negative.</p>
<p>The partial sums Sum[j&lt;=i](D[j]) are allowed to leave the
range, but the final X[i] values are always brought back into range
by adding or subtracting a multiple of Card Range(B,H,0).</p>
<p>More precisely:</p>
<pre class="codeblock">
  X[i] = Sum[j&lt;=i](D[j]) mod Card(B,H,0)
    if (B,H,S) is sub-range
  X[i] = (int32) Sum[j&lt;=i](D[j])
    if (B,H,S) is full-range
 
</pre>
(Here, the cast to <tt>int32</tt> denotes truncation to 32 bits.)
<p>Note that implementations can simply ignore 32-bit wraparound
when computing partial sums, if the coding is full-range.
Otherwise, more care must be taken to bring partial sums back into
range by subtracting or adding multiples of the range cardinality.
Also, 32-bit wraparound may be a hazard for ranges of size 2^30 or
more. It is possible to implement this using only 32-bit signed
arithmetic.</p>
<a name="tocEnUnVa" id="tocEnUnVa"></a>
<h4>6.5. Encodings of Uncorrelated Values</h4>
The coding methods described so far are designed to favor values
which, on average, tend to be near zero or near the preceding
value. Some data sets have marked statistical patterns in which
values have only weak arithmetic relations (to zero or to each
other), but which show strong repetitive patterns, especially in
their first-order statistics.
<p>The compressor may elect to use a population-based coding
transformation in such cases. This transformation takes a sequence
S of N arithmetic values and converts it into three value
sequences:</p>
<ul>
<li>F a table (arbitrary length K+1 &lt;&lt; N) of favored
values</li>
<li>T a sequence (length N) of value tokens</li>
<li>U a sequence (length &lt;&lt; N, depends on T) of unfavored
values</li>
</ul>
<p>Each of these sequences (F, T, and U) is in turn treated as a
sub-band, and transmitted with an independent encoding. Each
non-zero value in T indexes a value from F, while each zero value
in T selects (in order) a value from U:</p>
<pre class="codeblock">
  S[i] = F[T[i]-1]
    if T[i] != 0
  U = { S[i] such that T[i] == 0 }
 
</pre>
<a name="tocTabFav" id="tocTabFav"></a>
<h5>6.5.1. Table of Favorites</h5>
The table F contains any number of integer values. There is no
restriction on their number or identity, except that no value in F
may be repeated, except the last, and F must not contain unused
values. The last value in F must be a repetition of an earlier
occurrence of a "sentinel value" of F. This sentinel marks the end
of the table F, allowing the decompressor to prepare to read T and
U.
<p>The "central value" X of F is defined as that element of F which
is arithmetically closest to zero. If F contains both a positive X
and a negative -X of minimal absolute value, then -X is defined as
the central value. (I.e., a negative sign is the tie-breaker. The
central value is chosen so as to have a favorable encoding.)</p>
<p>(Note that implementations may compare values for centrality by
using the 32-bit signed int expression
<code>(X&gt;&gt;31)^(X&lt;&lt;1)</code> as an unsigned comparison
key.)</p>
<p>A valid sentinel value is either the central value of F, or the
last value of F. Thus, while parsing F, the decompressor must look
for a repetition of either the central value (so far) or of the
immediately previous value.</p>
<p>Let K be the number of values in F, ignoring the repetition of
the sentinel value. In the next band, values in <tt>[1..K]</tt>
will refer (as 1-origin indexes) to corresponding elements of
F.</p>
<a name="tocSeqTok" id="tocSeqTok"></a>
<h5>6.5.2. Sequence of Tokens</h5>
The sequence T follows the table F, and encodes the input of the
population transformation in a direct, element-by-element manner.
<p>Each element of T is a token for either a favored or an
unfavored value, encoded in the arithmetic range <tt>[0..K]</tt>.
Each non-zero value corresponds in order to an element of F, and
produces that favored value. Each zero value in T is a placeholder
for an "unfavored" value, which is still unknown.</p>
<p>As mentioned above, each element of F must be referred to by at
least one element of T. That is, the following two sets must be the
same:</p>
<pre class="codeblock">
  { F[T[i]-1] such that T[i] != 0 }
  { F[j] }
 
</pre>
<p>The statistics of the sequence T are quite favorable for compact
encoding in a suitable (B,H) scheme, assuming that the coder made
good choices for the contents of F. Generally speaking, the most
commonly occurring input values should be given early positions in
F.</p>
<p>A greedy algorithm could sort the input values by number of
occurrences and place the most common values at the front of F.
This would be likely to produce an improved encoding for the input.
Such techniques are neither mandated nor discouraged by this
specification.</p>
<a name="tocSeUnVa" id="tocSeUnVa"></a>
<h5>6.5.3. Sequence of Unfavored Values</h5>
The third subsequence consists of values which were not
representable by indexes into the table F. Let Z be the number of
zeroes encountered in T. There is a ordered, one-to-one
correspondence between the Z zeroes in T and all the Z values of U.
<p>Taken together, the elements of F and U selected by the elements
of T must be identical in value and order to the input of the
population transformation.</p>
<p>The decompressor can then read F into memory, read T into
memory, and then make a second pass over T, translating token
values, either referring to F or reading from U as necessary.</p>
<a name="tocAdaEnc" id="tocAdaEnc"></a>
<h4>6.6. Adaptive Encodings</h4>
Sometimes, in a very long sequence of values, the statistics will
change slowly, making an initially suitable coding tactic become
unsuitable.
<p>An adaptive coding method handles this situation by allowing
value sequences to be partitioned (effectively into sub-bands),
with an independent coding used locally in each part.</p>
<p>An adaptive coding method is specified by a count K, a coding
method A which will be used to encode K values, and another coding
method B which will handle the rest of the values.</p>
<p>Since bands are sized by context, when an adaptive coding method
is applied to the bytes of an encoded band, the method will be
provided in advance with the count N of values to decode. Thus,
after the method A has decoded K values, the method B will be used
to decode the rest of the (N-K) values in the band.</p>
<a name="band_coding" id="band_coding"></a> <a name="tocMetCod" id=
"tocMetCod"></a>
<h4>6.7. Meta-Coding</h4>
Every band in the Pack200 archive format whose primary encoding is
not BYTE1 is optionally preceded by a series of bytes called a
<em>band coding specifier</em> which specify a secondary coding or
codings used in that band, instead of the primary coding. The
decompressor must parse this coding specifier and save it away
before it reads any of the band elements. In a few extra bytes of
information, the coding specifier determines exactly how the
subsequent bytes are to be decoded into band values.
<p>Any compressor may elect not to provide a band coding specifier,
in which case the band's primary encoding governs the transmission
of elements. If the encoding of the first band element under the
primary encoding accidentally appears to be a band coding
specifier, the compressor is obligated to transmit an explicit band
coding specifier that reaffirms the band's primary encoding. This
is rare, because (as noted below) band coding specifiers present
themselves as negative numbers in the primary encoding, and
negative numbers are rare in most bands.</p>
<a name="tocCoSpSt" id="tocCoSpSt"></a>
<h5>6.7.1. Coding Specifier Structure</h5>
The symbolic structure of a band coding specifier is determined by
the following grammar. (This grammar is independent of the grammar
governing band structure, or any other grammar appearing in other
parts of this specification.)
<pre class="codeblock">
  BandCodingSpecifier:
        (Default | BHSDCode | RunCode | PopCode)
  BHSDCode:
        CanonicalBHSDCode | ArbitraryBHSDCode
  CanonicalBHSDCode:
        ( '(1,256,0)' | '(1,256,1)' | ... )
  ArbitraryBHSDCode:
        'arb' ( B H S D )
  B, H, S, D: 
        Integer
  RunCode:
        'run' K ACode BCode
  K:
        Integer
  ACode:
        (Default | BHSDCode | PopCode)
  BCode:
        (Default | BHSDCode | RunCode | PopCode)
  PopCode:
        'pop' ( FCode TCode UCode )
  FCode:
        (Default | BHSDCode | RunCode)
  TCode:
        (Default | BHSDCode | RunCode)
  UCode:
        (Default | BHSDCode | RunCode)
  Integer:
        ( '0' | '1' | ... )
  Default:
        'default'
 
</pre>
Note that adaptive coding methods ("RunCode" nonterminals) can be
chained via the "BCode" nonterminal, but cannot be nested directly
via the "ACode" nonterminal. (As the grammar shows, they may be
nested indirectly via the "PopCode" nonterminal.)
<p>Also, population coding methods can contain adaptive coding
methods, and vice versa. However, although the grammar does not
show this fact, population coding methods must not be nested, even
indirectly.</p>
<p>Not all possible integer values of K and L are equally well
expressible. The intended values of K are commensurate with
compressor windows, and the intended values of L are sharpness
parameters for BHS encodings.</p>
<a name="tocCoSpSe" id="tocCoSpSe"></a>
<h5>6.7.2. Coding Specifier Semantics</h5>
At any point, band contents are decoded under the control of three
pieces of information:
<ul>
<li>N, an expected number of band values to decode, or
"infinity"</li>
<li>D, a default BHSD coding</li>
<li>S, a coding specifier</li>
</ul>
<p>We denote the application of S in the context of N and D as
"S(N,D)". This application decodes up to N elements of transmitted
band data.</p>
<p>Just before a band is received, the decompressor knows an
expected band length N and a default coding method D, specified
statically as the band's primary encoding. The decompressor then
reads zero or more bytes which constitute a band encoding
specifier, and decodes N elements of band data based on the band
encoding specifier.</p>
<p>When the coding specifier is 'default', N values are decoded
using the default coding D, which is the band's primary encoding.
(This rule is necessary if the band's first element appears to
introduce a non-empty coding specifier. Such a default coding
specifier is the only kind that a compressor is obligated to emit;
the rest are all optional.)</p>
<p>When the coding specifier is another BHSDCode, N values are
decoded using that coding. The ambient default D is ignored.</p>
<p>When the coding specifier is a 'run' of K, ACode, BCode, two
steps are taken. First, the specifier ACode is given control, as
ACode(K,D). That is, N is temporarily set to K. Second, the
specifier BCode is given control as BCode(N-K,D). (Note: If N is
infinity, N-K will also be infinity.) In both steps, D remains
unchanged, so that occurrences of 'default' for ACode or BCode
cause D to be used.</p>
<p>It is illegal for a 'run' coding specifier to specify a K of
zero, or for it to be used to decode a run of K or fewer
values.</p>
<p>When the coding specifier is a 'pop' of FCode, TCode, UCode,
three steps are taken. First, FCode is applied as FCode(infinity,
D). The decoding of the F values stops when the first duplicate
value is encountered. (As specified in the section above on
population coding, that duplicate value acts as a sentinel, and
must be either the most "central" value read, or else the value
immediately previous to the sentinel value.) Let K be the number of
unique decoded values.</p>
<p>During the decoding of the F values by FCode, every 'run'
specifier in FCode must exhaust its count 'K' without decoding the
sentinel value. That is, the sentinel must be decoded by the last
simple BHSD coding in FCode.</p>
<p>In the second step, a different coding TCode is used, since the
T values are expected to be a dense encoding. TCode is applied as
TCode(N,D), and the tokens are read which determine the band values
to be delivered. (Note that a 'pop' coding method can only be
applied if the N value supplied is finite. This will be true, since
the only bands which are read with an infinite N are byte bands
such as <tt>bc_codes</tt>.) Let Z be the number of zeroes decoded
using TCode.</p>
<p>The third step is to use UCode to decode Z values, using the
original default encoding D. UCode is applied as U(Z,D). The
resulting band is produced from the T sequence, as documented
above, by replacing zeroes in the T sequence by successive U
values, and replacing other elements of the T sequence by those
indexed in the F sequence.</p>
<p>It is illegal for a 'pop' coding specifier to be used to decode
a run of no values, or of an infinite number of values. If Z (the
number of unfavored values) is zero, it is illegal for UCode to be
anything other than 'default'.</p>
<a name="tocCoSpMeEn" id="tocCoSpMeEn"></a>
<h5>6.7.3. Coding Specifier Meta-Encoding</h5>
The compressor uses a tense, byte-oriented encoding to transmit the
band encoding specifier. Although the "little language" above
allows a wide range of encodings, in practice many of them are
similar in performance and applicability. It is not necessary or
desirable to allow the compressor complete freedom to specify any
conceivable band encoding specifier. Instead, the meta-encoding
described in this section allows the compressor to select from a
limited but useful set of secondary encodings. It is up to the
compressor to make a choice that improves compression; the
heuristic or algorithm that controls such a selection is beyond the
scope of this specification.
<p>The common band coding specifier of 'default' is encoded in a
way that often requires no extra bytes. If the band has no
elements, no parsing at all is done. Otherwise, if the band's
default encoding is of variable length, the decompressor is
obligated to decode one value X from the initial bytes of the band
using the band's default coding D. If possible, the value X is
converted into an unsigned byte value XB, which is taken to be the
first byte of a band coding specifier, and X will be discarded.
Otherwise, the band coding specifier is taken to be 'default', and
so D is applied to the entire band, including the bytes which
produced the initial value X.</p>
<p>D must be of the form (B,H,S) or (B,H,S,D), where B&gt;1 and
H&lt;256. The value is D is irrelevant to the decoding of the first
value, and the decoding of X is done using (B,H,S,0). If S is not
zero, and if the value X is in the range [-256..-1], the coding
specifier byte XB is defined as <tt>XB = (-1-X)</tt>, and X is
discarded. Otherwise, if S is zero, and if the value of X is in the
range [(256-H)..(511-H)], the coding specifier byte XB is defined
as <tt>XB = (X-(256-H))</tt>, and X is discarded. Otherwise, there
is not a coding specifier byte XB, and X is the first band value,
as described above.</p>
<p>The value XB, if produced, is taken to be the initial byte of a
coding specifier preceding the actual band data. This specifier is
parsed, starting with XB, and continuing (if necessary) with bytes
bytes taken from <tt>band_headers</tt>. The parsed specifier is
then used to control decoding, starting at the next byte, of all
band elements.</p>
<p>If the band really does start with an element X1 in a range
(<tt>[-256..-1]</tt> or <tt>[L,L+255]</tt>) that requires the
production of a band specififer byte XB, but the compressor wishes
to use the default encoding, the compressor is required to specify
a band header, lest X1 mislead the decompressor. If the compressor
wishes to keep the default coding, it must in such cases specify an
explicit coding specifier of 'default', using an XB value of zero
(as specified below). This zero XB is transmitted, depending on the
default encoding, as an X value of -1 (usually the byte 1) or of L
(usually the bytes 192,0).</p>
<p>(An immediate consequence of this design is that byte bands can
never have non-default encodings, but all other bands can, since
all the other bands have default encodigns which are variable
length and have a large dynamic range. The "escape" values chosen
for X are rare in practice, so they are not usually confused with
real band data. Adding an extra zero value to reaffirm the default
will always cost one extra byte before the actual band data, and no
extra bytes in the <tt>band_headers</tt> band. In general, the
encoding of explicit X values will always require two bytes if S is
zero, and at most two bytes if S is not zero.)</p>
<p>The band <tt>band_headers</tt> transmits the non-initial band
header bytes (if any) of each band that has a band header. The
order of transmission is consistent with the overall order of all
bands in the archive, as given in the present specification's band
grammar. The length of <tt>band_headers</tt> is independently
specified (as <tt>#band_headers_size</tt>) in the archive header.
(It should be clear that the decompressor needs to find the end of
<tt>band_headers</tt> before it can read any further bands.)</p>
<p>Thus, the encoding of a coding specifier consists of a sequence
of bytes: an initial byte XB, and zero or more non-initial bytes
taken from <tt>band_headers</tt>. The encodings of the little
language specified in the previous section are as follows. The
encoding 'default' is a zero byte. Of all the possible BHSDCode
encodings, a sequence of 115 <em>canonical encodings</em> (defined
below) is selected to cover the expected range of uses. A BHSDCode
is represented as a single byte whose value is the index (1-based)
of the selected canonical coding.</p>
<pre class="codeblock">
  Enc{default}  = (0)
  Enc{CanonicalBHSDCode} = value in [1..115]
 
</pre>
<p>The special value 116 introduces an arbitrary, possibly
non-canonical BHSD code, described in the following byte.</p>
<pre class="codeblock">
  Enc{ arb ( B H S D ) } =
      116
    &amp; (D:[0..1] + 2*S[0..2] + 8*(B:[1..5]-1))
    &amp; (H[1..256]-1):
 
</pre>
The B value must be in the range [1..5]. The S value must be in the
range [0..2]. The H value must be in the range [1..256]. The D
value must be in the range [0..1]. (These ranges are inclusive.) In
addition, if B is 1, H must be 256, and if H is 256, B must not be
5.
<p>The 'run' construct encodings begin with a byte in [117..140],
and may be followed by an optional byte KB and then by one or two
encoding specifiers ACode and BCode. The offset from 117 represents
bitwise the following data:</p>
<ul>
<li>a two-bit field KX</li>
<li>a bit KBFlag</li>
<li>a bit ADef (ABDef == 1)</li>
<li>a bit BDef (ABDef == 2)</li>
</ul>
The last two bits are jointly encoded in the value ABDef. They are
never both true.
<pre class="codeblock">
  Enc{ run ( K ACode BCode ) } =
      (117 + (KX:[0..3]) + 4*(KBFlag:[0..1]) + 8*(ABDef:[0..2]))
    &amp; KB: one of [0..255] if KBFlag=1
    &amp; Enc{ ACode } if ADef=0  (ABDef != 1)
    &amp; Enc{ BCode } if BDef=0  (ABDef != 2)
 
</pre>
<p>After the leading byte is parsed, a byte KB is expected if the
KBFlag is set, otherwise KB is implicitly given the value 3.</p>
<p>The K value for the 'run' construct can take a range of values,
and is determined as follows:</p>
<pre class="codeblock">
  K = (KB+1) * 16^KX
 
</pre>
<p>The ACode coding is understood to be 'default' if the ADef bit
is set. Otherwise, the representation of ACode is parsed next.
Finally, the BCode coding is understood to be 'default' if the BDef
bit is set. Otherwise, the representation of BCode is parsed last.
Both ADef and BDef may be clear, but both may not be set.</p>
<p>The 'pop' construct encodings begin with a byte in [141..188],
and may be followed by one, two, or three encoding specifiers,
FCode, UCode, and TCode. The offset from 141 bitwise encodes the
following data:</p>
<ul>
<li>a bit FDef</li>
<li>a bit UDef</li>
<li>a bit TDef (TDefL &gt; 0)</li>
<li>a value L in [1..11] if TDef=1</li>
</ul>
The last two values are jointly encoded in the value TDefL.
<pre class="codeblock">
  Enc{ pop ( FCode TCode UCode ) }
    = (141 + (FDef:[0..1]) + 2*UDef:[0..1] + 4*(TDefL:[0..11]))
    &amp; Enc{ FCode } if FDef=0
    &amp; Enc{ TCode } if TDef=0  (TDefL==0)
    &amp; Enc{ UCode } if UDef=0
 
</pre>
<p>If TDef is zero, an explicit encoding specifier determines
TCode, and the L parameter is not present. If TDef is one, the L
parameter is present and is derived from TDefL, according to the
following table:</p>
<table border="1" summary="relation of L parameter to TDefL">
<tr align="center">
<th id="l_param_tdefl_t">TDefL</th>
<th id="l_param_tdefl_l">L</th>
</tr>
<tr align="right">
<td headers="l_param_tdefl_t">1</td>
<td headers="l_param_tdefl_l">4</td>
</tr>
<tr align="right">
<td headers="l_param_tdefl_t">2</td>
<td headers="l_param_tdefl_l">8</td>
</tr>
<tr align="right">
<td headers="l_param_tdefl_t">3</td>
<td headers="l_param_tdefl_l">16</td>
</tr>
<tr align="right">
<td headers="l_param_tdefl_t">4</td>
<td headers="l_param_tdefl_l">32</td>
</tr>
<tr align="right">
<td headers="l_param_tdefl_t">5</td>
<td headers="l_param_tdefl_l">64</td>
</tr>
<tr align="right">
<td headers="l_param_tdefl_t">6</td>
<td headers="l_param_tdefl_l">128</td>
</tr>
<tr align="right">
<td headers="l_param_tdefl_t">7</td>
<td headers="l_param_tdefl_l">192</td>
</tr>
<tr align="right">
<td headers="l_param_tdefl_t">8</td>
<td headers="l_param_tdefl_l">224</td>
</tr>
<tr align="right">
<td headers="l_param_tdefl_t">9</td>
<td headers="l_param_tdefl_l">240</td>
</tr>
<tr align="right">
<td headers="l_param_tdefl_t">10</td>
<td headers="l_param_tdefl_l">248</td>
</tr>
<tr align="right">
<td headers="l_param_tdefl_t">11</td>
<td headers="l_param_tdefl_l">252</td>
</tr>
</table>
<p>If the L parameter is present, the TCode is derived from the K
and L values. If K &lt; 256, then TCode is BYTE1 (1,255,0), and L
is ignored. Otherwise, TCode is the (B,H,S) coding where S=0,
H=(256-L), and B is the smallest value such that [0..K] is
contained in Range(B,H,S). (It is illegal to specify an L so large
that Range(5,256-L,0) does not contain K.)</p>
<p>The FCode coding is understood to be 'default' if the FDef bit
is set. Otherwise, the representation of FCode is parsed
immediately after the initial byte. The TCode coding is understood
to be derived from K and L if the TDef bit is set. Otherwise, the
representation of TCode is parsed next. Finally, the UCode coding
is understood to be 'default' if the UDef bit is set. Otherwise,
the representation of UCode is parsed last.</p>
<a name="tocCanCod" id="tocCanCod"></a>
<h5>6.7.4. Canonical BHSD Codings</h5>
Here is the list of all the canonical BHSD codings. These codings
are designed to match a diverse variety of band value ranges and
statistics.
<table border="1" summary="list of all canonical BHSD codings">
<tr>
<th id="canon_bhsd_i">index</th>
<th id="canon_bhsd_b">BHSD Coding</th>
</tr>
<tr>
<td headers="canon_bhsd_i">1</td>
<td headers="canon_bhsd_b">(1,256,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">2</td>
<td headers="canon_bhsd_b">(1,256,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">3</td>
<td headers="canon_bhsd_b">(1,256,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">4</td>
<td headers="canon_bhsd_b">(1,256,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">5</td>
<td headers="canon_bhsd_b">(2,256,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">6</td>
<td headers="canon_bhsd_b">(2,256,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">7</td>
<td headers="canon_bhsd_b">(2,256,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">8</td>
<td headers="canon_bhsd_b">(2,256,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">9</td>
<td headers="canon_bhsd_b">(3,256,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">10</td>
<td headers="canon_bhsd_b">(3,256,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">11</td>
<td headers="canon_bhsd_b">(3,256,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">12</td>
<td headers="canon_bhsd_b">(3,256,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">13</td>
<td headers="canon_bhsd_b">(4,256,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">14</td>
<td headers="canon_bhsd_b">(4,256,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">15</td>
<td headers="canon_bhsd_b">(4,256,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">16</td>
<td headers="canon_bhsd_b">(4,256,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">17</td>
<td headers="canon_bhsd_b">(5, 4,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">18</td>
<td headers="canon_bhsd_b">(5, 4,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">19</td>
<td headers="canon_bhsd_b">(5, 4,2)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">20</td>
<td headers="canon_bhsd_b">(5, 16,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">21</td>
<td headers="canon_bhsd_b">(5, 16,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">22</td>
<td headers="canon_bhsd_b">(5, 16,2)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">23</td>
<td headers="canon_bhsd_b">(5, 32,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">24</td>
<td headers="canon_bhsd_b">(5, 32,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">25</td>
<td headers="canon_bhsd_b">(5, 32,2)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">26</td>
<td headers="canon_bhsd_b">(5, 64,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">27</td>
<td headers="canon_bhsd_b">(5, 64,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">28</td>
<td headers="canon_bhsd_b">(5, 64,2)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">29</td>
<td headers="canon_bhsd_b">(5,128,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">30</td>
<td headers="canon_bhsd_b">(5,128,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">31</td>
<td headers="canon_bhsd_b">(5,128,2)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">32</td>
<td headers="canon_bhsd_b">(5, 4,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">33</td>
<td headers="canon_bhsd_b">(5, 4,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">34</td>
<td headers="canon_bhsd_b">(5, 4,2,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">35</td>
<td headers="canon_bhsd_b">(5, 16,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">36</td>
<td headers="canon_bhsd_b">(5, 16,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">37</td>
<td headers="canon_bhsd_b">(5, 16,2,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">38</td>
<td headers="canon_bhsd_b">(5, 32,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">39</td>
<td headers="canon_bhsd_b">(5, 32,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">40</td>
<td headers="canon_bhsd_b">(5, 32,2,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">41</td>
<td headers="canon_bhsd_b">(5, 64,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">42</td>
<td headers="canon_bhsd_b">(5, 64,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">43</td>
<td headers="canon_bhsd_b">(5, 64,2,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">44</td>
<td headers="canon_bhsd_b">(5,128,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">45</td>
<td headers="canon_bhsd_b">(5,128,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">46</td>
<td headers="canon_bhsd_b">(5,128,2,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">47</td>
<td headers="canon_bhsd_b">(2,192,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">48</td>
<td headers="canon_bhsd_b">(2,224,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">49</td>
<td headers="canon_bhsd_b">(2,240,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">50</td>
<td headers="canon_bhsd_b">(2,248,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">51</td>
<td headers="canon_bhsd_b">(2,252,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">52</td>
<td headers="canon_bhsd_b">(2, 8,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">53</td>
<td headers="canon_bhsd_b">(2, 8,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">54</td>
<td headers="canon_bhsd_b">(2, 16,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">55</td>
<td headers="canon_bhsd_b">(2, 16,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">56</td>
<td headers="canon_bhsd_b">(2, 32,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">57</td>
<td headers="canon_bhsd_b">(2, 32,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">58</td>
<td headers="canon_bhsd_b">(2, 64,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">59</td>
<td headers="canon_bhsd_b">(2, 64,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">60</td>
<td headers="canon_bhsd_b">(2,128,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">61</td>
<td headers="canon_bhsd_b">(2,128,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">62</td>
<td headers="canon_bhsd_b">(2,192,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">63</td>
<td headers="canon_bhsd_b">(2,192,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">64</td>
<td headers="canon_bhsd_b">(2,224,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">65</td>
<td headers="canon_bhsd_b">(2,224,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">66</td>
<td headers="canon_bhsd_b">(2,240,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">67</td>
<td headers="canon_bhsd_b">(2,240,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">68</td>
<td headers="canon_bhsd_b">(2,248,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">69</td>
<td headers="canon_bhsd_b">(2,248,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">70</td>
<td headers="canon_bhsd_b">(3,192,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">71</td>
<td headers="canon_bhsd_b">(3,224,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">72</td>
<td headers="canon_bhsd_b">(3,240,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">73</td>
<td headers="canon_bhsd_b">(3,248,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">74</td>
<td headers="canon_bhsd_b">(3,252,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">75</td>
<td headers="canon_bhsd_b">(3, 8,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">76</td>
<td headers="canon_bhsd_b">(3, 8,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">77</td>
<td headers="canon_bhsd_b">(3, 16,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">78</td>
<td headers="canon_bhsd_b">(3, 16,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">79</td>
<td headers="canon_bhsd_b">(3, 32,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">80</td>
<td headers="canon_bhsd_b">(3, 32,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">81</td>
<td headers="canon_bhsd_b">(3, 64,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">82</td>
<td headers="canon_bhsd_b">(3, 64,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">83</td>
<td headers="canon_bhsd_b">(3,128,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">84</td>
<td headers="canon_bhsd_b">(3,128,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">85</td>
<td headers="canon_bhsd_b">(3,192,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">86</td>
<td headers="canon_bhsd_b">(3,192,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">87</td>
<td headers="canon_bhsd_b">(3,224,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">88</td>
<td headers="canon_bhsd_b">(3,224,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">89</td>
<td headers="canon_bhsd_b">(3,240,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">90</td>
<td headers="canon_bhsd_b">(3,240,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">91</td>
<td headers="canon_bhsd_b">(3,248,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">92</td>
<td headers="canon_bhsd_b">(3,248,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">93</td>
<td headers="canon_bhsd_b">(4,192,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">94</td>
<td headers="canon_bhsd_b">(4,224,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">95</td>
<td headers="canon_bhsd_b">(4,240,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">96</td>
<td headers="canon_bhsd_b">(4,248,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">97</td>
<td headers="canon_bhsd_b">(4,252,0)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">98</td>
<td headers="canon_bhsd_b">(4, 8,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">99</td>
<td headers="canon_bhsd_b">(4, 8,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">100</td>
<td headers="canon_bhsd_b">(4, 16,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">101</td>
<td headers="canon_bhsd_b">(4, 16,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">102</td>
<td headers="canon_bhsd_b">(4, 32,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">103</td>
<td headers="canon_bhsd_b">(4, 32,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">104</td>
<td headers="canon_bhsd_b">(4, 64,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">105</td>
<td headers="canon_bhsd_b">(4, 64,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">106</td>
<td headers="canon_bhsd_b">(4,128,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">107</td>
<td headers="canon_bhsd_b">(4,128,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">108</td>
<td headers="canon_bhsd_b">(4,192,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">109</td>
<td headers="canon_bhsd_b">(4,192,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">110</td>
<td headers="canon_bhsd_b">(4,224,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">111</td>
<td headers="canon_bhsd_b">(4,224,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">112</td>
<td headers="canon_bhsd_b">(4,240,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">113</td>
<td headers="canon_bhsd_b">(4,240,1,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">114</td>
<td headers="canon_bhsd_b">(4,248,0,1)</td>
</tr>
<tr>
<td headers="canon_bhsd_i">115</td>
<td headers="canon_bhsd_b">(4,248,1,1)</td>
</tr>
</table>
<a name="tocStDeOu" id="tocStDeOu"></a>
<h2>7. Stability of Decompressor Output</h2>
From what has been said so far, it may appear that a decompressor
has considerable free choice in its arrangement of class file
contents. In the class file format, there are numerous degrees of
freedom which have no effect on the meaning of the file. For
example, constant pool entries, attribute lists, and class methods
are presented in no significant order, and could be shuffled at
will by the decompressor without changing the meaning of the Java
application.
<p>However, for any given Pack200 archive, every decompressor is
required to produce a particular byte-wise image for each class
file transmitted. This requirement is placed on decompressors in
order to make it possible for compressors to transmit information,
such as message digests, which relates to the eventual byte-wise
contents of transmitted class files. This section describes the
restrictions placed on every decompressor that makes the byte-wise
contents of its output files a well-defined function of its
input.</p>
<p>In general, the order of elements in a decompressed class file
must be consistent with the transmission order in the Pack200
archive. For example, the order of a class's fields declared in the
class file must correspond to the order in which that class's field
descriptors were transmitted in the <tt>field_descr</tt> band.
(This also happens to correspond to the order in the
<tt>field_flags</tt> bands.) This table gives all of the required
correspondences of class file order with archive transmission
order:</p>
<table border="1" summary=
"required correspondences of class file order with archive transmission order">
<tr align="center">
<th id="archive_transmission_order_e">element in<br />
class file</th>
<th id="archive_transmission_order_b">band which<br />
determines order</th>
</tr>
<tr>
<td headers="archive_transmission_order_e">implemented
interfaces</td>
<td headers="archive_transmission_order_b">class_interface</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">declared fields</td>
<td headers="archive_transmission_order_b">field_descr</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">declared methods</td>
<td headers="archive_transmission_order_b">method_descr</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">code handler list</td>
<td headers="archive_transmission_order_b">
code_handler_start_P</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">class attribute
list</td>
<td headers="archive_transmission_order_b">class_flags,
class_attr_indexes</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">field attribute
list</td>
<td headers="archive_transmission_order_b">field_flags,
field_attr_indexes</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">method attribute
list</td>
<td headers="archive_transmission_order_b">method_flags,
method_attr_indexes</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">code attribute list</td>
<td headers="archive_transmission_order_b">code_attr_indexes</td>
</tr>
<tr>
<td headers="archive_transmission_order_e">constant pool
entries</td>
<td headers="archive_transmission_order_b">cp_Utf8, etc. (see
below)</td>
</tr>
</table>
<p>Together, these required correspondences of order determine the
exact contents of the decompressed class file. The ordering of
interfaces, fields, methods, and exception handlers is directly
determined by the ordering of the bands that transmit them.</p>
<a name="tocOrAtLi" id="tocOrAtLi"></a>
<h3>7.1. Ordering of Attribute Lists</h3>
Attribute lists for classes, fields, and methods must begin with
all attributes transmitted because of set flag bits. The order must
be index order (from LSB to MSB in the flag word). After any
possible flag-caused attributes, the list must then contain any
overflow attributes. Any attribute list with overflow attributes
will present them in the same order as their layouts were
transmitted in the corresponding series of values from
<tt>class_attr_indexes</tt>, <tt>field_attr_indexes</tt>,
<tt>method_attr_indexes</tt>, or <tt>code_attr_indexes</tt>. Note
that an attribute layout whose index is less than 32 can be
specified zero or one times via a flag bit. Independently, it can
also be specified zero or more times via occurrences in a band
transmitting overflow attribute layouts.
<p>If an <tt>InnerClasses</tt> or <tt>BootstrapMethods</tt>
attribute must be added to a class, under the rules given in the
next section, those attributes must come last in the class's
attribute list. If more than one such attribute is added, the
relative ordering is <tt>BootstrapMethods</tt>, then
<tt>InnerClasses</tt>.</p>
<a name="ordering" id="ordering"></a> <a name="ic_subset_selection"
id="ic_subset_selection"></a> <a name="tocOrCoPo" id=
"tocOrCoPo"></a>
<h3>7.2. Ordering of Constant Pools</h3>
The constant pool <tt>cp(X)</tt> of a decompressed class file X is
defined as if by a post-processing of X and <tt>cp_All</tt> after
the decompressor has already produced most of X. Specifically,
suppose that the contents of X are determined, except that:
<ul>
<li><tt>cp(X)</tt> is not yet defined,</li>
<li>there is no <tt>InnerClasses</tt> attribute in X (even if was
an <tt>ic_Local(X)</tt> transmitted), and</li>
<li>the locations of constant references within X are noted but not
initialized with numbers.</li>
</ul>
<p>Then <tt>cp(X)</tt> is defined as if by the following steps,
which populate it from the global constant pool <tt>cp_All</tt>,
and also potentially produce an <tt>InnerClasses</tt> attribute for
X.</p>
<ul>
<li><tt>cp(X)</tt> is initially empty.</li>
<li>Every constant referenced from X is added to
<tt>cp(X)</tt>.</li>
<li>In the next step, any constant from <tt>cp_Signature</tt> must
be treated as making no additional references, despite its
transmitted structure.</li>
<li>Every constant referenced from <tt>cp(X)</tt> is added to
<tt>cp(X)</tt>, if it is not already there. (For example, a
constant from <tt>cp_Method</tt> refers to constants from
<tt>cp_Class</tt> and <tt>cp_Descr</tt>.)</li>
<li>The previous step is iterated until no further changes occur.
(There will be at most five more of these steps, with a longest
chain of references consisting, for example, of a
<tt>CONSTANT_InvokeDynamic</tt>, its <tt>cp_BootstrapMethod</tt>
constant, a <tt>CONSTANT_MethodHandle</tt>, a
<tt>CONSTANT_Methodref</tt>, a <tt>CONSTANT_NameAndType</tt>, and a
<tt>CONSTANT_Utf8</tt>.)</li>
</ul>
<p>At this point the constant pool <tt>cp(X)</tt> is well enough
defined to allow the decompressor to compute the set of relevant
nested classes, called <tt>ic_Relevant(X)</tt>.</p>
<ul>
<li><tt>ic_Relevant(X)</tt> is initially empty.</li>
<li>Every four-tuple from <tt>ic_All</tt> which mentions the
current class (defined by X) as an outer class is added to
<tt>ic_Relevant(X)</tt>.</li>
<li>For every class constant K referenced from both
<tt>ic_this_class</tt> and <tt>cp(X)</tt>, the corresponding
four-tuple from <tt>ic_All</tt> is selected, and added to
<tt>ic_Relevant(X)</tt>, if not already there.</li>
<li>The previous step is repeated until closure. (That is, until
<tt>ic_Relevant(X)</tt> no longer changes.)</li>
<li>The set <tt>ic_Relevant(X)</tt> is ordered into a sequence, so
that its order is consistent with <tt>ic_All</tt>. (I.e., it is a
subsequence of <tt>ic_All</tt>.)</li>
</ul>
<p>With <tt>ic_Relevant(X)</tt> and an optionally transmitted
<tt>ic_Local(X)</tt> in hand, the decompressor must next decide
whether to store an <tt>InnerClasses</tt> attribute
<tt>ic_Stored(X)</tt> for X, using these steps.</p>
<ul>
<li>If <tt>ic_Local(X)</tt> is present and empty, no
<tt>InnerClasses</tt> attribute will be stored for X, and none of
the following steps will be taken.</li>
<li>Also, if <tt>ic_Local(X)</tt> is not present and
<tt>ic_Relevant(X)</tt> is empty, no <tt>InnerClasses</tt>
attribute will be stored for X.</li>
<li>Otherwise, <tt>ic_Stored(X)</tt> is set to be the elements in
<tt>ic_Local(X)</tt> followed by the elements of
<tt>ic_Relevant(X)</tt> (both in transmission order).</li>
<li>Next, any elements in both <tt>ic_Local(X)</tt> and
<tt>ic_Relevant(X)</tt> are <em>removed</em> from
<tt>ic_Stored(X)</tt>, thus forming a symmetric difference.</li>
<li>The resulting sequence <tt>ic_Stored(X)</tt>, even if empty, is
added to the decompressor's output as an <tt>InnerClasses</tt>
attribute.</li>
<li>All <tt>cp_Class</tt> and <tt>cp_Utf8</tt> entries directly or
indirectly required by <tt>ic_Stored(X)</tt>, as well as the fixed
<tt>cp_Utf8</tt> entry spelled <tt>"InnerClasses"</tt>, are added
to <tt>cp(X)</tt> if not already there.</li>
</ul>
<p>With the last contributions from nested class records, the
decompressor finishes the constant pool using these steps:</p>
<ul>
<li>Every <tt>cp_Signature</tt> entry in <tt>cp(X)</tt> is
"flattened" into a <tt>cp_Utf8</tt> entry with the same
spelling.</li>
<li>If any <tt>cp_Utf8</tt> entry E in <tt>cp(X)</tt> was not
transmitted in <tt>cp_All</tt> but had an equivalently spelled
signature S transmitted, then E is replaced by S in
<tt>cp(X)</tt>.</li>
<li>The elements of <tt>cp(X)</tt> which are also in
<tt>cp_All</tt> are sorted into the same order as their occurrences
in <tt>cp_All</tt>.</li>
<li>All <tt>cp_Utf8</tt> constants in <tt>cp(X)</tt> not also in
<tt>cp_All</tt> are moved to the end of <tt>cp(X)</tt>, and are
sorted in the order defined by <tt>String.compareTo</tt>.</li>
<li>Next, any <tt>cp_Class</tt> constants in <tt>cp(X)</tt> not
also in <tt>cp_All</tt> are moved to the end of <tt>cp(X)</tt>, in
the order defined by <tt>String.compareTo</tt> on their class
names.</li>
<li>(At this point, the decompressor has uniquely determined a
position for every element of <tt>cp(X)</tt>.)</li>
<li>All elements of <tt>cp(X)</tt> which are referred to via a
one-byte index (i.e., a ldc bytecode) are moved in mass to the
beginning of <tt>cp(X)</tt>, without changing their relative
order.</li>
<li>All elements of <tt>cp(X)</tt> are transformed into their
equivalent class file constant types, with signatures being
"flattened" into equivalently spelled CONSTANT_Utf8 constants.</li>
<li>All <tt>cp_BootstrapMethod</tt> constants in <tt>cp(X)</tt> are
removed from <tt>cp(X)</tt> and placed (without reordering) in the
<tt>BootstrapMethods</tt> attribute for X. (If there are no such
elements, no such attribute is created.) If the attribute is
created, <tt>cp_Utf8</tt> entry spelled <tt>"BootstrapMethods"</tt> is added
to <tt>cp(X)</tt> if not already there.</li>
<li>The resulting sequence of class file constants, <tt>cp(X)</tt>,
is stored as the constant pool of X.</li>
</ul>
<p>After this process, the stored constant pool of X has
referential integrity, and all constant references can be coded as
indexes into <tt>cp(X)</tt>, which has a definite order derived
from <tt>cp_All</tt>. In particular, if a constant in
<tt>cp(X)</tt> needs to refer to another constant, that constant
must already have been inserted into <tt>cp(X)</tt>, during the
closure steps.</p>
<p>Note that the ordering of <tt>cp(X)</tt> is consistent with that
of <tt>cp_All</tt>, except that some signature references are
redirected to equivalent pre-existing elements of <tt>cp_Utf8</tt>,
and all operands of ldc bytecodes are forced to the front of the
constant pool.</p>
<p>When assigning local indexes to elements of <tt>cp(X)</tt>, the
decompressor must of course respect the reservation of empty
constant pool slots for index zero, and for CONSTANT_Long and
CONSTANT_Double constants, as required by the class file format.
Together with these rules, the construction and ordering of
<tt>cp(X)</tt> completely determines the assignment of concrete
indexes to constant references within X.</p>
<a name="tocAppend" id="tocAppend"></a>
<h2>8. Appendixes</h2>
<a name="bands" id="bands"></a> <a name="tocApLiBa" id=
"tocApLiBa"></a>
<h3>8.1. Appendix: List of Bands</h3>
Here is a list of all bands in the order they must occur in the
archive. This list is not part of the Pack200 specification, but it
is presented to help clarify the meaning of the grammar in the
specification proper which defines the names and ordering of the
bands. Four occurrences of ellipsis <strong>...</strong> refer to
insertion points where the compressor may insert variable numbers
of extra bands to help transmit unusual strings or non-standard
attributes. The other ellipses refer to repetitions of metadata
bands which it would be too tedious to include.
<table border="1" summary="list of all bands">
<tr align="center">
<th id="list_of_all_bands_b">Band</th>
<th id="list_of_all_bands_d">Default<br />
coding</th>
<th id="list_of_all_bands_l">Length</th>
<th id="list_of_all_bands_c">Constant pool<br />
referred to</th>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>archive_magic</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[4]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>archive_header</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[26]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>band_headers</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Utf8_prefix</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[MAX(0,#cp_Utf8_count-2)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Utf8_suffix</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[MAX(0,#cp_Utf8_count-1)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Utf8_chars</tt></td>
<td headers="list_of_all_bands_d">CHAR3</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*cp_Utf8_suffix)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Utf8_big_suffix</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(0,*cp_Utf8_suffix)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>{cp_Utf8_big_chars...}</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[*cp_Utf8_big_suffix[i]]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Int</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Int_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Float</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Float_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Long_hi</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Long_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Long_lo</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Long_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Double_hi</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Double_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Double_lo</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Double_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_String</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_String_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Class</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Class_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Signature_form</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[#cp_Signature_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>cp_Signature_classes</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[COUNT('L',...)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Descr_name</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Descr_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Descr_type</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Descr_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Field_class</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Field_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Field_desc</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Field_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Descr</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Method_class</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Method_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Method_desc</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Method_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Descr</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Imethod_class</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Imethod_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_Imethod_desc</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#cp_Imethod_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Descr</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>cp_MethodHandle_refkind</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[#cp_MethodHandle_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>cp_MethodHandle_member</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[#cp_MethodHandle_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_All</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>cp_MethodType</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[#cp_MethodType_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>cp_BootstrapMethod_ref</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[#cp_BootstrapMethod_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_MethodHandle</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>cp_BootstrapMethod_arg_count</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[#cp_BootstrapMethod_count]arg_tt&gt;</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>cp_BootstrapMethod_arg</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*class_interface_count)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_All</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>cp_InvokeDynamic_spec</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[#cp_InvokeDynamic_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_BootstrapMethod</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>cp_InvokeDynamic_descr</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[#cp_InvokeDynamic_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Descr</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>attr_definition_headers</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l">
<tt>[#attr_definition_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>attr_definition_name</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[#attr_definition_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>attr_definition_layout</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[#attr_definition_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>ic_this_class</tt></td>
<td headers="list_of_all_bands_d">UDELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#ic_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>ic_flags</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[#ic_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>ic_outer_class</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(1&lt;&lt;16,...)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>ic_name</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(1&lt;&lt;16,...)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_this</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#class_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_super</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#class_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_interface_count</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#class_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_interface</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*class_interface_count)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_field_count</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#class_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_method_count</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[#class_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_descr</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*class_field_count)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Descr</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_flags_hi</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*class_field_count)*#have_field_flags_hi]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_flags_lo</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*class_field_count)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_attr_count</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(1&lt;&lt;16,...)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_attr_indexes</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*field_attr_count)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_attr_calls</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>field_ConstantValue_KQ</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(ConstantValue,...)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Int, cp_Float,
etc.</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_Signature_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(Signature,...)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_anno_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_type_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_pair_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_name_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_T</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_caseI_KI</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Int</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_caseD_KD</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Double</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_caseF_KF</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Float</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_caseJ_KJ</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Long</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_casec_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_caseet_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_caseec_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RVA_cases_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_d"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>field_RVA_casearray_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>field_RVA_nesttype_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>field_RVA_nestpair_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>field_RVA_nestname_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>field_RIA_anno_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>{field_RIA_...}</tt></td>
<td headers="list_of_all_bands_d"></td>
<td headers="list_of_all_bands_l"></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>field_RIA_nestname_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>{field_attr_element_bands...}</tt></td>
<td headers="list_of_all_bands_d">(various)</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>(various)</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_descr</tt></td>
<td headers="list_of_all_bands_d">MDELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*class_method_count)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Descr</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_flags_hi</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*class_method_count)*#have_method_flags_hi]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_flags_lo</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*class_method_count)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_attr_count</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(1&lt;&lt;16,...)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_attr_indexes</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*method_attr_count)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_attr_calls</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_Exceptions_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(Exceptions,...)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_Exceptions_RC</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*method_Exceptions_N)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_Signature_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(Signature,...)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVA_anno_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVA_type_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVA_pair_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVA_name_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVA_T</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVA_caseI_KI</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Int</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVA_caseD_KD</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Double</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVA_caseF_KF</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Float</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVA_caseJ_KJ</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Long</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVA_casec_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_RVA_caseet_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_RVA_caseec_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVA_cases_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_RVA_casearray_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_RVA_nesttype_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_RVA_nestpair_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_RVA_nestname_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RIA_anno_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>{method_RIA_...}</tt></td>
<td headers="list_of_all_bands_d"></td>
<td headers="list_of_all_bands_l"></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_RIA_nestname_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_RVPA_param_NB</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RVPA_anno_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>{method_RVPA_...}</tt></td>
<td headers="list_of_all_bands_d"></td>
<td headers="list_of_all_bands_l"></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_RVPA_nestname_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_RIPA_param_NB</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_RIPA_anno_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>{method_RIPA_...}</tt></td>
<td headers="list_of_all_bands_d"></td>
<td headers="list_of_all_bands_l"></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_RIPA_nestname_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_AD_T</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_AD_caseI_KI</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Int</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_AD_caseD_KD</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Double</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_AD_caseF_KF</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Float</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_AD_caseJ_KJ</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Long</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_AD_casec_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_AD_caseet_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_AD_caseec_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>method_AD_cases_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_AD_casearray_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_AD_nesttype_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_AD_nestpair_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_AD_nestname_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_MethodParameters_NB</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_MethodParameters_name_RUN</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>null|cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>method_MethodParameters_flag_FH</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tr>
<td headers="list_of_all_bands_b">
<tt>{method_attr_element_bands...}</tt></td>
<td headers="list_of_all_bands_d">(various)</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>(various)</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_flags_hi</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[#class_count*#have_class_flags_hi]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_flags_lo</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[#class_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_attr_count</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(1&lt;&lt;16,...)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_attr_indexes</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*class_attr_count)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_attr_calls</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_SourceFile_RUN</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(SourceFile,...)]</tt></td>
<td headers="list_of_all_bands_c"><tt>null|cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_EnclosingMethod_RC</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(EnclosingMethod,...)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_EnclosingMethod_RDN</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(EnclosingMethod,...)]</tt></td>
<td headers="list_of_all_bands_c"><tt>null|cp_Descr</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_Signature_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(Signature,...)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_anno_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_type_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_pair_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_name_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_T</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_caseI_KI</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Int</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_caseD_KD</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Double</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_caseF_KF</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Float</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_caseJ_KJ</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Long</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_casec_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_caseet_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_caseec_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RVA_cases_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_RVA_casearray_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_c"><tt>[...]</tt></td>
<td headers="list_of_all_bands_l">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_RVA_nesttype_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_RVA_nestpair_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_RVA_nestname_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>class_RIA_anno_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>{class_RIA_...}</tt></td>
<td headers="list_of_all_bands_d"></td>
<td headers="list_of_all_bands_l"></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_RIA_nestname_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_InnerClasses_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(InnerClasses,...)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_InnerClasses_RC</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*class_InnerClasses_N)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_InnerClasses_F</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*class_InnerClasses_N)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_InnerClasses_outer_RCN</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(!=0,*class_InnerClasses_F)]</tt></td>
<td headers="list_of_all_bands_c"><tt>null|cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_InnerClasses_name_RUN</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(!=0,*class_InnerClasses_F)]</tt></td>
<td headers="list_of_all_bands_c"><tt>null|cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_file_version_minor_H</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(version,...)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>class_file_version_major_H</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(version,...)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>{class_attr_element_bands...}</tt></td>
<td headers="list_of_all_bands_d">(various)</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>(various)</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>code_headers</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[COUNT(Code,...)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>code_max_stack</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(0,*code_headers)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>code_max_na_locals</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(0,*code_headers)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>code_handler_count</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(0,*code_headers)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_handler_start_P</tt></td>
<td headers="list_of_all_bands_d">BCI5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*code_header_count)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>code_handler_end_PO</tt></td>
<td headers="list_of_all_bands_d">BRANCH5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*code_header_count)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_handler_catch_PO</tt></td>
<td headers="list_of_all_bands_d">BRANCH5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*code_header_count)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_handler_class_RCN</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*code_header_count)]</tt></td>
<td headers="list_of_all_bands_c"><tt>null|cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>code_flags_hi</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[...*#have_code_flags_hi]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>code_flags_lo</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>code_attr_count</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(1&lt;&lt;16,...)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>code_attr_indexes</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*code_attr_count)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>code_attr_calls</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_StackMapTable_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(StackMapTable,...)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_StackMapTable_frame_T</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l">
<tt>[SUM(*code_StackMapTable_N)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_StackMapTable_local_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(255,*code_StackMapTable_frame_T)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_StackMapTable_stack_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(255,*code_StackMapTable_frame_T)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_StackMapTable_offset</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_StackMapTable_T</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_StackMapTable_RC</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(7,*code_StackMapTable_T)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_StackMapTable_P</tt></td>
<td headers="list_of_all_bands_d">BCI5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(8,*code_StackMapTable_T)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LineNumberTable_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LineNumberTable_bci_P</tt></td>
<td headers="list_of_all_bands_d">BCI5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LineNumberTable_line</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTable_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTable_bci_P</tt></td>
<td headers="list_of_all_bands_d">BCI5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTable_span_O</tt></td>
<td headers="list_of_all_bands_d">BRANCH5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTable_name_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTable_type_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTable_slot</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTypeTable_N</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTypeTable_bci_P</tt></td>
<td headers="list_of_all_bands_d">BCI5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTypeTable_span_O</tt></td>
<td headers="list_of_all_bands_d">BRANCH5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTypeTable_name_RU</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTypeTable_type_RS</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Signature</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>code_LocalVariableTypeTable_slot</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b">
<tt>{code_attr_element_bands...}</tt></td>
<td headers="list_of_all_bands_d">(various)</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>(various)</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_codes</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_case_count</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(switch,*bc_codes)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_case_value</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_byte</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_short</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_local</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_label</tt></td>
<td headers="list_of_all_bands_d">BRANCH5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_intref</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Int</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_floatref</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Float</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_longref</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Long</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_doubleref</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Double</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_stringref</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_String</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_loadablevalueref</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT({qldc,qldc_w},*bc_codes)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_All</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_classref</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Class</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_fieldref</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Field</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_methodref</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Method</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_imethodref</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Imethod</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_thisfield</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Field
subsequence</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_superfield</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Field
subsequence</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_thismethod</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Method
subsequence</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_supermethod</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Method
subsequence</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_initref</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Method
subsequence</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_escref</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[COUNT(ref_escape,*bc_codes)]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_All</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_escrefsize</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_escsize</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>bc_escbyte</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[...]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>file_name</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[#file_count]</tt></td>
<td headers="list_of_all_bands_c"><tt>cp_Utf8</tt></td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>file_size_hi</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[#file_count*(#have_file_size_hi)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>file_size_lo</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l"><tt>[#file_count]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>file_modtime</tt></td>
<td headers="list_of_all_bands_d">DELTA5</td>
<td headers="list_of_all_bands_l">
<tt>[#file_count*(#have_file_modtime)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>file_options</tt></td>
<td headers="list_of_all_bands_d">UNSIGNED5</td>
<td headers="list_of_all_bands_l">
<tt>[#file_count*(#have_file_options)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
<tr>
<td headers="list_of_all_bands_b"><tt>file_bits</tt></td>
<td headers="list_of_all_bands_d">BYTE1</td>
<td headers="list_of_all_bands_l"><tt>[SUM(*file_size)]</tt></td>
<td headers="list_of_all_bands_c">&nbsp;</td>
</tr>
</table>
<a name="pseudocode" id="pseudocode"></a> <a name="tocApPsCoIl" id=
"tocApPsCoIl"></a>
<h3>8.2. Appendix: Pseudo-Code Illustrations</h3>
<a name="str_psc" id="str_psc"></a> <a name="tocReUtCoPo" id=
"tocReUtCoPo"></a>
<h4>8.2.1. Representation of <tt>cp_Utf8</tt> Constant Pool</h4>
The following pseudo-code asserts the relations, as described in the section <a href=
"#str_psc_ref">Utf8 Constants</a>, between the band lengths and
contents, and <tt>cp_Utf8</tt> constant pool elements. (This code
merely comments on the specification given above; it does not
itself add new information to the specification.)
<pre class="codeblock">
  assert(cp_Utf8[0].equals(""));
  int cursor = 0;
  int big_cursor = 0;
  for (int i = 1; i &lt; cp_Utf8_count; i++) {
    String thisString = cp_Utf8[i];

    int prefix = (i == 1)? 0: cp_Utf8_prefix[i-2];
    int suffix = thisString.length() - prefix;
    String prevString = cp_Utf8[i-1];
    String prevPrefix = prevString.substring(0, prefix);
    String thisPrefix = thisString.substring(0, prefix);
    assert(prevPrefix.equals(thisPrefix));

    int small_suffix = cp_Utf8_suffix[i-1];
    char[] suffix_chars;
    int offset;
    if (small_suffix != 0) {
      assert(suffix == small_suffix);
      suffix_chars = cp_Utf8_chars;
      offset = cursor;
      cursor += suffix;
    } else {
      assert(suffix == cp_Utf8_big_suffix[big_cursor]);
      suffix_chars = cp_Utf8_big_chars[big_cursor];
      offset = 0;
      assert(suffix == suffix_chars.length);
      big_cursor += 1;
    }
    String thisSuffix = thisString.substring(prefix);
    String theseChars = new String(suffix_chars, offset, suffix);
    assert(thisSuffix.equals(theseChars));
  }
  assert(cp_Utf8_prefix.length == Math.max(0, cp_Utf8_count-2));
  assert(cp_Utf8_suffix.length == Math.max(0, cp_Utf8_count-1));
  assert(cp_Utf8_chars.length == cursor);
  assert(cp_Utf8_big_suffix.length == big_cursor);
  assert(cp_Utf8_big_chars.length == big_cursor);
 
</pre>
<a name="sig_psc" id="sig_psc"></a> <a name="tocReSiCoPo" id=
"tocReSiCoPo"></a>
<h4>8.2.2. Representation of <tt>cp_Signature</tt> Constant
Pool</h4>
The following pseudo-code asserts the relations, as described in the section <a href=
"#sig_psc_ref">Type Signatures</a>, between the band lengths and
contents, and <tt>cp_Signature</tt> constant pool elements. (This
code merely comments on the specification given above; it does not
itself add new information to the specification.)
<pre class="codeblock">
  int cursor = 0;
  for (int i = 0; i &lt; cp_Signature_count; i++) {
    String sign = cp_Signature[i];
    String form = cp_Signature_form[i];
    int form_ptr = 0;
    int sign_ptr = 0;
    for (; form_ptr &lt; form.length(); form_ptr++) {
      assert(form.charAt(form_ptr) == sign.charAt(sign_ptr));
      sign_ptr += 1;
      if (form.charAt(form_ptr) == 'L') {
        String cls = cp_Class[cursor];
        assert(sign.startsWith(cls, sign_ptr));
        cursor += 1;
        sign_ptr += cls.length();
      }
    }
    assert(sign_ptr == sign.length());
  }
  assert(cp_Signature_form.length == cp_Signature_count);
  assert(cp_Signature_classes.length == cursor);
</pre>
<a name="bci_psc" id="bci_psc"></a> <a name="tocReByOf" id=
"tocReByOf"></a>
<h4>8.2.3. Representation of Byte Offsets</h4>
The following pseudo-code asserts the relations, as described in the section <a href=
"#bci_psc_ref">Attribute Layout Definitions</a>, between a byte offset and its
encoding in a band governed by a <tt>bc_index</tt> layout element.
(This code merely comments on the specification given above; it
does not itself add new information to the specification.)
<pre class="codeblock">
  // ins_pos is a display of all instruction boundaries
  int[] ins_pos;
  ...
  Arrays.sort(ins_pos);
  assert(ins_pos[0] == 0);
  assert(ins_pos[ins_pos.length-1] == bytecodes.length);
  int regulars = ins_pos.length; //  # instruction boundaries
  ...
  int renumber_bci(int bci) {
    int i = Arrays.binarySearch(ins_pos, bci);
    return (i &gt;= 0) ? i : (i == -1) ? bci : ins_pos.length + bci - (-i-1);
  }
  ...
  for (int bci = -100; bci &lt;= bytecodes.length+100; bci++) {
    int bci_numbering_for_band = renumber_bci(bci);
    int i = Arrays.binarySearch(ins_pos, bci);
    if (i &gt;= 0) {
      assert(ins_pos[i] == bci);
      assert(bci_numbering_for_band &lt; regulars);
      assert(bci_numbering_for_band == i);
    } else if (0 &lt; bci &amp;&amp; bci &lt; bytecodes.length) {
      int nexti = (-i-1);  // index of next instruction
      assert(ins_pos[nexti-1] &lt; bci &amp;&amp; bci &lt; ins_pos[nexti]);
      int prevRegulars = nexti;
      int prevAll = bci;
      int prevIrregulars = prevAll - prevRegulars;
      assert(bci_numbering_for_band &gt;= regulars);
      assert(bci_numbering_for_band == regulars + prevIrregulars);
    } else {
      // other (random) numbers are unchanged by renumbering
      assert(bci_numbering_for_band &gt;= bytecodes.length ||
             bci_numbering_for_band &lt; 0);
      assert(bci_numbering_for_band == bci);
    }
  }
</pre>
<a name="icn_psc" id="icn_psc"></a> <a name="tocRePrNeClNa" id=
"tocRePrNeClNa"></a>
<h4>8.2.4. Representation of Predictable Nested Class Names</h4>
The following pseudo-code asserts the relations, as described in the section <a href=
"#icn_psc_ref">Nested Classes</a>, between the nested class's
mangled name and the predictable outer and simple names. Note that
searches for the literal characters '/' and '$' must be replaced in
real implementations by searches for the character ranges
associated with the SLASH and DOLLAR nonterminals. (This code
merely comments on the specification given above; it does not
itself add new information to the specification.)
<pre class="codeblock">
  String bcn, predictableOuter, predictableICName;
  ...
  String name = bcn.substring(bcn.lastIndexOf('/')+1);
  int dollar2 = name.lastIndexOf('$');
  assert(predictableICName == null ||
         (predictableICName.charAt(0) &gt; '9' &amp;&amp;
          predictableICName.indexOf('$') &lt; 0));
  if (predictableICName == null) {
    // bcnCase1 or bcnCase4
    assert(predictableOuter == null);
    assert(dollar2 == -1 ||
           dollar2+1 == name.length() ||
           isDigit(name.charAt(dollar2+1)));
  } else if (predictableOuter == null) {
    // bcnCase2
    assert(name.endsWith("$"+predictableICName));
    int dollar1 = name.substring(0, dollar2).lastIndexOf('$');
    assert(dollar1 &gt;= 0 &amp;&amp; dollar1+1 &lt; dollar2);
    assert(isDigitString(name.substring(dollar1+1, dollar2)));
  } else {
    // bcnCase3
    assert(bcn.equals(predictableOuter+"$"+predictableICName));
  }
 
</pre>
<a name="faq" id="faq"></a> <a name="tocAppDes" id="tocAppDes"></a>
<h3>8.3. Appendix: Design FAQ</h3>
This collection of frequently asked questions concerning the
Pack200 archive format is meant to serve as a design rationale.
<a name="tocGenQue" id="tocGenQue"></a>
<h4>8.3.1. General Questions</h4>
<ol>
<li>
<p><b>Why not use an existing generic compression mechanism, such
as <tt>.jar</tt>, <tt>.zip</tt>, or <tt>.tar.gz</tt> files?</b>
First, it is better to know the structure of a thing compressed.
Second, a zip or jar archive is compressed element-wise not
globally. This means that any symbol shared by several classes must
be mentioned independently once in each class file. Third, the
structure of an individual class file is really an interleaving of
many different kind of data, each with their own statistics, which
limits the effectiveness of a single-stream compressor such as
gzip. The specific benefit of reordering the data into bands is
about a factor of two, independently of the quality of the
off-the-shelf compressor used as a post-pass. There are also
significant marginal benefits from the various type-specific
recoding techniques. The net result is to improve a compression
factor from 2-4X to 7-9X.</p>
</li>
<li>
<p><b>Why is this specification so complex?</b> The techniques
described here are the result of much experimentation over several
years. Each feature of this specification is thought to contribute
measurably to the overall compression ratio achieved by this
technology. The authors would be happy to be shown, by benchmarks,
that some given feature can be omitted without significant loss of
compression performance.</p>
<p>(A compression performance multiplier of 1.002 or more for some
particular technique is significant, because such multipliers
accumulate readily into performance that end-users notice. A
multiplier of less than 1.0005 is insignificant.)</p>
</li>
<li>
<p><b>The Pack200 transmission format is closely tied to the
current class file format. Won't it go out of date as soon as the
class file format evolves further?</b> Further developments are
likely to take the form of new attributes or perhaps new bytecodes.
The layout language defined by Pack200 supports a very wide range
of attribute formats, including arbitrary mixes of bytes and
constant pool references. Likewise, the bytecode representation
includes escape operators which can represent arbitrary mixes of
data and constant pool references. Although such constructs will
not compress as optimally as the features for which this
specification is directly designed, it appears that reasonable
future extensions will continue to be transmittable, without
disturbing the compression of current features, and without
requiring decompressors to be updated.</p>
</li>
<li>
<p><b>Since Pack200 is a lossy compression algorithm, won't it
break signed JAR files?</b> Signed JAR files contain secure hashes
over the bytewise contents of individual class files. Any change to
the bits of a class file will change its hash code, making the
innocuous changes of Pack200 indistinguishable from attacks on the
application code.</p>
<p>Pack200, like many other compression algorithms, allows the
compressor many degrees of freedom in choosing the contents of the
compressed archive, but no degrees of freedom in choosing the
contents of the decompressed JAR file. Given a compressed archive,
all compliant Pack200 decompressors must produce the same class
file bytes, for each transmitted class file. This stability of
output persists for class files even if a resource file (such as
the manifest) changes its contents. Thus, for any given class file,
compression may be lossy, but the decompression of each class file
must be exact, in a useful way defined by the Pack200
specification.</p>
<p>This means that a compressor with the right stability properties
can be used to produce a signed, packed JAR using these steps:</p>
<ol>
<li>Pack the original signed JAR file.</li>
<li>Unpack it, producing perturbed class files.</li>
<li>Re-sign it, ensuring that only the manifest changes.</li>
<li>Re-pack it, using the updated manifest.</li>
</ol>
<p>(Note: If this specification allows two compliant decompressors
to produce different JAR archive elements for the same compressed
archive input, it is a bug in the specification. The specification
is thought to be free of such bugs, but if you find one please
report it.)</p>
</li>
<li>
<p><b>What is the relationship between file names in Pack200
archives and file names in JAR (or ZIP) archives or disk files?</b>
Pack200 specifies that file names are transmitted as Utf8 strings.
Since these strings are intended to function as names of JAR
elements in functioning Java applications, the strings must also
conform to Java usage, which also represents pathnames as Utf8
strings in JAR files and 16-bit Unicode in memory. Also, in JAR
files, pathname components are separated by the forward slash
character ('/'), and not by any system-specific character. This
allows class loaders to easily convert the internal representation
of the class names (e.g., "java/lang/Object") to pathnames (e.g.,
"java/lang/Object.class").</p>
<p>The Pack200 specification does not dictate the interpretation of
file name strings with respect to any other tool or operating
system. However, the natural mapping would be as coherent as
possible with Java's usages.</p>
</li>
<li>
<p><b>What is the relationship between file dates in JAR (or ZIP)
archives or disk files?</b> Pack200 specifies that file dates are
transmitted as 32-bit counts of seconds relative to Java's time
base (i.e., <tt>System.currentTimeMillis</tt> divided by one
thousand). This provides absolute times relative to UTC, at a
one-second granularity. If an operating system provides more
accurate file times, they must be adjusted to a nearby whole second
before transmission in a Pack200 archive.</p>
<p>JAR and ZIP store dates in local format (i.e.,
<tt>"YYYY/MM/DD&nbsp;HH:MM:SS"</tt>) with no timezone
specification. This means that conversion to and from Java's
UTC-based times requires a guess at the timezone under which the
compressor was operating. (This problem is not unique to Pack200.
It is a problem with all uses of ZIP and JAR archives.) For many
purposes, the standard guess is that the decompressor and
compressor were operating in the same timezone and during the same
yearly daylight savings time regime. However, in order to provide
more stability in the times transmitted in Pack200 archives, it is
expected that most compressors and decompressors will agree to use
UTC as the timezone when interpreting ZIP-style local times.</p>
</li>
<li>
<p><b>Doesn't the JEFF file
format also oprovide a class-specific compression algorithm?</b>
Yes, the JEFF Working Group has defined a standard file format
(ISO/IEC 20970) which allows class files to be compressed about 50%
and <i>also</i> loaded directly into memory for interpretive
execution. As compression performance, it is comparable with the
DEFLATE algorithm used within JAR archives. Pack200 provides much
greater compression. However, Pack200 archives are not designed for
direct execution by any virtual machine. The greater compression
level of Pack200 is won at a cost of complexity in the unpacker, a
complexity incompatible with any requirement of direct loading or
execution.</p>
</li>
<li>
<p><b>Why doesn't Pack200 use Huffman encoding? (Same question for
LZW, or BWT, or move-to-front, or any other standard compression
technique.)</b> As a matter of simplicity and division of labor,
Pack200 intentionally focuses on finding and removing large-scale
redundancies specific to class files. Pack200 produces a
byte-oriented output, hopefully with clear patterns and a simple
alphabet statistics. It relies on a post-pass compressor to encode
these bytes in some more efficient string-sharing, bit-sliced
representation.</p>
<p>The following considerations support this design:</p>
<ul>
<li>Repeating similar compression tactics in two places in a
pipeline of transformations can actually degrade overall
compression. For example, doing move-to-front in Pack200 band
transmission would make it harder for the DEFLATE algorithm to
detect repeated patterns, because they would have varying spellings
in the tokens DEFLATE would observe. (Delta encoding also has this
risk, which is why it's optional in Pack200. But, off-the-shelf
back ends don't generally do delta encoding.)</li>
<li>Relying on an off-the-shelf backend for final compression
simplifies the Pack200 design.</li>
<li>It also lets Pack200 leverage the latest byte-oriented
compression tools.</li>
<li>Such factoring also simplifies engineering of packer
heuristics.</li>
<li>The job of Pack200 is to find redundancies and patterns at
class and package scales. It seems cleaner to avoid messing with
byte-level scales.</li>
<li>Some specific standard compression techniques may still be
encumbered by patents, even on simple, self-evident techniques.
Avoiding such patents is a significant cost in engineering a
compressor. We would rather avoid this cost by using a standard
tool.</li>
</ul>
</li>
<li>
<p><b>How does this specification cope with archive format
changes?</b> The major and minor version numbers of a Pack200
archive advertise which version of this standard has been generated
by a packer. Because of the flexibility of attribute
layouts, packers can sometimes represent new classfile formats in
old archive formats, but newer archive formats may be required for
reasons of functionality or performance.</p>
<p>Unpacker implementations are strongly encouraged to support each
standard version of the archive format, since there is not always a
strong alignment between packer and unpacker versions at either end
of a deployment channel. Packer implementations are encouraged to
preserve the ability to emit older archive formats, to maintain
maximum compatibility with unpackers.</p>
<p>The reference implementation chooses to maintain backward
compatibility by producing a 1.5 pack format if the input JAR
archive contains no 1.6 (or newer) classfiles. In general, it will
produce the oldest possible archive version compatible with all the
input classfiles. An empty archive will default to the oldest
archive version, which is 1.5.</p>
</li>
<!-- === TEMPLATE FAQ ITEM: ===

<li><p><b>


QQQ?

</b>

AAA.

</p><p>

AAA2.

</p></li>

=== --></ol>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
