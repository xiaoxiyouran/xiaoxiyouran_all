<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>Default Policy Implementation and Policy File Syntax</title>
<link rel="stylesheet" type="text/css" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->



<h1>Default Policy Implementation and Policy File Syntax</h1>

<p>The policy for a Java&trade; programming language application
environment (specifying which permissions are available for code
from various sources, and executing as various principals) is
represented by a Policy object. More specifically, it is
represented by a <code>Policy</code> subclass providing an
implementation of the abstract methods in the <code>Policy</code>
class (which is in the <code>java.security</code> package).</p>
<p>The source location for the policy information utilized by the
Policy object is up to the Policy implementation. The Policy
reference implementation obtains its information from static policy
configuration files.</p>
<p>The rest of this document pertains to the Policy reference
implementation and the syntax that must be used in policy files it
reads. For information about using the <b>Policy Tool</b> to create
a policy file (without needing to know the required syntax), see
the Policy Tool documentation (<a href=
"../../tools/unix/policytool.html">for Solaris, Linux, or Mac OS X</a>)
(<a href="../../tools/windows/policytool.html">for
Windows</a>).</p>
<p>Here is an outline for the rest of this document:</p>
<dl>
<dd><a href="#DefaultImpl"><b>Default Policy
Implementation</b></a></dd>
<dd><a href="#DefaultLocs"><b>Default Policy File
Locations</b></a></dd>
<dd><a href="#ChangingDefault"><b>Changing the Policy
Implementation</b></a></dd>
<dd><a href="#FileSyntax"><b>Policy File Syntax</b></a></dd>
<dd><a href="#Examples"><b>Policy File Examples</b></a></dd>
<dd><a href="#PropertyExp"><b>Property Expansion in Policy
Files</b></a></dd>
<dd><a href="#GeneralExp"><b>General Expansion in Policy
Files</b></a></dd>
<dd><a href="#RelatedDoc"><b>Related Documentation</b></a></dd>
</dl>
<br />
<h2><a name="DefaultImpl" id="DefaultImpl">Default Policy
Implementation</a></h2>
In the Policy reference implementation, the policy can be specified
within one or more policy configuration files. The configuration
file(s) specify what permissions are allowed for code from a
specified code source, and executed by a specified principal. Each
configuration file must be encoded in UTF-8.
<p>A policy file can be composed via a simple text editor, or via
the graphical <b>Policy Tool</b> utility.</p>
<p>There is by default a single system-wide policy file, and a
single (optional) user policy file.</p>
<p>The Policy reference implementation is initialized the first
time its <code>getPermissions</code> method is called, or whenever
its <code>refresh</code> method is called. Initialization involves
parsing the policy configuration file(s) (see <a href=
"#FileSyntax">Policy File Syntax</a>), and then populating the
Policy object.</p>
<h2><a name="DefaultLocs" id="DefaultLocs">Default Policy File
Locations</a></h2>
<p>As mentioned previously, there is by default a single
system-wide policy file, and a single user policy file.</p>
<p>The system policy file is by default located at</p>
<pre class="codeblock">
<i>java.home</i>/lib/security/java.policy  (Solaris, Linux, or Mac OS X)
<i>java.home</i>\lib\security\java.policy  (Windows)
</pre>
<p><b>Note:</b> <i><code>java.home</code></i> refers to the value
of the system property named "<code>java.home</code>", which
specifies the directory that houses the runtime environment --
either the <tt>jre</tt> directory in the Java SE Development Kit
(JDK) or the top-level directory of the Java SE Runtime Environment
(JRE).</p>
<p>The system policy file is meant to grant system-wide code
permissions. The <code>java.policy</code> file installed with the
JDK grants all permissions to standard extensions, allows anyone to
listen on un-privileged ports, and allows any code to read certain
"standard" properties that are not security-sensitive, such as the
"<code>os.name</code>" and "<code>file.separator</code>"
properties.</p>
<p>The user policy file is by default located at</p>
<pre class="codeblock">
<i>user.home</i>/.java.policy  (Solaris, Linux, or Mac OS X)
<i>user.home</i>\.java.policy  (Windows)
</pre>
<p><b>Note:</b> <i><code>user.home</code></i> refers to the value
of the system property named "<code>user.home</code>", which
specifies the user's home directory.</p>
<p>When the Policy is initialized, the system policy is loaded in
first, and then the user policy is added to it. If neither policy
is present, a built-in policy is used. This built-in policy is the
same as the java.policy file installed with the JRE.</p>
<p>Policy file locations are specified in the security properties
file, which is located at</p>
<pre class="codeblock">
<i>java.home</i>/lib/security/java.security  (Solaris, Linux, or Mac OS X)
<i>java.home</i>\lib\security\java.security  (Windows)
</pre>
As noted above, <i><code>java.home</code></i> indicates the
directory that houses the runtime environment--either the
<tt>jre</tt> directory in the JDK or the top-level directory of the
JRE. The policy file locations are specified as the values of
properties whose names are of the form
<pre class="codeblock">
policy.url.<i>n</i>
</pre>
where <i><code>n</code></i> is a number. You specify each such
property value in a line of the following form:
<pre class="codeblock">
policy.url.<i>n</i>=<i>URL</i>
</pre>
Here, <i><code>URL</code></i> is a URL specification.
<p>For example, the default system and user policy files are
defined in the security properties file as</p>
<pre class="codeblock">
policy.url.1=file:${java.home}/lib/security/java.policy
policy.url.2=file:${user.home}/.java.policy
</pre>
<p>(See <a href="#PropertyExp">Property Expansion</a> for
information about specifying property values via a special syntax,
such as specifying the <i><code>java.home</code></i> property value
via <i><code>${java.home}</code></i>.)</p>
<p>You can actually specify a number of URLs (including ones of the
form "<code>http://</code>"), and all the designated policy files
will get loaded. You can also comment out or change the second one
to disable reading the default user policy file.</p>
<p>The algorithm starts at <code>policy.url.1</code>, and keeps
incrementing until it does not find a URL. Thus if you have
<code>policy.url.1</code> and <code>policy.url.3</code>,
<code>policy.url.3</code> will never be read.</p>
<h3>Specifying an Additional Policy File at Runtime</h3>
<p>It is also possible to specify an additional or a different
policy file when invoking execution of an application. This can be
done via the "<code>-Djava.security.policy</code>" command line
argument, which sets the value of the
<i><code>java.security.policy</code></i> property. For example, if
you use</p>
<pre class="codeblock">
    java -Djava.security.manager -Djava.security.policy=<i>someURL</i> SomeApp
</pre>
where <i><code>someURL</code></i> is a URL specifying the location
of a policy file, then the specified policy file will be loaded in
addition to all the policy files that are specified in the security
properties file.
<p><b>Notes:</b></p>
<ul>
<li>The URL can be any regular URL or simply the name of a policy
file in the current directory, as in
<pre class="codeblock">
    java -Djava.security.manager -Djava.security.policy=mypolicy SomeApp
</pre></li>
<li>The "<code>-Djava.security.manager</code>" argument ensures
that the default security manager is installed, and thus the
application is subject to policy checks. It is not required if the
application <i><code>SomeApp</code></i> installs a security
manager.</li>
</ul>
<p>If you use</p>
<pre class="codeblock">
    java -Djava.security.manager -Djava.security.policy==<i>someURL</i> SomeApp
</pre>
(note the double equals) then <i>just</i> the specified policy file
will be used; all the ones indicated in the security properties
file will be ignored.
<p>If you want to pass a policy file to the appletviewer, then use
a "<code>-J-Djava.security.policy</code>" argument as follows:</p>
<pre class="codeblock">
    appletviewer -J-Djava.security.policy=<i>someURL</i> myApplet
</pre>
<b>Note:</b> The "<code>-Djava.security.policy</code>" policy file
value will be ignored (for both <code>java</code> and
<code>appletviewer</code> commands) if the
"<code>policy.allowSystemProperty</code>" property in the security
properties file is set to false. The default is true.
<h2><a name="ChangingDefault" id="ChangingDefault">Changing the
Policy Implementation</a></h2>
<p>An alternative policy class can be given to replace the Policy
reference implementation class, as long as the former is a subclass
of the abstract Policy class and implements the
<code>getPermissions</code> method (and other methods as
necessary).</p>
<p>The Policy reference implementation can be changed by editing
the security properties file, which is the
<code>java.security</code> file in the <code>lib/security</code>
directory of the JDK or JRE.</p>
<p>One of the types of properties you can set in
<code>java.security</code> is of the following form:</p>
<pre class="codeblock">
    policy.provider=<i>PolicyClassName</i>
</pre>
<p><i><code>PolicyClassName</code></i> must specify the fully
qualified name of the desired <code>Policy</code> implementation
class. The default security properties file entry for this property
is the following:</p>
<pre class="codeblock">
    policy.provider=sun.security.provider.PolicyFile
</pre>
<p>To customize, you can change the property value to specify
another class, as in</p>
<pre class="codeblock">
    policy.provider=com.mycom.MyPolicy
</pre>
<h2><a name="FileSyntax" id="FileSyntax">Policy File
Syntax</a></h2>
<p>The policy configuration file(s) for a JDK or JRE installation
specifies what permissions (which types of system resource
accesses) are granted to code from a specified code source, and
executed as a specified principal.</p>
<p>For an applet (or an application running under a security
manager) to be allowed to perform secured actions (such as reading
or writing a file), the applet (or application) must be granted
permission for that particular action. In the Policy reference
implementation, that permission must be granted by a grant entry in
a policy configuration file. See below and the <a href=
"spec/security-spec.doc.html">"Java Security Architecture
Specification"</a> for more information. (The only exception is
that code always automatically has permission to read files from
its same (URL) location, and subdirectories of that location; it
does not need explicit permission to do so.)</p>
<p>A policy configuration file essentially contains a list of
entries. It may contain a "keystore" entry, and contains zero or
more "grant" entries.</p>
<h3><a name="KeyStoreEntry" id="KeyStoreEntry">Keystore
Entry</a></h3>
<p>A <i>keystore</i> is a database of private keys and their
associated digital certificates such as X.509 certificate chains
authenticating the corresponding public keys. The <b>keytool</b>
utility (<a href="../../tools/unix/keytool.html">for
Solaris, Linux, or Mac OS X</a>) (<a href="../../tools/windows/keytool.html">for
Windows</a>) is used to create and administer keystores. The
keystore specified in a policy configuration file is used to look
up the public keys of the signers specified in the grant entries of
the file. A keystore entry must appear in a policy configuration
file if any grant entries specify signer aliases, or if any grant
entries specify principal aliases (see below).</p>
<p>At this time, there can be only one
<b><code>keystore</code>/<code>keystorePasswordURL</code></b> entry
in the policy file (other entries following the first one are
ignored). This entry can appear anywhere outside the file's grant
entries. It has the following syntax:</p>
<pre class="codeblock">
keystore "some_keystore_url", "keystore_type", "keystore_provider";
keystorePasswordURL "some_password_url";
</pre>
<code>some_keystore_url</code> specifies the URL location of the
keystore, <code>some_password_url</code> specifies the URL location
of the keystore password, <code>keystore_type</code> specifies the
keystore type, and <code>keystore_provider</code> specifies the
keystore provider. Note that the input stream from
<code>some_keystore_url</code> is passed to the
<code>KeyStore.load</code> method. If <code>NONE</code> is
specified as the URL, then a null stream is passed to the
<code>KeyStore.load</code> method. <code>NONE</code> should be
specified if the <code>KeyStore</code> is not file-based, for
example, if it resides on a hardware token device.
<p>The URL is relative to the policy file location. Thus if the
policy file is specified in the security properties file as:</p>
<pre class="codeblock">
    policy.url.1=http://foo.example.com/fum/some.policy
</pre>
and that policy file has an entry:
<pre class="codeblock">
    keystore ".keystore";
</pre>
then the keystore will be loaded from:
<pre class="codeblock">
    http://foo.example.com/fum/.keystore
</pre>
The URL can also be absolute.
<p>A <b>keystore type</b> defines the storage and data format of
the keystore information, and the algorithms used to protect
private keys in the keystore and the integrity of the keystore
itself. The default type supported by Sun Microsystems is a
proprietary keystore type named "JKS". Thus, if the keystore type
is "JKS", it does not need to be specified in the keystore
entry.</p>
<h3>Grant Entries</h3>
<p>Code being executed is always considered to come from a
particular "code source" (represented by an object of type
<code>CodeSource</code>). The code source includes not only the
location (URL) where the code originated from, but also a reference
to the certificate(s) containing the public key(s) corresponding to
the private key(s) used to sign the code. Certificates in a code
source are referenced by symbolic alias names from the user's
keystore. Code is also considered to be executed as a particular
principal (represented by an object of type
<code>Principal</code>), or group of principals.</p>
<p>Each <b>grant entry</b> includes one or more "permission
entries" preceded by optional <code>codeBase</code>,
<code>signedBy</code>, and principal name/value pairs that specify
which code you want to grant the permissions. The basic format of a
grant entry is the following:</p>
<pre class="codeblock">
  grant signedBy "<i>signer_names</i>", codeBase "<i>URL</i>",
        principal <i>principal_class_name</i> "<i>principal_name</i>",
        principal <i>principal_class_name</i> "<i>principal_name</i>",
        ... {

      permission <i>permission_class_name</i> "<i>target_name</i>", "<i>action</i>", 
          signedBy "<i>signer_names</i>";
      permission <i>permission_class_name</i> "<i>target_name</i>", "<i>action</i>", 
          signedBy "<i>signer_names</i>";
      ...
  };
        
</pre>
All non-italicized items above must appear as is (although case
doesn't matter and some are optional, as noted below). Italicized
items represent variable values.
<p>A grant entry must begin with the word <code>grant</code>.</p>
<h3>The <code>SignedBy</code>, <code>Principal</code>, and
<code>CodeBase</code> Fields</h3>
<p>The <code>signedBy</code>, <code>codeBase</code>, and
<code>principal</code> values are optional, and the order of these
fields does not matter.</p>
<p>A <code>signedBy</code> value indicates the alias for a
certificate stored in the keystore. The public key within that
certificate is used to verify the digital signature on the code;
you grant the permission(s) to code signed by the private key
corresponding to the public key in the keystore entry specified by
the alias.</p>
<p>The <code>signedBy</code> value can be a comma-separated list of
multiple aliases. An example is "Adam,Eve,Charles", which means
"signed by Adam and Eve and Charles"; the relationship is AND, not
OR. To be more exact, a statement like "Code signed by Adam" means
"Code in a class file contained in a JAR which is signed using the
private key corresponding to the public key certificate in the
keystore whose entry is aliased by Adam".</p>
<p>The <code>signedBy</code> field is optional in that, if it is
omitted, it signifies "any signer". It doesn't matter whether the
code is signed or not or by whom.</p>
<p>A principal value specifies a
<code>class_name</code>/<code>principal_name</code> pair which must
be present within the executing thread's principal set. The
principal set is associated with the executing code by way of a
Subject.</p>
<p>The <code>principal_class_name</code> may be set to the wildcard
value, *, which allows it to match any <code>Principal</code>
class. In addition, the <code>principal_name</code> may also be set
to the wildcard value, *, allowing it to match any
<code>Principal</code> name. When setting the
<code>principal_class_name</code> or <code>principal_name</code> to
*, do not surround the * with quotes. Also, if you specify a
wildcard principal class, you must also specify a wildcard
principal name.</p>
<p>The principal field is optional in that, if it is omitted, it
signifies "any principals".</p>
<p><a name="keystoreAliasReplace" id="keystoreAliasReplace"><b>Note
on KeyStore Alias Replacement:</b></a></p>
<p>If the principal class_name/principal_name pair is specified as
a single quoted string, it is treated as a keystore alias. The
keystore is consulted and queried (via the alias) for an X509
Certificate. If one is found, the principal class_name is
automatically treated as
<code>javax.security.auth.x500.X500Principal</code>, and the
<code>principal_name</code> is automatically treated as the subject
distinguished name from the certificate. If an X509 Certificate
mapping is not found, the entire grant entry is ignored.</p>
<p>A <code>codeBase</code> value indicates the code source
location; you grant the permission(s) to code from that location.
An empty <code>codeBase</code> entry signifies "any code"; it
doesn't matter where the code originates from.</p>
<p><b>Note:</b> a <code>codeBase</code> value is a URL and thus
should always utilize slashes (never backslashes) as the directory
separator, even when the code source is actually on a Windows
system. Thus, if the source location for code on a Windows system
is actually <code>C:\somepath\api\</code>, then the policy
<code>codeBase</code> entry should look like:</p>
<pre class="codeblock">
    grant codeBase "file:/C:/somepath/api/" {
        ...
    };
</pre>
The exact meaning of a <code>codeBase</code> value depends on the
characters at the end. A <code>codeBase</code> with a trailing "/"
matches all class files (not JAR files) in the specified directory.
A <code>codeBase</code> with a trailing "/*" matches all files
(both class and JAR files) contained in that directory. A
<code>codeBase</code> with a trailing "/-" matches all files (both
class and JAR files) in the directory and recursively all files in
subdirectories contained in that directory. The following table
illustrates the different cases.
<table summary="codeBase values and meanings" border="1"
cellpadding="5">
<tr>
<th id="h1">Codebase URL of Downloaded Code</th>
<th id="h2">Codebase URL in Policy</th>
<th id="h3">Match?</th>
</tr>
<tr>
<td headers="h1">www.example.com/people/gong/</td>
<td headers="h2">www.example.com/people/gong</td>
<td headers="h3">
Y
</td>
</tr>
<tr>
<td headers="h1">www.example.com/people/gong/</td>
<td headers="h2">www.example.com/people/gong/</td>
<td headers="h3">
Y
</td>
</tr>
<tr>
<td headers="h1">www.example.com/people/gong/</td>
<td headers="h2">www.example.com/people/gong/*</td>
<td headers="h3">
Y
</td>
</tr>
<tr>
<td headers="h1">www.example.com/people/gong/</td>
<td headers="h2">www.example.com/people/gong/-</td>
<td headers="h3">
Y
</td>
</tr>
<tr>
<td headers="h1">www.example.com/people/gong/appl.jar</td>
<td headers="h2">www.example.com/people/gong/</td>
<td headers="h3">
N
</td>
</tr>
<tr>
<td headers="h1">www.example.com/people/gong/appl.jar</td>
<td headers="h2">www.example.com/people/gong/-</td>
<td headers="h3">
Y
</td>
</tr>
<tr>
<td headers="h1">www.example.com/people/gong/appl.jar</td>
<td headers="h2">www.example.com/people/gong/*</td>
<td headers="h3">
Y
</td>
</tr>
<tr>
<td headers="h1">www.example.com/people/gong/appl.jar</td>
<td headers="h2">www.example.com/people/-</td>
<td headers="h3">
Y
</td>
</tr>
<tr>
<td headers="h1">www.example.com/people/gong/appl.jar</td>
<td headers="h2">www.example.com/people/*</td>
<td headers="h3">
N
</td>
</tr>
<tr>
<td headers="h1">www.example.com/people/gong/</td>
<td headers="h2">www.example.com/people/-</td>
<td headers="h3">
Y
</td>
</tr>
<tr>
<td headers="h1">www.example.com/people/gong/</td>
<td headers="h2">www.example.com/people/*</td>
<td headers="h3">
N
</td>
</tr>
</table>
<h3>The Permission Entries</h3>
<p>A <b>permission entry</b> must begin with the word
<code>permission</code>. The word
<code><i>permission_class_name</i></code> in the template above
would actually be a specific permission type, such as
<code>java.io.FilePermission</code> or
<code>java.lang.RuntimePermission</code>.</p>
<p>The "<i><code>action</code></i>" is required for many permission
types, such as <code>java.io.FilePermission</code> (where it
specifies what type of file access is permitted). It is not
required for categories such as
<code>java.lang.RuntimePermission</code> where it is not
necessary--you either have the permission specified by the
"<code><i>target_name</i></code>" value following the
<i><code>permission_class_name</code></i> or you don't.</p>
<p>The <code>signedBy</code> name/value pair for a permission entry
is optional. If present, it indicates a signed permission. That is,
the permission class itself must be signed by the given alias(es)
in order for the permission to be granted. For example, suppose you
have the following grant entry:</p>
<pre class="codeblock">
  grant {
      permission Foo "foobar", signedBy "FooSoft";
  };
</pre>
<p>Then this permission of type <i>Foo</i> is granted if the
<code>Foo.class</code> permission was placed in a JAR file and the
JAR file was signed by the private key corresponding to the public
key in the certificate specified by the "FooSoft" alias, or if
<code>Foo.class</code> is a system class, since system classes are
not subject to policy restrictions.</p>
<p>Items that appear in a permission entry must appear in the
specified order (<code>permission</code>,
<i>permission_class_name</i>, "<i>target_name</i>",
"<i>action</i>", and <code>signedBy</code> "<i>signer_names</i>").
An entry is terminated with a semicolon.</p>
<p>Case is unimportant for the identifiers
(<code>permission</code>, <code>signedBy</code>,
<code>codeBase</code>, etc.) but is significant for the
<i>permission_class_name</i> or for any string that is passed in as
a value.</p>
<h3>Note Regarding File Path Specifications on Windows Systems</h3>
<p><b>Note:</b> When you are specifying a
<code>java.io.FilePermission</code>, the
"<i><code>target_name</code></i>" is a file path. On Windows
systems, whenever you directly specify a file path in a string (but
not in a codeBase URL), you need to include two backslashes for
each actual single backslash in the path, as in</p>
<pre class="codeblock">
  grant {
      permission java.io.FilePermission "C:\\users\\cathy\\foo.bat", "read";
  };
</pre>
The reason this is necessary is because the strings are processed
by a tokenizer (<code>java.io.StreamTokenizer</code>), which allows
"<code>\</code>" to be used as an escape string (for example,
"<code>\n</code>" to indicate a new line) and which thus requires
two backslashes to indicate a single backslash. After the tokenizer
has processed the above file path string, converting double
backslashes to single backslashes, the end result is
<pre class="codeblock">
    "C:\users\cathy\foo.bat"
</pre>
<h2><a name="Examples" id="Examples">Policy File Examples</a></h2>
<p>An example of two entries in a policy configuration file is</p>
<pre class="codeblock">
  // If the code is signed by "Duke", grant it read/write access to all 
  // files in /tmp:
  grant signedBy "Duke" {
      permission java.io.FilePermission "/tmp/*", "read,write";
  };

  // Grant everyone the following permission:
  grant { 
      permission java.util.PropertyPermission "java.vendor", "read";
  };
 
</pre>
<p>The contents of another sample policy configuration file appear
below.</p>
<pre class="codeblock">
  grant signedBy "sysadmin", codeBase "file:/home/sysadmin/*" {
      permission java.security.SecurityPermission "Security.insertProvider.*";
      permission java.security.SecurityPermission "Security.removeProvider.*";
      permission java.security.SecurityPermission "Security.setProperty.*";
  };
</pre>
This specifies that <i>only</i> code that satisfies the following
conditions can call methods in the Security class to add or remove
providers or to set Security properties:
<ul>
<li>The code was loaded from a signed JAR file that is in the
"<code>/home/sysadmin/</code>" directory on the local file
system.</li>
<li>The signature can be verified using the public key referenced
by the alias name "sysadmin" in the keystore.</li>
</ul>
<p>Either component of the code source (or both) may be missing. An
example where <code>codeBase</code> is missing is:</p>
<pre class="codeblock">
  grant signedBy "sysadmin" {
      permission java.security.SecurityPermission "Security.insertProvider.*";
      permission java.security.SecurityPermission "Security.removeProvider.*";
  };
</pre>
If this policy is in effect, code that comes in a JAR File signed
by "sysadmin" can add/remove providers, regardless of where the JAR
File originated from.
<p>An example without a signer is:</p>
<pre class="codeblock">
  grant codeBase "file:/home/sysadmin/-" {
      permission java.security.SecurityPermission "Security.insertProvider.*";
      permission java.security.SecurityPermission "Security.removeProvider.*";
  };
</pre>
In this case, code that comes from anywhere beneath the
"<code>/home/sysadmin/</code>" directory on the local filesystem
can add/remove providers. The code does not need to be signed.
<p>An example where neither <code>codeBase</code> nor
<code>signedBy</code> is included is:</p>
<pre class="codeblock">
  grant {
      permission java.security.SecurityPermission "Security.insertProvider.*";
      permission java.security.SecurityPermission "Security.removeProvider.*";
  };
</pre>
Here, with both code source components missing, any code
(regardless of where it originated from, or whether or not it is
signed, or who signed it) can add/remove providers.
<p>The following represents a principal-based entry.</p>
<pre class="codeblock">
  grant principal javax.security.auth.x500.X500Principal "cn=Alice" {
      permission java.io.FilePermission "/home/Alice", "read, write";
  };
</pre>
This permits any code executing as the X500Principal,
"<code>cn=Alice</code>", permission to read and write to
"<code>/home/Alice</code>".
<p>The following represents a principal-based entry with a wildcard
value.</p>
<pre class="codeblock">
  grant principal javax.security.auth.x500.X500Principal * {
      permission java.io.FilePermission "/tmp", "read, write";
  };
</pre>
This permits any code executing as an X500Principal (regardless of
the distinguished name), permission to read and write to
"<code>/tmp</code>".
<p>The following example shows a grant statement with both
codesource and principal information.</p>
<pre class="codeblock">
  grant codebase "http://www.games.example.com",
        signedBy "Duke",
        principal javax.security.auth.x500.X500Principal "cn=Alice" {
      permission java.io.FilePermission "/tmp/games", "read, write";
  };
</pre>
This allows code downloaded from
"<code>www.games.example.com</code>", signed by
"<code>Duke</code>", and executed by "<code>cn=Alice</code>",
permission to read and write into the "<code>/tmp/games</code>"
directory.
<p>The following example shows a grant statement with KeyStore
alias replacement:</p>
<pre class="codeblock">
  keystore "http://foo.example.com/blah/.keystore";

  grant principal "alice" {
      permission java.io.FilePermission "/tmp/games", "read, write";
  };
</pre>
"<code>alice</code>" will be replaced by
<pre class="codeblock">
    javax.security.auth.x500.X500Principal "cn=Alice"
</pre>
assuming the X.509 certificate associated with the keystore alias,
<i><code>alice</code></i>, has a subject distinguished name of
"<code>cn=Alice</code>". This allows code executed by the
X500Principal "<code>cn=Alice</code>" permission to read and write
into the "<code>/tmp/games</code>" directory.
<h2><a name="PropertyExp" id="PropertyExp">Property Expansion in
Policy Files</a></h2>
Property expansion is possible in policy files and in the security
properties file.
<p>Property expansion is similar to expanding variables in a shell.
That is, when a string like</p>
<pre class="codeblock">
    ${some.property}
</pre>
appears in a policy file, or in the security properties file, it
will be expanded to the value of the system property. For example,
<pre class="codeblock">
    permission java.io.FilePermission "${user.home}", "read";
</pre>
will expand "<code>${user.home}</code>" to use the value of the
"user.home" system property. If that property's value is
"<code>/home/cathy</code>", then the above is equivalent to
<pre class="codeblock">
    permission java.io.FilePermission "/home/cathy", "read";
</pre>
In order to assist in platform-independent policy files, you can
also use the special notation of "<code>${/}</code>", which is a
shortcut for "<code>${file.separator}</code>". This allows things
like
<pre class="codeblock">
    permission java.io.FilePermission "${user.home}${/}*", "read";
</pre>
If the value of the "<code>user.home</code>" property is
<code>/home/cathy</code>, and you are on Solaris, Linux, or Mac OS X, the above
gets converted to:
<pre class="codeblock">
    permission java.io.FilePermission "/home/cathy/*", "read";
</pre>
If on the other hand the "<code>user.home</code>" value is
<code>C:\users\cathy</code> and you are on a Windows system, the
above gets converted to:
<pre class="codeblock">
    permission java.io.FilePermission "C:\users\cathy\*", "read";
</pre>
Also, as a special case, if you expand a property in a codebase,
such as
<pre class="codeblock">
    grant codeBase "file:${java.home}/lib/ext/"
</pre>
then any file.separator characters will be automatically converted
to <code>/</code>'s. Thus on a Windows system, the above would get
converted to
<pre class="codeblock">
    grant codeBase "file:C:/jdk1.4/jre/lib/ext/"
</pre>
even if "<code>java.home</code>" is set to
<code>C:\jdk1.4\jre</code>. Thus you don't need to use
<code>${/}</code> in codebase strings (and you shouldn't).
<p>Property expansion takes place anywhere a double quoted string
is allowed in the policy file. This includes the
<i>"<code>signer_names</code>"</i>, <i>"<code>URL</code>"</i>,
<i>"<code>target_name</code>"</i>, and <i>"<code>action</code>"</i>
fields.</p>
<p>Whether or not property expansion is allowed is controlled by
the value of the "<code>policy.expandProperties</code>" property in
the security properties file. If the value of this property is true
(the default), expansion is allowed.</p>
<p><b>Note:</b> You can't use nested properties; they will not
work. For example,</p>
<pre class="codeblock">
    "${user.${foo}}"
</pre>
doesn't work, even if the "<code>foo</code>" property is set to
"<code>home</code>". The reason is the property parser doesn't
recognize nested properties; it simply looks for the first
"<code>${</code>", and then keeps looking until it finds the first
"<code>}</code>" and tries to interpret the result (in this case,
"<code>${user.$foo}</code>") as a property, but fails if there is
no such property.
<p><b>Note:</b> If a property can't be expanded in a grant entry,
permission entry, or keystore entry, that entry is ignored. For
example, if the system property "<code>foo</code>" is not defined
and you have:</p>
<pre class="codeblock">
    grant codeBase "${foo}" {
        permission ...;
        permission ...;
    };
</pre>
then all the permissions in this grant entry are ignored. If you
have
<pre class="codeblock">
    grant {
        permission Foo "${foo}";
        permission Bar "barTarget";
    };
</pre>
then only the "<code>permission Foo...</code>" entry is ignored.
And finally, if you have
<pre class="codeblock">
    keystore "${foo}";
</pre>
then the keystore entry is ignored.
<h3>Windows Systems, File Paths, and Property Expansion</h3>
As noted above, on Windows systems, when you directly specify a
file path in a string (but not in a codeBase URL), you need to
include two backslashes for each actual single backslash in the
path, as in
<pre class="codeblock">
    grant {
        permission java.io.FilePermission "C:\\users\\cathy\\foo.bat", "read";
    };
</pre>
This is because the strings are processed by a tokenizer
(<code>java.io.StreamTokenizer</code>), which allows
"<code>\</code>" to be used as an escape string (e.g.,
"<code>\n</code>" to indicate a new line) and which thus requires
two backslashes to indicate a single backslash. After the tokenizer
has processed the above file path string, converting double
backslashes to single backslashes, the end result is
<pre class="codeblock">
    "C:\users\cathy\foo.bat"
</pre>
Expansion of a property in a string takes place after the tokenizer
has processed the string. Thus if you have the string
<pre class="codeblock">
    "${user.home}\\foo.bat"
</pre>
then first the tokenizer processes the string, converting the
double backslashes to a single backslash, and the result is
<pre class="codeblock">
    "${user.home}\foo.bat"
</pre>
Then the <code>${user.home}</code> property is expanded and the end
result is
<pre class="codeblock">
    "C:\users\cathy\foo.bat"
</pre>
assuming the "<code>user.home</code>" value is
<code>C:\users\cathy</code>. Of course, for platform independence,
it would be better if the string was initially specified without
any explicit slashes, i.e., using the <code>${/}</code> property
instead, as in
<pre class="codeblock">
    "${user.home}${/}foo.bat"
</pre>
<h2><a name="GeneralExp" id="GeneralExp">General Expansion in
Policy Files</a></h2>
Generalized forms of expansion are also supported in policy files.
For example, permission names may contain a string of the form:
<pre class="codeblock">
${{protocol:protocol_data}}
</pre>
If such a string occurs in a permission name, then the value in
<i>protocol</i> determines the exact type of expansion that should
occur, and <i>protocol_data</i> is used to help perform the
expansion. <i>protocol_data</i> may be empty, in which case the
above string should simply take the form:
<pre class="codeblock">
${{protocol}}
</pre>
<p>There are two protocols supported in the default policy file
implementation:</p>
<ol>
<li><code>${{self}}</code>
<p>The protocol, <b><code>self</code></b>, denotes a replacement of
the entire string, <code>${{self}}</code>, with one or more
principal class/name pairs. The exact replacement performed depends
upon the contents of the grant clause to which the permission
belongs.</p>
<p>If the grant clause does not contain any principal information,
the permission will be ignored (permissions containing
<code>${{self}}</code> in their target names are only valid in the
context of a principal-based grant clause). For example,
<code>BarPermission</code> will always be ignored in the following
grant clause:</p>
<pre class="codeblock">
            grant codebase "www.example.com", signedby "duke" {
                permission BarPermission "... ${{self}} ...";
            };
        
</pre>
If the grant clause contains principal information,
<code>${{self}}</code> will be replaced with that same principal
information. For example, <code>${{self}}</code> in
<code>BarPermission</code> will be replaced with
<b><code>javax.security.auth.x500.X500Principal
"cn=Duke"</code></b> in the following grant clause:
<pre class="codeblock">
grant principal javax.security.auth.x500.X500Principal "cn=Duke" {
    permission BarPermission "... ${{self}} ...";
};
</pre>
If there is a comma-separated list of principals in the grant
clause, then <code>${{self}}</code> will be replaced by the same
comma-separated list or principals. In the case where both the
principal class and name are wildcarded in the grant clause,
<code>${{self}}</code> is replaced with all the principals
associated with the <code>Subject</code> in the current
<code>AccessControlContext</code>.
<p>The following example describes a scenario involving both
<b><code>self</code></b> and <a href=
"#keystoreAliasReplace"><code>KeyStore</code> alias replacement</a>
together:</p>
<pre class="codeblock">
keystore "http://foo.example.com/blah/.keystore";

grant principal "duke" {
    permission BarPermission "... ${{self}} ...";
};
</pre>
In the above example, "<code>duke</code>" will first be expanded
into <code><b>javax.security.auth.x500.X500Principal
"cn=Duke"</b></code> assuming the X.509 certificate associated with
the <code>KeyStore</code> alias, "<code>duke</code>", has a subject
distinguished name of "<code>cn=Duke</code>". Next,
<code>${{self}}</code> will be replaced with the same principal
information that was just expanded in the grant clause:
<b><code>javax.security.auth.x500.X500Principal
"cn=Duke"</code></b>.</li>
<li><code>${{alias:<i>alias_name</i>}}</code>
<p>The protocol, <b><code>alias</code></b>, denotes a
java.security.KeyStore alias substitution. The
<code>KeyStore</code> used is the one specified in the <a href=
"#KeyStoreEntry"><code>KeyStore</code> entry</a>. <i>alias_name</i>
represents an alias into the <code>KeyStore</code>.
<code>${{alias:<i>alias_name</i>}}</code> is replaced with
<b><code>javax.security.auth.x500.X500Principal "DN"</code></b>,
where <i><code>DN</code></i> represents the subject distinguished
name of the certificate belonging to
<i><code>alias_name</code></i>. For example:</p>
<pre class="codeblock">
keystore "http://foo.example.com/blah/.keystore";

grant codebase "www.example.com" {
    permission BarPermission "... ${{alias:duke}} ...";
};
</pre>
In the above example the X.509 certificate associated with the
alias, <i><code>duke</code></i>, is retrieved from the
<code>KeyStore</code>,
<i><code>foo.example.com/blah/.keystore</code></i>. Assuming duke's
certificate specifies "<code>o=dukeOrg, cn=duke</code>" as the
subject distinguished name, then <code>${{alias:duke}}</code> is
replaced with <b><code>javax.security.auth.x500.X500Principal
"o=dukeOrg, cn=duke"</code></b>.
<p>The permission entry is ignored under the following error
conditions:</p>
<ul>
<li>The keystore entry is unspecified</li>
<li>The <i><code>alias_name</code></i> is not provided</li>
<li>The certificate for <i><code>alias_name</code></i> can not be
retrieved</li>
<li>The certificate retrieved is not an X.509 certificate</li>
</ul>
</li>
</ol>
<h2><a name="RelatedDoc" id="RelatedDoc">Related
Documentation</a></h2>
<ul>
<li><a href="permissions.html">Permissions in the Java SE
JDK</a></li>
<li>Policy Tool (<a href="../../tools/unix/policytool.html">for Solaris, Linux, or Mac OS X</a>) (<a href= "../../tools/windows/policytool.html">for Windows</a>)</li>
</ul>
<p><!-- Body text ends here --></p>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
