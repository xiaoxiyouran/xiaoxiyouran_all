<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<link rel="stylesheet" type="text/css" href=
"../../../css/jdk_index_style.css" />
<title>Java PKI API Programmer's Guide</title>
<link rel="stylesheet" type="text/css" href="../../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>Java PKI Programmer's Guide</h1>
<div class="a1"><a href="#javasemaincontent" class="skiplink">Skip Table of Contents</a></div>
<ul>
  <li><a href="#Overview">Overview</a>
    <ul>
       <li><a href="#Who">Who Should Read This Document</a></li>
      <li><a href="#RelatedDocs">Related Documentation</a></li>
      <li><a href="#Introduction">Introduction</a></li>
    </ul>
  </li>  
  <li><a href="#CoreClasses">Core Classes and Interfaces</a>
    <ul>
      <li><a href="#CommonClasses">Basic Classes</a>
        <ul>
          <li><a href="#CertPath">The CertPath Class</a></li>
          <li><a href="#CertificateFactory">The CertificateFactory Class</a></li>
          <li><a href="#CertPathParameters">The CertPathParameters Interface</a></li>
        </ul>
      </li>
      <li><a href="#ValidationClasses">Certification Path Validation Classes</a>
        <ul>
          <li><a href="#CertPathValidator">The CertPathValidator Class</a></li>
          <li><a href="#CertPathValidatorResult">The CertPathValidatorResult Interface</a></li>
        </ul>
      </li>
      <li><a href="#BuildingClasses">Certification Path Building Classes</a>
        <ul>
          <li><a href="#CertPathBuilder">The CertPathBuilder Class</a></li>
          <li><a href="#CertPathBuilderResult">The CertPathBuilderResult Interface</a></li>
        </ul>
      </li>
      <li><a href="#StorageClasses">Certificate/CRL Storage Classes</a>
        <ul>
          <li><a href="#CertStore">The CertStore Class</a></li>
          <li><a href="#CertStoreParameters">The CertStoreParameters Interface</a>
            <ul>
              <li><a href="#LDAPCertStoreParameters">The LDAPCertStoreParameters Class</a></li>
              <li><a href="#CollectionCertStoreParameters">The CollectionCertStoreParameters Class</a></li>
            </ul>
          </li>
          <li><a href="#CertSelector">The CertSelector and CRLSelector Interfaces</a>
            <ul>
              <li><a href="#X509CertSelector">The X509CertSelector Class</a></li>
              <li><a href="#X509CRLSelector">The X509CRLSelector Class</a></li>
            </ul>
          </li>
        </ul>
      </li>
      <li><a href="#PKIXClasses">PKIX Classes</a>
        <ul>
          <li><a href="#TrustAnchor">The TrustAnchor Class</a></li>
          <li><a href="#PKIXParameters">The PKIXParameters Class</a></li>
          <li><a href="#PKIXCertPathValidatorResult">The PKIXCertPathValidatorResult Class</a></li>
          <li><a href="#PolicyNode">The PolicyNode Interface and PolicyQualifierInfo Class</a></li>
          <li><a href="#PKIXBuilderParameters">The PKIXBuilderParameters Class</a></li>
          <li><a href="#PKIXCertPathBuilderResult">The PKIXCertPathBuilderResult Class</a></li>
          <li><a href="#PKIXCertPathChecker">The PKIXCertPathChecker Class</a></li>
          <li><a href="#PKIXValidationExample">Using PKIXCertPathChecker in Certificate Path Validation</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#ServiceProvider">Implementing a Service Provider</a></li>
  <li><a href="#StS">Signature Timestamp Support</a></li>
  <li><a href="#AppA">Appendix A: Standard Names</a></li>
  <li><a href="#AppB">Appendix B: The "SUN" Provider</a></li>
  <li><a href="#AppC">Appendix C: On-Line Certificate Status Protocol (OCSP) Support</a></li>
  <li><a href="#AppD">Appendix D: Disabling Cryptographic Algorithms</a></li>
</ul>

<a name="javasemaincontent"/>

<h2><a name="Overview" id="Overview"></a>Overview</h2>
<p>The Java Certification Path
API consists of classes and interfaces for handling certification
paths (also known as "certificate chains"). A certification path is
an ordered list of certificates. If a certification path meets
certain validation rules, it may be used to securely establish the
mapping of a public key to a subject.</p>
<p>This API defines interfaces and abstract classes for creating,
building, and validating certification paths.&nbsp; Implementations
may be plugged in using a provider-based interface. The API is
based on the <a href=
"../crypto/CryptoSpec.html#ProviderArch">Cryptographic Service
Provider architecture,</a> described in the <a href=
"../crypto/CryptoSpec.html">Java Cryptography Architecture
Reference Guide</a>.</p>
<p>The API also includes algorithm-specific classes for building
and validating X.509 certification paths according to the PKIX
standards. The PKIX standards are developed by the <a href="http://datatracker.ietf.org/wg/pkix/charter/">IETF PKIX
working group</a>.</p>
<p>This API was originally specified using the <a href=
"http://jcp.org/en/home/index">Java Community
Process</a> program as
Java Specification Request
(JSR) 000055. The API was included in the Java SDK, starting with Java SE Development Kit (JDK) 1.4. Please refer to <a href="http://jcp.org/en/jsr/detail?id=55">JSR 55: Certification Path API</a> for more information on the JSR.</p>
<h3><a name="Who" id="Who"></a>Who Should Read This Document</h3>
This document is intended for two classes of experienced
developers:
<ol>
<li>
<p>those who want to design secure applications that build or
validate certification paths.</p>
</li>
<li>
<p>those who want to write a service provider implementation for
building or validating certification paths.</p>
</li>
</ol>
<h3><a name="RelatedDocs" id="RelatedDocs"></a>Related
Documentation</h3>
This document assumes you have already read the following
documents:
<ul>
<li>
<p><a href="../cert3.html">X.509 Certificates and Certificate
Revocation Lists (CRLs)</a></p>
</li>
<li>
<p><a href="../crypto/CryptoSpec.html">Java Cryptography
Architecture Reference Guide</a></p>
</li>
<li>
<p><a href="../crypto/HowToImplAProvider.html">How to Implement a
Provider for the Java Cryptography Architecture</a></p>
</li>
</ul>
<h3><a name="Introduction" id="Introduction"></a> Introduction</h3>
<p>Users of public key applications and systems must be confident
that a subject's public key is genuine, i.e., that the associated
private key is owned by the subject. Public key certificates are
used to establish this trust. A <b>public key (or identity)</b>
<b>certificate</b> is a binding of a public key to an identity,
which is digitally signed by the private key of another entity,
often called a <b>Certification Authority</b> (CA). We shall use
the term CA to refer to an entity that signs a certificate for the
remainder of this section.</p>
<p>If the user does not have a trusted copy of the public key of
the CA that signed the subject's public key certificate, then
another public key certificate vouching for the signing CA is
required. This logic can be applied recursively, until a chain of
certificates (or <b>a certification path</b>) is discovered from a
<strong>trust anchor</strong> or a
<strong>most-trusted CA</strong> to the
target subject (commonly referred to as the <b>end-entity</b>). The
<b>most-trusted CA</b> is usually specified by a certificate issued
to a CA that the user directly trusts. In general, a certification path is an
ordered list of certificates, usually comprised of the end-entity's
public key certificate and zero or more additional certificates. A
certification path typically has one or more encodings, allowing it
to be safely transmitted across networks and to different operating
system architectures.</p>
<p>The following figure illustrates a certification path from a most-trusted
CA's public key (CA 1) to the target subject (Alice). The
certification path establishes trust in Alice's public key through
an intermediate CA named CA2.</p>

<a name="certification_image"/>

<img src="cp.gif" alt="Certification path from a most-trusted
CA's public key (CA 1) to the target subject (Alice)"
name="Graphic1" align="left" width="767" height="196" border="0"
id="Graphic1" /><br clear="left" />

<p><a href="img_text/cp.html">Description of Figure Certification Path</a></p>

<p>A certification path must be validated before it can be relied
on to establish trust in a subject's public key. Validation can
consist of various checks on the certificates contained in the
certification path, such as verifying the signatures and checking
that each certificate has not been revoked. The PKIX standards
define an algorithm for validating certification paths consisting
of X.509 certificates.</p>
<p>Often a user may not have a certification path from a
most-trusted CA to the subject. Providing services to build or
discover certification paths is an important feature of public key
enabled systems. <a href="http://www.ietf.org/rfc/rfc2587.txt">RFC
2587</a> defines an LDAP (Lightweight Directory Access Protocol)
schema definition which facilitates the discovery of X.509
certification paths using the LDAP directory service protocol.</p>
<p>Building and validating certification paths is an important part
of many standard security protocols such as SSL/TLS, S/MIME, and
IPSEC. The Java Certification Path API provides a set of classes and interfaces
for developers who need to integrate this functionality into their
applications. This API benefits two types of developers: those who
need to write service provider implementations for a specific
certification path building or validation algorithm; and those who
need to access standard algorithms for creating, building, and
validating certification paths in an implementation-independent
manner.</p>
<h2><a name="CoreClasses" id="CoreClasses"></a>Core Classes and
Interfaces</h2>
<p>The core classes of the Java Certification Path API consist of
interfaces and classes that support certification path
functionality in an algorithm- and implementation -independent
manner. The API also includes a set of algorithm-specific classes
for the PKIX standards that are discussed in the section titled
<a href="#PKIXClasses">PKIX Classes</a>. The API builds on and
extends the existing <code>java.security.cert</code> package for
handling certificates. The core classes can be broken up into 4
class categories: Basic, Validation, Building, and Storage:</p>
<ul>
<li>
<p><a href="#CommonClasses">Basic Certification Path
Classes</a></p>
<ul>
<li>
<p><code>CertPath</code>, <code>CertificateFactory</code>,
<code>CertPathParameters</code></p>
</li>
</ul>
</li>
<li>
<p><a href="#ValidationClasses">Certification Path Validation
Classes</a></p>
<ul>
<li>
<p><code>CertPathValidator</code>,
<code>CertPathValidatorResult</code></p>
</li>
</ul>
</li>
<li>
<p><a href="#BuildingClasses">Certification Path Building
Classes</a></p>
<ul>
<li>
<p><code>CertPathBuilder</code>,
<code>CertPathBuilderResult</code></p>
</li>
</ul>
</li>
<li>
<p><a href="#StorageClasses">Certificate/CRL Storage
Classes</a></p>
<ul>
<li>
<p><code>CertStore</code>, <code>CertStoreParameters</code>,
<code>CertSelector</code>, <code>CRLSelector</code></p>
</li>
</ul>
</li>
</ul>
<p>The following sections describe the most commonly used methods
of each class and interface. Usage examples for some of the classes
are interspersed throughout the guide. The complete reference
documentation for the relevant Certification Path API classes can
be found in:</p>
<ul>
<li>
<p><a href=
"../../../../api/java/security/cert/package-summary.html"><tt>java.security.cert</tt>
package summary</a></p>
</li>
</ul>
<p>Most of the classes and interfaces in the CertPath API are not
thread-safe. However, there are some exceptions which will be noted
in this guide and the API specification. Multiple threads that need
to access a single non-thread-safe object concurrently should
synchronize amongst themselves and provide the necessary locking.
Multiple threads each manipulating separate objects need not
synchronize.</p>
<h3><a name="CommonClasses" id="CommonClasses"></a>Basic
Certification Path Classes</h3>
<p>The basic certification path classes provide fundamental
functionality for encoding and representing certification paths.
The key basic class in the Java Certification Path API is
<tt>CertPath</tt>, which encapsulates the universal aspects shared
by all types of certification paths. An application uses an
instance of the <tt>CertificateFactory</tt> class to create a
<tt>CertPath</tt> object.</p>
<h4><a name="CertPath" id="CertPath"></a>The CertPath Class</h4>
<p>The <tt>CertPath</tt> class is an abstract class for
certification paths. It defines the functionality shared by all
certification path objects. Various certification path types can be
implemented by subclassing the <tt>CertPath</tt> class, even though
they may have different contents and ordering schemes. All
<tt>CertPath</tt> objects are serializable, immutable and
thread-safe and share the following characteristics:</p>
<ul>
<li>
<p>A type<br />
<br />
This corresponds to the type of the certificates in the
certification path, for example: X.509. The type of a
<tt>CertPath</tt> is obtained using the method:<br />
<br /></p>
<pre class="codeblock">
    public String getType()
</pre>
<p>See Appendix A in the <a href=
"../crypto/CryptoSpec.html#AppA">Java Cryptography Architecture
Reference Guide</a> for information about standard certificate
types.<br />
<br /></p>
</li>
<li>
<p>A list of certificates<br />
<br />
The <tt>getCertificates</tt> method returns the list of
certificates in the certification path: &nbsp;<br />
<br /></p>
<pre class="codeblock">
    public abstract List&lt;? extends Certificate&gt; getCertificates()
</pre>
This method returns a <tt>List</tt> of zero or more
<tt>java.security.cert.Certificate</tt> objects. The returned
<code>List</code> and the <code>Certificates</code> contained
within it are immutable, in order to protect the contents of the
<tt>CertPath</tt> object. The ordering of the certificates returned
depends on the type. By convention, the certificates in a
<tt>CertPath</tt> object of type X.509 are ordered starting with
the target certificate and ending with a certificate issued by the
trust anchor. That is, the issuer of one certificate is the subject
of the following one. The certificate representing the
<code>TrustAnchor</code> should not be included in the
certification path. Unvalidated X.509 <tt>CertPath</tt>s may not
follow this convention. PKIX <tt><a href=
"#CertPathValidator">CertPathValidator</a></tt>s will detect any
departure from these conventions that cause the certification path
to be invalid and throw a <tt>CertPathValidatorException</tt>. 
<!-- (The next paragraph confuses readers - too many details too early.
      Perhaps mention this later in the PKIXCertPathValidatorResult section)
        <p>In addition, an X.509
        <code>CertPath</code> may not contain the most-trusted CA certificate
        used to anchor the path. However, the <code>getTrustedCert</code> method of 
        a <code><a href="#PKIXCertPathValidatorResult">PKIXCertPathValidatorResult</a></code>
        returns the most-trusted CA certificate (or <code>null</code> if not applicable)
        used by a PKIX <code>CertPathValidator</code> to anchor the path. The PKIX 
        classes are discussed more in the <A HREF="#PKIXClasses">PKIX Classes</A> 
        section.--><br />
<br /></li>
<li>
<p>One or more encodings<br />
<br />
Each <code>CertPath</code> object supports one or more encodings.
These are external encoded forms for the certification path, used
when a standard representation of the path is needed outside the
Java Virtual Machine (as when transmitting the path over a network
to some other party). Each path can be encoded in a default format,
the bytes of which are returned using the method:<br />
<br /></p>
<pre class="codeblock">
    public abstract byte[] getEncoded()
</pre>
Alternatively, the <tt>getEncoded(String)</tt> method returns a
specific supported encoding by specifying the encoding format as a
<tt>String</tt> (ex: "PKCS7"). A list of <a href="#AppA">standard
encoding formats</a> are defined in Appendix A.<br />
<br />
<pre class="codeblock">
    public abstract byte[] getEncoded(String encoding)
</pre>
Also, the <tt>getEncodings</tt> method returns an iterator over the
supported encoding format <tt>String</tt>s (the default encoding
format is returned first):<br />
<br />
<pre class="codeblock">
    public abstract Iterator&lt;String&gt; getEncodings()
</pre></li>
</ul>
<p>All <code>CertPath</code> objects are also
<code>Serializable</code>. <code>CertPath</code> objects are
resolved into an alternate <code><a href=
"../../../../api/java/security/cert/CertPath.CertPathRep.html">CertPathRep</a></code>
object during serialization. This allows a <code>CertPath</code>
object to be serialized into an equivalent representation
regardless of its underlying implementation.</p>
<p><code>CertPath</code> objects are generated from an encoded byte
array or list of <code>Certificate</code>s using a <code><a href=
"#CertificateFactory">CertificateFactory</a></code>. Alternatively,
a <code>CertPathBuilder</code> may be used to try to find a
<code>CertPath</code> from a most-trusted CA to a particular
subject. Once a <code>CertPath</code> object has been created, it
may be validated by passing it to the <code>validate</code> method
of <code>CertPathValidator</code>. Each of these concepts are
explained in more detail in subsequent sections.</p>
<h4><a name="CertificateFactory" id="CertificateFactory"></a>The
CertificateFactory Class</h4>
<p>The <tt><a href=
"../crypto/CryptoSpec.html#CertificateFactory">CertificateFactory</a></tt>
class is an <a href="../crypto/CryptoSpec.html#Engine">engine
class</a> that defines the functionality of a certificate factory.
In releases prior to JDK 1.4 it was used to generate
<code>Certificate</code> and <code>CRL</code> objects. It was
enhanced in JDK 1.4 to also be used to generate certification
path (<tt><a href="#CertPath">CertPath</a></tt>) objects. A
<tt>CertificateFactory</tt> should not be confused with a
<tt>CertPathBuilder</tt>. A <tt><a href=
"#CertPathBuilder">CertPathBuilder</a></tt> (discussed later) is
used to discover or find a certification path when one does not
exist. In contrast, a <tt>CertificateFactory</tt> is used when a
certification path has already been discovered and the caller needs
to instantiate a <tt>CertPath</tt> object from its contents which
exist in a different form such as an encoded byte array or an array
of <code>Certificate</code>s.</p>
<h5>Creating a CertificateFactory Object</h5>
<p>See the <a href=
"../crypto/CryptoSpec.html#CertificateFactory"><code>CertificateFactory</code></a>
section in the Java Cryptography Architecture Reference Guide for
details on creating a <code>CertificateFactory</code> object.</p>
<h5>Generating CertPath Objects</h5>
<p>A <tt>CertificateFactory</tt> instance generates
<tt>CertPath</tt> objects from a <code>List</code> of
<tt>Certificate</tt> objects or from an <code>InputStream</code>
that contains the encoded form of a <code>CertPath</code>. Just
like a <code>CertPath</code>, each <tt>CertificateFactory</tt>
supports a default encoding format for certification paths (ex:
PKCS#7). To generate a <code>CertPath</code> object and initialize
it with the data read from an input stream (in the default encoding
format), use the <tt>generateCertPath</tt> method:</p>
<pre class="codeblock">
    public final CertPath generateCertPath(InputStream inStream)
</pre>
<p>or from a particular encoding format:</p>
<pre class="codeblock">
    public final CertPath generateCertPath(InputStream inStream, 
                                           String encoding)
</pre>
<p>To find out what encoding formats are supported, use the
<tt>getCertPathEncodings</tt> method (the default encoding is
returned first):</p>
<pre class="codeblock">
    public final Iterator&lt;String&gt; getCertPathEncodings()
</pre>
<p>To generate a certification path object from a <tt>List</tt> of
<tt>Certificate</tt> objects, use the following method:</p>
<pre class="codeblock">
    public final CertPath generateCertPath(List&lt;? extends Certificate&gt; certificates)
</pre>
<p>A <code>CertificateFactory</code> always returns
<tt>CertPath</tt> objects that consist of <code>Certificate</code>s
that are of the same type as the factory. For example, a
<tt>CertificateFactory</tt> of type X.509 returns <tt>CertPath</tt>
objects consisting of certificates that are an instance of
<tt>java.security.cert.X509Certificate</tt>.</p>
<p>The following code sample illustrates generating a certification
path from a PKCS#7 encoded certificate reply stored in a file:</p>
<pre class="codeblock">
    // open an input stream to the file
    FileInputStream fis = new FileInputStream(filename);
    // instantiate a CertificateFactory for X.509
    CertificateFactory cf = CertificateFactory.getInstance("X.509");
    // extract the certification path from
    // the PKCS7 SignedData structure
    CertPath cp = cf.generateCertPath(fis, "PKCS7");
    // print each certificate in the path
    List&lt;Certificate&gt; certs = cp.getCertificates();
    for (Certificate cert : certs) {
        System.out.println(cert);
    }
        
</pre>
Here's another code sample that fetches a certificate chain from a
<code>KeyStore</code> and converts it to a <code>CertPath</code>
using a <code>CertificateFactory</code>:
<pre class="codeblock">
    // instantiate a KeyStore with type JKS
    KeyStore ks = KeyStore.getInstance("JKS");
    // load the contents of the KeyStore
    ks.load(new FileInputStream("./keystore"),
        "password".toCharArray());
    // fetch certificate chain stored with alias "sean"
    Certificate[] certArray = ks.getCertificateChain("sean");
    // convert chain to a List
    List certList = Arrays.asList(certArray);
    // instantiate a CertificateFactory for X.509
    CertificateFactory cf = CertificateFactory.getInstance("X.509");
    // extract the certification path from
    // the List of Certificates
    CertPath cp = cf.generateCertPath(certList);
        
</pre>
<p style="margin-left: 0.47in">Note that there is an existing
method in <code>CertificateFactory</code> named
<code>generateCertificates</code> that parses a sequence of
<code>Certificate</code>s. For encodings consisting of multiple
certificates, use <code>generateCertificates</code> when you want
to parse a collection of possibly unrelated certificates.
Otherwise, use <code>generateCertPath</code> when you want to
generate a <code>CertPath</code> and subsequently validate it with
a <code>CertPathValidator</code> (discussed later).</p>
<h4><a name="CertPathParameters" id="CertPathParameters"></a>The
CertPathParameters Interface</h4>
<p>The <tt>CertPathParameters</tt> interface is a transparent
representation of the set of parameters used with a particular
certification path builder or validation algorithm. Its main
purpose is to group (and provide type safety for) all certification
path parameter specifications. The <code>CertPathParameters</code>
interface extends the <code>Cloneable</code> interface and defines
a <code>clone()</code> method that does not throw an exception. All
concrete implementations of this interface should implement and
override the <code>Object.clone()</code> method, if necessary. This
allows applications to clone any <code>CertPathParameters</code>
object.</p>
<p>Objects implementing the <tt>CertPathParameters</tt> interface
are passed as arguments to methods of the <tt><a href=
"#CertPathValidator">CertPathValidator</a></tt> and <tt><a href=
"#CertPathBuilder">CertPathBuilder</a></tt> classes. Typically, a
concrete implementation of the <code>CertPathParameters</code>
interface will hold a set of input parameters specific to a
particular certification path build or validation algorithm. For
example, the <code>PKIXParameters</code> class is an implementation
of the <code>CertPathParameters</code> interface that holds a set
of input parameters for the PKIX certification path validation
algorithm. One such parameter is the set of most-trusted CAs that
the caller trusts for anchoring the validation process. This
parameter among others is discussed in more detail in the section
discussing the <code><a href=
"#PKIXParameters">PKIXParameters</a></code> class.</p>
<h3><a name="ValidationClasses" id=
"ValidationClasses"></a>Certification Path Validation Classes</h3>
<p>The Java Certification Path API includes classes and interfaces
for validating certification paths. An application uses an instance
of the <tt>CertPathValidator</tt> class to validate a
<tt>CertPath</tt> object. If successful, the result of the
validation algorithm is returned in an object implementing the
<tt>CertPathValidatorResult</tt> interface.</p>
<h4><a name="CertPathValidator" id="CertPathValidator"></a> The
CertPathValidator Class</h4>
<p>The <tt>CertPathValidator</tt> class is an <a href=
"../crypto/CryptoSpec.html#Engine">engine class</a> used to
validate a certification path.</p>
<h5>Creating a CertPathValidator Object</h5>
<p>As with all engine classes, the way to get a
<tt>CertPathValidator</tt> object for a particular validation
algorithm is to call one of the <tt>getInstance</tt> static factory
methods on the <tt>CertPathValidator</tt> class:</p>
<pre class="codeblock">
        public static CertPathValidator getInstance(String algorithm)
        public static CertPathValidator getInstance(String algorithm, 
                                                    String provider)
        public static CertPathValidator getInstance(String algorithm, 
                                                    Provider provider)
</pre>
The <code>algorithm</code> parameter is the name of a certification
path validation algorithm (for example, "PKIX"). Standard
<code>CertPathValidator</code> algorithm names are listed in
<a href="#AppA">Appendix A</a>.
<h5>Validating a Certification Path</h5>
<p>Once a <tt>CertPathValidator</tt> object is created, paths can
be validated by calling the <tt>validate</tt> method, passing it
the certification path to be validated and a set of
algorithm-specific parameters:</p>
<pre class="codeblock">
        public final CertPathValidatorResult 
                validate(CertPath certPath, CertPathParameters params)
                throws CertPathValidatorException, 
                       InvalidAlgorithmParameterException
</pre>
<p>If the validation algorithm is successful, the result is
returned in an object implementing the <tt><a href=
"#CertPathValidatorResult">CertPathValidatorResult</a></tt>
interface. Otherwise, a <tt>CertPathValidatorException</tt> is
thrown. The <tt>CertPathValidatorException</tt> contains methods
that return the <tt>CertPath</tt>, and if relevant, the index of
the certificate that caused the algorithm to fail and the root
exception or cause of the failure.</p>
<p>Note that the <tt>CertPath</tt> and
<code>CertPathParameters</code> passed to the <tt>validate</tt>
method must be of a type that is supported by the validation
algorithm. Otherwise, an
<code>InvalidAlgorithmParameterException</code> is thrown. For
example, a <tt>CertPathValidator</tt> instance that implements the
PKIX algorithm validates <tt>CertPath</tt> objects of type X.509
and <code>CertPathParameters</code> that are an instance of
<code>PKIXParameters</code>.</p>
<h3><a name="CertPathValidatorResult" id=
"CertPathValidatorResult"></a> The CertPathValidatorResult
Interface</h3>
<p>The <tt>CertPathValidatorResult</tt> interface is a transparent
representation of the successful result or output of a
certification path validation algorithm. Its main purpose is to
group (and provide type safety for) all validation results. Like
the <code>CertPathParameters</code> interface,
<code>CertPathValidatorResult</code> extends <code>Cloneable</code>
and defines a <code>clone()</code> method that does not throw an
exception. This allows applications to clone any
<code>CertPathValidatorResult</code> object.</p>
<p>Objects implementing the <tt>CertPathValidatorResult</tt>
interface are returned by the <tt>validate</tt> method of
<tt><a href="#CertPathValidator">CertPathValidator</a></tt> (only
when successful; otherwise a
<code>CertPathValidatorException</code> is thrown with a
description of the failure). Typically, a concrete implementation
of the <code>CertPathValidatorResult</code> interface will hold a
set of output parameters specific to a particular certification
path validation algorithm. For example, the
<code>PKIXCertPathValidatorResult</code> class is an implementation
of the <code>CertPathValidatorResult</code> interface which
contains methods to get the output parameters of the PKIX
certification path validation algorithm. One such parameter is the
valid policy tree. This parameter among others is discussed in more
detail in the section discussing the <code><a href=
"#PKIXCertPathValidatorResult">PKIXCertPathValidatorResult</a></code>
class.</p>
<p>Here's a simplified code sample that illustrates how to create a
<code>CertPathValidator</code> and use it to validate a
certification path. The sample assumes that the
<code>CertPath</code> and <code>CertPathParameters</code> objects
which are passed to the <code>validate</code> method have been
previously created; a more complete example will be illustrated in
the section describing the PKIX classes.</p>
<pre class="codeblock">
    // create CertPathValidator that implements the "PKIX" algorithm
    CertPathValidator cpv = null;
    try {
        cpv = CertPathValidator.getInstance("PKIX");
    } catch (NoSuchAlgorithmException nsae) {
        System.err.println(nsae);
        System.exit(1);
    }
    // validate certification path ("cp") with specified parameters ("params")
    try {
        CertPathValidatorResult cpvResult = cpv.validate(cp, params);
    } catch (InvalidAlgorithmParameterException iape) {
        System.err.println("validation failed: " + iape);
        System.exit(1);
    } catch (CertPathValidatorException cpve) {
        System.err.println("validation failed: " + cpve);
        System.err.println("index of certificate that caused exception: "
                + cpve.getIndex());
        System.exit(1);
    }
</pre>
<h3><a name="BuildingClasses" id=
"BuildingClasses"></a>Certification Path Building Classes</h3>
<p>The Java Certification Path API includes classes for building
(or discovering) certification paths. An application uses an
instance of the <tt>CertPathBuilder</tt> class to build a
<tt>CertPath</tt> object. If successful, the result of the build is
returned in an object implementing the
<tt>CertPathBuilderResult</tt> interface.</p>
<h4><a name="CertPathBuilder" id="CertPathBuilder"></a> The
CertPathBuilder Class</h4>
<p>The <tt>CertPathBuilder</tt> class is an <a href=
"../crypto/CryptoSpec.html#Engine">engine class</a> used to build a
certification path.</p>
<h5>Creating a CertPathBuilder Object</h5>
<p>As with all engine classes, the way to get a
<tt>CertPathBuilder</tt> object for a particular build algorithm is
to call one of the <tt>getInstance</tt> static factory method on
the <tt>CertPathBuilder</tt> class:</p>
<pre class="codeblock">
        public static CertPathBuilder getInstance(String algorithm)
        public static CertPathBuilder getInstance(String algorithm, 
                                                  String provider)
        public static CertPathBuilder getInstance(String algorithm, 
                                                  Provider provider)
</pre>
The <code>algorithm</code> parameter is the name of a certification
path builder algorithm (for example, "PKIX"). Standard
<code>CertPathBuilder</code> algorithm names are listed in <a href=
"#AppA">Appendix A</a>.
<h5>Building a Certification Path</h5>
<p>Once a <tt>CertPathBuilder</tt> object is created, paths can be
constructed by calling the <tt>build</tt> method, passing it an
algorithm-specific parameter specification:</p>
<pre class="codeblock">
        public final CertPathBuilderResult build(CertPathParameters params)
                throws CertPathBuilderException, 
                       InvalidAlgorithmParameterException
</pre>
<p>If the build algorithm is successful, the result is returned in
an object implementing the <tt><a href=
"#CertPathBuilderResult">CertPathBuilderResult</a></tt> interface.
Otherwise, a <tt>CertPathBuilderException</tt> is thrown containing
information about the failure; for example, the underlying
exception (if any) and an error message.</p>
<p>Note that the <code>CertPathParameters</code> passed to the
<tt>build</tt> method must be of a type that is supported by the
build algorithm. Otherwise, an
<code>InvalidAlgorithmParameterException</code> is thrown.</p>
<h4><a name="CertPathBuilderResult" id="CertPathBuilderResult"></a>
The CertPathBuilderResult Interface</h4>
<p>The <tt>CertPathBuilderResult</tt> interface is a transparent
representation of the result or output of a certification path
builder algorithm. This interface contains a method to return the
certification path that has been successfully built:</p>
<pre class="codeblock">
        public CertPath getCertPath()
</pre>
<p>The purpose of the <tt>CertPathBuilderResult</tt> interface is
to group (and provide type safety for) all build results. Like the
<code>CertPathValidatorResult</code> interface,
<code>CertPathBuilderResult</code> extends <code>Cloneable</code>
and defines a <code>clone()</code> method that does not throw an
exception. This allows applications to clone any
<code>CertPathBuilderResult</code> object.</p>
<p>Objects implementing the <tt>CertPathBuilderResult</tt>
interface are returned by the <tt>build</tt> method of <tt><a href=
"#CertPathBuilder">CertPathBuilder</a></tt>.</p>
<p>Here's a simplified code sample that illustrates how to create a
<code>CertPathBuilder</code> and use it to build a certification
path. The sample assumes that the <code>CertPathParameters</code>
object which is passed to the <code>build</code> method has been
previously created; a more complete example will be illustrated in
the section describing the PKIX classes.</p>
<pre class="codeblock">
    // create CertPathBuilder that implements the "PKIX" algorithm
    CertPathBuilder cpb = null;
    try {
        cpb = CertPathBuilder.getInstance("PKIX");
    } catch (NoSuchAlgorithmException nsae) {
        System.err.println(nsae);
        System.exit(1);
    }
    // build certification path using specified parameters ("params")
    try {
        CertPathBuilderResult cpbResult = cpb.build(params);
        CertPath cp = cpbResult.getCertPath();
        System.out.println("build passed, path contents: " + cp);
    } catch (InvalidAlgorithmParameterException iape) {
        System.err.println("build failed: " + iape);
        System.exit(1);
    } catch (CertPathBuilderException cpbe) {
        System.err.println("build failed: " + cpbe);
        System.exit(1);
    }
</pre>
<h3><a name="StorageClasses" id=
"StorageClasses"></a>Certificate/CRL Storage Classes</h3>
<p>The Java Certification Path API also includes the
<code>CertStore</code> class for retrieving certificates and CRLs
from a repository. This is useful because it allows a caller to
specify the repository a <tt>CertPathValidator</tt> or
<tt>CertPathBuilder</tt> implementation should use to find
certificates and CRLs (see the <tt>addCertStores</tt> method of
<tt><a href="#PKIXParameters">PKIXParameters</a></tt> for an
example).</p>
<p>A <tt>CertPathValidator</tt> implementation may use the
<tt>CertStore</tt> object that the caller specifies as a callback
mechanism to fetch CRLs for performing revocation checks.
Similarly, a <code>CertPathBuilder</code> may use the
<code>CertStore</code> as a callback mechanism to fetch
certificates and, if performing revocation checks, CRLs.</p>
<h4><a name="CertStore" id="CertStore"></a> The CertStore
Class</h4>
<p>The <tt>CertStore</tt> class is an <a href=
"../crypto/CryptoSpec.html#Engine">engine class</a> used to provide
the functionality of a certificate and certificate revocation list
(CRL) repository. It can be used by <tt><a href=
"#CertPathBuilder">CertPathBuilder</a></tt> and <tt><a href=
"#CertPathValidator">CertPathValidator</a></tt> implementations to
find certificates and CRLs or as a general purpose certificate and
CRL retrieval mechanism.</p>
<p>Unlike the <code>java.security.KeyStore</code> class, which
provides access to a cache of private keys and trusted
certificates, a <code>CertStore</code> is designed to provide
access to a potentially vast repository of untrusted certificates
and CRLs. For example, an LDAP implementation of
<code>CertStore</code> provides access to certificates and CRLs
stored in one or more directories using the LDAP protocol.</p>
<p>All public methods of CertStore objects are thread-safe. That
is, multiple threads may concurrently invoke these methods on a
single <code>CertStore</code> object (or more than one) with no ill
effects. This allows a <code>CertPathBuilder</code> to search for a
CRL while simultaneously searching for further certificates, for
instance.</p>
<h5>Creating a CertStore Object</h5>
<p>As with all engine classes, the way to get a <tt>CertStore</tt>
object for a particular repository type is to call one of the
<tt>getInstance</tt> static factory methods on the
<tt>CertStore</tt> class:</p>
<pre class="codeblock">
        public static CertStore getInstance(String type, 
                CertStoreParameters params)
        public static CertStore getInstance(String type,
                CertStoreParameters params, String provider)
        public static CertStore getInstance(String type,
                CertStoreParameters params, Provider provider)
</pre>
The <code>type</code> parameter is the name of a certificate
repository type (for example, "LDAP"). Standard
<code>CertStore</code> types are listed in <a href="#AppA">Appendix
A</a>.
<p>The initialization parameters (<code>params</code>) are specific
to the repository type. For example, the initialization parameters
for a server-based repository may include the hostname and the port
of the server. An <code>InvalidAlgorithmParameterException</code>
is thrown if the parameters are invalid for this
<code>CertStore</code> type. The
<code>getCertStoreParameters</code> method returns the
<code>CertStoreParameters</code> that were used to initialize a
<code>CertStore</code>:</p>
<pre class="codeblock">
        public final CertStoreParameters getCertStoreParameters()
</pre>
<h5>Retrieving Certificates</h5>
<p>Once you have created a <tt>CertStore</tt> object, you can
retrieve certificates from the repository using the
<tt>getCertificates</tt> method. This method takes a <tt><a href=
"#CertSelector">CertSelector</a></tt> (discussed in more detail
later) object as an argument, which specifies a set of selection
criteria for determining which certificates should be returned:</p>
<pre class="codeblock">
        public final Collection&lt;? extends Certificate&gt; getCertificates(CertSelector selector) 
                throws CertStoreException
</pre>
<p>This method returns a <tt>Collection</tt> of
<tt>java.security.cert.Certificate</tt> objects that satisfy the
selection criteria. An empty <tt>Collection</tt> is returned if
there are no matches. A <code>CertStoreException</code> is usually
thrown if an unexpected error condition is encountered, such as a
communications failure with a remote repository.</p>
<p>For some <tt>CertStore</tt> implementations, it may not be
feasible to search the entire repository for certificates or CRLs
that match the specified selection criteria. In these instances,
the <tt>CertStore</tt> implementation may use information that is
specified in the selectors to locate certificates and CRLs. For
instance, an LDAP <tt>CertStore</tt> may not search all entries in
the directory. Instead, it may just search entries that are likely
to contain the certificates it is looking for. If the
<tt>CertSelector</tt> provided does not provide enough information
for the LDAP <tt>CertStore</tt> to determine which entries it
should look in, the LDAP <tt>CertStore</tt> may throw a
<tt>CertStoreException</tt>.</p>
<h5>Retrieving CRLs</h5>
<p>You can also retrieve CRLs from the repository using the
<tt>getCRLs</tt> method. This method takes a <tt><a href=
"#CertSelector">CRLSelector</a></tt> (discussed in more detail
later) object as an argument, which specifies a set of selection
criteria for determining which CRLs should be returned:</p>
<pre class="codeblock">
        public final Collection&lt;? extends CRL&gt; getCRLs(CRLSelector selector) 
                throws CertStoreException
</pre>
<p>This method returns a <tt>Collection</tt> of
<tt>java.security.cert.CRL</tt> objects that satisfy the selection
criteria. An empty <tt>Collection</tt> is returned if there are no
matches.</p>
<h4><a name="CertStoreParameters" id="CertStoreParameters"></a> The
CertStoreParameters Interface</h4>
<p>The <tt>CertStoreParameters</tt> interface is a transparent
representation of the set of parameters used with a particular
<code>CertStore</code>. Its main purpose is to group (and provide
type safety for) all certificate storage parameter specifications.
The <code>CertStoreParameters</code> interface extends the
<code>Cloneable</code> interface and defines a <code>clone</code>
method that does not throw an exception. Implementations of this
interface should implement and override the
<code>Object.clone()</code> method, if necessary. This allows
applications to clone any <code>CertStoreParameters</code>
object.</p>
<p>Objects implementing the <tt>CertStoreParameters</tt> interface
are passed as arguments to the <tt>getInstance</tt> method of the
<tt>CertStore</tt> class. Two classes implementing the
<tt>CertStoreParameters</tt> interface are defined in this API: the
<tt><a href=
"#LDAPCertStoreParameters">LDAPCertStoreParameters</a></tt> and the
<tt><a href=
"#CollectionCertStoreParameters">CollectionCertStoreParameters</a></tt>
classes.</p>
<h5><a name="LDAPCertStoreParameters" id=
"LDAPCertStoreParameters"></a> The LDAPCertStoreParameters
Class</h5>
<p>The <tt>LDAPCertStoreParameters</tt> class is an implementation
of the <tt>CertStoreParameters</tt> interface and holds a set of
minimal initialization parameters (host and port number of the
directory server) for retrieving certificates and CRLs from a
<code>CertStore</code> of type <b>LDAP</b>.</p>
<p>Please refer to the <tt><a href=
"../../../../api/java/security/cert/LDAPCertStoreParameters.html">
LDAPCertStoreParameters</a></tt>
API documentation for more detailed information on this class.</p>
<h5><a name="CollectionCertStoreParameters" id=
"CollectionCertStoreParameters"></a> The
CollectionCertStoreParameters Class</h5>
<p>The <tt>CollectionCertStoreParameters</tt> class is an
implementation of the <tt>CertStoreParameters</tt> interface and
holds a set of initialization parameters for retrieving
certificates and CRLs from a <code>CertStore</code> of type
<b>Collection</b>.</p>
<p>Please refer to the <tt><a href=
"../../../../api/java/security/cert/CollectionCertStoreParameters.html">
CollectionCertStoreParameters</a></tt>
API documentation for more detailed information on this class.</p>
<h4><a name="CertSelector" id="CertSelector"></a> The CertSelector
and CRLSelector Interfaces</h4>
<p>The <tt>CertSelector</tt> and <tt>CRLSelector</tt> interfaces
are a specification of the set of criteria for selecting
certificates and CRLs from a collection or large group of
certificates and CRLs. The interfaces group and provide type safety
for all selector specifications. Each selector interface extends
<code>Cloneable</code> and defines a <code>clone()</code> method
that does not throw an exception. This allows applications to clone
any <code>CertSelector</code> or <code>CRLSelector</code>
object.</p>
<p>The <tt>CertSelector</tt> and <tt>CRLSelector</tt> interfaces
each define a method named <tt>match</tt>. The <tt>match</tt>
method takes a <tt>Certificate</tt> or <tt>CRL</tt> object as an
argument and returns <tt>true</tt> if the object satisfies the
selection criteria. Otherwise, it returns <tt>false</tt>. The
<tt>match</tt> method for the <tt>CertSelector</tt> interface is
defined as follows:</p>
<pre class="codeblock">
        public boolean match(Certificate cert)
</pre>
<p>and for the <tt>CRLSelector</tt> interface:</p>
<pre class="codeblock">
        public boolean match(CRL crl)
</pre>
<p>Typically, objects implementing these interfaces are passed as
parameters to the <code>getCertificates</code> and
<code>getCRLs</code> methods of the <code>CertStore</code> class.
These methods return a <code>Collection</code> of
<code>Certificate</code>s or <code>CRL</code>s from the
<code>CertStore</code> repository that match the specified
selection criteria. <code>CertSelector</code>s may also be used to
specify the validation constraints on a target or end-entity
certificate in a certification path (see for example, the <code>
<!-- <a href=" "../../../../api/java/security/cert/PKIXParameters.html#setTargetCertConstraints-java.security.cert.CertSelector-"> -->PKIXParameters.setTargetCertConstraints</code>
<!-- </a> -->
 method.</p>
<h5><a name="X509CertSelector" id="X509CertSelector"></a> The
X509CertSelector Class</h5>
<p>The <tt>X509CertSelector</tt> class is an implementation of the
<tt>CertSelector</tt> interface that defines a set of criteria for
selecting X.509 certificates. An <tt>X509Certificate</tt> object
must match <i>all</i> of the specified criteria to be selected by
the <tt>match</tt> method. The selection criteria are designed to
be used by a <tt>CertPathBuilder</tt> implementation to discover
potential certificates as it builds an X.509 certification
path.</p>
<p>For example, the <code>setSubject</code> method of
<code>X509CertSelector</code> allows a PKIX
<code>CertPathBuilder</code> to filter out
<code>X509Certificate</code>s that do not match the issuer name of
the preceding <code>X509Certificate</code> in a partially completed
chain. By setting this and other criteria in an
<code>X509CertSelector</code> object, a
<code>CertPathBuilder</code> is able to discard irrelevant
certificates and more easily find an X.509 certification path that
meets the requirements specified in the
<code>CertPathParameters</code> object.</p>
<p>Please refer to <a href=
"http://www.ietf.org/rfc/rfc3280.txt">http://www.ietf.org/rfc/rfc3280.txt</a>
for definitions of the X.509 certificate extensions mentioned in
this section.</p>
<h6>Creating an X509CertSelector Object</h6>
<p>An <tt>X509CertSelector</tt> object is created by calling the
default constructor:</p>
<pre class="codeblock">
        public X509CertSelector()
</pre>
<p>No criteria are initially set (any <code>X509Certificate</code>
will match).</p>
<h6>Setting Selection Criteria</h6>
<p>The selection criteria allow a caller to match on different
components of an X.509 certificate. A few of the methods for
setting selection criteria are described here. Please refer to the
<tt><a href=
"../../../../api/java/security/cert/X509CertSelector.html">
X509CertSelector</a></tt> API
documentation for details on the other methods.</p>
<p>The <tt>setIssuer</tt> methods set the issuer criterion:</p>
<pre class="codeblock">
        public void setIssuer(X500Principal issuer)
        public void setIssuer(String issuerDN)
        public void setIssuer(byte[] issuerDN)
</pre>
<p>The specified distinguished name (in <code>X500Principal</code>,
<a href="http://www.ietf.org/rfc/rfc2253.txt">RFC 2253</a> String
or ASN.1 DER encoded form) must match the issuer distinguished name
in the certificate. If null, any issuer distinguished name will do.
Note that use of an <code>X500Principal</code> to represent a
distinguished name is preferred because it is more efficient and
suitably typed.</p>
<p>Similarly, the <tt>setSubject</tt> methods set the subject
criterion:</p>
<pre class="codeblock">
        public void setSubject(X500Principal subject)
        public void setSubject(String subjectDN)
        public void setSubject(byte[] subjectDN)
</pre>
<p>The specified distinguished name (in <code>X500Principal</code>,
RFC 2253 String or ASN.1 DER encoded form) must match the subject
distinguished name in the certificate. If null, any subject
distinguished name will do.</p>
<p>The <tt>setSerialNumber</tt> method sets the serialNumber
criterion:</p>
<pre class="codeblock">
        public void setSerialNumber(BigInteger serial)
</pre>
<p>The specified serial number must match the certificate serial
number in the certificate. If null, any certificate serial number
will do.</p>
<p>The <tt>setAuthorityKeyIdentifier</tt> method sets the
authorityKeyIdentifier criterion:</p>
<pre class="codeblock">
        public void setAuthorityKeyIdentifier(byte[] authorityKeyID)
</pre>
<p>The certificate must contain an Authority Key Identifier
extension matching the specified value. If null, no check will be
done on the authorityKeyIdentifier criterion.</p>
<p>The <tt>setCertificateValid</tt> method sets the
certificateValid criterion:</p>
<pre class="codeblock">
        public void setCertificateValid(Date certValid)
</pre>
<p>The specified date must fall within the certificate validity
period for the certificate. If null, any date is valid.</p>
<p>The <tt>setKeyUsage</tt> method sets the keyUsage criterion:</p>
<pre class="codeblock">
        public void setKeyUsage(boolean[] keyUsage)
</pre>
<p>The certificate's Key Usage Extension must allow the specified
key usage values (those which are set to true). If null, no
keyUsage check will be done.</p>
<h6>Getting Selection Criteria</h6>
<p>The current values for each of the selection criteria can be
retrieved using an appropriate <tt>get</tt> method. Please refer to
the <tt><a href=
"../../../../api/java/security/cert/X509CertSelector.html">
X509CertSelector</a></tt> API
documentation for further details on these methods.</p>
<h6>Example</h6>
<p>Here is an example of retrieving X.509 certificates from an LDAP
<tt>CertStore</tt> with the <tt>X509CertSelector</tt> class.</p>
<p>First, we create the <code>LDAPCertStoreParameters</code> object
that we will use to initialize the <code>CertStore</code> object
with the hostname and port of the LDAP server:</p>
<pre class="codeblock">
        LDAPCertStoreParameters lcsp = new 
                LDAPCertStoreParameters("ldap.sun.com", 389);
</pre>
<p>Next, create the <tt><a href="#CertStore">CertStore</a></tt>
object, and pass it the <code>LDAPCertStoreParameters</code>
object, as in the following statement:</p>
<pre class="codeblock">
        CertStore cs = CertStore.getInstance("LDAP", lcsp);
</pre>
<p>This call creates a <tt>CertStore</tt> object that retrieves
certificates and CRLs from an LDAP repository using the schema
defined in RFC 2587.</p>
<p>The following block of code establishes an
<code>X509CertSelector</code> to retrieve all unexpired (as of the
current date and time) end-entity certificates issued to a
particular subject with 1) a key usage that allows digital
signatures, and 2) a subject alternative name with a specific email
address:</p>
<pre class="codeblock">
        X509CertSelector xcs = new X509CertSelector();
        // select only unexpired certificates
        xcs.setCertificateValid(new Date());
        // select only certificates issued to
        // 'CN=alice, O=xyz, C=us'
        xcs.setSubject(new X500Principal("CN=alice, O=xyz, C=us"));
        // select only end-entity certificates
        xcs.setBasicConstraints(-2);
        // select only certificates with a digitalSignature
        // keyUsage bit set (set the first entry in the
        // boolean array to true)
        boolean[] keyUsage = {true};
        xcs.setKeyUsage(keyUsage);
        // select only certificates with a subjectAltName of
        // 'alice@xyz.example.com' (1 is the integer value of 
        // an RFC822Name)
        xcs.addSubjectAlternativeName(1, "alice@xyz.example.com");
</pre>
<p>Then we pass the selector to the <tt>getCertificates</tt> method
of our <tt>CertStore</tt> object that we previously created:</p>
<pre class="codeblock">
        Collection&lt;Certificate&gt; certs = cs.getCertificates(xcs);
</pre>
<p>A PKIX <code>CertPathBuilder</code> may use similar code to help
discover and sort through potential certificates by discarding
those that do not meet validation constraints or other
criteria.</p>
<h5><a name="X509CRLSelector" id="X509CRLSelector"></a> The
X509CRLSelector Class</h5>
<p>The <tt>X509CRLSelector</tt> class is an implementation of the
<tt>CRLSelector</tt> interface that defines a set of criteria for
selecting X.509 CRLs. An <tt>X509CRL</tt> object must match
<i>all</i> of the specified criteria to be selected by the
<tt>match</tt> method. The selection criteria are designed to be
useful to a <tt>CertPathValidator</tt> or <tt>CertPathBuilder</tt>
implementation that must retrieve CRLs from a repository to check
the revocation status of certificates in an X.509 certification
path.</p>
<p>For example, the <code>setDateAndTime</code> method of
<code>X509CRLSelector</code> allows a PKIX
<code>CertPathValidator</code> to filter out <code>X509CRL</code>s
that have been issued after or expire before the time indicated. By
setting this and other criteria in an <code>X509CRLSelector</code>
object, it allows the <code>CertPathValidator</code> to discard
irrelevant CRLs and more easily check if a certificate has been
revoked.</p>
<p>Please refer to <a href=
"http://www.ietf.org/rfc/rfc3280.txt">http://www.ietf.org/rfc/rfc3280.txt</a>
for definitions of the X.509 CRL fields and extensions mentioned in
this section.</p>
<h6>Creating an X509CRLSelector Object</h6>
<p>An <tt>X509CRLSelector</tt> object is created by calling the
default constructor:</p>
<pre class="codeblock">
        public X509CRLSelector()
</pre>
<p>No criteria are initially set (any <code>X509CRL</code> will
match).</p>
<h6>Setting Selection Criteria</h6>
<p>The selection criteria allow a caller to match on different
components of an X.509 CRL. Most of the methods for setting
selection criteria are described here. Please refer to the
<tt><a href=
"../../../../api/java/security/cert/X509CRLSelector.html">
X509CRLSelector</a></tt> API
documentation for details on the remaining methods.</p>
<p>The <code>setIssuers</code> and <tt>setIssuerNames</tt> methods
set the issuerNames criterion:</p>
<pre class="codeblock">
        public void setIssuers(Collection&lt;X500Principal&gt; issuers)
        public void setIssuerNames(Collection&lt;?&gt; names)
</pre>
<p>The issuer distinguished name in the CRL must match at least one
of the specified distinguished names. The <code>setIssuers</code>
method is preferred as the use of <code>X500Principal</code>s to
represent distinguished names is more efficient and suitably typed.
For the <code>setIssuerNames</code> method, each entry of the
<tt>names</tt> argument is either a <tt>String</tt> or a byte array
(representing the name, in RFC 2253 or ASN.1 DER encoded form,
respectively). If null, any issuer distinguished name will do.</p>
<p>The <tt>setMinCRLNumber</tt> and <tt>setMaxCRLNumber</tt>
methods set the minCRLNumber and maxCRLNumber criterion:</p>
<pre class="codeblock">
        public void setMinCRLNumber(BigInteger minCRL)
        public void setMaxCRLNumber(BigInteger maxCRL)
</pre>
<p>The CRL must have a CRL Number extension whose value is greater
than or equal to the specified value if the
<tt>setMinCRLNumber</tt> method is called, and less than or equal
to the specified value if the <tt>setMaxCRLNumber</tt> method is
called. If the value passed to one of these methods is null, the
corresponding check is not done.</p>
<p>The <tt>setDateAndTime</tt> method sets the dateAndTime
criterion:</p>
<pre class="codeblock">
        public void setDateAndTime(Date dateAndTime)
</pre>
<p>The specified date must be equal to or later than the value of
the thisUpdate component of the CRL and earlier than the value of
the nextUpdate component. If null, no dateAndTime check will be
done.</p>
<p>The <tt>setCertificateChecking</tt> method sets the certificate
whose revocation status is being checked:</p>
<pre class="codeblock">
        public void setCertificateChecking(X509Certificate cert)
</pre>
<p>This is not a criterion. Rather, it is optional information that
may help a <code>CertStore</code> find CRLs that would be relevant
when checking revocation for the specified certificate. If null is
specified, then no such optional information is provided. An
application should always call this method when checking revocation
for a particular certificate, as it may provide the
<code>CertStore</code> with more information for finding the
correct CRLs and filtering out irrelevant ones.</p>
<h6>Getting Selection Criteria</h6>
<p>The current values for each of the selection criteria can be
retrieved using an appropriate <tt>get</tt> method. Please refer to
the <tt><a href=
"../../../../api/java/security/cert/X509CRLSelector.html">
X509CRLSelector</a></tt>API
documentation for further details on these methods.</p>
<h6>Example</h6>
<p>Creating an <tt>X509CRLSelector</tt> to retrieve CRLs from an
LDAP repository is similar to the <tt>X509CertSelector</tt>
example. Suppose we want to retrieve all current (as of the current
date and time) CRLs issued by a specific CA and with a minimum CRL
number. First, we create an <tt><a href=
"#X509CRLSelector">X509CRLSelector</a></tt> object and call the
appropriate methods to set the selection criteria:</p>
<pre class="codeblock">
        X509CRLSelector xcrls = new X509CRLSelector();
        // select CRLs satisfying current date and time
        xcrls.setDateAndTime(new Date());
        // select CRLs issued by 'O=xyz, C=us'
        xcrls.addIssuerName("O=xyz, C=us");
        // select only CRLs with a CRL number at least '2'
        xcrls.setMinCRLNumber(new BigInteger("2"));
</pre>
<p>Then we pass the selector to the <tt>getCRLs</tt> method of our
<tt>CertStore</tt> object (created in the <tt>X509CertSelector</tt>
example):</p>
<pre class="codeblock">
        Collection&lt;CRL&gt; crls = cs.getCRLs(xcrls);
</pre>
<h3><a name="PKIXClasses" id="PKIXClasses"></a>PKIX Classes</h3>
<p>The Java Certification Path API also includes a set of
algorithm-specific classes modeled for use with the PKIX
certification path validation algorithm defined in <a href=
"http://www.ietf.org/rfc/rfc3280.txt">RFC 3280</a>: <i>Public Key
Infrastructure Certificate and Certificate Revocation List (CRL)
Profile</i>.</p>
<h4><a name="TrustAnchor" id="TrustAnchor"></a>The TrustAnchor
Class</h4>
<p>This class represents a "most-trusted CA", which is used as a
trust anchor for validating X.509 certification paths. A
most-trusted CA includes the public key of the CA, the CA's name,
and any constraints upon the set of paths which may be validated
using this key. These parameters can be specified in the form of a
trusted <code>X509Certificate</code> or as individual
parameters.</p>
<p>All <code>TrustAnchor</code> objects are immutable and
thread-safe. That is, multiple threads may concurrently invoke the
methods defined in this class on a single <code>TrustAnchor</code>
object (or more than one) with no ill effects. Requiring
<code>TrustAnchor</code> objects to be immutable and thread-safe
allows them to be passed around to various pieces of code without
worrying about coordinating access.</p>
<p>Note that although this class is described as a PKIX class it
may be used with other X.509 certification path validation
algorithms.</p>
<h5>Creating a TrustAnchor Object</h5>
<p>To instantiate a <code>TrustAnchor</code> object, a caller must
specify "the most-trusted CA" as a trusted
<code>X509Certificate</code> or public key and distinguished name
pair. The caller may also optionally specify name constraints that
are applied to the trust anchor by the validation algorithm during
initialization. Note that support for name constraints on trust
anchors is not required by the PKIX algorithm, therefore a PKIX
<code>CertPathValidator</code> or <code>CertPathBuilder</code> may
choose not to support this parameter and instead throw an
exception. Use one of the following constructors to create a
<code>TrustAnchor</code> object:</p>
<pre class="codeblock">
        public TrustAnchor(X509Certificate trustedCert, 
                byte[] nameConstraints)
        public TrustAnchor(X500Principal caPrincipal, PublicKey pubKey, 
                byte[] nameConstraints)
        public TrustAnchor(String caName, PublicKey pubKey, 
                byte[] nameConstraints)
</pre>
<p>The <code>nameConstraints</code> parameter is specified as a byte
array containing the ASN.1 DER encoding of a NameConstraints
extension. An <code>IllegalArgumentException</code> is thrown if
the name constraints cannot be decoded (are not formatted
correctly).</p>
<h5>Getting Parameter Values</h5>
<p>Each of the parameters can be retrieved using a corresponding
get method:</p>
<pre class="codeblock">
        public final X509Certificate getTrustedCert()
        public final X500Principal getCA()
        public final String getCAName()
        public final PublicKey getCAPublicKey()
        public final byte[] getNameConstraints()
</pre>
Note that the <code>getTrustedCert</code> method returns
<code>null</code> if the trust anchor was specified as a public key
and name pair. Likewise, the <code>getCA</code>,
<code>getCAName</code> and <code>getCAPublicKey</code> methods
return <code>null</code> if the trust anchor was specified as an
<code>X509Certificate</code>.
<h4><a name="PKIXParameters" id="PKIXParameters"></a>The
PKIXParameters Class</h4>
<p>This class (which implements the <tt><a href=
"#CertPathParameters">CertPathParameters</a></tt> interface)
specifies the set of input parameters defined by the PKIX
certification path validation algorithm. It also includes a few
additional useful parameters.</p>
<p>An X.509 <code>CertPath</code> object and a
<tt>PKIXParameters</tt> object are passed as arguments to the
<tt>validate</tt> method of a <tt><a href=
"#CertPathValidator">CertPathValidator</a></tt> instance
implementing the PKIX algorithm. The <code>CertPathValidator</code>
uses the parameters to initialize the PKIX certification path
validation algorithm.</p>
<h5>Creating a PKIXParameters Object</h5>
<p>To instantiate a <code>PKIXParameters</code> object, a caller
must specify "the most-trusted CA(s)" as defined by the PKIX
validation algorithm. The most-trusted CAs can be specified using
one of two constructors:</p>
<pre class="codeblock">
        public PKIXParameters(Set&lt;TrustAnchor&gt; trustAnchors) 
            throws InvalidAlgorithmParameterException
        public PKIXParameters(KeyStore keystore)
            throws KeyStoreException, InvalidAlgorithmParameterException
</pre>
<p>The first constructor allows the caller to specify the
most-trusted CAs as a <code>Set</code> of <code>TrustAnchor</code>
objects. Alternatively, a caller can use the second constructor and
specify a <code>KeyStore</code> instance containing trusted
certificate entries, each of which will be considered as a
most-trusted CA.</p>
<h5>Setting Parameter Values</h5>
<p>Once a <tt>PKIXParameters</tt> object has been created, a caller
can set (or replace the current value of) various parameters. A few
of the methods for setting parameters are described here. Please
refer to the <tt>
<!-- <A HREF="../../../../api/java/security/cert/PKIXParameters.html"><SPAN STYLE="font-weight: medium"><SPAN STYLE="font-style: normal"> -->
PKIXParameters <!-- </SPAN></SPAN></A> --></tt> API documentation
for details on the other methods.</p>
<p>The <tt>setInitialPolicies</tt> method sets the initial policy
identifiers, as specified by the PKIX validation algorithm. The
elements of the <tt>Set</tt> are object identifiers (OIDs)
represented as a <tt>String</tt>. If the
<code>initialPolicies</code> parameter is null or not set, any
policy is acceptable:</p>
<pre class="codeblock">
        public void setInitialPolicies(Set&lt;String&gt; initialPolicies)
</pre>
<p>The <tt>setDate</tt> method sets the time for which the validity
of the path should be determined. If the <tt>date</tt> parameter is
not set or is null, the current date is used:</p>
<pre class="codeblock">
        public void setDate(Date date)
</pre>
<p>The <tt>setPolicyMappingInhibited</tt> method sets the value of
the policy mapping inhibited flag. The default value for the flag,
if not specified, is false:</p>
<pre class="codeblock">
        public void setPolicyMappingInhibited(boolean val)
</pre>
<p>The <tt>setExplicitPolicyRequired</tt> method sets the value of
the explicit policy required flag. The default value for the flag,
if not specified, is false:</p>
<pre class="codeblock">
        public void setExplicitPolicyRequired(boolean val)
</pre>
<p>The <tt>setAnyPolicyInhibited</tt> method sets the value of the
any policy inhibited flag. The default value for the flag, if not
specified, is false:</p>
<pre class="codeblock">
        public void setAnyPolicyInhibited(boolean val)
</pre>
<p>The <tt>setTargetCertConstraints</tt> method allows the caller
to set constraints on the target or end-entity certificate. For
example, the caller can specify that the target certificate must
contain a specific subject name. The constraints are specified as a
<code>CertSelector</code> object. If the <code>selector</code>
parameter is null or not set, no constraints are defined on the
target certificate:</p>
<pre class="codeblock">
        public void setTargetCertConstraints(CertSelector selector)
</pre>
<p>The <tt>setCertStores</tt> method allows a caller to specify a
<code>List</code> of <tt>CertStore</tt> objects that will be used
by a PKIX implementation of <tt>CertPathValidator</tt> to find CRLs
for path validation. This provides an extensible mechanism for
specifying where to locate CRLs. The <tt>setCertStores</tt> method
takes a <code>List</code> of <tt>CertStore</tt> objects as a
parameter. The first <tt>CertStore</tt>s in the list may be
preferred to those that appear later.</p>
<pre class="codeblock">
        public void setCertStores(List&lt;CertStore&gt; stores)
</pre>
<p>The <tt>setCertPathCheckers</tt> method allows a caller to
extend the PKIX validation algorithm by creating
implementation-specific certification path checkers. For example,
this mechanism can be used to process private certificate
extensions. The <tt>setCertPathCheckers</tt> method takes a list of
<tt><a href="#PKIXCertPathChecker">PKIXCertPathChecker</a></tt>
(discussed later) objects as a parameter:</p>
<pre class="codeblock">
        public void setCertPathCheckers(List&lt;PKIXCertPathChecker&gt; checkers)
</pre>
<p>The <tt>setRevocationEnabled</tt> method allows a caller to
disable revocation checking. Revocation checking is enabled by
default, since it is a required check of the PKIX validation
algorithm. However, PKIX does not define how revocation should be
checked. An implementation may use CRLs or OCSP, for example. This
method allows the caller to disable the implementation's default
revocation checking mechanism if it is not appropriate. A different
revocation checking mechanism can then be specified by calling the
<tt>setCertPathCheckers</tt> method, and passing it a
<code>PKIXCertPathChecker</code> that implements the alternate
mechanism.</p>
<pre class="codeblock">
        public void setRevocationEnabled(boolean val)
</pre>
<p>The <tt>setPolicyQualifiersRejected</tt> method allows a caller
to enable or disable policy qualifier processing. When a
<tt>PKIXParameters</tt> object is created, this flag is set to
<tt>true</tt>. This setting reflects the most common (and simplest)
strategy for processing policy qualifiers. Applications that want
to use a more sophisticated policy must set this flag to
<tt>false</tt>.</p>
<pre class="codeblock">
        public void setPolicyQualifiersRejected(boolean qualifiersRejected)
</pre>
<h5>Getting Parameter Values</h5>
<p>The current values for each of the parameters can be retrieved
using an appropriate <tt>get</tt> method. Please refer to the
<tt><a href=
"../../../../api/java/security/cert/PKIXParameters.html">
PKIXParameters</a></tt> API
documentation for further details on these methods.</p>
<h4><a name="PKIXCertPathValidatorResult" id=
"PKIXCertPathValidatorResult"></a> The PKIXCertPathValidatorResult
Class</h4>
<p>This class (which implements the <tt><a href=
"#CertPathValidatorResult">CertPathValidatorResult</a></tt>
interface) represents the result of the PKIX certification path
validation algorithm.&nbsp; It holds the valid policy tree and
subject public key resulting from the validation algorithm, and
includes methods (<code>getPolicyTree()</code> and
<code>getPublicKey()</code>) for returning them. Instances of
<tt>PKIXCertPathValidatorResult</tt> are returned by the
<tt>validate</tt> method of <tt><a href=
"#CertPathValidator">CertPathValidator</a></tt> objects
implementing the PKIX algorithm.</p>
<p>Please refer to the <tt><a href=
"../../../../api/java/security/cert/PKIXCertPathValidatorResult.html">
PKIXCertPathValidatorResult</a></tt>
API documentation for more detailed information on this class.</p>
<h4><a name="PolicyNode" id="PolicyNode"></a> The PolicyNode
Interface and PolicyQualifierInfo Class</h4>
<p>The PKIX validation algorithm defines several outputs related to
certificate policy processing. Most applications will not need to
use these outputs, but all providers that implement the PKIX
validation or building algorithm must support them.</p>
<p>The <code>PolicyNode</code> interface represents a node of a
valid policy tree resulting from a successful execution of the PKIX
certification path validation. An application can obtain the root
of a valid policy tree using the <code>getPolicyTree</code> method
of <code>PKIXCertPathValidatorResult</code>. Policy Trees are
discussed in more detail in the <a href=
"http://www.ietf.org/rfc/rfc3280.txt">PKIX Certificate and CRL
Profile</a>.</p>
<p>The <code>getPolicyQualifiers</code> method of
<code>PolicyNode</code> returns a <code>Set</code> of
<code>PolicyQualifierInfo</code> objects, each of which represents
a policy qualifier contained in the Certificate Policies extension
of the relevant certificate that this policy applies to.</p>
<p>Most applications will not need to examine the valid policy tree
and policy qualifiers. They can achieve their policy processing
goals by setting the policy-related parameters in
<code>PKIXParameters</code>. However, the valid policy tree is
available for more sophisticated applications, especially those
that process policy qualifiers.</p>
<p>Please refer to the <code><a href=
"../../../../api/java/security/cert/PolicyNode.html">PolicyNode</a></code>
and <code><a href=
"../../../../api/java/security/cert/PolicyQualifierInfo.html">PolicyQualifierInfo</a></code>
API documentation for more detailed information on these
classes.</p>
<h5>Example of Validating a Certification Path using the PKIX
algorithm</h5>
<p>This is an example of validating a certification path with the
PKIX validation algorithm. The example ignores most of the
exception handling and assumes that the certification path and
public key of the trust anchor have already been created.</p>
<p>First, create the <tt><a href=
"#CertPathValidator">CertPathValidator</a></tt>, as in the
following line:</p>
<pre class="codeblock">
    CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
</pre>
<p>The next step is to create a <tt><a href=
"#TrustAnchor">TrustAnchor</a></tt> object. This will be used as an
anchor for validating the certification path. In this example, the
most-trusted CA is specified as a public key and name (name
constraints are not applied and are specified as
<code>null</code>):</p>
<pre class="codeblock">
    TrustAnchor anchor = new TrustAnchor("O=xyz,C=us", pubkey, null);
</pre>
<p>The next step is to create a <tt><a href=
"#PKIXParameters">PKIXParameters</a></tt> object. This will be used
to populate the parameters used by the PKIX algorithm. In this
example, we pass to the constructor a <code>Set</code> containing a
single element - the <code>TrustAnchor</code> we created in the
previous step:</p>
<pre class="codeblock">
    PKIXParameters params = new PKIXParameters(Collections.singleton(anchor));
</pre>
<p>Next, we populate the parameters object with constraints or
other parameters used by the validation algorithm. In this example,
we enable the explicitPolicyRequired flag and specify a set of
initial policy OIDs (the contents of the set are not shown):</p>
<pre class="codeblock">
    // set other PKIX parameters here
    params.setExplicitPolicyRequired(true);
    params.setInitialPolicies(policyIds);
</pre>
<p>The final step is to validate the certification path using the
input parameter set we have created:</p>
<pre class="codeblock">
    try {
        PKIXCertPathValidatorResult result =
            (PKIXCertPathValidatorResult) cpv.validate(certPath, params);
        PolicyNode policyTree = result.getPolicyTree();
        PublicKey subjectPublicKey = result.getPublicKey();
    } catch (CertPathValidatorException cpve) {
        System.out.println("Validation failure, cert[" 
            + cpve.getIndex() + "] :" + cpve.getMessage());
    }
</pre>
<p>If the validation algorithm is successful, the policy tree and
subject public key resulting from the validation algorithm are
obtained using the <code>getPolicyTree</code> and
<code>getPublicKey</code> methods of
<code>PKIXCertPathValidatorResult</code>.</p>
<p>Otherwise, a <tt>CertPathValidatorException</tt> is thrown and
the caller can catch the exception and print some details about the
failure, such as the error message and the index of the certificate
that caused the failure.</p>
<h4><a name="PKIXBuilderParameters" id=
"PKIXBuilderParameters"></a>The PKIXBuilderParameters Class</h4>
<p>This class (which extends the <tt><a href=
"#PKIXParameters">PKIXParameters</a></tt> class) specifies the set
of parameters to be used with <a href=
"#CertPathBuilder"><tt>CertPathBuilder</tt>s</a> that build
certification paths validated against the PKIX certification path
validation algorithm.</p>
<p>A <tt>PKIXBuilderParameters</tt> object is passed as an argument
to the <tt>build</tt> method of a <tt><a href=
"#CertPathBuilder">CertPathBuilder</a></tt> instance implementing
the PKIX algorithm. All PKIX <tt>CertPathBuilder</tt>s <i>must</i>
return certification paths which have been validated according to
the PKIX certification path validation algorithm.</p>
<p>Please note that the mechanism that a PKIX
<code>CertPathBuilder</code> uses to validate a constructed path is
an implementation detail. For example, an implementation might
attempt to first build a path with minimal validation and then
fully validate it using an instance of a PKIX
<code>CertPathValidator</code>, whereas a more efficient
implementation may validate more of the path as it is building it,
and backtrack to previous stages if it encounters validation
failures or dead-ends.</p>
<h5>Creating a PKIXBuilderParameters Object</h5>
<p>Creating a <tt>PKIXBuilderParameters</tt> object is similar to
creating a <tt>PKIXParameters</tt> object. However, a caller
<i>must</i> specify constraints on the target or end-entity
certificate when creating a <tt>PKIXBuilderParameters</tt> object.
These constraints should provide the <code>CertPathBuilder</code>
with enough information to find the target certificate. The
constraints are specified as a <code>CertSelector</code> object.
Use one of the following constructors to create a
<tt>PKIXBuilderParameters</tt> object:</p>
<pre class="codeblock">
        public PKIXBuilderParameters(Set&lt;TrustAnchor&gt; trustAnchors, 
                CertSelector targetConstraints)
                throws InvalidAlgorithmParameterException
        public PKIXBuilderParameters(KeyStore keystore, 
                CertSelector targetConstraints) 
                throws KeyStoreException, InvalidAlgorithmParameterException
                                                
</pre>
<h5>Getting/Setting Parameter Values</h5>
<p>The <tt>PKIXBuilderParameters</tt> class inherits all of the
parameters that can be set in the <tt>PKIXParameters</tt> class. In
addition, the <tt>setMaxPathLength</tt> method can be called to
place a limit on the maximum number of certificates in a
certification path:</p>
<pre class="codeblock">
        public void setMaxPathLength(int maxPathLength)
</pre>
<p>The <tt>maxPathLength</tt> parameter specifies the maximum
number of non-self-issued intermediate certificates that may exist
in a certification path. A <tt>CertPathBuilder</tt> instance
implementing the PKIX algorithm must not build paths longer than
the length specified. If the value is 0, the path can only contain
a single certificate. If the value is -1, the path length is
unconstrained (i.e., there is no maximum). The default maximum path
length, if not specified, is 5. This method is useful to prevent
the <code>CertPathBuilder</code> from spending resources and time
constructing long paths that may or may not meet the caller's
requirements.</p>
<p>If any of the CA certificates in the path contain a Basic
Constraints extension, the value of the pathLenConstraint component
of the extension overrides the value of the
<tt>maxPathLength</tt> parameter whenever the result is a
certification path of smaller length. There is also a corresponding
<code>getMaxPathLength</code> method for retrieving this
parameter:</p>
<pre class="codeblock">
        public int getMaxPathLength()
</pre>
<p>Also, the <tt>setCertStores</tt> method (inherited from the
<code>PKIXParameters</code> class) is typically used by a PKIX
implementation of <tt>CertPathBuilder</tt> to find Certificates for
path construction as well as finding CRLs for path validation. This
provides an extensible mechanism for specifying where to locate
Certificates and CRLs.</p>
<h4><a name="PKIXCertPathBuilderResult" id=
"PKIXCertPathBuilderResult"></a> The PKIXCertPathBuilderResult
Class</h4>
<p>This class (which extends the
<tt>PKIXCertPathValidatorResult</tt> class and implements the
<tt><a href="#CertPathBuilderResult">CertPathBuilderResult</a></tt>
interface) represents the successful result of the PKIX
certification path construction algorithm.&nbsp; Instances of
<tt>PKIXCertPathBuilderResult</tt> are returned by the
<tt>build</tt> method of <tt><a href=
"#CertPathBuilder">CertPathBuilder</a></tt> objects implementing
the PKIX algorithm.</p>
<p>The <tt>getCertPath</tt> method of a
<tt>PKIXCertPathBuilderResult</tt> instance always returns a
<tt>CertPath</tt> object validated using the PKIX certification
path validation algorithm. The returned <tt>CertPath</tt> object
does not include the most-trusted CA certificate that may have been
used to anchor the path. Instead, use the
<code>getTrustAnchor</code> method to get the
<code>Certificate</code> of the most-trusted CA.</p>
<p>Please refer to the <tt><a href=
"../../../../api/java/security/cert/PKIXCertPathBuilderResult.html">
PKIXCertPathBuilderResult</a></tt>
API documentation for more detailed information on this class.</p>
<h5>Example of Building a Certification Path using the PKIX
algorithm</h5>
<p>This is an example of building a certification path validated
against the PKIX algorithm. Some details have been left out, such
as exception handling, and the creation of the trust anchors and
certificates for populating the <code>CertStore</code>.</p>
<p>First, create the <tt><a href=
"#CertPathBuilder">CertPathBuilder</a></tt>, as in the following
example:</p>
<pre class="codeblock">
    CertPathBuilder cpb = CertPathBuilder.getInstance("PKIX");
</pre>
<p>This call creates a <tt>CertPathBuilder</tt> object that returns
paths validated against the PKIX algorithm.</p>
<p>The next step is to create a <tt><a href=
"#PKIXBuilderParameters">PKIXBuilderParameters</a></tt> object.
This will be used to populate the PKIX parameters used by the
<tt>CertPathBuilder</tt>:</p>
<pre class="codeblock">
    // Create parameters object, passing it a Set of
    // trust anchors for anchoring the path
    // and a target subject DN.
    X509CertSelector targetConstraints = new X509CertSelector();
    targetConstraints.setSubject("CN=alice,O=xyz,C=us");
    PKIXBuilderParameters params = 
        new PKIXBuilderParameters(trustAnchors, targetConstraints);
</pre>
<p>The next step is to specify the <tt>CertStore</tt> that the
<tt>CertPathBuilder</tt> will use to look for certificates and
CRLs. For this example, we will populate a Collection
<tt>CertStore</tt> with the certificates and CRLs:</p>
<pre class="codeblock">
    CollectionCertStoreParameters ccsp = 
        new CollectionCertStoreParameters(certsAndCrls);
    CertStore store = CertStore.getInstance("Collection", ccsp);
    params.addCertStore(store);
</pre>
<p>The next step is to build the certification path using the input
parameter set we have created:</p>
<pre class="codeblock">
    try {
        PKIXCertPathBuilderResult result = 
            (PKIXCertPathBuilderResult) cpb.build(params);
        CertPath cp = result.getCertPath();
    } catch (CertPathBuilderException cpbe) {
        System.out.println("build failed: " + cpbe.getMessage());
    }
</pre>
<p>If the <code>CertPathBuilder</code> cannot build a path that
meets the supplied parameters it will throw a
<tt>CertPathBuilderException</tt>. Otherwise, the validated
certification path can be obtained from the
<tt>PKIXCertPathBuilderResult</tt> using the
<code>getCertPath</code> method.</p>

<h4><a name="PKIXCertPathChecker" id="PKIXCertPathChecker"></a>The PKIXCertPathChecker Class</h4>

<p>This section describes a powerful class that allows a user to extend a PKIX <tt>CertPathValidator</tt> or
<tt>CertPathBuilder</tt> implementation. This is an advanced feature that most users will not need to understand. However, anyone implementing a PKIX service provider should read this section.</p>

<p>The <tt>PKIXCertPathChecker</tt> class is an abstract class that executes one or more checks on an X.509 certificate. Developers should create concrete implementations of the <tt>PKIXCertPathChecker</tt> class when it is necessary to dynamically extend a PKIX <tt>CertPathValidator</tt> or <tt>CertPathBuilder</tt> implementation at runtime. The following are a few examples of when a <tt>PKIXCertPathChecker</tt> implementation is useful:</p>

<ul>
  <li>
    <p>If the revocation mechanism supplied by a PKIX <tt>CertPathValidator</tt> or <tt>CertPathBuilder</tt>
implementation is not adequate: For example, you can
use the <code><a href="../../../../api/java/security/cert/PKIXRevocationChecker.html">PKIXRevocationChecker</a></code> class (introduced in JDK 8; see <a href="#PKIXRevocationChecker">Check Revocation Status of Certificates with PKIXRevocationChecker Class</a>) to have more control
over the revocation mechanism, or you can implement your own
<code>PKIXCertPathChecker</code> to check that certificates have not been revoked.</p>
</li>

<li>
<p>If the user wants to recognize certificates containing a
critical private extension. Since the extension is private, it will
not be recognized by the PKIX <tt>CertPathValidator</tt> or
<tt>CertPathBuilder</tt> implementation and a
<tt>CertPathValidatorException</tt> will be thrown. In this case, a
developer can implement a <tt>PKIXCertPathChecker</tt> that
recognizes and processes the critical private extension.</p>
</li>
<li>
<p>If the developer wants to record information about each
certificate processed for debugging or display purposes.</p>
</li>
<li>
<p>If the user wants to reject certificates with certain policy
qualifiers.</p>
</li>
</ul>

<p>The <tt>setCertPathCheckers</tt> method of the
<tt>PKIXParameters</tt> class allows a user to pass a
<code>List</code> of <tt>PKIXCertPathChecker</tt> objects to a PKIX
<tt>CertPathValidator</tt> or <tt>CertPathBuilder</tt>
implementation. Each of the <tt>PKIXCertPathChecker</tt> objects
will be called in turn, for each certificate processed by the PKIX
<tt>CertPathValidator</tt> or <tt>CertPathBuilder</tt>
implementation.</p>
<h5>Creating and using a PKIXCertPathChecker Object</h5>
<p>The <tt>PKIXCertPathChecker</tt> class does not have a public
constructor. This is intentional, since creating an instance of
<tt>PKIXCertPathChecker</tt> is an implementation-specific issue.
For example, the constructor for a <tt>PKIXCertPathChecker</tt>
implementation that uses OCSP to check a certificate's revocation
status may require the hostname and port of the OCSP server:</p>
<pre class="codeblock">
        PKIXCertPathChecker checker = new OCSPChecker("ocsp.sun.com", 1321);
</pre>
<p>Once the checker has been instantiated, it can be added as a
parameter using the <tt>addCertPathChecker</tt> method of the
<tt>PKIXParameters</tt> class:</p>
<pre class="codeblock">
        params.addCertPathChecker(checker);
</pre>
<p>Alternatively, a <tt>List</tt> of checkers can be added using
the <tt>setCertPathCheckers</tt> method of the
<tt>PKIXParameters</tt> class.</p>
<h5>Implementing a PKIXCertPathChecker Object</h5>
<p>The <tt>PKIXCertPathChecker</tt> class is abstract. It has four
methods (<tt>check</tt>, <tt>getSupportedExtensions</tt>,
<tt>init</tt>, and <tt>isForwardCheckingSupported</tt>) that all
concrete subclasses must implement.</p>
<p>Implementing a <tt>PKIXCertPathChecker</tt> may be trivial or
complex. A <tt>PKIXCertPathChecker</tt> implementation can be
stateless or stateful. A stateless implementation does not maintain
state between successive calls of the <tt>check</tt> method. For
example, a <tt>PKIXCertPathChecker</tt> that checks that each
certificate contains a particular policy qualifier is stateless. In
contrast, a stateful implementation does maintain state between
successive calls of the <tt>check</tt> method. The <tt>check</tt>
method of a stateful implementation usually depends on the contents
of prior certificates in the certification path. For example, a
<tt>PKIXCertPathChecker</tt> that processes the NameConstraints
extension is stateful.</p>
<p>Also, the order in which the certificates processed by a service
provider implementation are presented (passed) to a
<tt>PKIXCertPathChecker</tt> is very important, especially if the
implementation is stateful. Depending on the algorithm used by the
service provider, the certificates may be presented in
<i>reverse</i> or <i>forward</i> order. A reverse ordering means
that the certificates are ordered from the most trusted CA (if
present) to the target subject, whereas a forward ordering means
that the certificates are ordered from the target subject to the
most trusted CA. The order must be made known to the
<tt>PKIXCertPathChecker</tt> implementation, so that it knows how
to process consecutive certificates.</p>
<h5>Initializing a PKIXCertPathChecker Object</h5>
<p>The <tt>init</tt> method initializes the internal state of the
checker:</p>
<pre class="codeblock">
        public abstract void init(boolean forward)
</pre>
<p>All stateful implementations should clear or initialize any
internal state in the checker. This prevents a service provider
implementation from calling a checker that is in an uninitialized
state. It also allows stateful checkers to be reused in subsequent
operations without reinstantiating them. The <tt>forward</tt>
parameter indicates the order of the certificates presented to the
<tt>PKIXCertPathChecker</tt>. If <tt>forward</tt> is <tt>true</tt>,
the certificates are presented from target to trust anchor; if
<tt>false</tt>, from trust anchor to target.</p>
<h5>Forward Checking</h5>
<p>The <tt>isForwardCheckingSupported</tt> method returns a
<tt>boolean</tt> that indicates if the <tt>PKIXCertPathChecker</tt>
supports forward checking:</p>
<pre class="codeblock">
        public abstract boolean isForwardCheckingSupported()
</pre>
<p>All <tt>PKIXCertPathChecker</tt> implementations
<i>must</i>support reverse
checking. A <tt>PKIXCertPathChecker</tt> implementation
<i>may</i>support forward
checking.</p>
<p>Supporting forward checking improves the efficiency of
<code>CertPathBuilder</code>s that build forward, since it allows
paths to be checked as they are built. However, some stateful
<code>PKIXCertPathChecker</code>s may find it difficult or
impossible to support forward checking.</p>
<h5>Supported Extensions</h5>
<p>The <tt>getSupportedExtensions</tt> method returns an immutable
<tt>Set</tt> of OID <tt>String</tt>s for the X.509 extensions that
the <tt>PKIXCertPathChecker</tt> implementation supports (i.e.,
recognizes, is able to process):</p>
<pre class="codeblock">
        public abstract Set&lt;String&gt; getSupportedExtensions()
</pre>
<p>The method should return <tt>null</tt> if no extensions are
processed. All implementations should return the <tt>Set</tt> of
OID <tt>String</tt>s that the <tt>check</tt> method may
process.</p>
<p>A <code>CertPathBuilder</code> can use this information to
identify certificates with unrecognized critical extensions, even
when performing a forward build with a
<code>PKIXCertPathChecker</code> that does not support forward
checking.</p>
<h5>Executing the Check</h5>
<p>The following method executes a check on the certificate:</p>
<pre class="codeblock">
        public abstract void 
                check(Certificate cert, Collection&lt;String&gt; unresolvedCritExts)
                throws CertPathValidatorException
</pre>
<p>The <tt>unresolvedCritExts</tt> parameter contains a collection
of OIDs as <tt>String</tt>s. These OIDs represent the set of
critical extensions in the certificate that have not yet been
resolved by the certification path validation algorithm. Concrete
implementations of the <tt>check</tt> method should remove any
critical extensions that it processes from the
<tt>unresolvedCritExts</tt> parameter.</p>
<p>If the certificate does not pass the check(s), a
<tt>CertPathValidatorException</tt> should be thrown.</p>
<h5>Cloning a PKIXCertPathChecker</h5>
<p>The <tt>PKIXCertPathChecker</tt> class implements the
<tt>Cloneable</tt> interface. All stateful
<tt>PKIXCertPathChecker</tt> implementations must override the
<tt>clone</tt> method if necessary. The default implementation of
the <tt>clone</tt> method calls the <tt>Object.clone</tt> method,
which performs a simple clone by copying all fields of the original
object to the new object. A stateless implementation should not
override the <tt>clone</tt> method. However, all stateful
implementations must ensure that the default <tt>clone</tt> method
is correct, and override it if necessary. For example, a
<tt>PKIXCertPathChecker</tt> that stores state in an array must
override the <tt>clone</tt> method to make a copy of the array,
rather than just a reference to the array.</p>
<p>The reason that <tt>PKIXCertPathChecker</tt> objects are
<tt>Cloneable</tt> is to allow a PKIX <tt>CertPathBuilder</tt>
implementation to efficiently backtrack and try another path when a
potential certification path reaches a dead end or point of
failure. In this case, the implementation is able to restore prior
path validation states by restoring the cloned objects.</p>
<h5>Example</h5>
<p>This is an example of a stateless <tt>PKIXCertPathChecker</tt>
implementation. It checks if a private extension exists in a
certificate and processes it according to some rules.</p>
<pre class="codeblock">
        import java.security.cert.Certificate;
        import java.security.cert.X509Certificate;
        import java.util.Collection;
        import java.util.Collections;
        import java.util.Set;
        import java.security.cert.PKIXCertPathChecker;
        import java.security.cert.CertPathValidatorException;

        public class MyChecker extends PKIXCertPathChecker {
            private static Set supportedExtensions =
                Collections.singleton("2.16.840.1.113730.1.1");

            /*
             * Initialize checker
             */
            public void init(boolean forward) 
                throws CertPathValidatorException {
                // nothing to initialize
            }

            public Set getSupportedExtensions() {        
                return supportedExtensions;
            }

            public boolean isForwardCheckingSupported() {
                return true;
            }

            /*
             * Check certificate for presence of Netscape's
             * private extension
             * with OID "2.16.840.1.113730.1.1"
             */
            public void check(Certificate cert, 
                              Collection unresolvedCritExts)
                throws CertPathValidatorException 
            {
                X509Certificate xcert = (X509Certificate) cert;
                byte[] ext = 
                    xcert.getExtensionValue("2.16.840.1.113730.1.1");
                if (ext == null)
                    return;

                //
              // process private extension according to some 
                // rules - if check fails, throw a 
                // CertPathValidatorException ...
                // {insert code here}

                // remove extension from collection of unresolved 
                // extensions (if it exists)
                if (unresolvedCritExts != null)
                    unresolvedCritExts.remove("2.16.840.1.113730.1.1");
            }
        }
</pre>
<h5>How a PKIX Service Provider implementation should use a
PKIXCertPathChecker</h5>
<p>Each <tt>PKIXCertPathChecker</tt> object must be initialized by
a service provider implementation before commencing the build or
validation algorithm, for example:</p>
<pre class="codeblock">
        List&lt;PKIXCertPathChecker&gt; checkers = params.getCertPathCheckers();
        for (PKIXCertPathChecker checker : checkers) {
            checker.init(false);
        }
</pre>
<p>For each certificate that it validates, the service provider
implementation must call the <tt>check</tt> method of each
<tt>PKIXCertPathChecker</tt> object in turn, passing it the
certificate and any remaining unresolved critical extensions:</p>
<pre class="codeblock">
        for (PKIXCertPathChecker checker : checkers) {
            checker.check(cert, unresolvedCritExts);
        }
</pre>
<p>If any of the <tt>check</tt>s throw a
<tt>CertPathValidatorException</tt>, a
<code>CertPathValidator</code> implementation should terminate the
validation procedure. However, a <tt>CertPathBuilder</tt>
implementation may simply log the failure and continue to search
for other potential paths. If all of the <tt>check</tt>s are
successful, the service provider implementation should check that
all critical extensions have been resolved and if not, consider the
validation to have failed. For example:</p>
<pre class="codeblock">
        if (unresolvedCritExts != null &amp;&amp;
            !unresolvedCritExts.isEmpty())
        {
            // note that a CertPathBuilder may have an enclosing
            // try block to catch the exception below and continue on error
            throw new CertPathValidatorException
                ("Unrecognized Critical Extension");
        }
</pre>
<p>As discussed in the previous section, a <tt>CertPathBuilder</tt>
implementation may need to backtrack when a potential certification
path reaches a dead end or point of failure. Backtracking in this
context implies returning to the previous certificate in the path
and checking for other potential paths. If the
<tt>CertPathBuilder</tt> implementation is validating the path as
it is building it, it will need to restore the previous state of
each <tt>PKIXCertPathChecker</tt>.
It can do this by making clones of the <tt>PKIXCertPathChecker</tt>
objects <i>before</i> each certificate is processed, for
example:</p>
<pre class="codeblock">
        /* clone checkers */
        List newList = new ArrayList(checkers);
        ListIterator li = newList.listIterator();
        while (li.hasNext()) {   
            PKIXCertPathChecker checker = (PKIXCertPathChecker) li.next();
            li.set(checker.clone());
        }
</pre>
<h4><a name="PKIXValidationExample" id="PKIXValidationExample"></a>
Using PKIXCertPathChecker in Certificate Path Validation</h4>
<p>Using a <code>PKIXCertPathChecker</code> to customize
certificate path validation is relatively straightforward.</p>
<h5>Basic Certification Path Validation</h5>
<p>First, consider code that validates a certificate path:</p>
<pre class="codeblock">
Set&lt;TrustAnchor&gt; trustAnchors = getTrustAnchors();
CertPath cp = getCertPath();

PKIXParameters pkixp = new PKIXParameters(trustAnchors);
pkixp.setRevocationEnabled(false);

CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
PKIXCertPathValidatorResult pcpvr =
    (PKIXCertPathValidatorResult)cpv.validate(cp, pkixp);
</pre>
<p>If the validation fails, the <code>validate()</code> method
throws an exception.</p>
<p>The fundamental steps are as follows:</p>
<ol>
<li>Obtain the CA root certificates and the certification path to
be validated.</li>
<li>Create a <code>PKIXParameters</code> with the trust
anchors.</li>
<li>Use a <code>CertPathValidator</code> to validate the
certificate path.</li>
</ol>
<p>In this example, <code>getTrustAnchors()</code> and
<code>getCertPath()</code> are the methods that obtain CA root
certificates and the certification path.</p>
<p>The <code>getTrustAnchors()</code> method in the example must
return a <code>Set</code> of <code>TrustAnchor</code>s that
represent the CA root certificates you wish to use for validation.
Here is one simple implementation that loads a single CA root
certificate from a file:</p>
<pre class="codeblock">
public Set&lt;TrustAnchor&gt; getTrustAnchors()
    throws IOException, CertificateException {
  InputStream in = new FileInputStream("x509_ca-certificate.cer");
  CertificateFactory cf = CertificateFactory.getInstance("X.509");
  X509Certificate c = (X509Certificate)cf.generateCertificate(in);
  in.close();

  TrustAnchor anchor = new TrustAnchor(c, null);
  return Collections.singleton(anchor);
}
</pre>
<p>Similarly, here is a simple implementation of
<code>getCertPath()</code> that loads a certificate path from a
file:</p>
<pre class="codeblock">
public CertPath getCertPath() throws IOException, CertificateException {
  CertificateFactory cf = CertificateFactory.getInstance("X.509");

  InputStream in = new FileInputStream("certpath.pkcs7");
  CertPath cp = cf.generateCertPath(in, "PKCS7");
  in.close();
  
  return cp;
}
</pre>
<p>Note that PKCS#7 does not require a specific order for the
certificates in the file, so this code only works for certification
path validation when the certificates are ordered starting from the
entity to be validated and progressing back toward the CA root. If
the certificates are not in the right order, you need to do some
additional processing. <code>CertificateFactory</code> has a
<code>generateCertPath()</code> method that accepts a
<code>Collection</code>, which is useful for this type of
processing.</p>

<!-- ********************************************************************* -->

<h5>Adding in a <code>PKIXCertPathChecker</code></h5>

<p>To customize certification path validation, add a <code>PKIXCertPathChecker</code> as follows. In this example,
<code>SimpleChecker</code> is a <code>PKIXCertPathChecker</code> subclass. The new lines are shown in <b>bold</b>.</p>

<pre class="codeblock">
Set&lt;TrustAnchor&gt; trustAnchors = getTrustAnchors();
CertPath cp = getCertPath();

PKIXParameters pkixp = new PKIXParameters(trustAnchors);
pkixp.setRevocationEnabled(false);

<b>SimpleChecker sc = new SimpleChecker();
pkixp.addCertPathChecker(sc);</b>

CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
PKIXCertPathValidatorResult pcpvr =
    (PKIXCertPathValidatorResult)cpv.validate(cp, pkixp);
</pre>

<p><code>SimpleChecker</code> is a rudimentary subclass of <code>PKIXCertPathChecker</code>. Its <code>check()</code> method is called for every certificate in the certification path that is being validated. <code>SimpleChecker</code> uses an <code>AlgorithmConstraints</code> implementation to examine the signature algorithm and public key of each certificate.</p>

<pre class="codeblock">
import java.security.AlgorithmConstraints;
import java.security.CryptoPrimitive;
import java.security.Key;
import java.security.cert.*;
import java.util.*;

public class SimpleChecker extends PKIXCertPathChecker {
  private final static Set&lt;CryptoPrimitive&gt; SIGNATURE_PRIMITIVE_SET =
      EnumSet.of(CryptoPrimitive.SIGNATURE);
  
  public void init(boolean forward) throws CertPathValidatorException {}
  
  public boolean isForwardCheckingSupported() { return true; }
  
  public Set&lt;String&gt; getSupportedExtensions() { return null; }
  
  public void check(Certificate cert,
      Collection&lt;String&gt; unresolvedCritExts)
      throws CertPathValidatorException {
    X509Certificate c = (X509Certificate)cert;
    String sa = c.getSigAlgName();
    Key key = c.getPublicKey();
    
    AlgorithmConstraints constraints = new SimpleConstraints();
    
    if (constraints.permits(SIGNATURE_PRIMITIVE_SET, sa, null) == false)
      throw new CertPathValidatorException("Forbidden algorithm: " + sa);

    if (constraints.permits(SIGNATURE_PRIMITIVE_SET, key) == false)
      throw new CertPathValidatorException("Forbidden key: " + key);
  }
}
</pre>

<p>Finally, <code>SimpleConstraints</code> is a rather severe <code>AlgorithmConstraints</code> implementation that allows only RSA algorithms and requires keys to be 2048 bits or larger.</p>

<pre class="codeblock">
import java.security.AlgorithmConstraints;
import java.security.AlgorithmParameters;
import java.security.CryptoPrimitive;
import java.security.Key;
import java.security.interfaces.RSAKey;
import java.util.Set;

public class SimpleConstraints implements AlgorithmConstraints {
  public boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
      String algorithm, AlgorithmParameters parameters) {
    return permits(primitives, algorithm, null, parameters);
  }

  public boolean permits(Set&lt;CryptoPrimitive&gt; primitives, Key key) {
    return permits(primitives, null, key, null);
  }
  
  public boolean permits(Set&lt;CryptoPrimitive&gt; primitives,
      String algorithm, Key key, AlgorithmParameters parameters) {
    if (algorithm == null) algorithm = key.getAlgorithm();
    
    if (algorithm.indexOf("RSA") == -1) return false;
    
    if (key != null) {
      RSAKey rsaKey = (RSAKey)key;
      int size = rsaKey.getModulus().bitLength();
      if (size &lt; 2048) return false;
    }

    return true;
  }
}
</pre>

<!-- ******************************************************************* -->

<h5><a name="PKIXRevocationChecker">Check Revocation Status of Certificates with PKIXRevocationChecker Class</a></h5>

<p>The <code><a href="../../../../api/java/security/cert/PKIXRevocationChecker.html">PKIXRevocationChecker</a></code> class (introduced in JDK 8), which is a subclass of <code>PKIXCertPathChecker</code>, checks the revocation status of certificates with the PKIX algorithm.</p>

<p>An instance of <code>PKIXRevocationChecker</code> checks the revocation status of certificates with the Online Certificate Status Protocol (OCSP) or Certificate Revocation Lists (CRLs). OCSP is described in <a href="http://www.ietf.org/rfc/rfc2560.txt">RFC 2560</a> and is a network protocol for determining the status of a certificate. A CRL is a time-stamped list identifying revoked certificates, and RFC 5280 describes an algorithm for determining the revocation status of certificates using CRLs.</p>

<p>Each PKIX <code>CertPathValidator</code> and <code>CertPathBuilder</code> instance provides a default revocation implementation that is enabled by default. If you want more control over the revocation settings used by that implementation, use the <code>PKIXRevocationChecker</code> class.</p>

<p>Follow these general steps to check the revocation status of a certificate path with the <code>PKIXRevocationChecker</code> class:</p>

<ol>
  <li><p>Obtain a <code>PKIXRevocationChecker</code> instance by calling the <code>getRevocationChecker</code> method of a PKIX <code>CertPathValidator</code> or <code>CertPathBuilder</code> instance.</p></li>

  <li><p>Set additional parameters and options specific to certificate revocation with methods contained in the <code>PKIXRevocationChecker</code> class. These methods include <code><a href="../../../../api/java/security/cert/PKIXRevocationChecker.html#setOCSPResponder-java.net.URI-">setOCSPResponder(URI)</a></code>, which sets the URI that identifies the location of the OCSP responder (although normally the URI is included in the certificate and does not have to be set) and <code><a href="../../../../api/java/security/cert/PKIXRevocationChecker.html#setOCSPResponder-java.net.URI-">setOptions(Set&lt;PKIXRevocationChecker.Option&gt;)</a></code>, which sets revocation options. <code><a href="../../../../api/java/security/cert/PKIXRevocationChecker.Option.html">PKIXRevocationChecker.Option</a></code> is an enumerated type used to specify the following options:</p>
    <ul>
      <li><code>ONLY_END_ENTITY</code>: Only check the revocation status of end-entity certificates.</li>
      <li><code>PREFER_CRLS</code>: By default, OCSP is the preferred mechanism for checking revocation status, with CRLs as the fallback mechanism. Switch this preference to CRLs with this option.</li>
      <li><code>SOFT_FAIL</code>: Ignore network failures.</li>
    </ul>
 

  </li>

  <li><p>After obtaining an instance of <code>PKIXRevocationChecker</code>, add it to a <code>PKIXParameters</code> or <code>PKIXBuilderParameters</code> object with the <code><a href="../../../../api/java/security/cert/PKIXParameters.html#addCertPathChecker-java.security.cert.PKIXCertPathChecker-">addCertPathChecker</a></code> or <code><a href="../../../../api/java/security/cert/PKIXParameters.html#addCertPathChecker-java.security.cert.PKIXCertPathChecker-">setCertPathCheckers</a></code> method.</p>

</li>

  <li><p>Follow one of these steps depending on whether you are using a PKIX <code>CertPathValidator</code> or <code>CertPathBuilder</code> instance:</p>

    <ul>
      <li><p>If you are using a PKIX <code>CertPathValidator</code> instance, call the <code><a href="../../../../api/java/security/cert/CertPathValidator.html#validate-java.security.cert.CertPath-java.security.cert.CertPathParameters-">validate</a></code> method using as arguments the certificate path you want to validate and the <code>PKIXParameters</code> object that contains a revocation checker.</p></li>

      <li><p>If you are using a PKIX <code>CertPathBuilder</code> instance, call the <code><a href="../../../../api/java/security/cert/CertPathBuilder.html#build-java.security.cert.CertPathParameters-">build</a></code> method using as arguments the <code>PKIXBuilderParameters</code> object that contains a revocation checker.</p></li>
    </ul>
  </li>
  
   
  <li><p>Call the <code>validate</code> method of the PKIX <code>CertPathValidator</code> or <code>CertPathBuilder</code> instance using as arguments the certificate path you want to validate and the <code>PKIXParameters</code> or <code>PKIXBuilderParameters</code> object that contains a revocation checker.</p></li>

</ol>
 

<p>The following excerpt checks the revocation status of certificates contained in a certificate path. The <code>CertPath</code> object <code>path</code> is the certificate path, and <code>params</code> is an object of type <code>PKIXParameters</code>:</p> 


<pre class="codeblock">
    CertPathValidator cpv = CertPathValidator.getInstance("PKIX");
    PKIXRevocationChecker rc = (PKIXRevocationChecker)cpv.getRevocationChecker();
    rc.setOptions(EnumSet.of(Option.SOFT_FAIL));
    params.addCertPathChecker(rc);
    params.setRevocationEnabled(false);
    CertPathValidatorResult res = cpv.validate(path, params);
</pre>

<p>In this excerpt, the <code>SOFT_FAIL</code> option causes the revocation checker to ignore any network failures (such as failing to establish a connection to the OCSP server) when it checks the revocation status.</p>


<h2><a name="ServiceProvider" id="ServiceProvider"></a>Implementing a Service Provider</h2>
<p>This section is intended for experienced programmers wishing to
create their own provider packages supplying certification path
service implementations. This section assumes you have read the
document: <a href="../crypto/HowToImplAProvider.html">How to
Implement a Provider for the Java Cryptography
Architecture</a>.</p>
<p>The following engine classes are defined in the Java
Certification Path API:</p>
<ul>
<li>
<p><b><code>CertPathValidator</code></b> - used to validate
certification paths</p>
</li>
<li>
<p><b><code>CertPathBuilder</code></b> - used to build
certification paths</p>
</li>
<li>
<p><b><code>CertStore</code></b> - used to retrieve certificates
and CRLs from a repository</p>
</li>
</ul>
<p>In addition, the pre-existing <code>CertificateFactory</code>
engine class was enhanced in the JDK 1.4 to support generation
of certification paths.</p>
<p>The application interfaces supplied by an engine class are
implemented in terms of a "Service Provider Interface" (SPI). The
name of each SPI class is the same as that of the corresponding
engine class, followed by "Spi". For example, the SPI class
corresponding to the <tt>CertPathValidator</tt> engine class is the
<tt>CertPathValidatorSpi</tt> class. Each SPI class is abstract. To
supply the implementation of a particular type of service, for a
specific algorithm or type, a provider must subclass the
corresponding SPI class and provide implementations for all the
abstract methods. For example, the <tt>CertStore</tt> class
provides access to the functionality of retrieving certificates and
CRLs from a repository. The actual implementation supplied in a
<tt>CertStoreSpi</tt> subclass would be that for a specific type of
certificate repository, such as LDAP.</p>
<h3>Steps to Implement and Integrate a Provider</h3>
<p>Developers should follow the required <a href=
"../crypto/HowToImplAProvider.html#Steps">steps listed in the
<i>How To Implement A Provider for the Java Cryptography
Architecture</i> document.</a> Here are some additional
rules to follow for certain steps:</p>

<p><b>Step 3: Write your "Master Class", a subclass of
Provider</b></p>
<p>These are the properties that must be defined for the
certification path services, where the algorithm name is
substituted for <i>algName</i>, and certstore type for
<i>storeType</i>:<br />
<br /></p>
<ul>
<li>
<p><tt>CertPathValidator</tt>.<i>algName</i></p>
</li>
<li>
<p><tt>CertPathBuilder</tt>.<i>algName</i></p>
</li>
<li>
<p><tt>CertStore</tt>.<i>storeType</i></p>
</li>
</ul>
<p>See <a href="#AppA">Appendix A</a> for the standard names that
are defined for <i>algName</i> and <i>storeType</i>. The value of
each property must be the fully qualified name of the class
implementing the specified algorithm, or certstore type. That is,
it must be the package name followed by the class name, where the
two are separated by a period. For example, a provider sets the
<code>CertPathValidator.PKIX</code> property to have the value
"sun.security.provider.certpath.PKIXCertPathValidator" as
follows:</p>
<pre class="codeblock">
put("CertPathValidator.PKIX", "sun.security.provider.certpath.PKIXCertPathValidator")
</pre>
<p>In addition, service attributes can be defined for the
certification path services. These attributes can be used as
filters for selecting service providers. See Appendix A for the
definition of some standard service attributes. For example, a
provider may set the <code>ValidationAlgorithm</code> service
attribute to the name of an RFC or specification that defines the
PKIX validation algorithm:</p>
<pre class="codeblock">
put("CertPathValidator.PKIX ValidationAlgorithm", "RFC3280");
</pre>
<p><b>Step 8: Document your Provider and its Supported
Services</b></p>
<p>Certification path service providers should document the
following information for each SPI:</p>

<p><b>Certificate Factories</b></p>
<p>A provider should document what types of certification paths
(and the version numbers of the certificates in the path, if
relevant) can be created by the factory. A provider should describe
the ordering of the certificates in the certification path, as well
as the contents.</p>
<p>A provider should document the list of encoding formats
supported. This is not technically necessary, since the client can
request them by calling the <tt>getCertPathEncodings</tt> method.
However, the documentation should describe each encoding format in
more detail and reference any standards when applicable.</p>
<p><b>Certification Path Validators</b></p>
<p>A provider should document any relevant information regarding
the <tt>CertPathValidator</tt> implementation, including the types
of certification paths that it validates. In particular, a PKIX
<tt>CertPathValidator</tt> implementation should document the
following information:</p>
<ul>
<li>The RFC or specification it is compliant with.</li>
<li>The mechanism it uses to check that certificates have not been
revoked.</li>
<li>Any optional certificate or CRL extensions that it recognizes
and how it processes them.</li>
</ul>
<p><b>Certification Path Builders</b></p>
<p>A provider should document any relevant information regarding
the <tt>CertPathBuilder</tt> implementation, including the types of
certification paths that it creates and whether or not they are
validated. In particular a PKIX <tt>CertPathBuilder</tt>
implementation should document the following information:</p>
<ul>
<li>The RFC or specification it is compliant with.</li>
<li>The mechanism it uses to check that certificates have not been
revoked.</li>
<li>Any optional certificate or CRL extensions that it recognizes
and how it processes them.</li>
<li>Details on the algorithm it uses for finding certification
paths. Ex: depth-first, breadth-first, forward (i.e., from target
to trust anchor(s)), reverse (i.e., from trust anchor(s) to
target).</li>
<li>The algorithm it uses to select and sort potential
certificates. For example, given two certificates that are
potential candidates for the next certificate in the path, what
criteria are used to select one before the other? What criteria are
used to reject a certificate?</li>
<li>If applicable, the algorithm it uses for backtracking or
constructing another path (i.e., when potential paths do not meet
constraints).</li>
<li>The types of <tt>CertStore</tt> implementations that have been
tested. The implementation should be designed to work with any
<tt>CertStore</tt> type, but this information may still be
useful.</li>
</ul>
<p>All <tt>CertPathBuilder</tt> implementations should provide
additional debugging support, in order to analyze and correct
potential path building problems. Details on how to access this
debugging information should be documented.</p>
<p><b>Certificate/CRL Stores</b></p>
<p>A provider should document what types of certificates and CRLs
(and the version numbers, if relevant) are retrieved by the
<tt>CertStore</tt>.</p>
<p>A provider should also document any relevant information
regarding the <tt>CertStore</tt> implementation (such as
protocols used or formats supported). For example, an LDAP
<tt>CertStore</tt> implementation should describe which versions of
LDAP are supported and which standard attributes are used for
finding certificates and CRLs. It should also document if the
implementation caches results, and for how long (i.e., under what
conditions are they refreshed).</p>
<p>If the implementation returns the certificates and CRLs in a
particular order, it should describe the sorting algorithm. An
implementation should also document any additional or default
initialization parameters.<br />
<br />
Finally, an implementation should document if and how it uses
information in the <tt>CertSelector</tt> or <tt>CRLSelector</tt>
objects to find certificates and CRLs.</p>


<h3>Service Interdependencies</h3>
<p>Here are some common types of algorithm interdependencies in
certification path service implementations:</p>

<p><b>Certification Path Validation and Signature
Algorithms</b></p>
<p>A <tt>CertPathValidator</tt> implementation often requires use
of a signature algorithm to verify each certificate's digital
signature. The <tt>setSigProvider</tt> method of the
<tt>PKIXParameters</tt> class allows a user to specify a specific
<tt>Signature</tt> provider.</p>
<p><b>Certification Path Builders and Certificate Factories</b></p>
<p>A <tt>CertPathBuilder</tt> implementation will often utilize a
<tt>CertificateFactory</tt> to generate a certification path from a
list of certificates.</p>
<p><b>CertStores and Certificate Factories</b></p>
<p>A <tt>CertStore</tt> implementation will often utilize a
<tt>CertificateFactory</tt> to generate certificates and CRLs from
their encodings. For example, an LDAP <tt>CertStore</tt>
implementation may use an X.509 <tt>CertificateFactory</tt> to
generate X.509 certificates and CRLs from their ASN.1 encoded form.
&nbsp;</p>

<h3>Certification Path Parameter Specification Interfaces</h3>
<p>The Certification Path API contains two interfaces representing
<i>transparent</i> specifications of parameters, the
<tt>CertPathParameters</tt> and <tt>CertStoreParameters</tt>
interfaces.</p>
<p>Two implementations of the <tt>CertPathParameters</tt> interface
are included, the <tt>PKIXParameters</tt> and
<tt>PKIXBuilderParameters</tt> classes. If you are working with
PKIX certification path validation and algorithm parameters, you
can utilize these classes. If you need parameters for a different
algorithm, you will need to supply your own
<tt>CertPathParameters</tt> implementation for that algorithm.</p>
<p>Two implementations of the <tt>CertStoreParameters</tt>
interface are included, the <tt>LDAPCertStoreParameters</tt> and
the <tt>CollectionCertStoreParameters</tt> classes. These classes
are to be used with LDAP and Collection <tt>CertStore</tt>
implementations, respectively. If you need parameters for a
different repository type, you will need to supply your own
<tt>CertStoreParameters</tt> implementation for that type.</p>
<p>The <code>CertPathParameters</code> and
<code>CertStoreParameters</code> interfaces each define a
<code>clone</code> method that implementations should override. A
typical implementation will perform a "deep" copy of the object,
such that subsequent changes to the copy will not affect the
original (and vice versa). However, this is not an absolute
requirement for implementations of
<code>CertStoreParameters</code>. A shallow copy implementation of
<code>clone</code> is more appropriate for applications that need
to hold a reference to a parameter contained in the
<code>CertStoreParameters</code>. For example, since
<code>CertStore.getInstance</code> makes a clone of the specified
<code>CertStoreParamter</code>s, a shallow copy <code>clone</code>
allows an application to hold a reference to and later release the
resources of a particular <code>CertStore</code> initialization
parameter, rather than waiting for the garbage collection
mechanism. This should be done with the utmost care, since the
<code>CertStore</code> may still be in use by other threads.</p>
<h3>Certification Path Result Specification Interfaces</h3>
<p>The Certification Path API contains two interfaces representing
<i>transparent</i> specifications of results, the
<tt>CertPathValidatorResult</tt> and <tt>CertPathBuilderResult</tt>
interfaces.</p>
<p>One implementation for each of the interfaces is included: the
<tt>PKIXCertPathValidatorResult</tt> and
<tt>PKIXCertPathBuilderResult</tt> classes. If you are implementing
PKIX certification path service providers, you can utilize these
classes. If you need certification path results for a different
algorithm, you will need to supply your own
<tt>CertPathValidatorResult</tt> or <tt>CertPathBuilderResult</tt>
implementation for that algorithm.</p>
<p>A PKIX implementation of a <tt>CertPathValidator</tt> or a
<tt>CertPathBuilder</tt> may find it useful to store additional
information in the <tt>PKIXCertPathValidatorResult</tt> or
<tt>PKIXCertPathBuilderResult</tt>, such as debugging traces. In
these cases, the implementation should implement a subclass of the
appropriate result class with methods to retrieve the relevant
information. These classes must be shipped with the provider
classes, for example, as part of the provider JAR file.</p>
<h3>Certification Path Exception Classes</h3>
The Certification Path API contains a set of exception classes for
handling errors. <tt>CertPathValidatorException,
CertPathBuilderException</tt>, and <code>CertStoreException</code>
are subclasses of <tt>GeneralSecurityException</tt>.<br />
<br />
You may need to extend these classes in your service provider
implementation. For example, a <tt>CertPathBuilder</tt>
implementation may provide additional information such as debugging
traces when a <tt>CertPathBuilderException</tt> is thrown. The
implementation may throw a subclass of
<tt>CertPathBuilderException</tt> that holds this information.
Likewise, a <tt>CertStore</tt> implementation can provide
additional information when a failure occurs by throwing a subclass
of <tt>CertStoreException</tt>. Also, you may want to implement a
subclass of <tt>CertPathValidatorException</tt> to describe a
particular failure mode of your <tt>CertPathValidator</tt>
implementation.<br />
<br />
In each case, the new exception classes must be shipped with the
provider classes, for example, as part of the provider JAR file.
Each provider should document the exception subclasses.
<h3>TrustAnchor Class</h3>
<p>As previously mentioned, a PKIX
<code>CertPathValidator</code> or <code>CertPathBuilder</code> is
not required to support the <code>nameConstraints</code> parameter
of the <code>TrustAnchor</code> class. Implementations should throw
an <code>InvalidAlgorithmParameterException</code> if this
parameter is not supported.</p>

<!-- -->

<h2><a name="StS" id=
"StS"></a>Signature Timestamp Support</h2>

<h3><a name=INTRO>Introduction</a></h3>
<p>
This section describes the enhancements that have been added
to support signature timestamps.
</p>
 
<p>
Prior to Java SE 5.0, the signature generated by 
<code>jarsigner</code> contained no information about w
hen the signature was generated. With no other
information available, systems/deployers (including users of the Java
Plug-in) often based their validity assessment of a signed JAR file on
the validity of the signing certificate. When the signing certificate
expires, systems/deployers conclude that the signature, and hence, the
JAR file, has expired. Because signing certificates typically expire
annually, this caused customers significant problems by forcing them
to re-sign deployed JAR files annually.
</p>

<p>
Starting in Java SE 5.0, <code>jarsigner</code> can generate signatures that include a
timestamp, thus enabling systems/deployer (including Java Plug-in) to
check whether the JAR file was signed while the signing certificate was
still valid. In addition, APIs were added in Java SE 5.0 to allow applications
to obtain the timestamp information.
</p>

<p>
The following time-of-signing enhancements and additions are supported:
</p>
<ul>
<li><a href="#JARSIGNER">Jarsigner Enhancements</a>
<li><a href="#JAVAPLUGIN">Java Plug-in Enhancements</a>
<li><a href="#APIENHANCE">API Enhancements</a>
</ul>
 
<h3><a name="JARSIGNER">Jarsigner Enhancements</a></h3>
<p>
The <code>jarsigner</code> tool can now generate and store a signature timestamp 
when signing a JAR file. In addition, <code>jarsigner</code> supports alternative
signing mechanisms. This behavior is optional and is controlled by 
the user at the time of signing through the options described below.
</p>
 
<h4>Jarsigner Timestamp Options</h4>
<p>
The following <code>jarsigner</code> options support signature timestamps:
</p>

<p>
<code>-tsa url</code>
</p>
<p>
If <code>"-tsa http://example.tsa.url"</code> appears on the command line when 
signing a JAR file then a timestamp is generated for the signature. The URL,
<code>http://example.tsa.url</code>, identifies the location of the Time Stamping 
Authority (TSA). It overrides any URL found via the <code>-tsacert</code>
option. The <code>-tsa</code> option does not require the 
TSA's public key certificate to be present in the keystore.
</p>

<p> 
To generate the timestamp, <code>jarsigner</code> communicates with the TSA 
using the Time-Stamp Protocol (TSP) defined in 
<a href="http://www.ietf.org/rfc/rfc3161.txt">RFC 3161</a>. 
If successful, the timestamp token returned by the TSA is stored along with 
the signature in the signature block file.
</p>

<p>
<code>-tsacert alias</code>
</p>
<p>
If <code>"-tsacert alias"</code> appears on the command line when signing a 
JAR file then a timestamp is generated for the signature.  The <code>alias</code> 
identifies the TSA's public key certificate in the keystore that is currently in 
effect. The entry's certificate is examined for a Subject Information Access 
extension that contains a URL identifying the location of the TSA. 
</p>

<p>
The TSA's public key certificate must be present in the keystore when using 
<code>-tsacert</code>.
</p>
 
<h4>Alternative Signing Options</h4>
 
<h5>Specifying an Alternative Signing Mechanism</h5>
 
<p>
<code>-altsigner  class</code>
</p>
<p>
Specifies that an alternative signing mechanism be used. The fully-qualified
class name identifies a class file that extends the
<code>com.sun.jarsigner.ContentSigner abstract class</code>. The path to this 
class file is defined by the <code>-altsignerpath</code> option. If the 
<code>-altsigner</code> option is used, <code>jarsigner</code> uses the signing 
mechanism provided by the specified class. 
Otherwise, <code>jarsigner</code> uses its default signing mechanism.
</p>

<p>
For example, to use the signing mechanism provided by a class named
<code>com.sun.sun.jarsigner.AuthSigner</code>, use the <code>jarsigner</code> 
option <code>"-altsigner com.sun.jarsigner.AuthSigner"</code>
</p>
 
<h5>Specifying Path to Alternative Signing Mechanism</h5>
 
<p>
<code>-altsignerpath  classpathlist</code>
</p>
 
<p>
Specifies the path to the class file (the class file name is specified with 
the <code>-altsigner</code> option described above) and any JAR files it 
depends on. If the class file is in a JAR file, 
then this specifies the path to that JAR file, as shown in the example below.
</p>

<p>
An absolute path or a path relative to the current directory may be
specified. If <code>classpathlist</code> contains multiple paths or JAR files, 
they should be separated with a colon (<code>:</code>) on Solaris and a 
semi-colon (<code>;</code>) on Windows. This option is not necessary if the 
class is already in the search path.
</p>

<p> 
Example of specifying the path to a jar file that contains the class file:
</p>
<pre>    -altsignerpath /home/user/lib/authsigner.jar</pre>

<p>
Note that the JAR file name is included.
</p>

<p>
Example of specifying the path to the jar file that contains the class file:
</p>
<pre>    -altsignerpath /home/user/classes/com/sun/tools/jarsigner/</pre>
<p>
Note that the JAR file name is omitted.
</p>
 
<h3><a name=JAVAPLUGIN>Java Plug-in Enhancements</a></h3>
<p>
In Java SE 5.0, the Java Plug-in was enhanced to check signature timestamps
(if available) when validating  JAR files. The Java Plug-in will no
longer present a dialog when it encounters an expired or revoked
certificate when validating a signed jar, provided that the signature
timestamp confirms that the signature was generated prior to the
expiration or revocation date.
</p>

<p>
The TSA's certificate must be available from the Plug-in's 
keystore or certificate stores when the Plug-in is validating a JAR file 
containing a signature timestamp.
</p>

<p>
The Plug-in reverts to 1.4.x behavior if the signature does not contain
a timestamp.
</p>
 
<h3><a name=APIENHANCE>API Enhancements</a></h3>
<p>
The security and JAR APIs were enhanced to enable applications to
access timestamp information.
</p>

<p>
Two new classes were added to the <tt>java.security</tt> package.
These classes
are <a href="../../../../api/java/security/CodeSigner.html">CodeSigner</a>, 
which maintains information associated with a signer, and 
<a href="../../../../api/java/security/Timestamp.html">Timestamp</a>,
which represents information associated with a signature timestamp.
</p>

<p>
New methods were added to the 
<tt><a href="../../../../api/java/security/CodeSource.html#getCodeSigners--">
java.security.CodeSource</a></tt>
class and
<tt><a href="../../../../api/java/util/jar/JarEntry.html#getCodeSigners--">
java.util.jar.JarEntry</a></tt>
class to allow access to this new, optional information.
</p>

<!-- -->

<h2><a name="AppA" id=
"AppA"></a>Appendix A: Standard Names</h2>
<p>The Java Certification Path
API requires and utilizes a set of standard names for certification
path validation algorithms, encodings and certificate storage
types. The standard names previously found here in Appendix A and
in the other security specifications (JCA/JSSE/etc.) have been
combined in the <a href="../StandardNames.html">Standard Names
document</a>. Specific provider information can be found in the
<a href="../SunProviders.html">Sun Provider
Documentation</a>.</p>
<p>Please note that a service
provider may choose to define a new name for a proprietary or
non-standard algorithm that is not mentioned in the Standard Names
document. However, to prevent name collisions, it is recommended
that the name be prefixed with the reverse Internet domain name of
the provider's organization (for example:
<code>com.sun.MyCertPathValidator</code>).</p>
<hr />
<h2><a name="AppB" id=
"AppB">Appendix B: The "SUN" Provider</a></h2>
The CertPath implementation in
the SUN provider as of Java SE 5 passed the <a href=
"http://csrc.nist.gov/pki/testing/x509paths.html">Public Key
Interoperability Test Suite (PKITS)</a>.
<p>The "SUN" provider supports
the following standard algorithms, types and encodings:</p>
<ul>
<li><code>CertificateFactory</code>: <b>X.509</b>
<code>CertPath</code> type with <b>PKCS7</b> and <b>PkiPath</b>
encodings</li>
<li><code>CertPathValidator</code>: <b>PKIX</b>
algorithm</li>
<li><code>CertPathBuilder</code>:
<b>PKIX</b> algorithm</li>
<li><code>CertStore</code>:
<b>LDAP</b> and <b>Collection</b> <code>CertStore</code>
types</li>
</ul>
Each of these service provider
interface implementations is discussed in more detail below.
<h3>CertificateFactory</h3>
The "SUN" provider for the
<code>CertificateFactory</code> engine class has been enhanced to
support generation of X.509 <code>CertPath</code> objects. The
PKCS7 and PkiPath encodings are supported. The PKCS#7
implementation supports a subset of <a href=
"http://www.ietf.org/rfc/rfc2315.txt">RFC 2315</a> (only the
SignedData ContentInfo type is supported). The certificates in the
<code>CertPath</code> are ordered in the forward direction (from
target to trust anchor). Each certificate in the
<code>CertPath</code> is of type
<code>java.security.cert.X509Certificate</code>, and versions 1, 2
and 3 are supported.
<h3>CertPathValidator</h3>
<p>The "SUN" provider supplies a PKIX implementation of the
<code>CertPathValidator</code> engine class. The implementation
validates <code>CertPath</code>s of type X.509 and implements the
certification path validation algorithm defined in <a href=
"http://www.ietf.org/rfc/rfc3280.txt">RFC 3280: <i>PKIX Certificate
and CRL Profile</i></a>. This implementation sets the
<code>ValidationAlgorithm</code> service attribute to
"RFC3280".</p>
<p>In the Java SE 7 release, weak cryptographic algorithms can be
disabled in the "SUN" provider using a security property. The
<code>jdk.certpath.disabledAlgorithms</code> property is a list of
disabled algorithms that applies to certificate path verification.</p>
<p>From JDK 8 onwards the default value of <code>jdk.certpath.disabledAlgorithms</code>
is as follows:</p>
<pre class="codeblock">
    jdk.certpath.disabledAlgorithms=MD2, RSA keySize &lt; 1024
</pre>
<p>This means that no signature algorithm involving MD2 will be used to verify a certificate. And use of certificates with RSA key size of less than 1024 bits in length is restricted. <a href="#AppD">Appendix D</a> has examples of values for
<code>jdk.certpath.disabledAlgorithms</code>.</p>
<p>The PKIX Certificate and CRL
Profile has many optional features. The "SUN" provider implements
support for the policy mapping, <a href="#AIA">authority
information access</a> and <a href="#CRLDP">CRL distribution point
certificate</a> extensions, the issuing distribution point CRL
extension, and the reason code and certificate issuer CRL entry
extensions. It does not implement support for the freshest CRL or
subject information access certificate extensions. It also does not
include support for the freshest CRL and delta CRL Indicator CRL
extensions and the invalidity date and hold instruction code CRL
entry extensions.</p>
<p>The implementation supports a
CRL revocation checking mechanism that conforms to section 6.3 of
the PKIX Certificate and CRL Profile. OCSP (<a href=
"http://www.ietf.org/rfc/rfc2560.txt">RFC 2560</a>) is also
currently supported as a built in revocation checking mechanism.
See <a href="#AppC">Appendix C</a> for more details on the
implementation and configuration and how it works in conjunction
with CRLs.</p>
<p>The implementation does not
support the <code>nameConstraints</code> parameter of the
<code>TrustAnchor</code> class and the <code>validate</code> method
throws an <code>InvalidAlgorithmParameterException</code> if it is
specified.</p>
<h3>CertPathBuilder</h3>
The "SUN" provider supplies a
PKIX implementation of the <code>CertPathBuilder</code> engine
class. The implementation builds <code>CertPath</code>s of type
X.509. Each <code>CertPath</code> is validated according to the
PKIX algorithm defined in <a href=
"http://www.ietf.org/rfc/rfc3280.txt">RFC 3280: <i>PKIX Certificate
and CRL Profile</i></a>. This implementation sets the
<code>ValidationAlgorithm</code> service attribute to
"RFC3280".
<p>The implementation requires
that the <code>targetConstraints</code> parameter of a
<code>PKIXBuilderParameters</code> object is an instance of
<code>X509CertSelector</code> and the subject criterion is set to a
non-null value. Otherwise the <code>build</code> method throws an
<code>InvalidAlgorithmParameterException</code>.</p>
<p>The implementation builds
<code>CertPath</code> objects in a forward direction using a
depth-first algorithm. It backtracks to previous states and tries
alternate paths when a potential path is determined to be invalid
or exceeds the <code>PKIXBuilderParameters</code>
<code>maxPathLength</code> parameter.</p>
<p>Validation of the path is performed in the same manner as the
<code>CertPathValidator</code> implementation. The implementation
validates most of the path as it is being built, in order to
eliminate invalid paths earlier in the process. Validation checks
that cannot be executed on certificates ordered in a forward
direction are delayed and executed on the path after it has been
constructed (but before it is returned to the application).</p>
<p>As with <code>CertPathValidator</code>, the
<code>jdk.certpath.disabledAlgorithms</code> security property can
be used to exclude cryptographic algorithms that are not considered
safe.</p>
<p>When two or more potential
certificates are discovered that may lead to finding a path that
meets the specified constraints, the implementation uses the
following criteria to prioritize the certificates (in the examples
below, assume a <code>TrustAnchor</code> distinguished name of
"ou=D,ou=C,o=B,c=A" is specified):</p>
<ol>
<li>The issuer DN of the
certificate matches the DN of one of the specified
<code>TrustAnchor</code>s (ex: issuerDN =
"ou=D,ou=C,o=B,c=A").</li>
<li>The issuer DN of the
certificate is a descendant of the DN of one of the
<code>TrustAnchor</code>s, ordered by proximity to the anchor (ex:
issuerDN = "ou=E,ou=D,ou=C,o=B,c=A").</li>
<li>The issuer DN of the
certificate is an ancestor of the DN of one of the
<code>TrustAnchor</code>s, ordered by proximity to the anchor (ex:
issuerDN = "ou=C,o=B,c=A".</li>
<li>The issuer DN of the
certificate is in the same namespace of one of the
<code>TrustAnchor</code>s, ordered by proximity to the anchor (ex:
issuerDN = "ou=G,ou=C,o=B,c=A").</li>
<li>The issuer DN of the
certificate is an ancestor of the subject DN of the certificate,
ordered by proximity to the subject.</li>
</ol>
These are followed by
certificates which don't meet any of the above criteria.
<p>This implementation has been
tested with the LDAP and Collection <code>CertStore</code>
implementations included in this release of the "SUN"
provider.</p>
<p>Debugging support can be
enabled by setting the <code>java.security.debug</code> property to
<code>certpath</code>. For example:</p>
<pre class="codeblock">
       java -Djava.security.debug=certpath BuildCertPath

</pre>
This will print additional
debugging information to standard error.
<h3>CertStore</h3>
The "SUN" provider supports two
implementations of the <code>CertStore</code> engine class:
Collection and LDAP.
<h3>Collection
CertStore</h3>
The Collection
<code>CertStore</code> implementation can hold any objects that are
an instance of <code>java.security.cert.Certificate</code> or
<code>java.security.cert.CRL</code>.
<p>The certificates and CRLs are
not returned in any particular order and will not contain
duplicates.</p>
<h3>LDAP CertStore</h3>
The LDAP <code>CertStore</code>
implementation retrieves certificates and CRLs from an LDAP
directory using the LDAP schema defined in <a href=
"http://www.ietf.org/rfc/rfc2587.txt">RFC 2587</a>. The LDAPSchema
service attribute is set to "RFC2587".
<p>The implementation fetches
certificates from different locations, depending on the values of
the subject, issuer, and basicConstraints selection criteria
specified in the <code>X509CertSelector</code>. It performs as many
of the following operations as possible:</p>
<ol>
<li>Subject non-null,
basicConstraints &lt;= -1
<p>Looks for certificates in the
subject DN's "userCertificate" attribute.</p>
</li>
<li>Subject non-null,
basicConstraints &gt;= -1
<p>Looks for certificates in the
forward element of the subject DN's "crossCertificatePair"
attribute AND in the subject's "caCertificate"
attribute.</p>
</li>
<li>Issuer non-null,
basicConstraints &gt;= -1
<p>Looks for certificates in the
reverse element of the issuer DN's "crossCertificatePair" attribute
AND in the issuer DN's "caCertificate" attribute.</p>
</li>
</ol>
<p>In each case, certificates are
checked using <code>X509CertSelector.match()</code> before adding
them to the resulting collection.</p>
<p>If none of the conditions
specified above applies, then an exception is thrown to indicate
that it was impossible to fetch certificates using the criteria
supplied. Note that even if one or more of the conditions apply,
the Collection returned may still be empty if there are no
certificates in the directory.</p>
<p>The implementation fetches
CRLs from the issuer DNs specified in the
<code>setCertificateChecking</code>, <code>addIssuerName</code> or
<code>setIssuerNames</code> methods of the
<code>X509CRLSelector</code> class. If no issuer DNs have been
specified using one of these methods, the implementation throws an
exception indicating it was impossible to fetch CRLs using the
criteria supplied. Otherwise, the CRLs are searched as
follows:</p>
<p>The implementation first
creates a list of issuer names. If a certificate was specified in
the <code>setCertificateChecking</code> method, it uses the issuer
of that certificate. Otherwise, it uses the issuer names specified
using the <code>addIssuerName</code> or <code>setIssuerNames</code>
methods.</p>
<p>Next, the implementation
iterates through the list of issuer names. For each issuer name, it
searches first in the issuer's "authorityRevocationList" attribute
and then, if no matching CRL was found there, in the issuer's
"certificateRevocationList" attribute. One exception to the above
is that if the issuer name was obtained from the certificate
specified in the <code>setCertificateChecking</code> method, it
only checks the issuer's "authorityRevocationList" attribute if the
specified certificate is a CA certificate.</p>
<p>All CRLs are checked using
<code>X509CRLSelector.match()</code> before adding them to the
resulting collection.</p>
<p>If no CRLs satisfying the
selection criteria can be found, an empty Collection is
returned.</p>
<h4>Caching</h4>
By default each LDAP CertStore
instance caches lookups for a maximum of 30 seconds. The cache
lifetime can be changed by setting the system property
<code>sun.security.certpath.ldap.cache.lifetime</code> to a value
in seconds. A value of <code>0</code> disables the cache
completely. A value of <code>-1</code> means unlimited
lifetime.
<h3><a name="CRLDP" id=
"CRLDP">Support for the CRL Distribution Points
Extension</a></h3>
Support for the CRL Distribution
Points extension is available. It is disabled by default for
compatibility and can be enabled by setting the system property
<code>com.sun.security.enableCRLDP</code> to the value
<code>true</code>.
<p>If set to true, Sun's PKIX
implementation uses the information in a certificate's CRL
Distribution Points extension (in addition to
<code>CertStore</code>s that are specified) to find the CRL,
provided the distribution point is an X.500 distinguished name or a
URI of type ldap, http, or ftp.</p>
<dl>
<dd><b>Note:</b> Depending on your network and firewall setup, it
may be necessary to also configure your networking proxy servers as
described in the <a href="../../net/properties.html">networking
documentation</a>.</dd>
</dl>
<h3><a name="AIA" id=
"AIA">Support for the Authority Information Access (AIA)
Extension</a></h3>
Support for the caIssuers access
method of the Authority Information Access extension is available.
It is disabled by default for compatibility and can be enabled by
setting the system property
<code>com.sun.security.enableAIAcaIssuers</code> to the value
<code>true</code>.
<p>If set to true, Sun's PKIX
implementation of <code>CertPathBuilder</code> uses the information
in a certificate's AIA extension (in addition to
<code>CertStore</code>s that are specified) to find the issuing CA
certificate, provided it is a URI of type ldap, http, or
ftp.</p>
<dl>
<dd><b>Note:</b> Depending on your network and firewall setup, it
may be necessary to also configure your networking proxy servers as
described in the <a href="../../net/properties.html">networking
documentation</a>.</dd>
</dl>
<hr />
<h2><a name="AppC" id=
"AppC">Appendix C: On-Line Certificate Status Protocol (OCSP)
Support</a></h2>
<p>Client-side support for the
On-Line Certificate Status Protocol (OCSP) as defined in <a href=
"http://www.ietf.org/rfc/rfc2560.txt">RFC 2560</a> is supported as
of JDK 5.0. OCSP checking is controlled by the following five
security properties:</p>
<table border="1" cellpadding="3" width="600" summary=
"Certification Status Protocol Support property names">
<tr>
<th id="h1">Property Name</th>
<th id="h2">Description</th>
</tr>
<tr>
<td headers="h1"><tt>ocsp.enable</tt></td>
<td headers="h2">This property's value is either true or false. If true, OCSP
checking is enabled when doing certificate revocation checking; if
false or not set, OCSP checking is disabled.</td>
</tr>
<tr>
<td headers="h1"><tt>ocsp.responderURL</tt></td>
<td headers="h2">This property's value is a URL that identifies the location of
the OCSP responder. Here is an example.
<pre class="codeblock">
ocsp.responderURL=http://ocsp.example.net:80
</pre>
<p>By default, the location of the OCSP responder is determined
implicitly from the certificate being validated. The property is
used when the Authority Information Access extension (defined in
RFC 3280) is absent from the certificate or when it requires
overriding.</p>
</td>
</tr>
<tr>
<td headers="h1"><tt>ocsp.responderCertSubjectName</tt></td>
<td headers="h2">This property's value is the subject name of the OCSP
responder's certificate. Here is an example.
<pre class="codeblock">
ocsp.responderCertSubjectName="CN=OCSP Responder, O=XYZ Corp"
</pre>
<p>By default, the certificate of the OCSP responder is that of the
issuer of the certificate being validated. This property identifies
the certificate of the OCSP responder when the default does not
apply. Its value is a string distinguished name (defined in RFC
2253) which identifies a certificate in the set of certificates
supplied during cert path validation. In cases where the subject
name alone is not sufficient to uniquely identify the certificate,
then both the <tt>ocsp.responderCertIssuerName</tt> and
<tt>ocsp.responderCertSerialNumber</tt> properties must be used
instead. When th is property is set, then those two properties are
ignored.</p>
</td>
</tr>
<tr>
<td headers="h1"><tt>ocsp.responderCertIssuerName</tt></td>
<td headers="h2">This property's value is the issuer name of the OCSP
responder's certificate . Here is an example.
<pre class="codeblock">
ocsp.responderCertIssuerName="CN=Enterprise CA, O=XYZ Corp"
</pre>
<p>By default, the certificate of the OCSP responder is that of the
issuer of the certificate being validated. This property identifies
the certificate of the OCSP responder when the default does not
apply. Its value is a string distinguished name (defined in RFC
2253) which identifies a certificate in the set of certificates
supplied during cert path validation. When this property is set
then the <tt>ocsp.responderCertSerialNumber</tt> property must also
be set. Note that this property is ignored when the
<tt>ocsp.responderCertSubjectName</tt> property has been set.</p>
</td>
</tr>
<tr>
<td headers="h1"><tt>ocsp.responderCertSerialNumber</tt></td>
<td headers="h2">This property's value is the serial number of the OCSP
responder's certificate Here is an example.
<pre class="codeblock">
ocsp.responderCertSerialNumber=2A:FF:00
</pre>
<p>By default, the certificate of the OCSP responder is that of the
issuer of the certificate being validated. This property identifies
the certificate of the OCSP responder when the default does not
apply. Its value is a string of hexadecimal digits (colon or space
separators may be present) which identifies a certificate in the
set of certificates supplied during cert path validation. When this
property is set then the <tt>ocsp.responderCertIssuerName</tt>
property must also be set. Note that this property is ignored when
the <tt>ocsp.responderCertSubjectName</tt> property has been
set.</p>
</td>
</tr>
</table>
<p>These properties may be set
either staticly in the Java runtime's
<tt>$JAVA_HOME/jre/lib/security/java.security</tt> file, or
dynamically using the <tt>java.security.Security.setProperty()</tt>
method.</p>
<p>By default, OCSP checking is
not enabled. It is enabled by setting the <tt>ocsp.enable</tt>
property to <tt>"true"</tt>. Use of the remaining properties is
optional. Note that enabling OCSP checking only has an effect if
revocation checking has also been enabled. Revocation checking is
enabled via the <tt>
<!-- <a href="../../../../api/java/security/cert/PKIXParameters.html#setRevocationEn
abled(boolean)"> -->PKIXParameters.setRevocationEnabled() 
<!-- </a> --></tt> method.</p>
<p>OCSP checking works in
conjunction with Certificate Revocation Lists (CRLs) during
revocation checking. Below is a summary of the interaction of OCSP
and CRLs. Failover to CRLs occurs only if an OCSP problem is
encountered. Failover does not occur if the OCSP responder confirms
either that the certificate has been revoked or that it has not
been revoked.</p>
<table border="1" cellpadding="3" width="600" summary=
"summary of the interaction of OCSP and CRLs">
<tr>
<th id="h101">PKIXParameters RevocationEnabled (default=true)</th>
<th id="h102"><tt>ocsp.enable</tt> (default=false)</th>
<th id="h103">Behavior</th>
</tr>
<tr>
<td headers="h101">true</td>
<td headers="h102">true</td>
<td headers="h103">Revocation checking using OCSP,<br />
failover to using CRLs</td>
</tr>
<tr>
<td headers="h101">true</td>
<td headers="h102">false</td>
<td headers="h103">Revocation checking using CRLs only</td>
</tr>
<tr>
<td headers="h101">false</td>
<td headers="h102">true</td>
<td headers="h103">No revocation checking</td>
</tr>
<tr>
<td headers="h101">false</td>
<td headers="h102">false</td>
<td headers="h103">No revocation checking</td>
</tr>
</table>
<hr />
<h2><a name="AppD" id=
"AppD"></a>Appendix D: Disabling Cryptographic
Algorithms</h2>
<p>The <code>jdk.certpath.disabledAlgorithms</code> security
property contains a list of cryptographic algorithms that will not
be used during certification path processing. The exact syntax of
the property is described in the
<code>jre/lib/security/java.security</code> file, but is briefly
summarized here.</p>
<p>The security property contains a list of cryptographic
algorithms that must not be used. The algorithm names are separated
by commas. Furthermore, you can also specify restrictions on key
sizes.</p>
<p>For example, the following line in <code>java.security</code>
specifies that the MD2 and DSA algorithms must not be used for
certification path processing. Furthermore, RSA is disabled for key
sizes less than 2048 bits.</p>
<pre class="codeblock">
jdk.certpath.disabledAlgorithms=MD2, DSA, RSA keySize &lt; 2048
</pre>
<hr />

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
