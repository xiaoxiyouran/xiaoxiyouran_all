<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<!-- *********************************** -->
<head>
<title>JSSE Reference Guide</title>
<link rel="stylesheet" type="text/css" href="../../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>Java Secure Socket Extension (JSSE) Reference Guide</h1>
<p>This guide covers the following topics:</p>
<div class="a1"><a href="#maincontent" class="skiplink">Skip
Navigation Links</a></div>
<ul>
<li><a href="#Introduction">Introduction</a>
<ul>
<li><a href="#Features">Features and Benefits</a></li>
<li><a href="#StandardAPI">JSSE Standard API</a></li>
<li><a href="#SunJSSE">SunJSSE Provider</a></li>
<li><a href="#RelatedDocs">Related Documentation</a></li>
</ul>
</li>
<li><a href="#javaHome">The JRE Installation Directory</a></li>
<li><a href="#Terms">Terms and Definitions</a></li>
<li><a href="#SSLOverview">Secure Sockets Layer (SSL) Protocol
Overview</a>
<ul>
<li><a href="#WhySSL">Why Use SSL?</a></li>
<li><a href="#HowSSLWorks">How SSL Works</a></li>
</ul>
</li>
<li><a href="#JSSEClasses">JSSE Classes and Interfaces</a>
<ul>
<li><a href="#CoreClasses">Core Classes and Interfaces</a>
<ul>
<li><a href="#SocketFactory">SocketFactory and ServerSocketFactory
Classes</a></li>
<li><a href="#SSLSocketFactory">SSLSocketFactory and
SSLServerSocketFactory Classes</a></li>
<li><a href="#SSLSocket">SSLSocket and SSLServerSocket
Classes</a></li>
<li><a href="#SSLEngine">SSLEngine Class</a></li>
<li><a href="#SSLSession">SSLSession and ExtendedSSLSession
Interfaces</a></li>
<li><a href="#HttpsURLConnection">HttpsURLConnection Class</a></li>
</ul>
</li>
<li><a href="#SupportClasses">Support Classes and Interfaces</a>
<ul>
<li><a href="#SSLContext">SSLContext Class</a></li>
<li><a href="#TrustManager">TrustManager Interface</a></li>
<li><a href="#TrustManagerFactory">TrustManagerFactory
Class</a></li>
<li><a href="#X509TrustManager">X509TrustManager Interface</a></li>
<li><a href="#X509ExtendedTrustManager">X509ExtendedTrustManager
Class</a></li>
<li><a href="#KeyManager">KeyManager Interface</a></li>
<li><a href="#KeyManagerFactory">KeyManagerFactory Class</a></li>
<li><a href="#X509KeyManager">X509KeyManager Interface</a></li>
<li><a href="#X509ExtendedKeyManager">X509ExtendedKeyManager
Class</a></li>
<li><a href="#RelsTM_KM">Relationship Between a TrustManager and a
KeyManager</a></li>
</ul>
</li>
<li><a href="#SecondarySupportClasses">Secondary Support Classes
and Interfaces</a>
<ul>
<li><a href="#SSLParameters">SSLParameters Class</a>
<ul>
<li><a href="#cipher_suite_preference">Cipher Suite
Preference</a></li>
</ul>
</li>
<li><a href="#SSLSessionContext">SSLSessionContext
Interface</a></li>
<li><a href="#SSLSessionBindingListener">SSLSessionBindingListener
Interface</a></li>
<li><a href="#SSLSessionBindingEvent">SSLSessionBindingEvent
Class</a></li>
<li><a href=
"#HandShakeCompletedListener">HandShakeCompletedListener
Interface</a></li>
<li><a href="#HandShakeCompletedEvent">HandShakeCompletedEvent
Class</a></li>
<li><a href="#HostnameVerifier">HostnameVerifier Interface</a></li>
<li><a href="#X509Certificate">X509Certificate Class</a></li>
<li><a href="#AlgorithmConstraints">AlgorithmConstraints
Interface</a></li>
<li><a href="#StandardConstants">StandardConstants Class</a></li>
<li><a href="#SNIServerName">SNIServerName Class</a></li>
<li><a href="#SNIMatcher">SNIMatcher Class</a></li>
<li><a href="#SNIHostName">SNIHostName Class</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#InstallationAndCustomization">Customizing
JSSE</a></li>
<li><a href="#tlsRenegotiation">Transport Layer Security (TLS)
Renegotiation Issue</a>
<ul>
<li><a href="#phased">Phased Approach to Fixing This Issue</a></li>
<li><a href="#descPhase2">Description of the Phase 2 Fix</a></li>
<li><a href="#workarounds">Workarounds and Alternatives to SSL/TLS
Renegotiation</a></li>
<li><a href="#implDetails">Implementation Details</a></li>
<li><a href="#descPhase1">Description of the Phase 1 Fix</a></li>
<li><a href="#allowUnsafeCert">Allow Unsafe Server Certificate
Change in SSL/TLS renegotiations</a></li>
</ul>
</li>
<li><a href="#PKCS11">Hardware Acceleration and Smartcard
Support</a>
<ul>
<li><a href="#ConfigSmartcard">Configuring JSSE to Use Smartcards
as Keystores and Truststores</a></li>
<li><a href="#MultiDynamicKeystores">Multiple and Dynamic
Keystores</a></li>
</ul>
</li>
<li><a href="#KRB">Kerberos Cipher Suites</a>
<ul>
<li><a href="#KRBRequire">Kerberos Requirements</a></li>
<li><a href="#KRBPeerID">Peer Identity Information</a></li>
<li><a href="#KRBSM">Security Manager</a></li>
</ul>
</li>
<li><a href="#KeystoreFormats">Additional Keystore Formats
(PKCS12)</a></li>
<li><a href="#SNIExtension">Server Name Indication (SNI)
Extension</a></li>
<li><a href="#Troubleshooting">Troubleshooting</a>
<ul>
<li><a href="#InstallProbs">Configuration Problems</a></li>
<li><a href="#Debug">Debugging Utilities</a></li>
</ul>
</li>
<li><a href="#CodeExamples">Code Examples</a>
<ul>
<li><a href="#UnsecureSecure">Converting an Unsecure Socket to a
Secure Socket</a></li>
<li><a href="#SampleCode">Running the JSSE Sample Code</a></li>
<li><a href="#CreateKeystore">Creating a Keystore to Use with
JSSE</a></li>
<li><a href="#SNIExamples">Using the Server Name Indication (SNI)
Extension</a></li>
</ul>
</li>
<li><a href="#AppA">Appendix A: Standard Names</a></li>
<li><a href="#PLUG">Appendix B: Provider Pluggability</a></li>
</ul>
<hr width="100%" />
<a name="maincontent" id="maincontent"></a> 
<!-- *********************************************** -->
<h2><a name="Introduction" id="Introduction">Introduction</a></h2>
<p>Data that travels across a network can easily be accessed by
someone who is not the intended recipient. When the data includes
private information, such as passwords and credit card numbers,
steps must be taken to make the data unintelligible to unauthorized
parties. It is also important to ensure that the data has not been
modified, either intentionally or unintentionally, during
transport. The Secure Sockets Layer (SSL) and Transport Layer
Security (TLS) protocols were designed to help protect the privacy
and integrity of data while it is being transferred across a
network.</p>
<p>The Java Secure Socket Extension (JSSE) enables secure Internet
communications. It provides a framework and an implementation for a
Java version of the SSL and TLS protocols and includes
functionality for data encryption, server authentication, message
integrity, and optional client authentication. Using JSSE,
developers can provide for the secure passage of data between a
client and a server running any application protocol (such as HTTP,
Telnet, or FTP) over TCP/IP. For an introduction to SSL, see
<a href="#SSLOverview">Secure Sockets Layer (SSL) Protocol
Overview</a>.</p>
<p>By abstracting the complex underlying security algorithms and
handshaking mechanisms, JSSE minimizes the risk of creating subtle
but dangerous security vulnerabilities. Furthermore, it simplifies
application development by serving as a building block that
developers can integrate directly into their applications.</p>
<p>JSSE provides both an application programming interface (API)
framework and an implementation of that API. The JSSE API
supplements the core network and cryptographic services defined by
the <code>java.security</code> and <code>java.net</code> packages
by providing extended networking socket classes, trust managers,
key managers, SSL contexts, and a socket factory framework for
encapsulating socket creation behavior. Because the
<code>SSLSocket</code> class is based on a blocking I/O model, the
Java Development Kit (JDK) includes a nonblocking
<code>SSLEngine</code> class to enable implementations to choose
their own I/O methods.</p>

<p>The JSSE API is capable of supporting SSL versions 2.0 and 3.0
and TLS version 1.0. These security protocols encapsulate a normal
bidirectional stream socket, and the JSSE API adds transparent
support for authentication, encryption, and integrity protection.
The JSSE implementation shipped with the JDK supports SSL 3.0,
TLS (1.0, 1.1, and 1.2) and DTLS (version 1.0 and 1.2).
It does not implement SSL 2.0.</p>

<p>JSSE is a security component of the Java SE platform, and is
based on the same design principles found elsewhere in the <a href=
"../crypto/CryptoSpec.html#Design">Java Cryptography Architecture
(JCA)</a> framework. This framework for cryptography-related
security components allows them to have implementation independence
and, whenever possible, algorithm independence. JSSE uses the
<a href="../crypto/CryptoSpec.html#ProviderArch">cryptographic
service providers</a> defined by the JCA framework.</p>
<p>Other security components in the Java SE platform include the
<a href="../jaas/JAASRefGuide.html">Java Authentication and
Authorization Service (JAAS)</a> and the <a href=
"../../../tools/index.html#security">Java Security Tools</a>. JSSE
encompasses many of the same concepts and algorithms as those in
JCA but automatically applies them underneath a simple stream
socket API.</p>
<p>The JSSE API was designed to allow other SSL/TLS protocol and
Public Key Infrastructure (PKI) implementations to be plugged in
seamlessly. Developers can also provide alternative logic to
determine if remote hosts should be trusted or what authentication
key material should be sent to a remote host.</p>
<!-- *********************************************** -->
<h3><a name="Features" id="Features">Features and Benefits</a></h3>
<p>JSSE includes the following important features:</p>
<ul>
<li>Included as a standard component of the JDK</li>
<li>Extensible, provider-based architecture</li>
<li>Implemented in 100% pure Java</li>
<li>Provides API support for SSL versions 2.0 and 3.0, TLS 1.0 and
later, and an implementation of SSL 3.0 and TLS 1.0</li>
<li>Includes classes that can be instantiated to create secure
channels (<code>SSLSocket</code>, <code>SSLServerSocket</code>, and
<code>SSLEngine</code>)</li>
<li>Provides support for cipher suite negotiation, which is part of
the SSL handshaking used to initiate or verify secure
communications</li>
<li>Provides support for client and server authentication, which is
part of the normal SSL handshaking</li>
<li>Provides support for HTTP encapsulated in the SSL protocol,
which allows access to data such as web pages using HTTPS</li>
<li>Provides server session management APIs to manage
memory-resident SSL sessions</li>
<li>Provides support for several cryptographic algorithms commonly
used in cipher suites, including those listed in <a href=
"#T1">Table 1</a>.</li>
</ul>
<table border="1" summary=
"Cryptographic Functionality Available With JSSE">
<caption><a name="T1" id="T1">Table 1: Cryptographic Functionality
Available in JSSE</a></caption>
<thead>
<tr>
<th id="h1"><a name="FN11Back" id="FN11Back">Cryptographic Algorithm</a>
<a class="footnote" href="#FN11">Footnote 1</a></th>
<th id="h2">Cryptographic Process</th>
<th id="h3">Key Lengths (Bits)</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h1">Rivest Shamir Adleman (RSA)</td>
<td headers="h2">Authentication and key exchange</td>
<td headers="h3">512 and larger</td>
</tr>
<tr>
<td headers="h1">Rivest Cipher 4 (RC4)</td>
<td headers="h2">Bulk encryption</td>
<td headers="h3">128<br />
128 (40 effective)</td>
</tr>
<tr>
<td headers="h1">Data Encryption Standard (DES)</td>
<td headers="h2">Bulk encryption</td>
<td headers="h3">64 (56 effective)<br />
64 (40 effective)</td>
</tr>
<tr>
<td headers="h1">Triple DES (3DES)</td>
<td headers="h2">Bulk encryption</td>
<td headers="h3">192 (112 effective)</td>
</tr>
<tr>
<td headers="h1">Advanced Encryption Standard (AES)</td>
<td headers="h2">Bulk encryption</td>
<td headers="h3"><a name="FN12Back" id="FN12Back">256</a> <a class="footnote"
href="#FN12">Footnote 2</a><br />
128</td>
</tr>
<tr>
<td headers="h1">Diffie-Hellman (DH)</td>
<td headers="h2">Key agreement</td>
<td headers="h3">1024<br />
512</td>
</tr>
<tr>
<td headers="h1">Digital Signature Algorithm (DSA)</td>
<td headers="h2">Authentication</td>
<td headers="h3">1024</td>
</tr>
</tbody>
</table>
<p><a class="footnote" name="FN11" id="FN11" href=
"#FN11Back">Footnote 1</a> <small>The SunJSSE implementation uses
the <a href="../crypto/CryptoSpec.html">JCA</a> for all its
cryptographic algorithms.</small></p>
<p><a class="footnote" name="FN12" id="FN12" href=
"#FN12Back">Footnote 2</a> <small>Cipher suites that use AES_256
require installation of the Java Cryptography Extension (JCE)
Unlimited Strength Jurisdiction Policy Files. See <a href=
"http://www.oracle.com/technetwork/java/javase/downloads/index.html">
Java SE Download Page</a>.</small></p>
<!-- *********************************************** -->
<h3><a name="StandardAPI" id="StandardAPI">JSSE Standard
API</a></h3>
<p>The JSSE standard API, available in the <code>javax.net</code>
and <code>javax.net.ssl</code> packages, provides:</p>
<ul>
<li>Secure sockets and server sockets.</li>
<li>A nonblocking engine for producing and consuming streams of
SSL/TLS data (<code>SSLEngine</code>).</li>
<li>Factories for creating sockets, server sockets, SSL sockets,
and SSL server sockets. By using socket factories, you can
encapsulate socket creation and configuration behavior.</li>
<li>A class representing a secure socket context that acts as a
factory for secure socket factories and engines.</li>
<li>Key and trust manager interfaces (including X.509-specific key
and trust managers), and factories that can be used for creating
them.</li>
<li>A class for secure HTTP URL connections (HTTPS).</li>
</ul>
<!-- *********************************************** -->
<h3><a name="SunJSSE" id="SunJSSE">SunJSSE Provider</a></h3>
<p>Oracle's implementation of Java SE includes a JSSE provider
named <i>SunJSSE</i>, which comes preinstalled and preregistered
with the JCA. This provider supplies the following cryptographic
services:</p>
<ul>
<li>An implementation of the SSL 3.0 and TLS 1.0 security
protocols.</li>
<li>An implementation of the most common SSL and TLS cipher suites,
which encompass a combination of authentication, key agreement,
encryption, and integrity protection.</li>
<li>An implementation of an X.509-based key manager that chooses
appropriate authentication keys from a standard JCA keystore.</li>
<li>An implementation of an X.509-based trust manager that
implements rules for certificate chain path validation.</li>
<li>An implementation of PKCS12 as JCA keystore type "pkcs12".
Storing trust anchors in PKCS12 is not supported. Users should
store trust anchors in the Java keystore (JKS) format and save
private keys in PKCS12 format.</li>
</ul>
<p>More information about this provider is available in the
<a href="../SunProviders.html#SunJSSEProvider">SunJSSE</a> section
of the Oracle Providers Documentation.</p>
<!-- *********************************************** -->
<h3><a name="RelatedDocs" id="RelatedDocs">Related
Documentation</a></h3>
<p>The following list contains links to online documentation and
names of books about related subjects:</p>
<ul>
<li><b>JSSE API Documentation</b>
<ul>
<li><a href=
"../../../../api/javax/net/package-summary.html"><code>javax.net</code>
package</a></li>
<li><a href=
"../../../../api/javax/net/ssl/package-summary.html"><code>javax.net.ssl</code>
package</a></li>
<li><a href=
"../../../../api/javax/security/cert/package-summary.html"><code>javax.security.cert</code>
package</a></li>
</ul>
</li>
<li><b>Java SE Security</b>
<ul>
<li>The <a href="../index.html">Java SE Security Documentation</a>
index page</li>
<li>The <a href=
"http://www.oracle.com/technetwork/java/javase/tech/index-jsp-136007.html">
Java SE Security</a> home page</li>
<li>The <a href=
"http://docs.oracle.com/javase/tutorial/security/">Security
Features in Java SE</a> trail of the Java Tutorial</li>
<li><a href="../certpath/CertPathProgGuide.html">Java PKI
Programmer's Guide</a></li>
<li><a href=
"http://www.oracle.com/technetwork/java/javaee/gong-135902.html">Inside
Java 2 Platform Security, Second Edition: Architecture, API Design
and Implementation</a></li>
</ul>
</li>
<li><a name="CryptDocs" id="CryptDocs"><b>Cryptography</b></a>
<ul>
<li>The <a href=
"http://people.csail.mit.edu/rivest/crypto-security.html">Cryptography
and Security</a> page by Dr. Ronald L. Rivest (no longer
maintained)</li>
<li><cite>Applied Cryptography, Second Edition</cite> by Bruce
Schneier. John Wiley and Sons, Inc., 1996.</li>
<li><cite>Cryptography Theory and Practice</cite> by Doug Stinson.
CRC Press, Inc., 1995. Third edition published in 2005.</li>
<li><cite>Cryptography &amp; Network Security: Principles &amp;
Practice</cite> by William Stallings. Prentice Hall, 1998. Fifth
edition published in 2010.</li>
</ul>
</li>
<li><a name="SSLDocs" id="SSLDocs"><b>Secure Sockets Layer
(SSL)</b></a>
<ul>
<li><a href=
"http://tools.ietf.org/html/draft-ietf-tls-ssl-version3-00">The SSL
Protocol version 3.0 Internet Draft</a></li>
<li><a href="http://www.ietf.org/rfc/rfc2246.txt">The TLS Protocol
Version 1.0 RFC</a></li>
<li><a href="http://www.ietf.org/rfc/rfc2818.txt">HTTP Over TLS
RFC</a></li>
<li><cite>SSL and TLS: Designing and Building Secure Systems</cite>
by Eric Rescorla. Addison Wesley Professional, 2000.</li>
<li><cite>SSL and TLS Essentials: Securing the Web</cite> by
Stephen Thomas. John Wiley and Sons, Inc., 2000.</li>
<li><cite>Java 2 Network Security</cite>, Second Edition, by Marco
Pistoia, Duane F Reller, Deepak Gupta, Milind Nagnur, and Ashok K
Ramani. Prentice Hall, 1999.</li>
</ul>
</li>
<li><b>U.S. Encryption Policies</b>
<ul>
<li>U.S. Department of Commerce: <a href=
"http://www.commerce.gov/">http://www.commerce.gov/</a></li>
<li>Computer Systems Public Policy <a href=
"http://www.techceocouncil.org">http://www.techceocouncil.org/</a></li>
<li>Federal Information Processing Standards Publications (FIPS
PUBS): <a href=
"http://csrc.nist.gov/publications/PubsFIPS.html">http://csrc.nist.gov/publications/PubsFIPS.html</a></li>
<li>Revised U.S. Encryption Export Control Regulations: <a href=
"http://epic.org/crypto/export_controls/regs_1_00.html">http://epic.org/crypto/export_controls/regs_1_00.html</a></li>
</ul>
</li>
</ul>
<!-- *********************************************** -->
<h2><a name="javaHome" id="javaHome">The Java Runtime Environment
(JRE) Installation Directory</a></h2>
<p>The <var>java-home</var> variable placeholder is used throughout
this document to refer to the directory where the Java Runtime
Environment (JRE) is installed. This directory is determined based
on whether you are running JSSE with or without the JDK installed.
The JDK includes the JRE, but it is located on a different level in
the file hierarchy.</p>
<p>To see the default location of <var>java-home</var> for
different installations, refer to <a href="#T2">Table 2</a>.</p>
<table border="1" summary="The JRE Installation Directory">
<caption><a name="T2" id="T2">Table 2: The JRE Installation
Directory</a></caption>
<thead>
<tr>
<th id="h101">Operating System</th>
<th id="h102">JDK</th>
<th id="h103">JRE</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h101">Solaris/Linux</td>
<td headers="h102">~/jdk1.8.0/jre</td>
<td headers="h103">~/jre1.8.0</td>
</tr>
<tr>
<td headers="h101">Windows</td>
<td headers="h102">C:\jdk1.8.0\jre</td>
<td headers="h103">C:\jre1.8.0</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>Note:</strong> The tilde (~) in the path name represents
the current user's home directory on Solaris, Linux, or Mac OS X
operating systems.</p>
<hr />
<!-- *********************************************** -->
<h2><a name="Terms" id="Terms">Terms and Definitions</a></h2>
<p>Several terms relating to cryptography are used within this
document. This section defines some of these terms.</p>
<dl>
<dt><b>authentication</b></dt>
<dd>
<p>The process of confirming the identity of a party with whom one
is communicating.</p>
</dd>
<dt><a name="CipherSuite" id="CipherSuite"><b>cipher
suite</b></a></dt>
<dd>
<p>A combination of cryptographic parameters that define the
security algorithms and key sizes used for authentication, key
agreement, encryption, and integrity protection.</p>
</dd>
<dt><b>certificate</b></dt>
<dd>
<p>A digitally signed statement vouching for the identity and
public key of an entity (person, company, and so on). Certificates
can either be self-signed or issued by a Certificate Authority (CA)
&acirc;&euro;&rdquo; an entity that is trusted to issue valid
certificates for other entities. Well-known CAs include VeriSign,
Entrust, and GTE CyberTrust. X509 is a common certificate format
that can be managed by the JDK's keytool.</p>
</dd>
<dt><b>cryptographic hash function</b></dt>
<dd>
<p>An algorithm that is used to produce a relatively small
fixed-size string of bits (called a hash) from an arbitrary block
of data. A cryptographic hash function is similar to a checksum and
has three primary characteristics: it is a one-way function,
meaning that it is not possible to produce the original data from
the hash; a small change in the original data produces a large
change in the resulting hash; and it does not require a
cryptographic key.</p>
</dd>
<dt><b>Cryptographic Service Provider</b></dt>
<dd>
<p>Sometimes referred to simply as <a href=
"../crypto/CryptoSpec.html#ProviderArch"><dfn>provider</dfn></a>
for short, the Java Cryptography Architecture (JCA) defines it as a
package (or set of packages) that implements one or more engine
classes for specific cryptographic algorithms. An engine class
defines a cryptographic service in an abstract fashion without a
concrete implementation.</p>
</dd>
<dt><b>decryption</b></dt>
<dd>
<p>See <a href="#EncrDecr">encryption/decryption</a>.</p>
</dd>
<dt><b>digital signature</b></dt>
<dd>
<p>A digital equivalent of a handwritten signature. It is used to
ensure that data transmitted over a network was sent by whoever
claims to have sent it and that the data has not been modified in
transit. For example, an RSA-based digital signature is calculated
by first computing a cryptographic hash of the data and then
encrypting the hash with the sender's private key.</p>
</dd>
<dt><a name="EncrDecr" id=
"EncrDecr"><b>encryption</b>/<b>decryption</b></a></dt>
<dd>
<p>Encryption is the process of using a complex algorithm to
convert an original message (<dfn>cleartext</dfn>) to an encoded
message (<dfn>ciphertext</dfn>) that is unintelligible unless it is
decrypted. Decryption is the inverse process of producing cleartext
from ciphertext.</p>
<p>The algorithms used to encrypt and decrypt data typically come
in two categories: secret key (<dfn>symmetric</dfn>) cryptography
and public key (<dfn>asymmetric</dfn>) cryptography.</p>
</dd>
<dt><b>handshake protocol</b></dt>
<dd>
<p>The negotiation phase during which the two socket peers agree to
use a new or existing session. The handshake protocol is a series
of messages exchanged over the record protocol. At the end of the
handshake, new connection-specific encryption and integrity
protection keys are generated based on the key agreement secrets in
the session.</p>
</dd>
<dt><b>key agreement</b></dt>
<dd>
<p>A method by which two parties cooperate to establish a common
key. Each side generates some data, which is exchanged. These two
pieces of data are then combined to generate a key. Only those
holding the proper private initialization data can obtain the final
key. Diffie-Hellman (DH) is the most common example of a key
agreement algorithm.</p>
</dd>
<dt><b>key exchange</b></dt>
<dd>
<p>A method by which keys are exchanged. One side generates a
private key and encrypts it using the peer's public key (typically
RSA). The data is transmitted to the peer, who decrypts the key
using the corresponding private key.</p>
</dd>
<dt><a name="KMandTMdef" id="KMandTMdef"><b>key
manager</b>/<b>trust manager</b></a></dt>
<dd>
<p>Key managers and trust managers use keystores for their key
material. A key manager manages a keystore and supplies public keys
to others as needed (for example, for use in authenticating the
user to others). A trust manager decides who to trust based on
information in the truststore it manages.</p>
</dd>
<dt><a name="Stores" id=
"Stores"><b>keystore</b>/<b>truststore</b></a></dt>
<dd>
<p>A keystore is a database of key material. Key material is used
for a variety of purposes, including authentication and data
integrity. Various types of keystores are available, including
PKCS12 and Oracle's JKS.</p>
<p>Generally speaking, keystore information can be grouped into two
categories: key entries and trusted certificate entries. A key
entry consists of an entity's identity and its private key, and can
be used for a variety of cryptographic purposes. In contrast, a
trusted certificate entry contains only a public key in addition to
the entity's identity. Thus, a trusted certificate entry cannot be
used where a private key is required, such as in a
<code>javax.net.ssl.KeyManager</code>. In the JDK implementation of
JKS, a keystore may contain both key entries and trusted
certificate entries.</p>
<p>A truststore is a keystore that is used when making decisions
about what to trust. If you receive data from an entity that you
already trust, and if you can verify that the entity is the one
that it claims to be, then you can assume that the data really came
from that entity.</p>
<p>An entry should only be added to a truststore if the user trusts
that entity. By either generating a key pair or by importing a
certificate, the user gives trust to that entry. Any entry in the
truststore is considered a trusted entry.</p>
<p>It may be useful to have two different keystore files: one
containing just your key entries, and the other containing your
trusted certificate entries, including CA certificates. The former
contains private information, whereas the latter does not. Using
two files instead of a single keystore file provides a cleaner
separation of the logical distinction between your own certificates
(and corresponding private keys) and others' certificates. To
provide more protection for your private keys, store them in a
keystore with restricted access, and provide the trusted
certificates in a more publicly accessible keystore if needed.</p>
</dd>
<dt><b>message authentication code (MAC)</b></dt>
<dd>
<p>Provides a way to check the integrity of information transmitted
over or stored in an unreliable medium, based on a secret key.
Typically, MACs are used between two parties that share a secret
key in order to validate information transmitted between these
parties.</p>
<p>A MAC mechanism that is based on cryptographic hash functions is
referred to as HMAC. HMAC can be used with any cryptographic hash
function, such as Secure Hash Algorithm
(SHA-256), in combination with a secret shared key. HMAC is specified
in RFC 2104.</p>
</dd>
<dt><b>public-key cryptography</b></dt>
<dd>
<p>A cryptographic system that uses an encryption algorithm in
which two keys are produced. One key is made public, whereas the
other is kept private. The public key and the private key are
cryptographic inverses; what one key encrypts only the other key
can decrypt. Public-key cryptography is also called <dfn>asymmetric
cryptography</dfn>.</p>
</dd>
<dt><b>Record Protocol</b></dt>
<dd>
<p>A protocol that packages all data (whether application-level or
as part of the handshake process) into discrete records of data
much like a TCP stream socket converts an application byte stream
into network packets. The individual records are then protected by
the current encryption and integrity protection keys.</p>
</dd>
<dt><b>secret-key cryptography</b></dt>
<dd>
<p>A cryptographic system that uses an encryption algorithm in
which the same key is used both to encrypt and decrypt the data.
Secret-key cryptography is also called <dfn>symmetric
cryptography</dfn>.</p>
</dd>
<dt><b>session</b></dt>
<dd>
<p>A named collection of state information including authenticated
peer identity, cipher suite, and key agreement secrets that are
negotiated through a secure socket handshake and that can be shared
among multiple secure socket instances.</p>
</dd>
<dt><b>trust manager</b></dt>
<dd>
<p>See <a href="#KMandTMdef">key manager/trust manager</a>.</p>
</dd>
<dt><b>truststore</b></dt>
<dd>
<p>See <a href="#Stores">keystore/truststore</a>.</p>
</dd>
</dl>
<!-- *********************************************** -->
<h2><a name="SSLOverview" id="SSLOverview">Secure Sockets Layer
(SSL) Protocol Overview</a></h2>
<p>Secure Sockets Layer (SSL) is the most widely used protocol for
implementing cryptography on the web. SSL uses a combination of
cryptographic processes to provide secure communication over a
network. This section provides an introduction to SSL and the
cryptographic processes it uses.</p>
<p>SSL provides a secure enhancement to the standard TCP/IP sockets
protocol used for Internet communications. As shown in <a href=
"#T3">Table 3</a>, the secure sockets layer is added between the
transport layer and the application layer in the standard TCP/IP
protocol stack. The application most commonly used with SSL is
Hypertext Transfer Protocol (HTTP), the protocol for Internet web
pages. Other applications, such as Net News Transfer Protocol
(NNTP), Telnet, Lightweight Directory Access Protocol (LDAP),
Interactive Message Access Protocol (IMAP), and File Transfer
Protocol (FTP), can be used with SSL as well.</p>
<hr />
<p><strong>Note:</strong> There is currently no standard for secure
FTP.</p>
<hr />
<table border="1" summary="TCP/IP Protocol Stack with SSL">
<caption><a name="T3" id="T3">Table 3: TCP/IP Protocol Stack with
SSL</a></caption>
<thead>
<tr>
<th id="h201">TCP/IP Layer</th>
<th id="h202">Protocol</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h201">Application Layer</td>
<td headers="h202">HTTP, NNTP, Telnet, FTP, and so on</td>
</tr>
<tr>
<td headers="h201">Secure Sockets Layer</td>
<td headers="h202">SSL</td>
</tr>
<tr>
<td headers="h201">Transport Layer</td>
<td headers="h202">TCP</td>
</tr>
<tr>
<td headers="h201">Internet Layer</td>
<td headers="h202">IP</td>
</tr>
</tbody>
</table>
<p>SSL was developed by Netscape in 1994, and with input from the
Internet community, has evolved to become a standard. It is now
under the control of the international standards organization, the
Internet Engineering Task Force (IETF). The IETF renamed SSL to
Transport Layer Security (TLS), and released the first
specification, version 1.0, in January 1999. TLS 1.0 is a modest
upgrade to the most recent version of SSL, version 3.0. The
differences between SSL 3.0 and TLS 1.0 are minor. TLS 1.1 was
released in April 2006, and TLS 1.2 in August 2008. However, these
updated versions are not as widely supported as TLS 1.0 and SSL
3.0.</p>
<!-- *********************************************** -->
<h3><a name="WhySSL" id="WhySSL">Why Use SSL?</a></h3>
<p>Transferring sensitive information over a network can be risky
due to the following issues:</p>
<ul>
<li>You cannot always be sure that the entity with whom you are
communicating is really who you think it is.</li>
<li>Network data can be intercepted, so it is possible that it can
be read by an unauthorized third party, sometimes known as an
attacker.</li>
<li>An attacker who intercepts data may be able to modify it before
sending it on to the receiver.</li>
</ul>
<p>SSL addresses each of these issues. It addresses the first issue
by optionally allowing each of two communicating parties to ensure
the identity of the other party in a process called authentication.
Once the parties are authenticated, SSL provides an encrypted
connection between the two parties for secure message transmission.
Encrypting the communication between the two parties provides
privacy and therefore addresses the second issue. The encryption
algorithms used with SSL include a secure hash function, which is
similar to a checksum. This ensures that data is not modified in
transit. The secure hash function addresses the third issue of data
integrity.</p>
<hr />
<p><strong>Note:</strong> Both authentication and encryption are
optional, and depend on the the negotiated cipher suites between
the two entities.</p>
<hr />
<p>An e-commerce transaction is an obvious example of when to use
SSL. In an e-commerce transaction, it would be foolish to assume
that you can guarantee the identity of the server with whom you are
communicating. It would be easy enough for someone to create a
phony web site promising great services if only you enter your
credit card number. SSL allows you, the client, to authenticate the
identity of the server. It also allows the server to authenticate
the identity of the client, although in Internet transactions, this
is seldom done.</p>
<p>Once the client and the server are comfortable with each other's
identity, SSL provides privacy and data integrity through the
encryption algorithms that it uses. This allows sensitive
information, such as credit card numbers, to be transmitted
securely over the Internet.</p>
<p>Although SSL provides authentication, privacy, and data
integrity, it does not provide nonrepudiation services.
<dfn>Nonrepudiation</dfn> means that an entity that sends a message
cannot later deny sending it. When the digital equivalent of a
signature is associated with a message, the communication can later
be proved. SSL alone does not provide nonrepudiation.</p>
<!-- *********************************************** -->
<h3><a name="HowSSLWorks" id="HowSSLWorks">How SSL Works</a></h3>
<p>One of the reasons that SSL is effective is that it uses several
different cryptographic processes. SSL uses public-key cryptography
to provide authentication, and secret-key cryptography with digital
signatures to provide for privacy and data integrity. Before you
can understand SSL, it is helpful to understand these cryptographic
processes.</p>
<!-- *********************************************** -->
<h3>Cryptographic Processes</h3>
<p>The primary purpose of cryptography is to make it difficult for
an unauthorized third party to access and understand private
communication between two parties. It is not always possible to
restrict all unauthorized access to data, but private data can be
made unintelligible to unauthorized parties through the process of
encryption. Encryption uses complex algorithms to convert the
original message (<dfn>cleartext</dfn>) to an encoded message
(<dfn>ciphertext</dfn>). The algorithms used to encrypt and decrypt
data that is transferred over a network typically come in two
categories: secret-key cryptography and public-key cryptography.
These forms of cryptography are explained in the following
subsections.</p>
<p>Both secret-key cryptography and public-key cryptography depend
on the use of an agreed-upon cryptographic key or pair of keys. A
<dfn>key</dfn> is a string of bits that is used by the
cryptographic algorithm or algorithms during the process of
encrypting and decrypting the data. A cryptographic key is like a
key for a lock; only with the right key can you open the lock.</p>
<p>Safely transmitting a key between two communicating parties is
not a trivial matter. A public key certificate enables a party to
safely transmit its public key, while ensuring the receiver of the
authenticity of the public key. Public key certificates are
described in a later section.</p>
<p>The descriptions of the cryptographic processes that follow use
conventions widely used by the security community: the two
communicating parties are labeled with the names Alice and Bob. The
unauthorized third party, also known as the attacker, is named
Charlie.</p>
<!-- *********************************************** -->
<h4>Secret-Key Cryptography</h4>
<p>With secret-key cryptography, both communicating parties, Alice
and Bob, use the same key to encrypt and decrypt the messages.
Before any encrypted data can be sent over the network, both Alice
and Bob must have the key and must agree on the cryptographic
algorithm that they will use for encryption and decryption.</p>
<p>One of the major problems with secret-key cryptography is the
logistical issue of how to get the key from one party to the other
without allowing access to an attacker. If Alice and Bob are
securing their data with secret-key cryptography, and if Charlie
gains access to their key, then Charlie can understand any secret
messages he intercepts between Alice and Bob. Not only can Charlie
decrypt Alice's and Bob's messages, but he can also pretend that he
is Alice and send encrypted data to Bob. Bob will not know that the
message came from Charlie, not Alice.</p>
<p>Once the problem of secret key distribution is solved,
secret-key cryptography can be a valuable tool. The algorithms
provide excellent security and encrypt data relatively quickly. The
majority of the sensitive data sent in an SSL session is sent using
secret-key cryptography.</p>
<p>Secret-key cryptography is also called <dfn>symmetric
cryptography</dfn> because the same key is used to both encrypt and
decrypt the data. Well-known secret-key cryptographic algorithms
include
Advanced Encryption Standard (AES), Triple Data Encryption Standard (3DES),
and Rivest Cipher 4 (RC4).</p>
<!-- *********************************************** -->
<h4>Public-Key Cryptography</h4>
<p>Public-key cryptography solves the logistical problem of key
distribution by using both a public key and a private key. The
public key can be sent openly through the network while the private
key is kept private by one of the communicating parties. The public
and the private keys are cryptographic inverses of each other; what
one key encrypts, the other key will decrypt.</p>
<p>Assume that Bob wants to send a secret message to Alice using
public-key cryptography. Alice has both a public key and a private
key, so she keeps her private key in a safe place and sends her
public key to Bob. Bob encrypts the secret message to Alice using
Alice's public key. Alice can later decrypt the message with her
private key.</p>
<p>If Alice encrypts a message using her private key and sends the
encrypted message to Bob, then Bob can be sure that the data he
receives comes from Alice; if Bob can decrypt the data with Alice's
public key, the message must have been encrypted by Alice with her
private key, and only Alice has Alice's private key. The problem is
that anybody else can read the message as well because Alice's
public key is public. Although this scenario does not allow for
secure data communication, it does provide the basis for digital
signatures. A digital signature is one of the components of a
public key certificate, and is used in SSL to authenticate a client
or a server. Public key certificates and digital signatures are
described in later sections.</p>
<p>Public-key cryptography is also called <dfn>asymmetric
cryptography</dfn> because different keys are used to encrypt and
decrypt the data. A well-known public key cryptographic algorithm
often used with SSL is the Rivest Shamir Adleman (RSA) algorithm.
Another public key algorithm used with SSL that is designed
specifically for secret key exchange is the Diffie-Hellman (DH)
algorithm. Public-key cryptography requires extensive computations,
making it very slow. It is therefore typically used only for
encrypting small pieces of data, such as secret keys, rather than
for the bulk of encrypted data communications.</p>
<!-- *********************************************** -->
<h4>Comparison Between Secret-Key and Public-Key Cryptography</h4>
<p>Both secret-key cryptography and public-key cryptography have
strengths and weaknesses. With secret-key cryptography, data can be
encrypted and decrypted quickly, but because both communicating
parties must share the same secret key information, the logistics
of exchanging the key can be a problem. With public-key
cryptography, key exchange is not a problem because the public key
does not need to be kept secret, but the algorithms used to encrypt
and decrypt data require extensive computations, and are therefore
very slow.</p>
<!-- *********************************************** -->
<h4>Public Key Certificates</h4>
<p>A public key certificate provides a safe way for an entity to
pass on its public key to be used in asymmetric cryptography. The
public key certificate avoids the following situation: if Charlie
creates his own public key and private key, he can claim that he is
Alice and send his public key to Bob. Bob will be able to
communicate with Charlie, but Bob will think that he is sending his
data to Alice.</p>
<p>A public key certificate can be thought of as the digital
equivalent of a passport. It is issued by a trusted organization
and provides identification for the bearer. A trusted organization
that issues public key certificates is known as a Certificate
Authority (CA). The CA can be likened to a notary public. To obtain
a certificate from a CA, one must provide proof of identity. Once
the CA is confident that the applicant represents the organization
it says it represents, the CA signs the certificate attesting to
the validity of the information contained within the
certificate.</p>
<p>A public key certificate contains the following fields:</p>
<ul>
<li><b>Issuer</b><br />
The CA that issued the certificate. If a user trusts the CA that
issued the certificate, and if the certificate is valid, then the
user can trust the certificate.</li>
<li><b>Period of validity</b><br />
A certificate has an expiration date. This date should be checked
when verifying the validity of a certificate.</li>
<li><b>Subject</b><br />
Includes information about the entity that the certificate
represents.</li>
<li><b>Subject's public key</b><br />
The primary piece of information that the certificate provides is
the subject's public key. All the other fields are provided to
ensure the validity of this key.</li>
<li><b>Signature</b><br />
The certificate is digitally signed by the CA that issued the
certificate. The signature is created using the CA's private key
and ensures the validity of the certificate. Because only the
certificate is signed, not the data sent in the SSL transaction,
SSL does not provide for nonrepudiation.</li>
</ul>
<p>If Bob only accepts Alice's public key as valid when she sends
it in a public key certificate, then Bob will not be fooled into
sending secret information to Charlie when Charlie masquerades as
Alice.</p>
<p>Multiple certificates may be linked in a certificate chain. When
a certificate chain is used, the first certificate is always that
of the sender. The next is the certificate of the entity that
issued the sender's certificate. If more certificates are in the
chain, then each is that of the authority that issued the previous
certificate. The final certificate in the chain is the certificate
for a root CA. A root CA is a public certificate authority that is
widely trusted. Information for several root CAs is typically
stored in the client's Internet browser. This information includes
the CA's public key. Well-known CAs include VeriSign, Entrust, and
GTE CyberTrust.</p>
<!-- *********************************************** -->
<h4>Cryptographic Hash Functions</h4>
<p>When sending encrypted data, SSL typically uses a cryptographic
hash function to ensure data integrity. The hash function prevents
Charlie from tampering with data that Alice sends to Bob.</p>
<p>A cryptographic hash function is similar to a checksum. The main
difference is that whereas a checksum is designed to detect
accidental alterations in data, a cryptographic hash function is
designed to detect deliberate alterations. When data is processed
by a cryptographic hash function, a small string of bits, known as
a <dfn>hash</dfn>, is generated. The slightest change to the
message typically makes a large change in the resulting hash. A
cryptographic hash function does not require a cryptographic key.
A hash function often used with SSL is Secure Hash Algorithm (SHA).
SHA was proposed by the <a href=
"http://www.nist.gov/index.html">U.S. National Institute of
Standards and Technology (NIST)</a>.</p>
<!-- *********************************************** -->
<h4>Message Authentication Code</h4>
A message authentication code (MAC) is similar to a cryptographic
hash, except that it is based on a secret key. When secret key
information is included with the data that is processed by a
cryptographic hash function, then the resulting hash is known as an
HMAC.
<p>If Alice wants to be sure that Charlie does not tamper with her
message to Bob, then she can calculate an HMAC for her message and
append the HMAC to her original message. She can then encrypt the
message plus the HMAC using a secret key that she shares with Bob.
When Bob decrypts the message and calculates the HMAC, he will be
able to tell if the message was modified in transit. With SSL, an
HMAC is used with the transmission of secure data.</p>
<!-- *********************************************** -->
<h4>Digital Signatures</h4>
<p>Once a cryptographic hash is created for a message, the hash is
encrypted with the sender's private key. This encrypted hash is
called a digital signature.</p>
<!-- *********************************************** -->
<h3><a name="SSLHandshake" id="SSLHandshake">The SSL
Handshake</a></h3>
<p>Communication using SSL begins with an exchange of information
between the client and the server. This exchange of information is
called the SSL handshake. The SSL handshake includes the following
stages:</p>
<ol>
<li><b>Negotiating the cipher suite</b>
<p>The SSL session begins with a negotiation between the client and
the server as to which cipher suite they will use. A <dfn>cipher
suite</dfn> is a set of cryptographic algorithms and key sizes that
a computer can use to encrypt data. The cipher suite includes
information about the public key exchange algorithms or key
agreement algorithms, and cryptographic hash functions. The client
tells the server which cipher suites it has available, and the
server chooses the best mutually acceptable cipher suite.</p>
</li>
<li><b>Authenticating the server's identity (optional)</b>
<p>In SSL, the authentication step is optional, but in the example
of an e-commerce transaction over the web, the client will
generally want to authenticate the server. Authenticating the
server allows the client to be sure that the server represents the
entity that the client believes the server represents.</p>
<p>To prove that a server belongs to the organization that it
claims to represent, the server presents its public key certificate
to the client. If this certificate is valid, then the client can be
sure of the identity of the server.</p>
<p>The client and server exchange information that allows them to
agree on the same secret key. For example, with RSA, the client
uses the server's public key, obtained from the public key
certificate, to encrypt the secret key information. The client
sends the encrypted secret key information to the server. Only the
server can decrypt this message because the server's private key is
required for this decryption.</p>
</li>
<li><b>Agreeing on encryption mechanisms</b>
<p>Both the client and the server now have access to the same
secret key. With each message, they use the cryptographic hash
function, chosen in the first step of the handshake, and shared
secret information, to compute an HMAC that they append to the
message. They then use the secret key and the secret key algorithm
negotiated in the first step of the handshake to encrypt the secure
data and the HMAC. The client and server can now communicate
securely using their encrypted and hashed data.</p>
</li>
</ol>
<!-- *********************************************** -->
<h3>The SSL Protocol</h3>
<p>The previous section provides a high-level description of the
SSL handshake, which is the exchange of information between the
client and the server prior to sending the encrypted message. This
section provides more detail.</p>
<p><a href="#Fig1">Figure 1</a> shows the sequence of messages that
are exchanged in the SSL handshake. Messages that are sent only in
certain situations are noted as optional. Each of the SSL messages
is described below the figure.</p>
<div>
<div class="caption"><a name="Fig1" id="Fig1">Figure 1: Sequence of
Messages Exchanged in SSL Handshake</a></div>
<img src="sslmessages.gif" width="484" height="418" alt=
"Sequence of messages exchanged in SSL handshake." /></div>
<p>The SSL messages are sent in the following order:</p>
<ol>
<li><b>Client hello</b><br />
The client sends the server information including the highest
version of SSL that it supports and a list of the cipher suites
that it supports (TLS 1.0 is indicated as SSL 3.1). The cipher
suite information includes cryptographic algorithms and key
sizes.</li>
<li><b>Server hello</b><br />
The server chooses the highest version of SSL and the best cipher
suite that both the client and server support and sends this
information to the client.</li>
<li><a name="ServCertMsg" id="ServCertMsg"><b>Certificate</b>
(optional)</a><br />
The server sends the client a certificate or a certificate chain. A
certificate chain typically begins with the server's public key
certificate and ends with the certificate authority's root
certificate. This message is optional, but is used whenever server
authentication is required.</li>
<li><a name="ServCertReq" id="ServCertReq"><b>Certificate
request</b> (optional)</a><br />
If the server must authenticate the client, then it sends the
client a certificate request. In Internet applications, this
message is rarely sent.</li>
<li><b>Server key exchange</b> (optional)<br />
The server sends the client a server key exchange message if the
public key information from the <a href=
"#ServCertMsg">certificate</a> is not sufficient for key exchange.
For example, in cipher suites based on Diffie-Hellman (DH), this
message contains the server's DH public key.</li>
<li><b>Server hello done</b><br />
The server tells the client that it is finished with its initial
negotiation messages.</li>
<li><b>Certificate</b> (optional)<br />
If the server <a href="#ServCertReq">requested a certificate</a>
from the client, the client sends its certificate chain, just as
the server did previously.
<hr />
<p><strong>Note:</strong> Only a few Internet server applications
ask for a certificate from the client.</p>
<hr /></li>
<li><b>Client key exchange</b><br />
The client generates information used to create a key to use for
symmetric encryption. For RSA, the client then encrypts this key
information with the server's public key and sends it to the
server. For cipher suites based on DH, this message contains the
client's DH public key.</li>
<li><b>Certificate verify</b> (optional)<br />
This message is sent by the client when the client presents a
certificate as previously explained. Its purpose is to allow the
server to complete the process of authenticating the client. When
this message is used, the client sends information that it
digitally signs using a cryptographic hash function. When the
server decrypts this information with the client's public key, the
server is able to authenticate the client.</li>
<li><b>Change cipher spec</b><br />
The client sends a message telling the server to change to
encrypted mode.</li>
<li><b>Finished</b><br />
The client tells the server that it is ready for secure data
communication to begin.</li>
<li><b>Change cipher spec</b><br />
The server sends a message telling the client to change to
encrypted mode.</li>
<li><b>Finished</b><br />
The server tells the client that it is ready for secure data
communication to begin. This is the end of the SSL handshake.</li>
<li><b>Encrypted data</b><br />
The client and the server communicate using the symmetric
encryption algorithm and the cryptographic hash function negotiated
during the client hello and server hello, and using the secret key
that the client sent to the server during the client key exchange.
The handshake can be renegotiated at this time. See the next
section for details.</li>
<li><b>Close Messages</b><br />
At the end of the connection, each side sends a
<code>close_notify</code> message to inform the peer that the
connection is closed.</li>
</ol>
<p>If the parameters generated during an SSL session are saved,
then these parameters can sometimes be reused for future SSL
sessions. Saving SSL session parameters allows encrypted
communication to begin much more quickly.</p>
<h4>Handshaking Again (Renegotiation)</h4>
<p>Once the initial handshake is finished and application data is
flowing, either side is free to initiate a new handshake at any
time. An application might like to use a stronger cipher suite for
especially critical operations, or a server application might want
to require client authentication.</p>
<p>Regardless of the reason, the new handshake takes place over the
existing encrypted session, and application data and handshake
messages are interleaved until a new session is established.</p>
<p>Your application can initiate a new handshake by using one of
the following methods:</p>
<ul>
<li><code>SSLSocket.startHandshake()</code></li>
<li><code>SSLEngine.beginHandshake()</code></li>
</ul>
<p>Note that a protocol flaw related to renegotiation was found in
2009. The protocol and the Java SE implementation have both been
fixed. For more information, see <a href=
"#tlsRenegotiation">Transport Layer Security (TLS) Renegotiation
Issue</a>.</p>
<!-- *********************************************** -->
<h4><a name="ciphersuitechoice" id="ciphersuitechoice">Cipher Suite
Choice and Remote Entity Verification</a></h4>
The <a href="#SSLDocs">SSL/TLS protocols</a> define a specific
series of steps to ensure a <em>protected</em> connection. However,
the choice of cipher suite directly affects the type of security
that the connection enjoys. For example, if an anonymous cipher
suite is selected, then the application has no way to verify the
remote peer's identity. If a suite with no encryption is selected,
then the privacy of the data cannot be protected. Additionally, the
SSL/TLS protocols do not specify that the credentials received must
match those that peer might be expected to send. If the connection
were somehow redirected to a rogue peer, but the rogue's
credentials were acceptable based on the current trust material,
then the connection would be considered valid.
<p>When using raw <code>SSLSocket</code> and <code>SSLEngine</code>
classes, you should always check the peer's credentials before
sending any data. The <code>SSLSocket</code> and
<code>SSLEngine</code> classes do not automatically verify that the
host name in a URL matches the host name in the peer's credentials.
An application could be exploited with URL spoofing if the host
name is not verified.</p>
<p>Protocols such as HTTPS (<a href=
"http://www.ietf.org/rfc/rfc2818.txt">HTTP Over TLS</a>) do require
host name verification. Applications can use <a href=
"#HostnameVerifier">HostnameVerifier</a> to override the default
HTTPS host name rules. See <a href=
"#HttpsURLConnection">HttpsURLConnection</a> for more
information.</p>
<!-- *********************************************** -->
<h2><a name="JSSEClasses" id="JSSEClasses">JSSE Classes and
Interfaces</a></h2>
<p>To communicate securely, both sides of the connection must be
SSL-enabled. In the JSSE API, the endpoint classes of the
connection are <code>SSLSocket</code> and <code>SSLEngine</code>.
In <a href="#Fig2">Figure 2</a>, the major classes used to create
<code>SSLSocket</code> and <code>SSLEngine</code> are laid out in a
logical ordering. The text following the diagram, explains the
contents of the illustration.</p>
<div>
<div class="caption"><a name="Fig2" id="Fig2">Figure 2: Classes
Used to Create SSLSocket and SSLEngine</a></div>
<img src="classes1.jpg" width="581" height="429" alt=
"Diagram of classes used to create SSLSocket and SSLEngine" /></div>
<p>An <code>SSLSocket</code> is created either by an
<code>SSLSocketFactory</code> or by an <code>SSLServerSocket</code>
accepting an inbound connection. In turn, an
<code>SSLServerSocket</code> is created by an
<code>SSLServerSocketFactory</code>. Both
<code>SSLSocketFactory</code> and
<code>SSLServerSocketFactory</code> objects are created by an
<code>SSLContext</code>. An <code>SSLEngine</code> is created
directly by an <code>SSLContext</code>, and relies on the
application to handle all I/O.</p>
<hr />
<p><strong>Note:</strong> When using raw <code>SSLSocket</code> or
<code>SSLEngine</code> classes, you should always check the peer's
credentials before sending any data. The <code>SSLSocket</code> and
<code>SSLEngine</code> classes do not automatically verify, for
example, that the host name in a URL matches the host name in the
peer's credentials. An application could be exploited with URL
spoofing if the host name is not verified.</p>
<hr />
<p>There are two ways to obtain and initialize an
<code>SSLContext</code>:</p>
<ul>
<li>The simplest way is to call the static
<code>getDefault()</code> method on either the
<code>SSLSocketFactory</code> or
<code>SSLServerSocketFactory</code> class. This method creates a
default <code>SSLContext</code> with a default
<code>KeyManager</code>, <code>TrustManager</code>, and
<code>SecureRandom</code> (a secure random number generator). A
default <code>KeyManagerFactory</code> and
<code>TrustManagerFactory</code> are used to create the
<code>KeyManager</code> and <code>TrustManager</code>,
respectively. The key material used is found in the default
keystore and truststore, as determined by system properties
described in <a href="#CustomizingStores">Customizing the Default
Keystores and Truststores, Store Types, and Store
Passwords</a>.</li>
<li>The approach that gives the caller the most control over the
behavior of the created context is to call the static method
<code>getInstance()</code> on the <code>SSLContext</code> class,
and then initialize the context by calling the instance's proper
<code>init()</code> method. One variant of the <code>init()</code>
method takes three arguments: an array of <code>KeyManager</code>
objects, an array of <code>TrustManager</code> objects, and a
<code>SecureRandom</code> object. The <code>KeyManager</code> and
<code>TrustManager</code> objects are created by either
implementing the appropriate interfaces or using the
<code>KeyManagerFactory</code> and <code>TrustManagerFactory</code>
classes to generate implementations. The
<code>KeyManagerFactory</code> and <code>TrustManagerFactory</code>
can then each be initialized with key material contained in the
<code>KeyStore</code> passed as an argument to the
<code>init()</code> method of the <code>TrustManagerFactory</code>
or <code>KeyManagerFactory</code> classes. Finally, the
<code>getTrustManagers()</code> method (in
<code>TrustManagerFactory</code>) and <code>getKeyManagers()</code>
method (in <code>KeyManagerFactory</code>) can be called to obtain
the array of trust managers or key managers, one for each type of
trust or key material.</li>
</ul>
<p>Once an SSL connection is established, an
<code>SSLSession</code> is created which contains various
information, such as identities established and cipher suite used.
The <code>SSLSession</code> is then used to describe an ongoing
relationship and state information between two entities. Each SSL
connection involves one session at a time, but that session may be
used on many connections between those entities, simultaneously or
sequentially.</p>
<!-- *********************************************** -->
<h3><a name="CoreClasses" id="CoreClasses">Core Classes and
Interfaces</a></h3>
<p>The core JSSE classes are part of the <code>javax.net</code> and
<code>javax.net.ssl</code> packages.</p>
<!-- *********************************************** -->
<h3><a name="SocketFactory" id="SocketFactory">SocketFactory and
ServerSocketFactory Classes</a></h3>
<p>The abstract <code>javax.net.SocketFactory</code> class is used
to create sockets. Subclasses of this class are factories that
create particular subclasses of sockets and thus provide a general
framework for the addition of public socket-level functionality.
For example, see <a href="#SSLSocketFactory">SSLSocketFactory and
SSLServerSocketFactory</a>.</p>
<p>The abstract <code>javax.net.ServerSocketFactory</code> class is
analogous to the <code>SocketFactory</code> class, but is used
specifically for creating server sockets.</p>
<p>Socket factories are a simple way to capture a variety of
policies related to the sockets being constructed, producing such
sockets in a way that does not require special configuration of the
code that asks for the sockets:</p>
<ul>
<li>Due to polymorphism of both factories and sockets, different
kinds of sockets can be used by the same application code just by
passing different kinds of factories.</li>
<li>Factories can themselves be customized with parameters used in
socket construction. For example, factories could be customized to
return sockets with different networking timeouts or security
parameters already configured.</li>
<li>The sockets returned to the application can be subclasses of
<code>java.net.Socket</code> (or
<code>javax.net.ssl.SSLSocket</code>), so that they can directly
expose new APIs for features such as compression, security, record
marking, statistics collection, or firewall tunneling.</li>
</ul>
<!-- *********************************************** -->
<h3><a name="SSLSocketFactory" id=
"SSLSocketFactory">SSLSocketFactory and SSLServerSocketFactory
Classes</a></h3>
<p>The <code>javax.net.ssl.SSLSocketFactory</code> class acts as a
factory for creating secure sockets. This class is an abstract
subclass of <a href=
"#SocketFactory">javax.net.SocketFactory</a>.</p>
<p>Secure socket factories encapsulate the details of creating and
initially configuring secure sockets. This includes authentication
keys, peer certificate validation, enabled cipher suites, and the
like.</p>
<p>The <code>javax.net.ssl.SSLServerSocketFactory</code> class is
analogous to the <code>SSLSocketFactory</code> class, but is used
specifically for creating server sockets.</p>
<!-- *********************************************** -->
<h4>Obtaining an SSLSocketFactory</h4>
<p>The following ways can be used to obtain an
<code>SSLSocketFactory</code>:</p>
<ul>
<li>Get the default factory by calling the
<code>SSLSocketFactory.getDefault()</code> static method.</li>
<li>Receive a factory as an API parameter. That is, code that must
create sockets but does not care about the details of how the
sockets are configured can include a method with an
<code>SSLSocketFactory</code> parameter that can be called by
clients to specify which <code>SSLSocketFactory</code> to use when
creating sockets (for example,
<code>javax.net.ssl.HttpsURLConnection</code>).</li>
<li>Construct a new factory with specifically configured
behavior.</li>
</ul>
<p>The default factory is typically configured to support server
authentication only so that sockets created by the default factory
do not leak any more information about the client than a normal TCP
socket would.</p>
<p>Many classes that create and use sockets do not need to know the
details of socket creation behavior. Creating sockets through a
socket factory passed in as a parameter is a good way of isolating
the details of socket configuration, and increases the reusability
of classes that create and use sockets.</p>
<p>You can create new socket factory instances either by
implementing your own socket factory subclass or by using another
class which acts as a factory for socket factories. One example of
such a class is <code>SSLContext</code>, which is provided with the
JSSE implementation as a provider-based configuration class.</p>
<!-- *********************************************** -->
<h3><a name="SSLSocket" id="SSLSocket">SSLSocket and
SSLServerSocket Classes</a></h3>
<p>The <code>javax.net.ssl.SSLSocket</code> class is a subclass of
the standard Java <code>java.net.Socket</code> class. It supports
all of the standard socket methods and adds methods specific to
secure sockets. Instances of this class encapsulate the <a href=
"#SSLContext">SSLContext</a> under which they were created. There
are APIs to control the creation of secure socket sessions for a
socket instance, but trust and key management are not directly
exposed.</p>
<p>The <code>javax.net.ssl.SSLServerSocket</code> class is
analogous to the <code>SSLSocket</code> class, but is used
specifically for creating server sockets.<br /></p>
<p>To prevent peer spoofing, you should always <a href=
"#ciphersuitechoice">verify the credentials</a> presented to an
<code>SSLSocket</code>.</p>
<hr />
<p><strong>Note:</strong> Due to the complexity of the SSL and TLS
protocols, it is difficult to predict whether incoming bytes on a
connection are handshake or application data, and how that data
might affect the current connection state (even causing the process
to block). In the Oracle JSSE implementation, the
<code>available()</code> method on the object obtained by
<code>SSLSocket.getInputStream()</code> returns a count of the
number of application data bytes successfully decrypted from the
SSL connection but not yet read by the application.</p>
<hr />
<!-- *********************************************** -->
<h4>Obtaining an SSLSocket</h4>
Instances of <code>SSLSocket</code> can be obtained in one of the
following ways:
<ul>
<li>An <code>SSLSocket</code> can be created by an instance of
<a href="#SSLSocketFactory">SSLSocketFactory</a> via one of the
several <code>createSocket()</code> methods of that class.</li>
<li>An <code>SSLSocket</code> can be created through the
<code>accept()</code> method of the <code>SSLServerSocket</code>
class.</li>
</ul>
<!-- *********************************************** -->
<h3><a name="SSLEngine" id="SSLEngine">SSLEngine Class</a></h3>
<p>SSL/TLS is becoming increasingly popular. It is being used in a
wide variety of applications across a wide range of computing
platforms and devices. Along with this popularity come demands to
use SSL/TLS with different I/O and threading models to satisfy the
applications' performance, scalability, footprint, and other
requirements. There are demands to use SSL/TLS with blocking and
nonblocking I/O channels, asynchronous I/O, arbitrary input and
output streams, and byte buffers. There are demands to use it in
highly scalable, performance-critical environments, requiring
management of thousands of network connections.</p>
<p>Abstraction of the I/O transport mechanism using the
<code>SSLEngine</code> class in Java SE allows applications to use
the SSL/TLS protocols in a transport-independent way, and thus
frees application developers to choose transport and computing
models that best meet their needs. Not only does this abstraction
allow applications to use nonblocking I/O channels and other I/O
models, it also accommodates different threading models. This
effectively leaves the I/O and threading decisions up to the
application developer. Because of this flexibility, the application
developer must manage I/O and threading (complex topics in and of
themselves), as well as have some understanding of the SSL/TLS
protocols. The abstraction is therefore an advanced API: beginners
should use <code>SSLSocket</code>.</p>
<!--
<p>Newcomers to the API may wonder "Why not just have an
<code>SSLSocketChannel</code> which extends
<code>java.nio.channels.SocketChannel</code>?" There are the following reasons:</p>
<ul>
<li>There were a lot of very difficult questions about what an
<code>SSLSocketChannel</code> should be, including its class
hierarchy and how it should interoperate with a
<code>Selector</code> and other types of
<code>SocketChannel</code>. Each proposal brought up more
questions than answers. It was noted that any new API abstraction
extended to work with SSL/TLS would require the same significant
analysis and could result in large and complex APIs.</li>
<li>Any JSSE implementation of a new API would be free to choose
the "best" I/O and compute strategy, but hiding any of these
details is inappropriate for those applications needing full
control. Any specific implementation would be inappropriate for
some application segment.</li>
</ul>
<p>By abstracting the I/O and treating data as streams of bytes, these
issues are resolved and the new API could be used with any existing
or future I/O model. While this solution makes I/O and CPU handling
the developers' responsibility, JSSE implementations are prevented
from being unusable due to some unconfigurable and/or unchangeable
internal detail.</p>-->
<p>Users of other Java programming language APIs such as the Java
Generic Security Services (Java GSS) and the Java Simple
Authentication Security Layer (Java SASL) will notice similarities
in that the application is also responsible for transporting
data.</p>
<p>The core class is <a href=
"../../../../api/javax/net/ssl/SSLEngine.html"><code>javax.net.ssl.SSLEngine</code></a>.
It encapsulates an SSL/TLS state machine and operates on inbound
and outbound byte buffers supplied by the user of the
<code>SSLEngine</code> class. The diagram in <a href="#Fig3">Figure
3</a> illustrates the flow of data from the application, through
<code>SSLEngine</code>, to the transport mechanism, and back.</p>
<div>
<div class="caption"><a name="Fig3" id="Fig3">Figure 3: Flow of
Data Through SSLEngine</a></div>
<img src="sslengine.jpg" align="top" border="0" alt=
"Flow of data through SSLEngine" /></div>
<p>The application, shown on the left, supplies application
(plaintext) data in an application buffer and passes it to
<code>SSLEngine</code>. The <code>SSLEngine</code> object processes
the data contained in the buffer, or any handshaking data, to
produce SSL/TLS encoded data and places it to the network buffer
supplied by the application. The application is then responsible
for using an appropriate transport (shown on the right) to send the
contents of the network buffer to its peer. Upon receiving SSL/TLS
encoded data from its peer (via the transport), the application
places the data into a network buffer and passes it to
<code>SSLEngine</code>. The <code>SSLEngine</code> object processes
the network buffer's contents to produce handshaking data or
application data.</p>
<!--<p> If the application were to choose a stream-based socket as the
transport mechanism, then this overview more or less corresponds to
how an application would <code>SSLSocket</code>s except that with the new
abstraction, it is doing each exchange in two steps instead of one.</p>

<p>The TLS (and SSL) protocol is actually a collection of protocols.  One
protocol supports application data exchange while the others support
authentication, negotiation of the use of cipher suites and other
parameters, and communication of warnings and errors.  These
non-application data exchange tasks are referred to as
<em>handshaking</em> and affect the state of the <code>SSLEngine</code>.
When handshaking data is fed to the <code>SSLEngine</code> (encapsulated
within SSL/TLS encoded data received from the peer), it might change
the engine's state such that the engine cannot process any more
application data until it completes the handshaking.</p>
-->
<p>An instance of the <code>SSLEngine</code> class can be in one of
the following states:</p>
<ul>
<li><b>Creation:</b> Ready to be configured</li>
<li><b>Initial handshaking:</b> Perform authentication and
negotiate communication parameters</li>
<li><b>Application data:</b> Ready for application exchange</li>
<li><b>Rehandshaking:</b> Renegotiate communications
parameters/authentication; handshaking data may be mixed with
application data</li>
<li><b>Closure:</b> Ready to shut down the connection</li>
</ul>
<!-- *********************************************** -->
<h4>Creating an SSLEngine Object</h4>
<p>To create an <code>SSLEngine</code> object, you use the
<code>SSLContext.createSSLEngine()</code> method. You must
configure the engine to act as a client or a server, and set other
configuration parameters, such as which cipher suites to use and
whether to require client authentication.</p>
<p><a href="#ex1">Example 1</a> illustrates how to create an
<code>SSLEngine</code> object.</p>
<hr />
<p><strong>Note:</strong> The server name and port number are not
used for communicating with the server (all transport is the
responsibility of the application). They are hints to the JSSE
provider to use for SSL session caching, and for Kerberos-based
cipher suite implementations to determine which server credentials
should be obtained.</p>
<hr />
<div>
<div class="caption"><a name="ex1" id="ex1">Example 1: Creating an
SSLEngine object</a></div>
<pre class="codeblock">
import javax.net.ssl.*;
import java.security.*;

// Create and initialize the SSLContext with key material
char[] passphrase = "passphrase".toCharArray();

// First initialize the key and trust material
KeyStore ksKeys = KeyStore.getInstance("JKS");
ksKeys.load(new FileInputStream("testKeys"), passphrase);
KeyStore ksTrust = KeyStore.getInstance("JKS");
ksTrust.load(new FileInputStream("testTrust"), passphrase);

// KeyManagers decide which key material to use
KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509");
kmf.init(ksKeys, passphrase);

// TrustManagers decide whether to allow connections
TrustManagerFactory tmf = TrustManagerFactory.getInstance("SunX509");
tmf.init(ksTrust);

sslContext = SSLContext.getInstance("TLS");
sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);

// Create the engine
SSLEngine engine = sslContext.createSSLengine(hostname, port);

// Use as client
engine.setUseClientMode(true);
</pre></div>
<!-- *********************************************** -->
<h4>Generating and Processing SSL/TLS Data</h4>
<p>The two main <code>SSLEngine</code> methods are
<code>wrap()</code> and <code>unwrap()</code>. They are responsible
for generating and consuming network data respectively. Depending
on the state of the <code>SSLEngine</code> object, this data might
be handshake or application data.</p>
<p>Each <code>SSLEngine</code> object has several phases during its
lifetime. Before application data can be sent or received, the
SSL/TLS protocol requires a handshake to establish cryptographic
parameters. This handshake requires a series of back-and-forth
steps by the <code>SSLEngine</code> object. The "<a href=
"#SSLHandshake">SSL Handshake</a>" section provides more details
about the handshake itself.</p>
<p>During the initial handshaking, the <code>wrap()</code> and
<code>unwrap()</code> methods generate and consume handshake data,
and the application is responsible for transporting the data. The
<code>wrap()</code> and <code>unwrap()</code> method sequence is
repeated until the handshake is finished. Each
<code>SSLEngine</code> operation generates an instance of the
<code>SSLEngineResult</code> class, in which the
<code>SSLEngineResult.HandshakeStatus</code> field is used to
determine what operation must occur next to move the handshake
along.</p>
<p><a href="#T4">Table 4</a> shows the sequence of methods called
during a typical handshake, with corresponding messages and
statuses.</p>
<table summary="Typical handshake" border="1">
<caption><a name="T4" id="T4">Table 4: Typical
Handshake</a></caption>
<thead>
<tr>
<th id="h301">Client</th>
<th id="h302">SSL/TLS Message</th>
<th id="h303"><code>HandshakeStatus</code></th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h301"><code>wrap()</code></td>
<td headers="h302"><code>ClientHello</code></td>
<td headers="h303"><code>NEED_UNWRAP</code></td>
</tr>
<tr>
<td headers="h301"><code>unwrap()</code></td>
<td headers="h302"><code>ServerHello/Cert/ServerHelloDone</code></td>
<td headers="h303"><code>NEED_WRAP</code></td>
</tr>
<tr>
<td headers="h301"><code>wrap()</code></td>
<td headers="h302"><code>ClientKeyExchange</code></td>
<td headers="h303"><code>NEED_WRAP</code></td>
</tr>
<tr>
<td headers="h301"><code>wrap()</code></td>
<td headers="h302"><code>ChangeCipherSpec</code></td>
<td headers="h303"><code>NEED_WRAP</code></td>
</tr>
<tr>
<td headers="h301"><code>wrap()</code></td>
<td headers="h302"><code>Finished</code></td>
<td headers="h303"><code>NEED_UNWRAP</code></td>
</tr>
<tr>
<td headers="h301"><code>unwrap()</code></td>
<td headers="h302"><code>ChangeCipherSpec</code></td>
<td headers="h303"><code>NEED_UNWRAP</code></td>
</tr>
<tr>
<td headers="h301"><code>unwrap()</code></td>
<td headers="h302"><code>Finished</code></td>
<td headers="h303"><code>FINISHED</code></td>
</tr>
</tbody>
</table>
<p>When handshaking is complete, further calls to
<code>wrap()</code> will attempt to consume application data and
package it for transport. The <code>unwrap()</code> method will
attempt the opposite.</p>
<p>To send data to the peer, the application first supplies the
data that it wants to send via <code>SSLEngine.wrap()</code> to
obtain the corresponding SSL/TLS encoded data. The application then
sends the encoded data to the peer using its chosen transport
mechanism. When the application receives the SSL/TLS encoded data
from the peer via the transport mechanism, it supplies this data to
the <code>SSLEngine</code> via <code>SSLEngine.unwrap()</code> to
obtain the plaintext data sent by the peer.</p>
<p><a href="#ex2">Example 2</a> shows an SSL application that uses
a nonblocking <code>SocketChannel</code> to communicate with its
peer.</p>
<hr />
<p><strong>Note:</strong> The example can be made more robust and
scalable by using a <code>Selector</code> with the nonblocking
<code>SocketChannel</code>.</p>
<hr />
<p>In <a href="#ex2">Example 2</a>, the string <code>hello</code>
is sent to the peer by encoding it using the <code>SSLEngine</code>
created in <a href="#ex1">Example 1</a>. It uses information from
the <code>SSLSession</code> to determine how large the byte buffers
should be.</p>
<div>
<div class="caption"><a name="ex2" id="ex2">Example 2: Using a
Nonblocking SocketChannel</a></div>
<pre class="codeblock">
// Create a nonblocking socket channel
SocketChannel socketChannel = SocketChannel.open();
socketChannel.configureBlocking(false);
socketChannel.connect(new InetSocketAddress(hostname, port));

// Complete connection
while (!socketChannel.finishedConnect()) {
    // do something until connect completed
}

// Create byte buffers to use for holding application and encoded data
SSLSession session = engine.getSession();
ByteBuffer myAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
ByteBuffer myNetData = ByteBuffer.allocate(session.getPacketBufferSize());
ByteBuffer peerAppData = ByteBuffer.allocate(session.getApplicationBufferSize());
ByteBuffer peerNetData = ByteBuffer.allocate(session.getPacketBufferSize());

// Do initial handshake
doHandshake(socketChannel, engine, myNetData, peerNetData);

myAppData.put("hello".getBytes());
myAppData.flip();

while (myAppData.hasRemaining()) {
    // Generate SSL/TLS encoded data (handshake or application data)
    SSLEngineResult res = engine.wrap(myAppData, myNetData);

    // Process status of call
    if (res.getStatus() == SSLEngineResult.Status.OK) {
        myAppData.compact();

        // Send SSL/TLS encoded data to peer
        while(myNetData.hasRemaining()) {
            int num = socketChannel.write(myNetData);
            if (num == 0) {
                // no bytes written; try again later
            }
        }
    }

    // Handle other status:  BUFFER_OVERFLOW, CLOSED
    ...
}
</pre></div>
<p><a href="#ex3">Example 3</a> illustrates how to read data from
the same nonblocking <code>SocketChannel</code> and extract the
plaintext data from it by using the <code>SSLEngine</code> created
in <a href="#ex1">Example 1</a>. Each iteration of this code may or
may not produce plaintext data, depending on whether handshaking is
in progress.</p>
<div>
<div class="caption"><a name="ex3" id="ex3">Example 3: Reading Data
From Nonblocking SocketChannel</a></div>
<pre class="codeblock">
// Read SSL/TLS encoded data from peer
int num = socketChannel.read(peerNetData);
if (num == -1) {
    // The channel has reached end-of-stream
} else if (num == 0) {
    // No bytes read; try again ...
} else {
    // Process incoming data
    peerNetData.flip();
    res = engine.unwrap(peerNetData, peerAppData);

    if (res.getStatus() == SSLEngineResult.Status.OK) {
        peerNetData.compact();

        if (peerAppData.hasRemaining()) {
            // Use peerAppData
        }
    }
    // Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
    ...
}
</pre></div>
<!-- *********************************************** -->
<h4><a name="OperationStatus" id="OperationStatus">Understanding
SSLEngine Operation Statuses</a></h4>
<p>To indicate the status of the engine and what actions the
application should take, the <code>SSLEngine.wrap()</code> and
<code>SSLEngine.unwrap()</code> methods return an <a href=
"../../../../api/javax/net/ssl/SSLEngineResult.html"><code>SSLEngineResult</code></a>
instance, as shown in <a href="#ex2">Example 2</a>. This
<code>SSLEngineResult</code> object contains two pieces of status
information: the overall status of the engine and the handshaking
status.</p>
<p>The possible overall statuses are represented by the
<code>SSLEngineResult.Status</code> enum. The following statuses
are available:</p>
<ul>
<li><code>OK</code><br />
There was no error.</li>
<li><code>CLOSED</code><br />
The operation closed the <code>SSLEngine</code> or the operation
could not be completed because it was already closed.</li>
<li><code>BUFFER_UNDERFLOW</code><br />
The input buffer had insufficient data, indicating that the
application must obtain more data from the peer (for example, by
reading more data from the network).</li>
<li><code>BUFFER_OVERFLOW</code><br />
The output buffer had insufficient space to hold the result,
indicating that the application must clear or enlarge the
destination buffer.</li>
</ul>
<p><a href="#ex4">Example 4</a> illustrates how to handle the
<code>BUFFER_UNDERFLOW</code> and <code>BUFFER_OVERFLOW</code>
statuses of the <code>SSLEngine.unwrap()</code> method. It uses
<code>SSLSession.getApplicationBufferSize()</code> and
<code>SSLSession.getPacketBufferSize()</code> to determine how
large to make the byte buffers.</p>
<div>
<div class="caption"><a name="ex4" id="ex4">Example 4: Handling
BUFFER_UNDERFLOW and BUFFER_OVERFLOW</a></div>
<pre class="codeblock">
SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
switch (res.getStatus()) {

case BUFFER_OVERFLOW:
    // Maybe need to enlarge the peer application data buffer.
    if (engine.getSession().getApplicationBufferSize() &gt; peerAppData.capacity()) {
        // enlarge the peer application data buffer
    } else {
        // compact or clear the buffer
    }
    // retry the operation
    break;

case BUFFER_UNDERFLOW:
    // Maybe need to enlarge the peer network packet buffer
    if (engine.getSession().getPacketBufferSize() &gt; peerNetData.capacity()) {
        // enlarge the peer network packet buffer
    } else {
        // compact or clear the buffer
    }
    // obtain more inbound network data and then retry the operation
    break;

    // Handle other status: CLOSED, OK
    ...
}
</pre></div>
<p>The possible handshaking statuses are represented by the
<code>SSLEngineResult.HandshakeStatus</code> enum. They represent
whether handshaking has completed, whether the caller must obtain
more handshaking data from the peer or send more handshaking data
to the peer, and so on.</p>
<p>Having two statuses per result allows the SSLEngine to indicate
that the application must take two actions: one in response to the
handshaking and one representing the overall status of the
<code>wrap()</code> and <code>unwrap()</code> methods. For example,
the engine might, as the result of a single
<code>SSLEngine.unwrap()</code> call, return
<code>SSLEngineResult.Status.OK</code> to indicate that the input
data was processed successfully and
<code>SSLEngineResult.HandshakeStatus.NEED_UNWRAP</code> to
indicate that the application should obtain more SSL/TLS encoded
data from the peer and supply it to <code>SSLEngine.unwrap()</code>
again so that handshaking can continue. As you can see, the
previous examples were greatly simplified; they would need to be
expanded significantly to properly handle all of these
statuses.</p>
<p><a href="#ex5">Example 5</a> illustrates how to process
handshaking data by checking handshaking status and the overall
status of the <code>wrap()</code> and <code>unwrap()</code>
methods.</p>
<div>
<div class="caption"><a name="ex5" id="ex5">Example 5: Checking and
Processing Handshaking Statuses and Overall Statuses</a></div>
<pre class="codeblock">
void doHandshake(SocketChannel socketChannel, SSLEngine engine,
        ByteBuffer myNetData, ByteBuffer peerNetData) throws Exception {

    // Create byte buffers to use for holding application data
    int appBufferSize = engine.getSession().getApplicationBufferSize();
    ByteBuffer myAppData = ByteBuffer.allocate(appBufferSize);
    ByteBuffer peerAppData = ByteBuffer.allocate(appBufferSize);

    // Begin handshake
    engine.beginHandshake();
    SSLEngineResult.HandshakeStatus hs = engine.getHandshakeStatus();

    // Process handshaking message
    while (hs != SSLEngineResult.HandshakeStatus.FINISHED &amp;&amp;
        hs != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {

        switch (hs) {

        case NEED_UNWRAP:
            // Receive handshaking data from peer
            if (socketChannel.read(peerNetData) &lt; 0) {
                // The channel has reached end-of-stream
            }

            // Process incoming handshaking data
            peerNetData.flip();
            SSLEngineResult res = engine.unwrap(peerNetData, peerAppData);
            peerNetData.compact();
            hs = res.getHandshakeStatus();

            // Check status
            switch (res.getStatus()) {
            case OK :
                // Handle OK status
                break;

            // Handle other status: BUFFER_UNDERFLOW, BUFFER_OVERFLOW, CLOSED
            ...
            }
            break;

        case NEED_WRAP :
            // Empty the local network packet buffer.
            myNetData.clear();

            // Generate handshaking data
            res = engine.wrap(myAppData, myNetData);
            hs = res.getHandshakeStatus();

            // Check status
            switch (res.getStatus()) {
            case OK :
                myNetData.flip();

                // Send the handshaking data to peer
                while (myNetData.hasRemaining()) {
                    socketChannel.write(myNetData);
                }
                break;

            // Handle other status:  BUFFER_OVERFLOW, BUFFER_UNDERFLOW, CLOSED
            ...
            }
            break;

        case NEED_TASK :
            // Handle blocking tasks
            break;

        // Handle other status:  // FINISHED or NOT_HANDSHAKING
        ...
        }
    }

    // Processes after handshaking
    ...
}
</pre></div>
<!-- *********************************************** -->
<h4>Dealing With Blocking Tasks</h4>
<p>During handshaking, an <code>SSLEngine</code> might encounter
tasks that can block or take a long time. For example, a
<code>TrustManager</code> may need to connect to a remote
certificate validation service, or a <code>KeyManager</code> might
need to prompt a user to determine which certificate to use as part
of client authentication. To preserve the nonblocking nature of
<code>SSLEngine</code>, when the engine encounters such a task, it
will return <code>SSLEngineResult.HandshakeStatus.NEED_TASK</code>.
Upon receiving this status, the application should invoke
<code>SSLEngine.getDelegatedTask()</code> to get the task, and
then, using the threading model appropriate for its requirements,
process the task. The application might, for example, obtain
threads from a thread pool to process the tasks, while the main
thread handles other I/O.</p>
<p>The following code executes each task in a newly created
thread:</p>
<pre class="codeblock">
if (res.getHandshakeStatus() == SSLEngineResult.HandshakeStatus.NEED_TASK) {
    Runnable task;
    while ((task = engine.getDelegatedTask()) != null) {
        new Thread(task).start();
    }
}
</pre>
<p>The <code>SSLEngine</code> will block future <code>wrap()</code>
and <code>unwrap()</code> calls until all of the outstanding tasks
are completed. 
<!-- *********************************************** --></p>
<h4>Shutting Down</h4>
<p>For an orderly shutdown of an SSL/TLS connection, the SSL/TLS
protocols require transmission of close messages. Therefore, when
an application is done with the SSL/TLS connection, it should first
obtain the close messages from the <code>SSLEngine</code>, then
transmit them to the peer using its transport mechanism, and
finally shut down the transport mechanism. <a href="#ex6">Example
6</a> illustrates this.</p>
<div>
<div class="caption"><a name="ex6" id="ex6">Example 6: Shutting
Down an SSL/TLS Connection</a></div>
<pre class="codeblock">
// Indicate that application is done with engine
engine.closeOutbound();

while (!engine.isOutboundDone()) {
    // Get close message
    SSLEngineResult res = engine.wrap(empty, myNetData);

    // Check res statuses

    // Send close message to peer
    while(myNetData.hasRemaining()) {
        int num = socketChannel.write(myNetData);
        if (num == 0) {
            // no bytes written; try again later
        }
        myNetData().compact();
    }
}

// Close transport
socketChannel.close();
</pre></div>
<p>In addition to an application explicitly closing the
<code>SSLEngine</code>, the <code>SSLEngine</code> might be closed
by the peer (via receipt of a close message while it is processing
handshake data), or by the <code>SSLEngine</code> encountering an
error while processing application or handshake data, indicated by
throwing an <code>SSLException</code>. In such cases, the
application should invoke <code>SSLEngine.wrap()</code> to get the
close message and send it to the peer until
<code>SSLEngine.isOutboundDone()</code> returns <code>true</code>
(as shown in <a href="#ex6">Example 6</a>), or until the
<code>SSLEngineResult.getStatus()</code> returns
<code>CLOSED</code>.</p>
<p>In addition to orderly shutdowns, there can also be unexpected
shutdowns when the transport link is severed before close messages
are exchanged. In the previous examples, the application might get
<code>-1</code> or <tt>IOException</tt> when trying to read from
the nonblocking <code>SocketChannel</code>, or get
<tt>IOException</tt> when trying to write to the non-blocking
<tt>SocketChannel</tt>. When you get to the end of your input data,
you should call <code>engine.closeInbound()</code>, which will
verify with the <code>SSLEngine</code> that the remote peer has
closed cleanly from the SSL/TLS perspective. Then the application
should still try to shut down cleanly by using the procedure in
<a href="#ex6">Example 6</a>. Obviously, unlike
<code>SSLSocket</code>, the application using
<code>SSLEngine</code> must deal with more state transitions,
statuses, and programming. For more information about writing an
<code>SSLEngine</code>-based application, see <a href=
"#SSLEngineSample">Sample Code Illustrating the Use of an
SSLEngine</a>.</p>
<!-- *********************************************** -->
<h3><a name="SSLSession" id="SSLSession">SSLSession and
ExtendedSSLSession</a></h3>
<p>The <code>javax.net.ssl.SSLSession</code> interface represents a
security context negotiated between the two peers of an
<code>SSLSocket</code> or <code>SSLEngine</code> connection. After
a session has been arranged, it can be shared by future
<code>SSLSocket</code> or <code>SSLEngine</code> objects connected
between the same two peers.</p>
<p>In some cases, parameters negotiated during the handshake are
needed later in the handshake to make decisions about trust. For
example, the list of valid signature algorithms might restrict the
certificate types that can be used for authentication. The
<code>SSLSession</code> can be retrieved <em>during</em> the
handshake by calling <code>getHandshakeSession()</code> on an
<code>SSLSocket</code> or <code>SSLEngine</code>. Implementations
of <code>TrustManager</code> or <code>KeyManager</code> can use the
<code>getHandshakeSession()</code> method to get information about
session parameters to help them make decisions.</p>
<p>A fully initialized <code>SSLSession</code> contains the cipher
suite that will be used for communications over a secure socket as
well as a nonauthoritative hint as to the network address of the
remote peer, and management information such as the time of
creation and last use. A session also contains a shared master
secret negotiated between the peers that is used to create
cryptographic keys for encrypting and guaranteeing the integrity of
the communications over an <code>SSLSocket</code> or
<code>SSLEngine</code> connection. The value of this master secret
is known only to the underlying secure socket implementation and is
not exposed through the <code>SSLSession</code> API.</p>
<p>In Java SE, a TLS 1.2 session is represented by
<code>ExtendedSSLSession</code>, an implementation of
<code>SSLSession</code>. The <code>ExtendedSSLSession</code> class
adds methods that describe the signature algorithms that are
supported by the local implementation and the peer. The
<code>getRequestedServerNames()</code> method called on an
<code>ExtendedSSLSession</code> instance is used to obtain a list
of <code>SNIServerName</code> objects in the requested <a href=
"#SNIExtension">Server Name Indication (SNI)</a> extension. The
server should use the requested server names to guide its selection
of an appropriate authentication certificate, and/or other aspects
of the security policy. The client should use the requested server
names to guide its endpoint identification of the peer's identity,
and/or other aspects of the security policy.</p>
<p>Calls to the <code>getPacketBufferSize()</code> and
<code>getApplicationBufferSize()</code> methods on
<code>SSLSession</code> are used to determine the appropriate
buffer sizes used by <code>SSLEngine</code>.</p>
<hr />
<a name="LargePackets" id="LargePackets"></a>
<p><strong>Note:</strong> The SSL/TLS protocols specify that
implementations are to produce packets containing at most 16
kilobytes (KB) of plain text. However, some implementations violate
the specification and generate large records up to 32 KB. If the
<code>SSLEngine.unwrap()</code> code detects large inbound packets,
then the buffer sizes returned by <code>SSLSession</code> will be
updated dynamically. Applications should always <a href=
"#OperationStatus">check the <code>BUFFER_OVERFLOW</code> and
<code>BUFFER_UNDERFLOW</code> statuses and enlarge the
corresponding buffers</a> if necessary. SunJSSE will always send
standard compliant 16 KB records and allow incoming 32 KB records.
For a workaround, see the System property
<code>jsse.SSLEngine.acceptLargeFragments</code> in <a href=
"#InstallationAndCustomization">Customizing JSSE</a>.</p>
<hr />
<!-- *********************************************** -->
<h3><a name="HttpsURLConnection" id=
"HttpsURLConnection">HttpsURLConnection Class</a></h3>
<p>The HTTPS protocol is similar to HTTP, but HTTPS first
establishes a secure channel via SSL/TLS sockets and then <a href=
"#ciphersuitechoice">verifies the identity of the peer</a> before
requesting or receiving data. The
<code>javax.net.ssl.HttpsURLConnection</code> class extends the
<code>java.net.HttpsURLConnection</code> class and adds support for
HTTPS-specific features. For more information about how HTTPS URLs
are constructed and used, see the API specification sections about
the <a href=
"../../../../api/java/net/URL.html"><code>java.net.URL</code></a>,
<a href=
"../../../../api/java/net/URLConnection.html"><code>java.net.URLConnection</code></a>,
<a href=
"../../../../api/java/net/HttpURLConnection.html"><code>java.net.HttpURLConnection</code></a>,
and <a href=
"../../../../api/javax/net/ssl/HttpsURLConnection.html"><code>javax.net.ssl.HttpURLConnection</code></a>
classes.</p>
<p>Upon obtaining an <code>HttpsURLConnection</code> instance, you
can configure a number of HTTP and HTTPS parameters before actually
initiating the network connection via the
<code>URLConnection.connect()</code> method. Of particular interest
are:</p>
<ul>
<li><a href="#SettingSSLSocketFactory">Setting the Assigned
SSLSocketFactory</a></li>
<li><a href="#SettingHostnameVerifier">Setting the Assigned
HostnameVerifier</a></li>
</ul>
<!-- *********************************************** -->
<h4><a name="SettingSSLSocketFactory" id=
"SettingSSLSocketFactory">Setting the Assigned
SSLSocketFactory</a></h4>
<p>In some situations, it is desirable to specify the
<code>SSLSocketFactory</code> that an
<code>HttpsURLConnection</code> instance uses. For example, you
might want to tunnel through a proxy type that is not supported by
the default implementation. The new <code>SSLSocketFactory</code>
could return sockets that have already performed all necessary
tunneling, thus allowing <code>HttpsURLConnection</code> to use
additional proxies.</p>
<p>The <code>HttpsURLConnection</code> class has a default
<code>SSLSocketFactory</code> that is assigned when the class is
loaded (this is the factory returned by the
<code>SSLSocketFactory.getDefault()</code> method). Future
instances of <code>HttpsURLConnection</code> will inherit the
current default <code>SSLSocketFactory</code> until a new default
<code>SSLSocketFactory</code> is assigned to the class via the
static <code>HttpsURLConnection.setDefaultSSLSocketFactory()</code>
method. Once an instance of <code>HttpsURLConnection</code> has
been created, the inherited <code>SSLSocketFactory</code> on this
instance can be overridden with a call to the
<code>setSSLSocketFactory()</code> method.</p>
<hr />
<p><strong>Note:</strong> Changing the default static
<code>SSLSocketFactory</code> has no effect on existing instances
of <code>HttpsURLConnection</code>. A call to the
<code>setSSLSocketFactory()</code> method is necessary to change
the existing instances.</p>
<hr />
<p>You can obtain the per-instance or per-class
<code>SSLSocketFactory</code> by making a call to the
<code>getSSLSocketFactory()</code> or
<code>getDefaultSSLSocketFactory()</code> method, respectively.</p>
<!-- *********************************************** -->
<h4><a name="SettingHostnameVerifier" id=
"SettingHostnameVerifier">Setting the Assigned
HostnameVerifier</a></h4>
<p>If the host name of the URL does not match the host name in the
credentials received as part of the SSL/TLS handshake, then it is
possible that URL spoofing has occurred. If the implementation
cannot determine a host name match with reasonable certainty, then
the SSL implementation performs a callback to the instance's
assigned <code>HostnameVerifier</code> for further checking. The
host name verifier can take whatever steps are necessary to make
the determination, such as performing host name pattern matching or
perhaps opening an interactive dialog box. An unsuccessful
verification by the host name verifier closes the connection. For
more information regarding host name verification, see <a href=
"http://www.ietf.org/rfc/rfc2818.txt?number=2818">RFC 2818</a>.</p>
<p>The <code>setHostnameVerifier()</code> and
<code>setDefaultHostnameVerifier()</code> methods operate in a
similar manner to the <code>setSSLSocketFactory()</code> and
<code>setDefaultSSLSocketFactory()</code> methods, in that
<code>HostnameVerifier</code> objects are assigned on a
per-instance and per-class basis, and the current values can be
obtained by a call to the <code>getHostnameVerifier()</code> or
<code>getDefaultHostnameVerifier()</code> method.</p>
<!-- *********************************************** -->
<h2><a name="SupportClasses" id="SupportClasses">Support Classes
and Interfaces</a></h2>
<p>The classes and interfaces in this section are provided to
support the creation and initialization of <code>SSLContext</code>
objects, which are used to create <code>SSLSocketFactory</code>,
<code>SSLServerSocketFactory</code>, and <code>SSLEngine</code>
objects. The support classes and interfaces are part of the
<code>javax.net.ssl</code> package.</p>
<p>Three of the classes described in this section (<a href=
"#SSLContext"><code>SSLContext</code></a>, <a href=
"#KeyManagerFactory"><code>KeyManagerFactory</code></a>, and
<a href=
"#TrustManagerFactory"><code>TrustManagerFactory</code></a>) are
<dfn>engine classes</dfn>. An engine class is an API class for
specific algorithms (or protocols, in the case of
<code>SSLContext</code>), for which implementations may be provided
in one or more Cryptographic Service Provider (provider) packages.
For more information about providers and engine classes, see the
"Design Principles" and "Concepts" sections of the <a href=
"../crypto/CryptoSpec.html">Java Cryptography Architecture
Reference Guide</a>.</p>
<p>The SunJSSE provider that comes standard with JSSE provides
<code>SSLContext</code>, <code>KeyManagerFactory</code>, and
<code>TrustManagerFactory</code> implementations, as well as
implementations for engine classes in the standard
<code>java.security</code> API. <a href="#T5">Table 5</a> lists
implementations supplied by SunJSSE.</p>
<table summary="Typical handshake" border="1">
<caption><a name="T5" id="T5">Table 5: Implementations Supplied by
SunJSEE</a></caption>
<thead>
<tr>
<th id="class">Engine Class Implemented</th>
<th id="algorithm">Algorithm or Protocol</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="class"><code>KeyStore</code></td>
<td headers="algorithm">PKCS12</td>
</tr>
<tr>
<td headers="class"><code>KeyManagerFactory</code></td>
<td headers="algorithm">PKIX, SunX509</td>
</tr>
<tr>
<td headers="class"><code>TrustManagerFactory</code></td>
<td headers="algorithm">PKIX (X509 or SunPKIX), SunX509</td>
</tr>
<tr>
<td headers="class"><code>SSLContext</code></td>
<td headers="algorithm">SSLv3(<a class="footnote" href=
"../SunProviders.html#enable-sslv3">1</a>), TLSv1, TLSv1.1,
TLSv1.2</td>
</tr>
</tbody>
</table>
<!-- *********************************************** -->
<h3><a name="SSLContext" id="SSLContext">The SSLContext
Class</a></h3>
<p>The <code>javax.net.ssl.SSLContext</code> class is an engine
class for an implementation of a secure socket protocol. An
instance of this class acts as a factory for SSL socket factories
and SSL engines. An <code>SSLContext</code> object holds all of the
state information shared across all objects created under that
context. For example, session state is associated with the
<code>SSLContext</code> when it is negotiated through the handshake
protocol by sockets created by socket factories provided by the
context. These cached sessions can be reused and shared by other
sockets created under the same context.</p>
<p>Each instance is configured through its <code>init</code> method
with the keys, certificate chains, and trusted root CA certificates
that it needs to perform authentication. This configuration is
provided in the form of key and trust managers. These managers
provide support for the authentication and key agreement aspects of
the cipher suites supported by the context.</p>
<p>Currently, only X.509-based managers are supported.</p>
<!-- *********************************************** -->
<h4>Creating an SSLContext Object</h4>
<p>Like other JCA provider-based engine classes,
<code>SSLContext</code> objects are created using the
<code>getInstance()</code> factory methods of the
<code>SSLContext</code> class. These static methods each return an
instance that implements <em>at least</em> the requested secure
socket protocol. The returned instance may implement other
protocols, too. For example, <code>getInstance("TLSv1")</code> may
return an instance that implements TLSv1, TLSv1.1, and TLSv1.2. The
<code>getSupportedProtocols()</code> method returns a list of
supported protocols when an <code>SSLSocket</code>,
<code>SSLServerSocket</code>, or <code>SSLEngine</code> is created
from this context. You can control which protocols are actually
enabled for an SSL connection by using the
<code>setEnabledProtocols(String[] protocols)</code> method.</p>
<hr />
<p><strong>Note:</strong> An <code>SSLContext</code> object is
automatically created, initialized, and statically assigned to the
<code>SSLSocketFactory</code> class when you call the
<code>SSLSocketFactory.getDefault()</code> method. Therefore, you
do not have to directly create and initialize an
<code>SSLContext</code> object (unless you want to override the
default behavior).</p>
<p>To create an <code>SSLContext</code> object by calling the
<code>getInstance()</code> factory method, you must specify the
protocol name. You may also specify which provider you want to
supply the implementation of the requested protocol:</p>
<ul>
<li><code>public static SSLContext getInstance(String
protocol);</code></li>
<li><code>public static SSLContext getInstance(String protocol,
String provider);</code></li>
<li><code>public static SSLContext getInstance(String protocol,
Provider provider);</code></li>
</ul>
<p>If just a protocol name is specified, then the system will
determine whether an implementation of the requested protocol is
available in the environment. If there is more than one
implementation, then it will determine whether there is a preferred
one.</p>
<p>If both a protocol name and a provider are specified, then the
system will determine whether an implementation of the requested
protocol is in the provider requested. If there is no
implementation, an exception will be thrown.</p>
<p>A protocol is a string (such as <code>"TLS"</code>) that
describes the secure socket protocol desired. Common protocol names
for <code>SSLContext</code> objects are defined in <a href=
"#AppA">Appendix A</a>.</p>
<p>An <code>SSLContext</code> can be obtained as follows:</p>
<pre class="codeblock">
    SSLContext sc = SSLContext.getInstance("TLS");
</pre>
<p>A newly created <code>SSLContext</code> should be initialized by
calling the <code>init</code> method:</p>
<pre class="codeblock">
    public void init(KeyManager[] km, TrustManager[] tm, SecureRandom random);
</pre>
<p>If the <code>KeyManager[]</code> parameter is null, then an
empty <code>KeyManager</code> will be defined for this context. If
the <code>TrustManager[]</code> parameter is null, then the
installed security providers will be searched for the
highest-priority implementation of the <a href=
"#TrustManagerFactory"><code>TrustManagerFactory</code></a>, from
which an appropriate <code>TrustManager</code> will be obtained.
Likewise, the <code>SecureRandom</code> parameter may be null, in
which case a default implementation will be used.</p>
<p>If the internal default context is used, (for example, an
<code>SSLContext</code> is created by
<code>SSLSocketFactory.getDefault()</code> or
<code>SSLServerSocketFactory.getDefault()</code>), then a <a href=
"#DefaultKTMCust">default <code>KeyManager</code> and
<code>TrustManager</code></a> are created. The default
<code>SecureRandom</code> implementation is also chosen.</p>
<!-- *********************************************** -->
<h3><a name="TrustManager" id="TrustManager">The TrustManager
Interface</a></h3>
<p>The primary responsibility of the <code>TrustManager</code> is
to determine whether the presented authentication credentials
should be trusted. If the credentials are not trusted, then the
connection will be terminated. To authenticate the remote identity
of a secure socket peer, you must initialize an
<code>SSLContext</code> object with one or more
<code>TrustManager</code> objects. You must pass one
<code>TrustManager</code> for each authentication mechanism that is
supported. If null is passed into the <code>SSLContext</code>
initialization, then a trust manager will be created for you.
Typically, a single trust manager supports authentication based on
X.509 public key certificates (for example,
<code>X509TrustManager</code>). Some secure socket implementations
may also support authentication based on shared secret keys,
Kerberos, or other mechanisms.</p>
<p><code>TrustManager</code> objects are created either by a
<code>TrustManagerFactory</code>, or by providing a concrete
implementation of the interface.</p>
<!-- *********************************************** -->
<h3><a name="TrustManagerFactory" id="TrustManagerFactory">The
TrustManagerFactory Class</a></h3>
<p>The <code>javax.net.ssl.TrustManagerFactory</code> is an engine
class for a provider-based service that acts as a factory for one
or more types of <code>TrustManager</code> objects. Because it is
provider-based, additional factories can be implemented and
configured to provide additional or alternative trust managers that
provide more sophisticated services or that implement
installation-specific authentication policies.</p>
<!-- *********************************************** -->
<h4>Creating a TrustManagerFactory</h4>
You create an instance of this class in a similar manner to
<code>SSLContext</code>, except for passing an algorithm name
string instead of a protocol name to the <code>getInstance()</code>
method:
<pre class="codeblock">
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm);
    
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm, String provider);
    
    TrustManagerFactory tmf = TrustManagerFactory.getInstance(String algorithm, Provider provider);
</pre>
<p>A sample call is as follows:</p>
<pre class="codeblock">
    TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX", "SunJSSE");
</pre>
<p>The preceding call creates an instance of the SunJSSE provider's
PKIX trust manager factory. This factory can be used to create
trust managers that provide X.509 PKIX-based certification path
validity checking.</p>
<p>When initializing an <code>SSLContext</code>, you can use trust
managers created from a trust manager factory, or you can write
your own trust manager, for example, using the <a href=
"../../../../api/java/security/cert/CertPath.html"><code>CertPath</code></a>
API. For details, see the <a href=
"../certpath/CertPathProgGuide.html">Java PKI Programmer's
Guide</a>. You do not need to use a trust manager factory if you
implement a trust manager using the <a href=
"../../../../api/javax/net/ssl/X509TrustManager.html"><code>X509TrustManager</code></a>
interface.</p>
<p>A newly created factory should be initialized by calling one of
the <code>init()</code> methods:</p>
<pre class="codeblock">
    public void init(KeyStore ks);
    public void init(ManagerFactoryParameters spec);
</pre>
<p>Call whichever <code>init()</code> method is appropriate for the
<code>TrustManagerFactory</code> you are using. If you are not
sure, then ask the provider vendor.</p>
<p>For many factories, such as the SunX509
<code>TrustManagerFactory</code> from the SunJSSE provider, the
<code>KeyStore</code> is the only information required to
initialize the <code>TrustManagerFactory</code> and thus the first
<code>init</code> method is the appropriate one to call. The
<code>TrustManagerFactory</code> will query the
<code>KeyStore</code> for information about which remote
certificates should be trusted during authorization checks.</p>
<p>Sometimes, initialization parameters other than a
<code>KeyStore</code> are needed by a provider. Users of that
provider are expected to pass an implementation of the appropriate
<code>ManagerFactoryParameters</code> as defined by the provider.
The provider can then call the specified methods in the
<code>ManagerFactoryParameters</code> implementation to obtain the
needed information.</p>
<p>For example, suppose the <code>TrustManagerFactory</code>
provider requires initialization parameters B, R, and S from any
application that wants to use that provider. Like all providers
that require initialization parameters other than a
<code>KeyStore</code>, the provider requires the application to
provide an instance of a class that implements a particular
<code>ManagerFactoryParameters</code> subinterface. In the example,
suppose that the provider requires the calling application to
implement and create an instance of
<code>MyTrustManagerFactoryParams</code> and pass it to the second
<code>init()</code> method. The following example illustrates what
<code>MyTrustManagerFactoryParams</code> can look like:</p>
<pre class="codeblock">
    public interface MyTrustManagerFactoryParams extends ManagerFactoryParameters {
        public boolean getBValue();
        public float getRValue();
        public String getSValue():
    }
</pre>
<p>Some trust managers can make trust decisions without being
explicitly initialized with a <code>KeyStore</code> object or any
other parameters. For example, they may access trust material from
a local directory service via LDAP, use a remote online certificate
status checking server, or access default trust material from a
standard local location.</p>
<!-- *********************************************** -->
<h4><a name="CERTPATH" id="CERTPATH">PKIX TrustManager
Support</a></h4>
<p>The default trust manager algorithm is PKIX. It can be changed
by editing the <code>ssl.TrustManagerFactory.algorithm</code>
property in the <code>java.security</code> file.</p>
<p>The PKIX trust manager factory uses the <a href=
"../certpath/CertPathProgGuide.html">CertPath PKIX</a>
implementation from an installed security provider. The trust
manager factory can be initialized using the normal
<code>init(KeyStore ks)</code> method, or by passing CertPath
parameters to the the PKIX trust manager using the <a href=
"../../../../api/javax/net/ssl/CertPathTrustManagerParameters.html">
<code>javax.net.ssl.CertPathTrustManagerParameters</code></a>
class.</p>
<p>The following example illustrates how to get the trust manager
to use a particular LDAP certificate store and enable revocation
checking:</p>
<pre class="codeblock">
    import javax.net.ssl.*;
    import java.security.cert.*;
    import java.security.KeyStore;
    import java.io.FileInputStream;
    ...
    
    // Obtain Keystore password
    char[] pass = System.console().readPassword("Password: ");

    // Create PKIX parameters
    KeyStore anchors = KeyStore.getInstance("PKCS12");
    anchors.load(new FileInputStream(anchorsFile, pass));
    PKIXBuilderParameters pkixParams = new PKIXBuilderParameters(anchors, new X509CertSelector());
    
    // Specify LDAP certificate store to use
    LDAPCertStoreParameters lcsp = new LDAPCertStoreParameters("ldap.imc.org", 389);
    pkixParams.addCertStore(CertStore.getInstance("LDAP", lcsp));
    
    // Specify that revocation checking is to be enabled
    pkixParams.setRevocationEnabled(true);
    
    // Wrap PKIX parameters as trust manager parameters
    ManagerFactoryParameters trustParams = new CertPathTrustManagerParameters(pkixParams);
    
    // Create TrustManagerFactory for PKIX-compliant trust managers
    TrustManagerFactory factory = TrustManagerFactory.getInstance("PKIX");
    
    // Pass parameters to factory to be passed to CertPath implementation
    factory.init(trustParams);
    
    // Use factory
    SSLContext ctx = SSLContext.getInstance("TLS");
    ctx.init(null, factory.getTrustManagers(), null);
</pre>
<p>If the <code>init(KeyStore ks)</code> method is used, then
default PKIX parameters are used with the exception that revocation
checking is disabled. It can be enabled by setting the
<code>com.sun.net.ssl.checkRevocation</code> system property to
<code>true</code>. This setting requires that the CertPath
implementation can locate revocation information by itself. The
PKIX implementation in the provider can do this in many cases but
requires that the system property
<code>com.sun.security.enableCRLDP</code> be set to
<code>true</code>.</p>
<p>For more information about PKIX and the CertPath API, see the
<a href="../certpath/CertPathProgGuide.html">Java PKI Programmer's
Guide</a>.</p>
<!-- *********************************************** -->
<h3><a name="X509TrustManager" id="X509TrustManager">The
X509TrustManager Interface</a></h3>
<p>The <code>javax.net.ssl.X509TrustManager</code> interface
extends the general <code>TrustManager</code> interface. It must be
implemented by a trust manager when using X.509-based
authentication.</p>
<p>To support X.509 authentication of remote socket peers through
JSSE, an instance of this interface must be passed to the
<code>init</code> method of an <code>SSLContext</code> object.</p>
<!-- *********************************************** -->
<h4>Creating an X509TrustManager</h4>
<p>You can either implement this interface directly yourself or
obtain one from a provider-based <code>TrustManagerFactory</code>
(such as that supplied by the SunJSSE provider). You could also
implement your own interface that delegates to a factory-generated
trust manager. For example, you might do this to filter the
resulting trust decisions and query an end-user through a graphical
user interface.</p>
<hr />
<p><strong>Note:</strong> If a null KeyStore parameter is passed to
the SunJSSE PKIX or SunX509 <code>TrustManagerFactory</code>, then
the factory uses the following process to try to find trust
material:</p>
<hr />
<ol>
<li>
<p>If the <code>javax.net.ssl.trustStore</code> property is
defined, then the <code>TrustManagerFactory</code> attempts to find
a file using the file name specified by that system property, and
uses that file for the KeyStore parameter. If the
<code>javax.net.ssl.trustStorePassword</code> system property is
also defined, then its value is used to check the integrity of the
data in the truststore before opening it.</p>
<p>If the <code>javax.net.ssl.trustStore</code> property is defined
but the specified file does not exist, then a default
<code>TrustManager</code> using an empty keystore is created.</p>
</li>
<li>If the <code>javax.net.ssl.trustStore</code> system property
was not specified, then:
<ul>
<li>if the file
<var>java-home</var><code>/lib/security/jssecacerts</code> exists,
that file is used;</li>
<li>if the file
<var>java-home</var><code>/lib/security/cacerts</code> exists, that
file is used;</li>
<li>if neither of these files exists, then the SSL cipher suite is
anonymous, does not perform any authentication, and thus does not
need a truststore.</li>
</ul>
</li>
</ol>
<p>For information about what <var>java-home</var> refers to, see
<a href="#javaHome">The Installation Directory</a>.</p>
<p>The factory looks for a file specified via the
<code>javax.net.ssl.trustStore</code> security property or for the
jssecacerts file before checking for a <code>cacerts</code> file.
Therefore, you can provide a JSSE-specific set of trusted root
certificates separate from ones that might be present in cacerts
for code-signing purposes.</p>
<!-- *********************************************** -->
<h4><a name="OwnX509TM" id="OwnX509TM">Creating Your Own
X509TrustManager</a></h4>
<p>If the supplied <code>X509TrustManager</code> behavior is not
suitable for your situation, then you can create your own
<code>X509TrustManager</code> by either creating and registering
your own <code>TrustManagerFactory</code> or by implementing the
<code>X509TrustManager</code> interface directly.</p>
<p>The following example illustrates a
<code>MyX509TrustManager</code> class that enhances the default
SunJSSE <code>X509TrustManager</code> behavior by providing
alternative authentication logic when the default
<code>X509TrustManager</code> fails:</p>
<pre class="codeblock">
class MyX509TrustManager implements X509TrustManager {

     /*
      * The default PKIX X509TrustManager9.  Decisions are delegated
      * to it, and a fall back to the logic in this class is performed
      * if the default X509TrustManager does not trust it.
      */
     X509TrustManager pkixTrustManager;

     MyX509TrustManager() throws Exception {
         // create a "default" JSSE X509TrustManager.

         KeyStore ks = KeyStore.getInstance("PKCS12");
         ks.load(new FileInputStream("trustedCerts"), "passphrase".toCharArray());

         TrustManagerFactory tmf = TrustManagerFactory.getInstance("PKIX");
         tmf.init(ks);

         TrustManager tms [] = tmf.getTrustManagers();

         /*
          * Iterate over the returned trust managers, looking
          * for an instance of X509TrustManager.  If found,
          * use that as the default trust manager.
          */
         for (int i = 0; i &lt; tms.length; i++) {
             if (tms[i] instanceof X509TrustManager) {
                 pkixTrustManager = (X509TrustManager) tms[i];
                 return;
             }
         }

         /*
          * Find some other way to initialize, or else the
          * constructor fails.
          */
         throw new Exception("Couldn't initialize");
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkClientTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkClientTrusted(chain, authType);
         } catch (CertificateException excep) {
             // do any special handling here, or rethrow exception.
         }
     }

     /*
      * Delegate to the default trust manager.
      */
     public void checkServerTrusted(X509Certificate[] chain, String authType)
                 throws CertificateException {
         try {
             pkixTrustManager.checkServerTrusted(chain, authType);
         } catch (CertificateException excep) {
             /*
              * Possibly pop up a dialog box asking whether to trust the
              * cert chain.
              */
         }
     }

     /*
      * Merely pass this through.
      */
     public X509Certificate[] getAcceptedIssuers() {
         return pkixTrustManager.getAcceptedIssuers();
     }
}
</pre>
<p>Once you have created such a trust manager, assign it to an
<code>SSLContext</code> via the <code>init()</code> method, as in
the following example. Future <code>SocketFactories</code> created
from this <code>SSLContext</code> will use your new
<code>TrustManager</code> when making trust decisions.</p>
<pre class="codeblock">
    TrustManager[] myTMs = new TrustManager[] { new MyX509TrustManager() };
    SSLContext ctx = SSLContext.getInstance("TLS");
    ctx.init(null, myTMs, null);
</pre>
<!-- *********************************************** -->
<h4>Updating the Keystore Dynamically</h4>
<p>You can enhance <code>MyX509TrustManager</code> to handle
dynamic keystore updates. When a <code>checkClientTrusted</code> or
<code>checkServerTrusted</code> test fails and does not establish a
trusted certificate chain, you can add the required trusted
certificate to the keystore. You must create a new
<code>pkixTrustManager</code> from the
<code>TrustManagerFactory</code> initialized with the updated
keystore. When you establish a new connection (using the previously
initialized <code>SSLContext</code>), the newly added certificate
will be used when making trust decisions.</p>
<!-- *********************************************** -->
<h3><a name="X509ExtendedTrustManager" id=
"X509ExtendedTrustManager">X509ExtendedTrustManager Class</a></h3>
<p>The <code>X509ExtendedTrustManager</code> class is an abstract
implementation of the <code>X509TrustManager</code> interface. It
adds methods for connection-sensitive trust management. In
addition, it enables endpoint verification at the TLS layer.</p>
<p>In TLS 1.2 and later, both client and server can specify which
hash and signature algorithms they will accept. To authenticate the
remote side, authentication decisions must be based on both X509
certificates and the local accepted hash and signature algorithms.
The local accepted hash and signature algorithms can be obtained
using the
<code>ExtendedSSLSession.getLocalSupportedSignatureAlgorithms()</code>
method.</p>
<p>The <code>ExtendedSSLSession</code> object can be retrieved by
calling the <code>SSLSocket.getHandshakeSession()</code> method or
the <code>SSLEngine.getHandshakeSession()</code> method.</p>
<p>The <code>X509TrustManager</code> interface is not
connection-sensitive. It provides no way to access
<code>SSLSocket</code> or <code>SSLEngine</code> session
properties.</p>
<p>Besides TLS 1.2 support, the
<code>X509ExtendedTrustManager</code> class also supports algorithm
constraints and SSL layer host name verification. For JSSE
providers and trust manager implementations, the
<code>X509ExtendedTrustManager</code> class is highly recommended
over the legacy <code>X509TrustManager</code> interface.</p>
<!-- *********************************************** -->
<h4>Creating an X509ExtendedTrustManager</h4>
<p>You can either create an <code>X509ExtendedTrustManager</code>
subclass yourself (which is outlined in the following section) or
obtain one from a provider-based <code>TrustManagerFactory</code>
(such as that supplied by the SunJSSE provider). In Java SE 7, the
PKIX or SunX509 <code>TrustManagerFactory</code> returns an
<code>X509ExtendedTrustManager</code> instance.</p>
<!-- *********************************************** -->
<h4><a name="OwnX509ETM" id="OwnX509ETM">Creating Your Own
X509ExtendedTrustManager</a></h4>
<p>This section outlines how to create a subclass of
<code>X509ExtendedTrustManager</code> in nearly the same way as
described for <code>X509TrustManager</code>.</p>
<p>The following example illustrates how to create a class that
uses the PKIX <code>TrustManagerFactory</code> to locate a default
<code>X509ExtendedTrustManager</code> that will be used to make
decisions about trust. If the default trust manager fails for any
reason, then the subclass is can add other behavior. In the
example, these locations are indicated by comments in the
<code>catch</code> clauses.</p>
<pre class="codeblock">
    import java.io.*;
    import java.net.*;
    
    import java.security.*;
    import java.security.cert.*;
    import javax.net.ssl.*;
    
    public class MyX509ExtendedTrustManager extends X509ExtendedTrustManager {
    
         /*
          * The default PKIX X509ExtendedTrustManager.  Decisions are
          * delegated to it, and a fall back to the logic in this class is
          * performed if the default X509ExtendedTrustManager does not
          * trust it.
          */
         X509ExtendedTrustManager pkixTrustManager;
    
         MyX509ExtendedTrustManager() throws Exception {
             // create a &quot;default&quot; JSSE X509ExtendedTrustManager.
    
             KeyStore ks = KeyStore.getInstance(&quot;JKS&quot;);
             ks.load(new FileInputStream(&quot;trustedCerts&quot;), &quot;passphrase&quot;.toCharArray());
    
             TrustManagerFactory tmf = TrustManagerFactory.getInstance(&quot;PKIX&quot;);
             tmf.init(ks);
    
             TrustManager tms [] = tmf.getTrustManagers();
    
             /*
              * Iterate over the returned trust managers, looking
              * for an instance of X509ExtendedTrustManager. If found,
              * use that as the default trust manager.
              */
             for (int i = 0; i &lt; tms.length; i++) {
                 if (tms[i] instanceof X509ExtendedTrustManager) {
                     pkixTrustManager = (X509ExtendedTrustManager) tms[i];
                     return;
                 }
             }
    
             /*
              * Find some other way to initialize, or else we have to fail the
              * constructor.
              */
             throw new Exception(&quot;Couldn't initialize&quot;);
         }
    
         /*
          * Delegate to the default trust manager.
          */
         public void checkClientTrusted(X509Certificate[] chain, String authType)
                     throws CertificateException {
             try {
                 pkixTrustManager.checkClientTrusted(chain, authType);
             } catch (CertificateException excep) {
                 // do any special handling here, or rethrow exception.
             }
         }
    
         /*
          * Delegate to the default trust manager.
          */
         public void checkServerTrusted(X509Certificate[] chain, String authType)
                     throws CertificateException {
             try {
                 pkixTrustManager.checkServerTrusted(chain, authType);
             } catch (CertificateException excep) {
                 /*
                  * Possibly pop up a dialog box asking whether to trust the
                  * cert chain.
                  */
             }
         }
    
         /*
          * Connection-sensitive verification.
          */
         public void checkClientTrusted(X509Certificate[] chain, String authType, Socket socket)
                     throws CertificateException {
           try {
               pkixTrustManager.checkClientTrusted(chain, authType, socket);
           } catch (CertificateException excep) {
               // do any special handling here, or rethrow exception.
           }
         }
    
         public void checkClientTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
                     throws CertificateException {
           try {
               pkixTrustManager.checkClientTrusted(chain, authType, engine);
           } catch (CertificateException excep) {
               // do any special handling here, or rethrow exception.
           }
         }
    
         public void checkServerTrusted(X509Certificate[] chain, String authType, Socket socket)
                     throws CertificateException {
           try {
               pkixTrustManager.checkServerTrusted(chain, authType, socket);
           } catch (CertificateException excep) {
               // do any special handling here, or rethrow exception.
           }
         }
    
         public void checkServerTrusted(X509Certificate[] chain, String authType, SSLEngine engine)
                     throws CertificateException {
           try {
               pkixTrustManager.checkServerTrusted(chain, authType, engine);
           } catch (CertificateException excep) {
               // do any special handling here, or rethrow exception.
           }
         }
         
         /*
          * Merely pass this through.
          */
         public X509Certificate[] getAcceptedIssuers() {
             return pkixTrustManager.getAcceptedIssuers();
         }
    }
</pre>
<!-- *********************************************** -->
<h3><a name="KeyManager" id="KeyManager">The KeyManager
Interface</a></h3>
<p>The primary responsibility of the <code>KeyManager</code> is to
select the authentication credentials that will eventually be sent
to the remote host. To authenticate yourself (a local secure socket
peer) to a remote peer, you must initialize an
<code>SSLContext</code> object with one or more
<code>KeyManager</code> objects. You must pass one
<code>KeyManager</code> for each different authentication mechanism
that will be supported. If null is passed into the
<code>SSLContext</code> initialization, then an empty
<code>KeyManager</code> will be created. If the internal default
context is used (for example, an <code>SSLContext</code> created by
<code>SSLSocketFactory.getDefault()</code> or
<code>SSLServerSocketFactory.getDefault()</code>), then a <a href=
"#CustomizingStores">default <code>KeyManager</code></a> is
created. Typically, a single key manager supports authentication
based on X.509 public key certificates. Some secure socket
implementations may also support authentication based on shared
secret keys, Kerberos, or other mechanisms.</p>
<p><code>KeyManager</code> objects are created either by a
<code>KeyManagerFactory</code>, or by providing a concrete
implementation of the interface.</p>
<!-- *********************************************** -->
<h3><a name="KeyManagerFactory" id="KeyManagerFactory">The
KeyManagerFactory Class</a></h3>
<p>The <code>javax.net.ssl.KeyManagerFactory</code> class is an
engine class for a provider-based service that acts as a factory
for one or more types of <code>KeyManager</code> objects. The
SunJSSE provider implements a factory that can return a basic X.509
key manager. Because it is provider-based, additional factories can
be implemented and configured to provide additional or alternative
key managers.</p>
<!-- *********************************************** -->
<h4>Creating a KeyManagerFactory</h4>
<p>You create an instance of this class in a similar manner to
<code>SSLContext</code>, except for passing an algorithm name
string instead of a protocol name to the <code>getInstance()</code>
method:</p>
<pre class="codeblock">
    KeyManagerFactory kmf = getInstance(String algorithm);
    
    KeyManagerFactory kmf = getInstance(String algorithm, String provider);
    
    KeyManagerFactory kmf = getInstance(String algorithm, Provider provider);
</pre>
<p>A sample call as follows:</p>
<pre class="codeblock">
    KeyManagerFactory kmf = KeyManagerFactory.getInstance("SunX509", "SunJSSE");
</pre>
<p>The preceding call creates an instance of the SunJSSE provider's
default key manager factory, which provides basic X.509-based
authentication keys.</p>
<p>A newly created factory should be initialized by calling one of
the <code>init</code> methods:</p>
<pre class="codeblock">
    public void init(KeyStore ks, char[] password);
    public void init(ManagerFactoryParameters spec);
</pre>
<p>Call whichever <code>init</code> method is appropriate for the
<code>KeyManagerFactory</code> you are using. If you are not sure,
then ask the provider vendor.</p>
<p>For many factories, such as the default SunX509
<code>KeyManagerFactory</code> from the SunJSSE provider, the
<code>KeyStore</code> and password are the only information
required to initialize the <code>KeyManagerFactory</code> and thus
the first <code>init</code> method is the appropriate one to call.
The <code>KeyManagerFactory</code> will query the
<code>KeyStore</code> for information about which private key and
matching public key certificates should be used for authenticating
to a remote socket peer. The password parameter specifies the
password that will be used with the methods for accessing keys from
the <code>KeyStore</code>. All keys in the <code>KeyStore</code>
must be protected by the same password.</p>
<p>Sometimes initialization parameters other than a
<code>KeyStore</code> and password are needed by a provider. Users
of that provider are expected to pass an implementation of the
appropriate <code>ManagerFactoryParameters</code> as defined by the
provider. The provider can then call the specified methods in the
<code>ManagerFactoryParameters</code> implementation to obtain the
needed information.</p>
<p>Some factories can provide access to authentication material
without being initialized with a <code>KeyStore</code> object or
any other parameters. For example, they may access key material as
part of a login mechanism such as one based on JAAS, the Java
Authentication and Authorization Service.</p>
<p>As previously indicated, the SunJSSE provider supports a SunX509
factory that must be initialized with a <code>KeyStore</code>
parameter.</p>
<!-- *********************************************** -->
<h3><a name="X509KeyManager" id="X509KeyManager">The X509KeyManager
Interface</a></h3>
<p>The <code>javax.net.ssl.X509KeyManager</code> interface extends
the general <code>KeyManager</code> interface. It must be
implemented by a key manager for X.509-based authentication. To
support X.509 authentication to remote socket peers through JSSE,
an instance of this interface must be passed to the
<code>init()</code> method of an <code>SSLContext</code>
object.</p>
<!-- *********************************************** -->
<h4>Creating an X509KeyManager</h4>
<p>You can either implement this interface directly yourself or
obtain one from a provider-based <code>KeyManagerFactory</code>
(such as that supplied by the SunJSSE provider). You could also
implement your own interface that delegates to a factory-generated
key manager. For example, you might do this to filter the resulting
keys and query an end-user through a graphical user interface.</p>
<!-- *********************************************** -->
<h4>Creating Your Own X509KeyManager</h4>
<p>If the default <code>X509KeyManager</code> behavior is not
suitable for your situation, then you can create your own
<code>X509KeyManager</code> in a way similar to that shown in
<a href="#OwnX509TM">Creating Your Own X509TrustManager</a>.</p>
<!-- *********************************************** -->
<h3><a name="X509ExtendedKeyManager" id=
"X509ExtendedKeyManager">The X509ExtendedKeyManager Class</a></h3>
<p>The <code>X509ExtendedKeyManager</code> abstract class is an
implementation of the <code>X509KeyManager</code> interface that
allows for connection-specific key selection. It adds two methods
that select a key alias for client or server based on the key type,
allowed issuers, and current <code>SSLEngine</code>:</p>
<ul>
<li><code>public String chooseEngineClientAlias(String[] keyType,
Principal[] issuers, SSLEngine engine)</code></li>
<li><code>public String chooseEngineServerAlias(String keyType,
Principal[] issuers, SSLEngine engine)</code></li>
</ul>
<p>If a key manager is not an instance of the
<code>X509ExtendedKeyManager</code> class, then it will not work
with the <code>SSLEngine</code> class.</p>
<p>For JSSE providers and key manager implementations, the
<code>X509ExtendedKeyManager</code> class is highly recommended
over the legacy <code>X509KeyManager</code> interface.</p>
<p>In TLS 1.2 and later, both client and server can specify which
hash and signature algorithms they will accept. To pass the
authentication required by the remote side, local key selection
decisions must be based on both X509 certificates and the remote
accepted hash and signature algorithms. The remote accepted hash
and signature algorithms can be retrieved using the
<code>ExtendedSSLSession.getPeerSupportedSignatureAlgorithms()</code>
method.</p>
<p>You can create your own <code>X509ExtendedKeyManager</code>
subclass in a way similar to that shown in <a href=
"#OwnX509ETM">Creating Your Own X509ExtendedTrustManager</a>.</p>
<p>Support for the <a href="#SNIExtension">Server Name Indication
(SNI)</a> extension on the server side enables the key manager to
check the server name and select the appropriate key accordingly.
For example, suppose there are three key entries with certificates
in the keystore:</p>
<ul>
<li><code>cn=www.example.com</code></li>
<li><code>cn=www.example.org</code></li>
<li><code>cn=www.example.net</code></li>
</ul>
<p>If the ClientHello message requests to connect to
<code>www.example.net</code> in the SNI extension, then the server
should be able to select the certificate with subject
<code>cn=www.example.net</code>.</p>
<!-- *********************************************** -->
<h3><a name="RelsTM_KM" id="RelsTM_KM">Relationship Between a
TrustManager and a KeyManager</a></h3>
<p>Historically, there has been confusion regarding the
functionality of a <code>TrustManager</code> and a
<code>KeyManager</code>.</p>
<p>A <code>TrustManager</code> determines whether the remote
authentication credentials (and thus the connection) should be
trusted.</p>
<p>A <code>KeyManager</code> determines which authentication
credentials to send to the remote host.</p>
<!-- *********************************************** -->
<h2><a name="SecondarySupportClasses" id=
"SecondarySupportClasses">Secondary Support Classes and
Interfaces</a></h2>
<p>These classes are provided as part of the JSSE API to support
the creation, use, and management of secure sockets. They are less
likely to be used by secure socket applications than are the core
and support classes. The secondary support classes and interfaces
are part of the <code>javax.net.ssl</code> and
<code>javax.security.cert</code> packages.</p>
<!-- *********************************************** -->
<h3><a name="SSLParameters" id="SSLParameters">The SSLParameters
Class</a></h3>
<p>The <code>SSLParameters</code> class encapsulates the following
parameters that affect a TLS connection:</p>
<ul>
<li>The list of cipher suites to be accepted in an SSL/TLS
handshake</li>
<li>The list of protocols to be allowed</li>
<li>The endpoint identification algorithm during SSL/TLS
handshaking</li>
<li>The server names and server name matchers (see the <a href=
"#SNIExtension">Server Name Indication (SNI) Extension</a>)</li>
<li>The algorithm constraints</li>
<li>Whether SSL/TLS servers should request or require client
authentication</li>
<li>The cipher suite preference to be used in an SSL/TLS
handshake</li>
</ul>
<p>You can retrieve the current <code>SSLParameters</code> for an
<code>SSLSocket</code> or <code>SSLEngine</code> by using the
following methods:</p>
<ul>
<li><code>getSSLParameters()</code> in an <code>SSLSocket</code>,
<code>SSLServerSocket</code>, and <code>SSLEngine</code></li>
<li><code>getDefaultSSLParameters()</code> and
<code>getSupportedSSLParamters()</code> in an
<code>SSLContext</code></li>
</ul>
<p>You can assign <code>SSLParameters</code> with the
<code>setSSLParameters()</code> method in an
<code>SSLSocket</code>, <code>SSLServerSocket</code> and
<code>SSLEngine</code>.</p>
<p>You can explicitly set the server name indication with the
<code>SSLParameters.setServerNames()</code> method. The server name
indication in client mode also affects endpoint identification. In
the implementation of <code>X509ExtendedTrustManager</code>, it
uses the server name indication retrieved by the
<code>ExtendedSSLSession.getRequestedServerNames()</code> method.
The following example illustrates this functionality:</p>
<pre class="codeblock">
SSLSocketFactory factory = ...
SSLSocket sslSocket = factory.createSocket("172.16.10.6", 443);
// SSLEngine sslEngine = sslContext.createSSLEngine("172.16.10.6", 443);

SNIHostName serverName = new SNIHostName("www.example.com");
List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
serverNames.add(serverName);
 
SSLParameters params = sslSocket.getSSLParameters();
params.setServerNames(serverNames);
sslSocket.setSSLParameters(params);
// sslEngine.setSSLParameters(params);
</pre>
<p>In the preceding example, the host name in the server name
indication (<code>www.example.com</code>) will be used to make
endpoint identification against the peer's identity presented in
the end-entity's X.509 certificate.</p>
<h4><a name="cipher_suite_preference" id=
"cipher_suite_preference">Cipher Suite Preference</a></h4>
<p>During TLS handshaking, the client requests to negotiate a
cipher suite from a list of cryptographic options that it supports,
starting with its first preference. Then, the server selects a
single cipher suite from the list of cipher suites requested by the
client. Normally, the selection honors the client's preference.
However, to mitigate the risks of using weak cipher suites, the
server may select cipher suites based on its own preference rather
than the client's preference, by invoking the method
<code>SSLParameters.setUseCipherSuitesOrder(true)</code>.</p>
<!-- *********************************************** -->
<h3><a name="SSLSessionContext" id="SSLSessionContext">The
SSLSessionContext Interface</a></h3>
<p>The <code>javax.net.ssl.SSLSessionContext</code> interface is a
grouping of <a href="#SSLSession"><code>SSLSession</code></a>
objects associated with a single entity. For example, it could be
associated with a server or client that participates in many
sessions concurrently. The methods in this interface enable the
enumeration of all sessions in a context and allow lookup of
specific sessions via their session IDs.</p>
<p>An <code>SSLSessionContext</code> may optionally be obtained
from an <code>SSLSession</code> by calling the SSLSession
<code>getSessionContext()</code> method. The context may be
unavailable in some environments, in which case the
<code>getSessionContext()</code> method returns null.</p>
<!-- *********************************************** -->
<h3><a name="SSLSessionBindingListener" id=
"SSLSessionBindingListener">The SSLSessionBindingListener
Interface</a></h3>
<p>The <code>javax.net.ssl.SSLSessionBindingListener</code>
interface is implemented by objects that are notified when they are
being bound or unbound from an <a href=
"#SSLSession"><code>SSLSession</code></a>.</p>
<!-- *********************************************** -->
<h3><a name="SSLSessionBindingEvent" id=
"SSLSessionBindingEvent">The SSLSessionBindingEvent Class</a></h3>
<p>The <code>javax.net.ssl.SSLSessionBindingEvent</code> class
defines the event communicated to an <a href=
"#SSLSessionBindingListener"><code>SSLSessionBindingListener</code></a>
when it is bound or unbound from an <a href=
"#SSLSession"><code>SSLSession</code></a>.</p>
<!-- *********************************************** -->
<h3><a name="HandShakeCompletedListener" id=
"HandShakeCompletedListener">The HandShakeCompletedListener
Interface</a></h3>
<p>The <code>javax.net.ssl.HandShakeCompletedListener</code>
interface is an interface implemented by any class that is notified
of the completion of an SSL protocol handshake on a given
<code>SSLSocket</code> connection.</p>
<!-- *********************************************** -->
<h3><a name="HandShakeCompletedEvent" id=
"HandShakeCompletedEvent">The HandShakeCompletedEvent
Class</a></h3>
<p>The <code>javax.net.ssl.HandShakeCompletedEvent</code> class
define the event communicated to a <a href=
"#HandShakeCompletedListener"><code>HandShakeCompletedListener</code></a>
upon completion of an SSL protocol handshake on a given
<code>SSLSocket</code> connection.</p>
<!-- *********************************************** -->
<h3><a name="HostnameVerifier" id="HostnameVerifier">The
HostnameVerifier Interface</a></h3>
<p>If the SSL/TLS implementation's standard host name verification
logic fails, then the implementation calls the
<code>verify()</code> method of the class that implements this
interface and is assigned to this <code>HttpsURLConnection</code>
instance. If the callback class can determine that the host name is
acceptable given the parameters, it reports that the connection
should be allowed. An unacceptable response causes the connection
to be terminated.</p>
<p>For example:</p>
<pre class="codeblock">
    public class MyHostnameVerifier implements HostnameVerifier {
    
        public boolean verify(String hostname, SSLSession session) {
            // pop up an interactive dialog box
            // or insert additional matching logic
            if (good_address) {
                return true;
            } else {
                return false;
            }
        }
    }
    
    //...deleted...
    
    HttpsURLConnection urlc = (HttpsURLConnection)
      (new URL("https://www.example.com/")).openConnection();
    urlc.setHostnameVerifier(new MyHostnameVerifier());
</pre>
<p>See <a href="#HttpsURLConnection">The HttpsURLConnection
Class</a> for more information about how to assign the
<code>HostnameVerifier</code> to the
<code>HttpsURLConnection</code>.</p>
<!-- *********************************************** -->
<h3><a name="X509Certificate" id="X509Certificate">The
X509Certificate Class</a></h3>
<p>Many secure socket protocols perform authentication using public
key certificates, also called X.509 certificates. This is the
default authentication mechanism for the SSL/TLS protocols.</p>
<p>The <code>java.security.cert.X509Certificate</code> abstract
class provides a standard way to access the attributes of X.509
certificates.</p>
<hr />
<p><strong>Note:</strong> The
<code>javax.security.cert.X509Certificate</code> class is supported
only for backward compatibility with previous (1.0.x and 1.1.x)
versions of JSSE. New applications should use the
<code>java.security.cert.X509Certificate</code> class instead.</p>
<hr />
<!-- *********************************************** -->
<h3><a name="AlgorithmConstraints" id="AlgorithmConstraints">The
AlgorithmConstraints Interface</a></h3>
<p>The <code>java.security.AlgorithmConstraints</code> interface is
used for controlling allowed cryptographic algorithms.
<code>AlgorithmConstraints</code> defines three
<code>permits()</code> methods. These methods tell whether an
algorithm name or a key is permitted for certain cryptographic
functions. Cryptographic functions are represented by a set of
<code>CryptoPrimitive</code>, which is an enumeration containing
fields like <code>STREAM_CIPHER</code>,
<code>MESSAGE_DIGEST</code>, and <code>SIGNATURE</code>.</p>
<p>Thus, an <code>AlgorithmConstraints</code> implementation can
answer questions like: Can I use this key with this algorithm for
the purpose of a cryptographic operation?</p>
<p>An <code>AlgorithmConstraints</code> object can be associated
with an <code>SSLParameters</code> object by using the new
<code>setAlgorithmConstraints()</code> method. The current
<code>AlgorithmConstraints</code> object for an
<code>SSLParameters</code> object is retrieved using the
<code>getAlgorithmConstraints()</code> method.</p>
<!-- *********************************************** -->
<h3><a name="StandardConstants" id="StandardConstants">The
StandardConstants Class</a></h3>
<p>The <code>StandardConstants</code> class is used to represent
standard constants definitions in JSSE.</p>
<p><code>StandardConstants.SNI_HOST_NAME</code> represents a domain
name server (DNS) host name in a <a href="#SNIExtension">Server
Name Indication (SNI)</a> extension, which can be used when
instantiating an <code>SNIServerName</code> or
<code>SNIMatcher</code> object.</p>
<!-- *********************************************** -->
<h3><a name="SNIServerName" id="SNIServerName">The SNIServerName
Class</a></h3>
<p>An instance of the abstract <code>SNIServerName</code> class
represents a server name in the <a href="#SNIExtension">Server Name
Indication (SNI)</a> extension. It is instantiated using the type
and encoded value of the specified server name.</p>
<p>You can use the <code>getType()</code> and
<code>getEncoded()</code> methods to return the server name type
and a copy of the encoded server name value, respectively. The
<code>equals()</code> method can be used to check if some other
object is "equal" to this server name. The <code>hashCode()</code>
method returns a hash code value for this server name. To get a
string representation of the server name (including the server name
type and encoded server name value), use the
<code>toString()</code> method.</p>
<!-- *********************************************** -->
<h3><a name="SNIMatcher" id="SNIMatcher">The SNIMatcher
Class</a></h3>
<p>An instance of the abstract <code>SNIMatcher</code> class
performs match operations on an <code>SNIServerName</code> object.
Servers can use information from the <a href="#SNIExtension">Server
Name Indication (SNI)</a> extension to decide if a specific
<code>SSLSocket</code> or <code>SSLEngine</code> should accept a
connection. For example, when multiple "virtual" or "name-based"
servers are hosted on a single underlying network address, the
server application can use SNI information to determine whether
this server is the exact server that the client wants to access.
Instances of this class can be used by a server to verify the
acceptable server names of a particular type, such as host
names.</p>
<p>The <code>SNIMatcher</code> class is instantiated using the
specified server name type on which match operations will be
performed. To match a given <code>SNIServerName</code>, use the
<code>matches()</code> method. To return the server name type of
the given <code>SNIMatcher</code> object, use the
<code>getType()</code> method.</p>
<!-- *********************************************** -->
<h3><a name="SNIHostName" id="SNIHostName">The SNIHostName
Class</a></h3>
<p>An instance of the <code>SNIHostName</code> class (which extends
the <code>SNIServerName</code> class) represents a server name of
type "host_name" (see <a href="#StandardConstants">The
StandardConstants Class</a>) in the <a href="#SNIExtension">Server
Name Indication (SNI)</a> extension. To instantiate an
<code>SNIHostName</code>, specify the fully qualified DNS host name
of the server (as understood by the client) as a
<code>String</code> argument. The argument is illegal in the
following cases:</p>
<ul>
<li>The argument is empty.</li>
<li>The argument ends with a trailing period.</li>
<li>The argument is not a valid Internationalized Domain Name (IDN)
compliant with the RFC 3490 specification.</li>
</ul>
<p>You can also instantiate an <code>SNIHostName</code> by
specifying the encoded host name value as a byte array. This method
is typically used to parse the encoded name value in a requested
SNI extension. Otherwise, use the <code>SNIHostName(String
hostname)</code> constructor. The <code>encoded</code> argument is
illegal in the following cases:</p>
<ul>
<li>The argument is empty.</li>
<li>The argument ends with a trailing period.</li>
<li>The argument is not a valid Internationalized Domain Name (IDN)
compliant with the RFC 3490 specification.</li>
<li>The argument is not encoded in UTF-8 or US-ASCII.</li>
</ul>
<hr />
<p><strong>Note:</strong> The <code>encoded</code> byte array
passed in as an argument is cloned to protect against subsequent
modification.</p>
<hr />
<p>To return the host name of an <code>SNIHostName</code> object in
US-ASCII encoding, use the <code>getAsciiName()</code> method. To
compare a server name to another object, use the
<code>equals()</code> method (comparison is <em>not</em>
case-sensitive). To return a hash code value of an
<code>SNIHostName</code>, use the <code>hashCode()</code> method.
To return a string representation of an <code>SNIHostName</code>,
including the DNS host name, use the <code>toString()</code>
method.</p>
<p>You can create an <code>SNIMatcher</code> object for an
<code>SNIHostName</code> object by passing a regular expression
representing one or more host names to match to the
<code>createSNIMatcher()</code> method.</p>
<!-- *********************************************** -->
<a name="Customization" id="Customization"></a>
<h2><a name="InstallationAndCustomization" id=
"InstallationAndCustomization">Customizing JSSE</a></h2>
<p>JSSE includes a standard implementation that can be customized
by plugging in different implementations or specifying the default
keystore, and so on. <a href="#T6">Table 6</a> summarizes which
aspects can be customized, what the defaults are, and which
mechanisms are used to provide customization. The first column of
the table provides links to more detailed descriptions of each
designated aspect and how to customize it.</p>
<p>Some of the customizations are done by setting system property
or security property values. Sections following the table explain
how to set such property values.</p>
<hr />
<p><strong>Note:</strong> Many of the properties shown in this
table are currently used by the JSSE implementation, but there is
no guarantee that they will continue to have the same names and
types (system or security) or even that they will exist at all in
future releases. All such properties are flagged with an asterisk
(*). They are documented here for your convenience for use with the
JSSE implementation.</p>
<hr />
<table summary="Customizable items in JSSE" border="1">
<caption><a name="T6" id="T6">Table 6: Customizable Items in
JSSE</a></caption>
<thead>
<tr>
<th id="h501" width="30%" valign="top">Customizable Item</th>
<th id="h502" width="30%" valign="top">Default</th>
<th id="h503" width="40%" valign="top">How to Customize</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#X509CCust">X509Certificate
implementation</a></td>
<td headers="h502" width="30%" valign="top">X509Certificate implementation from
Oracle</td>
<td headers="h503" width="40%" valign="top"><code>cert.provider.x509v1</code>
security property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#HTTPSCust">HTTPS protocol
implementation</a></td>
<td headers="h502" width="30%" valign="top">Implementation from Oracle</td>
<td headers="h503" width="40%" valign="top">
<code>java.protocol.handler.pkgs</code> system property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#ProviderCust">Provider
implementation</a></td>
<td headers="h502" width="30%" valign="top">SunJSSE</td>
<td headers="h503" width="40%" valign="top">The <code>security.provider.n=</code>
line in security properties file</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top">Default <code>SSLSocketFactory</code>
implementation</td>
<td headers="h502" width="30%" valign="top"><code>SSLSocketFactory</code>
implementation from Oracle</td>
<td headers="h503" width="40%" valign="top">*
<code>ssl.SocketFactory.provider</code> security property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top">Default
<code>SSLServerSocketFactory</code> implementation</td>
<td headers="h502" width="30%" valign="top"><code>SSLServerSocketFactory</code>
implementation from Oracle</td>
<td headers="h503" width="40%" valign="top">*
<code>ssl.ServerSocketFactory.provider</code> security
property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#CustomizingStores">Default
keystore</a></td>
<td headers="h502" width="30%" valign="top">None</td>
<td headers="h503" width="40%" valign="top">* <code>javax.net.ssl.keyStore</code>
system property.<br />
Note that the value <code>NONE</code> may be specified. This
setting is appropriate if the keystore is not file-based (for
example, it resides in a hardware token).</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#CustomizingStores">Default
keystore password</a></td>
<td headers="h502" width="30%" valign="top">None</td>
<td headers="h503" width="40%" valign="top">*
<code>javax.net.ssl.keyStorePassword</code> system property.<br />
It is inadvisable to specify the password in a way that exposes it
to discovery by other users, for example, specifying the password
on the command line. To keep the password secure, have the
application prompt for the password, or specify the password in a
properly protected option file.</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#CustomizingStores">Default
keystore provider</a></td>
<td headers="h502" width="30%" valign="top">None</td>
<td headers="h503" width="40%" valign="top">*
<code>javax.net.ssl.keyStoreProvider</code> system property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#CustomizingStores">Default
keystore type</a></td>
<td headers="h502" width="30%" valign="top">
<code>KeyStore.getDefaultType()</code></td>
<td headers="h503" width="40%" valign="top">*
<code>javax.net.ssl.keyStoreType</code> system property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#CustomizingStores">Default
truststore</a></td>
<td headers="h502" width="30%" valign="top"><code>jssecacerts</code>, if it
exists. Otherwise, <code>cacerts</code>.</td>
<td headers="h503" width="40%" valign="top">*
<code>javax.net.ssl.trustStore</code> system property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#CustomizingStores">Default
truststore password</a></td>
<td headers="h502" width="30%" valign="top">None</td>
<td headers="h503" width="40%" valign="top">*
<code>javax.net.ssl.trustStorePassword</code> system
property.<br />
It is inadvisable to specify the password in a way that exposes it
to discovery by other users, for example, specifying the password
on the command line. To keep the password secure, have the
application prompt for the password, or specify the password in a
properly protected option file.</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#CustomizingStores">Default
truststore provider</a></td>
<td headers="h502" width="30%" valign="top">None</td>
<td headers="h503" width="40%" valign="top">*
<code>javax.net.ssl.trustStoreProvider</code> system property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#CustomizingStores">Default
truststore type</a></td>
<td headers="h502" width="30%" valign="top">
<code>KeyStore.getDefaultType()</code></td>
<td headers="h503" width="40%" valign="top">*
<code>javax.net.ssl.trustStoreType</code> system property<br />
Note that the value <code>NONE</code> may be specified. This
setting is appropriate if the truststore is not file-based (for
example, it resides in a hardware token).</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#DefaultKTMCust">Default key
manager factory algorithm name</a></td>
<td headers="h502" width="30%" valign="top">SunX509</td>
<td headers="h503" width="40%" valign="top">
<code>ssl.KeyManagerFactory.algorithm</code> security property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#DefaultKTMCust">Default
trust manager factory algorithm name</a></td>
<td headers="h502" width="30%" valign="top">PKIX</td>
<td headers="h503" width="40%" valign="top">
<code>ssl.TrustManagerFactory.algorithm</code> security
property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#DisabledAlgorithms">Disabled
certificate verification cryptographic algorithms</a></td>
<td headers="h502" width="30%" valign="top">MD2, RSA keySize &lt; 1024</td>
<td headers="h503" width="40%" valign="top">
<code>jdk.certpath.disabledAlgorithms</code> security property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href=
"#DisabledAlgorithms">Disabled/Restricted Algorithms</a></td>
<td headers="h502" width="30%" valign="top">SSLv3</td>
<td headers="h503" width="40%" valign="top">
<code>jdk.tls.disabledAlgorithms</code> security property.<br />
Disables specific algorithms (protocols versions, ciphersuites, key
exchange mechanisms, etc.) that will not be negotiated for SSL/TLS
connections, even if they are enabled explicitly in an
application.</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top">Default proxy host</td>
<td headers="h502" width="30%" valign="top">None</td>
<td headers="h503" width="40%" valign="top">* <code>https.proxyHost</code> system
property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top">Default proxy port</td>
<td headers="h502" width="30%" valign="top">80</td>
<td headers="h503" width="40%" valign="top">* <code>https.proxyPort</code> system
property</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top">Server Name Indication option</td>
<td headers="h502" width="30%" valign="top"><code>true</code></td>
<td headers="h503" width="40%" valign="top">* <code>jsse.enableSNIExtension</code>
system property.<br />
Server Name Indication (SNI) is a TLS extension, defined in
<a href="http://www.ietf.org/rfc/rfc6066.txt">RFC 6066</a>. It
enables TLS connections to virtual servers, in which multiple
servers for different network names are hosted at a single
underlying network address.<br />
Some very old SSL/TLS vendors may not be able handle SSL/TLS
extensions. In this case, set this property to <code>false</code>
to disable the SNI extension.</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top">Default cipher suites</td>
<td headers="h502" width="30%" valign="top">Determined by the socket factory</td>
<td headers="h503" width="40%" valign="top">* <code>https.cipherSuites</code>
system property. This contains a comma-separated list of cipher
suite names specifying which cipher suites to enable for use on
this <code>HttpsURLConnection</code>. See the <a href=
"../../../../api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites-java.lang.String:A-">
<code>SSLSocket.setEnabledCipherSuites(String[])</code>
method.</a> Note that this method sets
the preference order of the ClientHello cipher suites directly from the
<code>String</code> array
passed to it.</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top">Default handshaking protocols</td>
<td headers="h502" width="30%" valign="top">Determined by the socket factory</td>
<td headers="h503" width="40%" valign="top">* <a name="https_porocols" id=
"https_porocols"></a><code>https.protocols</code> system
property.<br />
This contains a comma-separated list of protocol suite names
specifying which protocol suites to enable on this
<code>HttpsURLConnection</code>. See the <a href=
"../../../../api/javax/net/ssl/SSLSocket.html#setEnabledProtocols-java.lang.String:A-">
<code>SSLSocket.setEnabledProtocols(String[])</code>
method.</a></td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top">Default HTTPS port</td>
<td headers="h502" width="30%" valign="top">443</td>
<td headers="h503" width="40%" valign="top">* Customize via <code>port</code>
field in the HTTPS URL.</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#JCECust">JCE encryption
algorithms used by the SunJSSE provider</a></td>
<td headers="h502" width="30%" valign="top">SunJCE implementations</td>
<td headers="h503" width="40%" valign="top">Give alternative JCE algorithm
providers a higher preference order than the SunJCE provider</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top">Default sizing buffers for large
SSL/TLS packets</td>
<td headers="h502" width="30%" valign="top">None</td>
<td headers="h503" width="40%" valign="top">*
<code>jsse.SSLEngine.acceptLargeFragments</code> system
property.<br />
By setting this system property to <code>true</code>,
<code>SSLSession</code> will size buffers to handle <a href=
"#LargePackets">large data packets</a> by default. This may cause
applications to allocate unnecessarily large <code>SSLEngine</code>
buffers. Instead, applications should <a href=
"#OperationStatus">dynamically check for buffer overflow
conditions</a> and resize buffers as appropriate.</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#descPhase2">Allow Unsafe
SSL/TLS Renegotiations</a></td>
<td headers="h502"><code>false</code></td>
<td headers="h503">* <code>sun.security.ssl.allowUnsafeRenegotiation</code> system
property.<br />
Setting this system property to <code>true</code> permits full
(unsafe) legacy renegotiation.</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#descPhase2">Allow Legacy
Hello Messages (Renegotiations)</a></td>
<td headers="h502"><code>true</code></td>
<td headers="h503">* <code>sun.security.ssl.allowLegacyHelloMessages</code> system
property.<br />
Setting this system property to <code>true</code> allows the peer
to handshake without requiring the proper RFC 5746 messages.</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href=
"../SunProviders.html#SunJSSE_Protocols">Default Enabled TLS
Protocols</a></td>
<td headers="h502">None</td>
<td headers="h503"><a name="jdk_tls_client_protocols" id=
"jdk_tls_client_protocols"></a><code>jdk.tls.client.protocols</code>
system property.<br />
To enable specific <code>SunJSSE</code> protocols on the client,
specify them in a comma-separated list within quotation marks; all
other supported protocols are then disabled on the client. For
example, if the value of this property is
<code>"TLSv1,TLSv1.1"</code>, then the default protocol settings on
the client for TLSv1 and TLSv1.1 are enabled on the client, while
SSLv3, TLSv1.2, and SSLv2Hello are disabled on the client.</td>
</tr>
<tr>
<td headers="h501" width="30%" valign="top"><a href="#customizing_dh_keys">Size of
ephemeral Diffie-Hellman keys</a></td>
<td headers="h502">1024 bits</td>
<td headers="h503"><code>jdk.tls.ephemeralDHKeySize</code> system property.</td>
</tr>
</tbody>
</table>
<p>* <small>This property is currently used by the JSSE
implementation, but it is not guaranteed to be examined and used by
other implementations. If it <i>is</i> examined by another
implementation, then that implementation should handle it in the
same manner as the JSSE implementation does. There is no guarantee
the property will continue to exist or be of the same type (system
or security) in future releases.</small></p>
<a name="SystemProps" id="SystemProps"></a>
<hr />
<p><strong>Note:</strong> Some items are customized by setting
<code>java.lang.System</code> properties, whereas others are
customized by setting <code>java.security.Security</code>
properties. The following sections explain how to set values for
both types of properties.</p>
<hr />
<!-- *********************************************** -->
<h3>How to Specify a java.lang.System Property</h3>
<p>You can customize some aspects of JSSE by setting system
properties. There are several ways to set these properties:</p>
<ul>
<li>
<p>To set a system property statically, use the <code>-D</code>
option of the <code>java</code> command. For example, to run an
application named MyApp and set the
<code>javax.net.ssl.trustStore</code> system property to specify a
<a href="#CustomizingStores">truststore</a> named MyCacertsFile,
enter the following:</p>
<pre class="codeblock">
        java -Djavax.net.ssl.trustStore=MyCacertsFile MyApp
                
</pre></li>
<li>
<p>To set a system property dynamically, call the
<code>java.lang.System.setProperty()</code> method in your
code:</p>
<pre class="codeblock">
        System.setProperty("<i>propertyName</i>", "<i>propertyValue</i>");
                
</pre>
<p>For example, a <code>setProperty()</code> call corresponding to
the previous example for setting the
<code>javax.net.ssl.trustStore</code> system property to specify a
truststore named "<code>MyCacertsFile</code>" would be:</p>
<pre class="codeblock">
        System.setProperty("javax.net.ssl.trustStore", "MyCacertsFile");
                
</pre></li>
<li>
<p>In the Java Deployment environment (Plug-In/Web Start), there
are several ways to set the system properties. For more
information, see <a href="../../deploy/index.html">Java Platform,
Standard Edition Deployment Guide</a>.</p>
<ul>
<li>
<p>Use the Java Control Panel to set the Runtime Environment
Property on a local or per-VM basis. This creates a local
<code>deployment.properties</code> file. Deployers can also
distribute an enterprise wide <code>deployment.properties</code>
file by using the <code>deployment.config</code> mechanism. For
more information, see <a href=
"../../deploy/properties.html">Deployment Configuration File and
Properties</a>.</p>
</li>
<li>
<p>To set a property for a specific applet, use the HTML subtag
<code>&lt;PARAM&gt;</code> "java_arguments" within the
<code>&lt;APPLET&gt;</code> tag. For more information, see the
<a href="../../deploy/applet_dev_guide.html#JSDPG712">Command-line
Arguments</a> section of the <cite>Java Platform, Standard Edition
Deployment Guide</cite>.</p>
</li>
<li>
<p>To set the property in a specific Java Web Start application or
applet using Plugin2, use the JNLP <code>property</code> subelement
of the <code>resources</code> element. For more information, see
the <a href=
"../../javaws/developersguide/syntax.html#resources">resources
Element</a> section of the <cite>Java Web Start Guide</cite>.</p>
</li>
</ul>
</li>
</ul>
<!-- *********************************************** -->
<h3><a name="SecurityProps" id="SecurityProps">How to Specify a
java.security.Security Property</a></h3>
<p>You can customize some aspects of JSSE by setting security
properties. You can set a security property either statically or
dynamically:</p>
<ul>
<li>
<p>To set a security property statically, add a line to the
security properties file. The security properties file is located
at <var>java-home</var>/lib/security/java.security.</p>
<p><var>java-home</var> refers to the directory where the JRE is
installed, as described in <a href="#javaHome">The Installation
Directory</a>.</p>
<p>To specify a security property value in the security properties
file, you add a line of the following form:</p>
<pre class="codeblock">
        <i>propertyName</i>=<i>propertyValue</i>
                
</pre>
<p>For example, suppose that you want to specify a different key
manager factory algorithm name than the default SunX509. You do
this by specifying the algorithm name as the value of a security
property named <code>ssl.KeyManagerFactory.algorithm</code>. For
example, to set the value to MyX509, add the following line to the
security properties file:</p>
<pre class="codeblock">
        ssl.KeyManagerFactory.algorithm=MyX509
                
</pre></li>
<li>
<p>To set a security property dynamically, call the
<code>java.security.Security.setProperty</code> method in your
code:</p>
<pre class="codeblock">
        Security.setProperty("<i>propertyName</i>," "<i>propertyValue</i>");
                
</pre>
<p>For example, a call to the <code>setProperty()</code> method
corresponding to the previous example for specifying the key
manager factory algorithm name would be:</p>
<pre class="codeblock">
        Security.setProperty("ssl.KeyManagerFactory.algorithm", "MyX509");
        
</pre></li>
</ul>
<!-- *********************************************** -->
<h3><a name="X509CCust" id="X509CCust">Customizing the
X509Certificate Implementation</a></h3>
<p>The X509Certificate implementation returned by the
<code>X509Certificate.getInstance()</code> method is by default the
implementation from the JSSE implementation.</p>
<p>You can optionally cause a different implementation to be
returned. To do so, specify the name (and package) of the other
implementation's class as the value of a <a href=
"#SecurityProps">security property</a> named
<code>cert.provider.x509v1</code>. For example, if the class is
called <code>MyX509CertificateImpl</code> and it appears in the
<code>com.cryptox</code> package, then you should add the following
line to the security properties file:</p>
<pre class="codeblock">
    cert.provider.x509v1=com.cryptox.MyX509CertificateImpl
</pre>
<!-- *********************************************** -->
<h3><a name="HTTPSCust" id="HTTPSCust">Specifying an Alternative
HTTPS Protocol Implementation</a></h3>
<p>You can communicate securely with an SSL-enabled web server by
using the HTTPS URL scheme for the <code>java.net.URL</code> class.
The JDK provides a default HTTPS URL implementation.</p>
<p>If you want an alternative HTTPS protocol implementation to be
used, set the <code>java.protocol.handler.pkgs</code> <a href=
"#SystemProps">system property</a> to include the new class name.
This action causes the specified classes to be found and loaded
before the JDK default classes. See the <a href=
"../../../../api/java/net/URL.html"><code>java.net.URL</code></a>
class documentation for details.</p>
<hr />
<p><strong>Note:</strong> In past JSSE releases, you had to set the
<code>java.protocol.handler.pkgs</code> system property during JSSE
installation. This step is no longer required unless you want to
obtain an instance of
<code>com.sun.net.ssl.HttpsURLConnection</code>. For more
information, see <a href="#HttpsURLConnectionEx">Code Using the
HttpsURLConnection Class</a> in the "Troubleshooting" section.</p>
<hr />
<!-- *********************************************** -->
<h3><a name="ProviderCust" id="ProviderCust">Customizing the
Provider Implementation</a></h3>
<p>JDK 1.4 and later releases come standard with a JSSE
Cryptographic Service Provider, or <i>provider</i> for short, named
SunJSSE. Providers are essentially packages that implement one or
more engine classes for specific cryptographic algorithms. The JSSE
engine classes are <code>SSLContext</code>,
<code>KeyManagerFactory</code>, and
<code>TrustManagerFactory</code>. For more information about
providers and engine classes, see the <a href=
"../crypto/CryptoSpec.html">Java Cryptography Architecture
Reference Guide</a>.</p>
<hr />
<p><strong>Note:</strong> The transformation strings used when
SunJSSE calls <code>Cipher.getInstance()</code> are
"RSA/ECB/PKCS1Padding", "RC4", "DES/CBC/NoPadding", and
"DESede/CBC/NoPadding". For further information about the
<code>Cipher</code> class and transformation strings see the
<a href="../crypto/CryptoSpec.html">Java Cryptography Architecture
Reference Guide</a>.</p>
<hr />
<p>Before it can be used, a provider must be registered, either
statically or dynamically. You do not need to register the SunJSSE
provider because it is preregistered. If you want to use other
providers, read the following sections to see how to register
them.</p>
<!-- *********************************************** -->
<h3>Registering the Cryptographic Service Provider Statically</h3>
<p>You register a provider statically by adding a line of the
following form to the <a href="#SecurityProps">security properties
file</a>:</p>
<pre class="codeblock">
    security.provider.<i>n</i>=<i>providerClassName</i>
</pre>
<p>This declares a provider, and specifies its preference order
<code>n</code>. The preference order is the order in which
providers are searched for requested algorithms (when no specific
provider is requested). "1" is the most preferred, followed by "2",
and so on.</p>
<p>The <i>providerClassName</i> is the fully qualified name of the
provider class. You obtain this name from the provider vendor.</p>
<p>The standard security provider and the SunJSSE provider shipped
with JDK 6 are automatically registered for you; the following
lines appear in the <code>java.security</code> security properties
file to register the <code>SunJCE</code> security provider with
preference order 5 and the SunJSSE provider with preference order
4:</p>
<pre class="codeblock">
    security.provider.1=sun.security.pkcs11.SunPKCS11 \
    ${java.home}/lib/security/sunpkcs11-solaris.cfg
    security.provider.2=sun.security.provider.Sun
    security.provider.3=sun.security.rsa.SunRsaSign
    security.provider.4=com.sun.net.ssl.internal.ssl.Provider
    security.provider.5=com.sun.crypto.provider.SunJCE
    security.provider.6=sun.security.jgss.SunProvider
    security.provider.7=com.sun.security.sasl.Provider
</pre>
<p>To use another JSSE provider, add a line registering the other
provider, giving it whatever preference order you prefer.</p>
<p>You can have more than one JSSE provider registered at the same
time. The registered providers may include different
implementations for different algorithms for different engine
classes, or they may have support for some or all of the same types
of algorithms and engine classes. When a particular engine class
implementation for a particular algorithm is searched for, if no
specific provider is specified for the search, then the providers
are searched in preference order and the implementation from the
first provider that supplies an implementation for the specified
algorithm is used.</p>
<!-- *********************************************** -->
<h3>Registering the Cryptographic Service Provider Dynamically</h3>
<p>Instead of registering a provider statically, you can add the
provider dynamically at runtime by calling the
<code>Security.addProvider()</code> method at the beginning of your
program. For example, to dynamically add a provider whose provider
class name is <code>MyProvider</code> and whose
<code>MyProvider</code> class resides in the <code>com.ABC</code>
package, you would call:</p>
<pre class="codeblock">
    Security.addProvider(new com.ABC.MyProvider());
</pre>
<p>The <code>Security.addProvider()</code> method adds the
specified provider to the next available preference position.</p>
<p>This type of registration is not persistent and can only be done
by a program with sufficient permissions.</p>
<!-- *********************************************** -->
<h3><a name="CustomizingStores" id="CustomizingStores">Customizing
the Default Keystores and Truststores, Store Types, and Store
Passwords</a></h3>
<p>Whenever a default <code>SSLSocketFactory</code> or
<code>SSLServerSocketFactory</code> is created (via a call to
<code>SSLSocketFactory.getDefault</code> or
<code>SSLServerSocketFactory.getDefault</code>), and this default
<code>SSLSocketFactory</code> (or
<code>SSLServerSocketFactory</code>) comes from the JSSE reference
implementation, a default <code>SSLContext</code> is associated
with the socket factory. (The default socket factory will come from
the JSSE implementation.)</p>
<p>This default <code>SSLContext</code> is initialized with a
default <code>KeyManager</code> and a default
<code>TrustManager</code>. If a keystore is specified by the
<code>javax.net.ssl.keyStore</code> <a href="#SystemProps">system
property</a> and an appropriate
<code>javax.net.ssl.keyStorePassword</code> <a href=
"#SystemProps">system property</a>, then the
<code>KeyManager</code> created by the default
<code>SSLContext</code> will be a <code>KeyManager</code>
implementation for managing the specified keystore. (The actual
implementation will be as specified in <a href=
"#DefaultKTMCust">Customizing the Default Key and Trust
Managers</a>.) If no such system property is specified, then the
keystore managed by the <code>KeyManager</code> will be a new empty
keystore.</p>
<p>Generally, the peer acting as the server in the handshake will
need a keystore for its KeyManager in order to obtain credentials
for authentication to the client. However, if one of the anonymous
cipher suites is selected, then the server's
<code>KeyManager</code> keystore is not necessary. And, unless the
server requires client authentication, the peer acting as the
client does not need a <code>KeyManager</code> keystore. Thus, in
these situations it may be OK if no
<code>javax.net.ssl.keyStore</code> system property value is
defined.</p>
<p>Similarly, if a truststore is specified by the
<code>javax.net.ssl.trustStore</code> system property, then the
<code>TrustManager</code> created by the default
<code>SSLContext</code> will be a <code>TrustManager</code>
implementation for managing the specified truststore. In this case,
if such a property exists but the file it specifies does not, then
no truststore is used. If no <code>javax.net.ssl.trustStore</code>
property exists, then a default truststore is searched for. If a
truststore named <var>java-home</var>/lib/security/jssecacerts is
found, it is used. If not, then a truststore named
<var>java-home</var>/lib/security/cacerts is searched for and used
(if it exists). For more information about <var>java-home</var>,
see <a href="#javaHome">The Installation Directory</a>. Finally, if
a truststore is still not found, then the truststore managed by the
<code>TrustManager</code> will be a new empty truststore.</p>
<hr />
<p><strong>Note:</strong> The JDK ships with a limited number of
trusted root certificates in the
<var>java-home</var>/lib/security/cacerts file. As documented in
<a href="../../../tools/index.html#security">keytool</a> reference
pages, it is your responsibility to maintain (that is, add and
remove) the certificates contained in this file if you use this
file as a truststore.</p>
<p>Depending on the certificate configuration of the servers that
you contact, you may need to add additional root certificates.
Obtain the needed specific root certificates from the appropriate
vendor.</p>
<hr />
<p>If the <code>javax.net.ssl.keyStoreType</code> and/or
<code>javax.net.ssl.keyStorePassword</code> system properties are
also specified, then they are treated as the default
<code>KeyManager</code> keystore type and password, respectively.
If no type is specified, then the default type is that returned by
the <code>KeyStore.getDefaultType()</code> method, which is the
value of the <code>keystore.type</code> security property, or "jks"
if no such security property is specified. If no keystore password
is specified, then it is assumed to be a blank string "".</p>
<p>Similarly, if the <code>javax.net.ssl.trustStoreType</code>
and/or <code>javax.net.ssl.trustStorePassword</code> system
properties are also specified, then they are treated as the default
truststore type and password, respectively. If no type is
specified, then the default type is that returned by the
<code>KeyStore.getDefaultType()</code> method. If no truststore
password is specified, then it is assumed to be a blank string
"".</p>
<hr />
<p><strong>Note:</strong> This section describes the current JSSE
reference implementation behavior. The system properties described
in this section are not guaranteed to continue to have the same
names and types (system or security) or even to exist at all in
future releases. They are also not guaranteed to be examined and
used by any other JSSE implementations. If they <i>are</i> examined
by an implementation, then that implementation should handle them
in the same manner as the JSSE reference implementation does, as
described herein.</p>
<hr />
<!-- *********************************************** -->
<h3><a name="DefaultKTMCust" id="DefaultKTMCust">Customizing the
Default Key Managers and Trust Managers</a></h3>
<p>As noted in <a href="#CustomizingStores">Customizing the Default
Keystores and Truststores, Store Types, and Store Passwords</a>,
whenever a default <code>SSLSocketFactory</code> or
<code>SSLServerSocketFactory</code> is created, and this default
<code>SSLSocketFactory</code> (or
<code>SSLServerSocketFactory</code>) comes from the JSSE reference
implementation, a default <code>SSLContext</code> is associated
with the socket factory.</p>
<p>This default <code>SSLContext</code> is initialized with a
<code>KeyManager</code> and a <code>TrustManager</code>. The
<code>KeyManager</code> and/or <code>TrustManager</code> supplied
to the default <code>SSLContext</code> will be an implementation
for managing the specified keystore or truststore, as described in
the aforementioned section.</p>
<p>The <code>KeyManager</code> implementation chosen is determined
by first examining the <code>ssl.KeyManagerFactory.algorithm</code>
<a href="#SecurityProps">security property</a>. If such a property
value is specified, then a <code>KeyManagerFactory</code>
implementation for the specified algorithm is searched for. The
implementation from the first provider that supplies an
implementation is used. Its <code>getKeyManagers()</code> method is
called to determine the <code>KeyManager</code> to supply to the
default <code>SSLContext</code>. Technically,
<code>getKeyManagers()</code> returns an array of
<code>KeyManager</code> objects, one <code>KeyManager</code> for
each type of key material. If no such security property value is
specified, then the default value of SunX509 is used to perform the
search.</p>
<hr />
<p><strong>Note:</strong> A <code>KeyManagerFactory</code>
implementation for the SunX509 algorithm is supplied by the SunJSSE
provider. The <code>KeyManager</code> that it specifies is a
<code>javax.net.ssl.X509KeyManager</code> implementation.</p>
<hr />
<p>Similarly, the <code>TrustManager</code> implementation chosen
is determined by first examining the
<code>ssl.TrustManagerFactory.algorithm</code> security property.
If such a property value is specified, then a
<code>TrustManagerFactory</code> implementation for the specified
algorithm is searched for. The implementation from the first
provider that supplies an implementation is used. Its
<code>getTrustManagers()</code> method is called to determine the
<code>TrustManager</code> to supply to the default
<code>SSLContext</code>. Technically,
<code>getTrustManagers()</code> returns an array of
<code>TrustManager</code> objects, one <code>TrustManager</code>
for each type of trust material. If no such security property value
is specified, then the default value of PKIX is used to perform the
search.</p>
<hr />
<p><strong>Note:</strong> A <code>TrustManagerFactory</code>
implementation for the PKIX algorithm is supplied by the SunJSSE
provider. The <code>TrustManager</code> that it specifies is a
<code>javax.net.ssl.X509TrustManager</code> implementation.</p>
<hr />
<p><strong>Note:</strong> This section describes the current JSSE
reference implementation behavior. The system properties described
in this section are not guaranteed to continue to have the same
names and types (system or security) or even to exist at all in
future releases. They are also not guaranteed to be examined and
used by any other JSSE implementations. If they <i>are</i> examined
by an implementation, then that implementation should handle them
in the same manner as the JSSE reference implementation does, as
described herein.</p>
<hr />
<!-- *********************************************** -->
<h3><a name="DisabledAlgorithms" id=
"DisabledAlgorithms">Disabled/Restricted Algorithms</a></h3>
<p>The cryptographic hash algorithm MD2 is no longer considered
secure. Java SE 7 included two new security properties and a new
API that support disabling specific cryptographic algorithms.</p>
<p>The <code>jdk.tls.disabledAlgorithms</code> property applies to
TLS handshaking, whereas the
<code>jdk.certpath.disabledAlgorithms</code> property applies to
certification path processing.</p>
<p>Starting with JDK 8u31, SSLv3 is disabled by default and the
default value of the Security property
<code>jdk.tls.disabledAlgorithms</code> is now as follows:</p>
<pre class="codeblock">
jdk.tls.disabledAlgorithms=SSLv3
</pre>
<p>If SSLv3 is absolutely required, the protocol can be reactivated
as described in <a href=
"../SunProviders.html#enable-sslv3">Enabling SSLv3</a>.</p>
<p>From JDK 8 onwards, the default value of
<code>jdk.certpath.disabledAlgorithms</code> includes <code>RSA
keySize &lt; 1024</code>. This means the use of certificates with
RSA key size less than 1024 bits in length is restricted. The
default value of <code>jdk.certpath.disabledAlgorithms</code> is
now as follows:</p>
<pre class="codeblock">
    jdk.certpath.disabledAlgorithms=MD2, RSA keySize &lt; 1024
</pre>
<p>This means that any certificate signed with MD2 or with a RSA
key of size &lt; 1024, is not acceptable.</p>
<p>Each security property contains a list of cryptographic
algorithms that will not be used during certification path
processing. The exact syntax of the properties is described in the
<var>java-home</var>/lib/security/java.security file, but is
briefly summarized here. The algorithm names are separated by
commas. Furthermore, you can also specify certain key sizes that
cannot be used.</p>
<p>For example, the following line in <code>java.security</code>
specifies that the MD2 and DSA algorithms must not be used for
certification path processing, and RSA is disabled for key sizes
less than 2048 bits.</p>
<pre class="codeblock">
    jdk.certpath.disabledAlgorithms=MD2, DSA, RSA keySize &lt; 2048
</pre>
<!-- *********************************************** -->
<h3><a name="JCECust" id="JCECust">Customizing the Encryption
Algorithm Providers</a></h3>
<p>The SunJSSE provider uses the SunJCE implementation for all its
cryptographic needs. Although it is recommended that you leave the
provider at its regular position, you can use implementations from
other JCA or JCE providers by registering them <em>before</em> the
SunJCE provider. The <a href=
"../crypto/CryptoSpec.html#ProviderImplReq">standard JCA
mechanism</a> can be used to configure providers, either statically
via the security properties file
<var>java-home</var>/lib/security/java.security, or dynamically via
the <code>addProvider()</code> or <code>insertProviderAt()</code>
method in the <code>java.security.Security</code> class. For
information about <var>java-home</var>, see <a href="#javaHome">The
Installation Directory</a>.</p>
<!-- ******************************** -->
<h3><a name="customizing_dh_keys" id=
"customizing_dh_keys">Customizing Size of Ephemeral Diffie-Hellman
Keys</a></h3>
<p>Diffie-Hellman (DH) keys of sizes less than 1024 bits have been
deprecated because of their insufficient strength. In JDK 8, you
can customize the ephemeral DH key size with the system property
<code>jdk.tls.ephemeralDHKeySize</code>. This system property does
not impact DH key sizes in ServerKeyExchange messages for
exportable cipher suites. It impacts only the DHE_RSA, DHE_DSS, and
DH_anon-based cipher suites in the JSSE Oracle provider.</p>
<p>You can specify one of the following values for this
property:</p>
<ul>
<li>Undefined: A DH key of size 1024 bits will be used always for
non-exportable cipher suites. This is the default value for this
property.</li>
<li><code>legacy</code>: The JSSE Oracle provider preserves the
legacy behavior (for example, using ephemeral DH keys of sizes 512
bits and 768 bits) of JDK 7 and earlier releases.</li>
<li><code>matched</code>: For non-exportable anonymous cipher
suites, the DH key size in ServerKeyExchange messages is 1024 bits.
For X.509 certificate based authentication (of non-exportable
cipher suites), the DH key size matching the corresponding
authentication key is used, except that the size must be between
1024 bits and 2048 bits. For example, if the public key size of an
authentication certificate is 2048 bits, then the ephemeral DH key
size should be 2048 bits unless the cipher suite is exportable.
This key sizing scheme keeps the cryptographic strength consistent
between authentication keys and key-exchange keys.</li>
<li>A valid integer between 1024 and 2048, inclusively: A fixed
ephemeral DH key size of the specified value, in bits, will be used
for non-exportable cipher suites.</li>
</ul>
<p>The following table summaries the minimum and maximum acceptable
DH key sizes for each of the possible values for the system
property <code>jdk.tls.ephemeralDHKeySize</code>:</p>
<table summary="Minimum and maximum acceptable DH key sizes"
border="1">
<tr>
<th id="h601">Value of <code>jdk.tls.ephemeralDHKeySize</code></th>
<th id="h602">Undefined</th>
<th id="h603"><code>legacy</code></th>
<th id="h604"><code>matched</code></th>
<th id="h605">Integer value (fixed)</th>
</tr>
<tr>
<th id="h606">Exportable DH key size</th>
<td headers="h601">512</td>
<td headers="h602">512</td>
<td headers="h603">512</td>
<td headers="h604">512</td>
</tr>
<tr>
<th id="h607">Non-exportable anonymous cipher suites</th>
<td headers="h601">1024</td>
<td headers="h602">768</td>
<td headers="h603">1024</td>
<td headers="h604">The fixed key size is specified by a valid integer property
value, which must be between 1024 and 2048, inclusively.</td>
</tr>
<tr>
<th id="h608">Authentication certificate</th>
<td headers="h601">1024</td>
<td headers="h602">768</td>
<td headers="h603">The key size is the same as the authentication certificate, but
must be between 1024 bits and 2048 bits, inclusively. However, the
SunJCE provider only supports 2048-bit DH keys larger than 1024
bits. Consequently, you may use the values 1024 or 2048 only.</td>
<td headers="h604">The fixed key size is specified by a valid integer property
value, which must be between 1024 and 2048, inclusively.</td>
</tr>
</table>
<!-- ******************************** -->
<h2><a name="tlsRenegotiation" id="tlsRenegotiation">Transport
Layer Security (TLS) Renegotiation Issue</a></h2>
<p>In the fall of 2009, a flaw was discovered in the SSL/TLS
protocols. A fix to the protocol was developed by the IETF TLS
Working Group, and current versions of the JDK contain this fix.
This section describes the situation in much more detail, along
with interoperability issues when communicating with older
implementations that do not contain this protocol fix.</p>
<p>The vulnerability allowed for man-in-the-middle (MITM) attacks
where chosen plain text could be injected as a prefix to a TLS
connection. This vulnerability did not allow an attacker to decrypt
or modify the intercepted network communication once the client and
server have successfully negotiated a session between
themselves.</p>
<p>Additional information is available at <a href=
"http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2009-3555"
target="_blank">CVE-2009-3555</a> (posted on Mitre's <a href=
"http://cve.mitre.org/index.html" target="_blank">Common
Vulnerabilities and Exposures List</a>, 2009) and <a href=
"http://www.educatedguesswork.org/2009/11/understanding_the_tls_renegoti.html"
target="_blank">Understanding the TLS Renegotiation Attack</a>
(posted on Eric Rescorla's blog, <a href=
"http://www.educatedguesswork.org/" target="_blank">Educated
Guesswork</a>, November 5, 2009).</p>
<!-- ******************************** -->
<h3><a name="phased" id="phased">Phased Approach to Fixing This
Issue</a></h3>
<p>The fix for this issue was handled in two phases:</p>
<ul>
<li>
<p>Phase 1: Until a protocol fix could be developed, an interim fix
that disabled SSL/TLS renegotiations by default was made available
in the <a href=
"http://www.oracle.com/technetwork/topics/security/javacpumar2010-083341.html">
March 30, 2010 Java SE and Java for Business Critical Patch
Update</a>.</p>
</li>
<li>
<p>Phase 2: The <a href="http://www.ietf.org/">IETF</a> issued
<a href="http://www.ietf.org/rfc/rfc5746.txt">RFC 5746</a>, which
addresses the renegotiation protocol flaw. The following table
lists the JDK and JRE releases that include the fix which
implements RFC 5746 and supports secure renegotiation.</p>
<table border="1" summary=
"Releases that include the fix which implements RFC 5746 and supports secure renegotiation">
<caption><a name="T7" id="T7">Table 7: JDK and JRE Releases With
Fixes to the TLS Renegotiation Issue</a></caption>
<thead>
<tr>
<th id="h701">JDK Family</th>
<th id="h702">Vulnerable Releases</th>
<th id="h703">Phase 1 Fix (Disable Renegotiations)</th>
<th id="h704">Phase 2 Fix (RFC 5746)</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h701">JDK and JRE 6</td>
<td headers="h702">Update 18 and earlier</td>
<td headers="h703">Updates 19 through 21</td>
<td headers="h704">Update 22</td>
</tr>
<tr>
<td headers="h701">JDK and JRE 5.0</td>
<td headers="h702">Update 23 and earlier</td>
<td headers="h703">Updates 24 through 25</td>
<td headers="h704">Update 26</td>
</tr>
<tr>
<td headers="h701">JDK and JRE 1.4.2</td>
<td headers="h702">Update 25 and earlier</td>
<td headers="h703">Updates 26 through 27</td>
<td headers="h704">Update 28</td>
</tr>
</tbody>
</table>
</li>
</ul>
<hr />
<p><strong>Note:</strong> Applications that do not require
renegotiations are not affected by the Phase 2 default
configuration. However applications that require renegotiations
(for example, web servers that initially allow for anonymous client
browsing, but later require SSL/TLS authenticated clients):</p>
<ul>
<li>Are not affected if the peer is also compliant with RFC
5746</li>
<li>Are affected if the peer has not been upgraded to RFC 5746 (see
next section for details)</li>
</ul>
<hr />
<!-- ******************************** -->
<a name="descPhase2" id="descPhase2"></a>
<h3>Description of the Phase 2 Fix</h3>
<p>The SunJSSE implementation reenables renegotiations by default
for connections to peers compliant with RFC 5746. That is, both the
client and server <strong>must support RFC 5746</strong> in order
to securely renegotiate. SunJSSE provides some interoperability
modes for connections with peers that have not been upgraded, but
users are <strong>strongly encouraged to update both their client
and server implementations as soon as possible</strong>.</p>
<p>With the Phase 2 fix, SunJSSE has three renegotiation
interoperability modes. Each mode fully supports the RFC 5746
secure renegotiation, but has these added semantics when
communicating with a peer that has not been upgraded:</p>
<ul>
<li>
<p><b>Strict mode</b>: Requires both client and server be upgraded
to RFC 5746 and to send the proper RFC 5746 messages. If not, the
initial (or subsequent) handshaking will fail and the connection
will be terminated.</p>
</li>
<li>
<p><b>Interoperable mode (default)</b>: Use of the proper RFC 5746
messages is optional; however, legacy (original SSL/TLS
specifications) renegotiations are disabled if the proper messages
are not used. Initial legacy connections are still allowed, but
legacy renegotiations are disabled. This is the best mix of
security and interoperability, and is the default setting.</p>
</li>
<li>
<p><b>Insecure mode</b>: Permits full legacy renegotiation. Most
interoperable with legacy peers but vulnerable to the original MITM
attack.</p>
</li>
</ul>
<p>The three mode distinctions only affect a connection with a peer
that has not been upgraded. Ideally, strict (full RFC 5746) mode
should be used for all clients and servers; however, it will take
some time for all deployed SSL/TLS implementations to support RFC
5746, because the interoperable mode is the current default.</p>
<p><a href="#T8">Table 8</a> contains interoperability information
about the modes for various cases in which the client and/or server
are either updated to support RFC 5746 or not.</p>
<table border="1" summary="Interoperability information">
<caption><a name="T8" id="T8">Table 8: Interoperability
Information</a></caption>
<thead>
<tr>
<th id="h801">Client</th>
<th id="h802">Server</th>
<th id="h803">Mode</th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h801">Updated</td>
<td headers="h802">Updated</td>
<td headers="h803">
<p>Secure renegotiation in all modes.</p>
</td>
</tr>
<tr>
<td headers="h801"><a name="FN21Back" id="FN21Back">Legacy</a> <a class="footnote"
href="#FN21">Footnote 1</a></td>
<td headers="h802">Updated</td>
<td headers="h803">
<ul>
<li><b>Strict</b><br />
If clients do not send the proper RFC 5746 messages, then initial
connections will immediately be terminated by the server
(<code>SSLHandshakeException</code> or
<code>handshake_failure</code>).</li>
<li><a name="FN2223Back" id="FN2223Back"><b>Interoperable</b><br />
Initial connections from legacy clients are allowed (missing RFC
5746 messages), but renegotiations will not be allowed by the
server.</a> <a class="footnote" href="#FN22">Footnote 2</a>
<a class="footnote" href="#FN23">Footnote 3</a></li>
<li><b>Insecure</b><br />
Connections and renegotiations with legacy clients are allowed, but
are vulnerable to the original MITM attack.</li>
</ul>
</td>
</tr>
<tr>
<td headers="h801">Updated</td>
<td headers="h802">Legacy <a class="footnote" href="#FN21">Footnote 1</a></td>
<td headers="h803">
<ul>
<li><b>Strict</b><br />
If the server does not respond with the proper RFC 5746 messages,
then the client will immediately terminate the connection
(<code>SSLHandshakeException</code> or
<code>handshake_failure</code>).</li>
<li><b>Interoperable</b><br />
Initial connections from legacy servers are allowed (missing RFC
5746 messages), but renegotiations will not be allowed by the
server. <a class="footnote" href="#FN22">Footnote 2</a> <a class=
"footnote" href="#FN23">Footnote 3</a></li>
<li><b>Insecure</b><br />
Connections and renegotiations with legacy servers are allowed, but
are vulnerable to the original MITM attack.</li>
</ul>
</td>
</tr>
<tr>
<td headers="h801">Legacy <a class="footnote" href="#FN21">Footnote 1</a></td>
<td headers="h802">Legacy <a class="footnote" href="#FN21">Footnote 1</a></td>
<td headers="h803">Existing SSL/TLS behavior, vulnerable to the MITM attack.</td>
</tr>
</tbody>
</table>
<p><a class="footnote" name="FN21" id="FN21" href=
"#FN21Back">Footnote 1</a> <small>"Legacy" means the original
SSL/TLS specifications (that is, <em>not</em> RFC
5746).</small></p>
<p><a class="footnote" name="FN22" id="FN22" href=
"#FN2223Back">Footnote 2</a> <small>SunJSSE Phase 1 implementations
reject renegotiations unless specifically reenabled. If
renegotiations are reenabled, then they will be treated as "Legacy"
by the peer that is compliant with RFC 5746, because they do not
send the proper RFC 5746 messages.</small></p>
<p><a class="footnote" name="FN23" id="FN23" href=
"#FN2223Back">Footnote 3</a> <small>In SSL/TLS, renegotiations can
be initiated by either side. Like the Phase 1 fix, applications
communicating with a peer that has not been upgraded in
Interoperable mode and that attempt to initiate renegotiation (via
<code>SSLSocket.startHandshake()</code> or
<code>SSLEngine.beginHandshake()</code>) will receive an
<code>SSLHandshakeException</code> (<code>IOException</code>) and
the connection will be shut down (<code>handshake_failure</code>).
Applications that receive a renegotiation request from a peer that
has not been upgraded will respond according to the type of
connection in place:</small></p>
<ul>
<li><small><b>TLSv1</b><br />
A warning alert message of type <code>no_renegotiation(100)</code>
will be sent to the peer and the connection will remain open. Older
versions of SunJSSE will shut down the connection when a
<code>no_renegotiation</code> alert is received.</small></li>
<li><small><b>SSLv3</b><br />
The application will receive an <code>SSLHandshakeException</code>,
and the connection will be closed (<code>handshake_failure</code>).
The <code>no_renegotiation</code> alert is not defined in the SSLv3
specification.</small></li>
</ul>
<p>The following system properties are used to set the mode:</p>
<ul>
<li><code>sun.security.ssl.allowUnsafeRenegotiation</code>
(introduced in Phase 1) controls whether legacy (unsafe)
renegotiations are permitted.</li>
<li><code>sun.security.ssl.allowLegacyHelloMessages</code>
(introduced in Phase 2) allows the peer to perform the handshake
process without requiring the proper RFC 5746 messages.</li>
</ul>
<table border="1" summary=
"System properties to set interoperability modes">
<caption><a name="T9" id="T9">Table 9: Values of the System
Properties for Setting the Interoperability Mode</a></caption>
<thead>
<tr>
<th id="h901">Mode</th>
<th id="h902"><code>allowLegacyHelloMessages</code></th>
<th id="h903"><code>allowUnsafeRenegotiation</code></th>
</tr>
</thead>
<tbody>
<tr>
<td headers="h901">Strict</td>
<td headers="h902">false</td>
<td headers="h903">false</td>
</tr>
<tr>
<td headers="h901">Interoperable (default)</td>
<td headers="h902">true</td>
<td headers="h903">false</td>
</tr>
<tr>
<td headers="h901">Insecure</td>
<td headers="h902">true</td>
<td headers="h903">true</td>
</tr>
</tbody>
</table>
<hr />
<p><strong>Caution:</strong> Do not reenable the insecure SSL/TLS
renegotiation, as this would reestablish the vulnerability.</p>
<hr />
<p>For information about how to configure a specific mode by
setting a system property, see <a href="#SystemProps">How to
Specify a java.lang.System Property</a>. 
<!-- ******************************** --></p>
<h3><a name="workarounds" id="workarounds">Workarounds and
Alternatives to SSL/TLS Renegotiation</a></h3>
<p>All peers should be updated to RFC 5746-compliant implementation
as soon as possible. Even with this RFC 5746 fix, communications
with peers that have not been upgraded will be affected if a
renegotiation is necessary. Here are a few suggested options:</p>
<ul>
<li>
<p><b>Restructure the peer to not require renegotiation.</b></p>
<p>Renegotiations are typically used by web servers that initially
allow for anonymous client browsing but later require SSL/TLS
authenticated clients, or that may initially allow weak cipher
suites but later need stronger ones. The alternative is to require
client authentication or strong cipher suites during the
<em>initial</em> negotiation. There are a couple of options for
doing so:</p>
<ul>
<li>
<p>If an application has a browse mode until a certain point is
reached and a renegotiation is required, then you can restructure
the server to eliminate the browse mode and require all initial
connections be strong.</p>
</li>
<li>
<p>Break the server into two entities, with the browse mode
occurring on one entity, and using a second entity for the more
secure mode. When the renegotiation point is reached, transfer any
relevant information between the servers.</p>
</li>
</ul>
<p>Both of these options require a fair amount of work, but will
not reopen the original security flaw.</p>
</li>
<li>
<p><b>Set renegotiation interoperability mode to "insecure" using
the system properties.</b></p>
<p>See the <a href="#descPhase2">Description of the Phase 2 Fix</a>
for information and warnings.</p>
</li>
</ul>
<!-- ******************************** -->
<h3><a name="implDetails" id="implDetails">Implementation
Details</a></h3>
<p>RFC 5746 defines two new data structures, which are mentioned
here for advanced users:</p>
<ul>
<li>A pseudo-cipher suite called the Signaling Cipher Suite Value
(SCSV), "TLS_EMPTY_RENEGOTIATION_INFO_SCSV"</li>
<li>A TLS extension called the Renegotiation Info (RI).</li>
</ul>
<p>Either of these can be used to signal that an implementation is
RFC 5746-compliant and can perform secure renegotiations. For more
relevant technical discussions, see the <a href=
"http://www.ietf.org/mail-archive/web/tls/current/maillist.html">IETF
email discussion</a> from November 2009 to February 2010.</p>
<p>RFC 5746 enables clients to send either an SCSV or RI in the
first <code>ClientHello</code>. For maximum interoperability,
SunJSSE uses the SCSV by default, as a few TLS/SSL servers do not
handle unknown extensions correctly. The presence of the SCSV in
the enabled cipher suites
(<code>SSLSocket.setEnabledCipherSuites()</code> or
<code>SSLEngine.setEnabledCipherSuites()</code>) determines whether
the SCSV is sent in the initial <code>ClientHello</code>, or if an
RI should be sent instead.</p>
<p>SSLv2 does not support SSL/TLS extensions. If the
<code>SSLv2Hello</code> protocol is enabled, then the SCSV is sent
in the initial <code>ClientHello</code>.</p>
<!-- ******************************** -->
<h3><a name="descPhase1" id="descPhase1">Description of the Phase 1
fix</a></h3>
<p>As previously mentioned, the Phase 1 Fix was to disable
renegotiations by default until a fix compliant with RFC 5746 could
be developed. Renegotiations could be reenabled by setting the
<code>sun.security.ssl.allowUnsafeRenegotiation</code> system
property. The Phase 2 fix uses the same
<code>sun.security.ssl.allowUnsafeRenegotiation</code> system
property, but also requires it to use RFC 5746 messages.</p>
<p>All applications should upgrade to the Phase 2 RFC 5746 fix as
soon as possible.</p>
<h3><a name="allowUnsafeCert" id="allowUnsafeCert">Allow Unsafe
Server Certificate Change in SSL/TLS renegotiations</a></h3>
<p>Server certificate change in an SSL/TLS renegotiation may be
unsafe:</p>
<ol>
<li>if endpoint identification is not enabled in an SSL/TLS
handshaking; and</li>
<li>if the previous handshake is a session-resumption abbreviated
initial handshake; and</li>
<li>if the identities represented by both certificates can be
regarded as the same.</li>
</ol>
<p>Two certificates can be considered to represent the same
identity:</p>
<ol>
<li>If the subject alternative names of IP address are present in
both certificates, they should be identical; otherwise,</li>
<li>if the subject alternative names of DNS name are present in
both certificates, they should be identical; otherwise,</li>
<li>if the subject fields are present in both certificates, the
certificate subjects and issuers should be identical.</li>
</ol>
<p>Starting with JDK 8u25, unsafe server certificate change in
SSL/TLS renegotiations is not allowed by default. The new system
property <code>jdk.tls.allowUnsafeServerCertChange</code>, can be
used to define whether unsafe server certificate change in an
SSL/TLS renegotiation should be restricted or not.</p>
<p>The default value of this system property is
<code>"false"</code>.</p>
<p><strong>Caution:</strong> DO NOT set the system property to
<code>"true"</code> unless it is really necessary, as this would
re-establish the unsafe server certificate change
vulnerability.</p>
<!-- *********************************************** -->
<h2><a name="PKCS11" id="PKCS11">Hardware Acceleration and
Smartcard Support</a></h2>
<p>The <a href="../crypto/CryptoSpec.html">Java Cryptography
Architecture (JCA)</a> is a set of packages that provides a
framework and implementations for encryption, key generation and
key agreement, and message authentication code (MAC) algorithms.
The SunJSSE provider uses JCA exclusively for all of its
cryptographic operations and can automatically take advantage of
JCE features and enhancements, including JCA's support for <a href=
"http://www.rsa.com/rsalabs/node.asp?id=2133">PKCS#11</a>. This
support enables the SunJSSE provider to use hardware cryptographic
accelerators for significant performance improvements and to use
smartcards as keystores for greater flexibility in key and trust
management.</p>
<p>Use of hardware cryptographic accelerators is automatic if JCA
has been configured to use the Oracle PKCS#11 provider, which in
turn has been configured to use the underlying accelerator
hardware. The provider must be configured before any other JCA
providers in the provider list. For details on how to configure the
Oracle PKCS#11 provider, see the <a href="../p11guide.html">PKCS#11
Guide</a>.</p>
<!-- *********************************************** -->
<h3><a name="ConfigSmartcard" id="ConfigSmartcard">Configuring JSSE
to Use Smartcards as Keystores and Truststores</a></h3>
<p>Support for PKCS#11 in JCA also enables access to smartcards as
a keystore. For details on how to configure the type and location
of the keystores to be used by JSSE, see the <a href=
"#InstallationAndCustomization">Customizing JSSE</a> section. To
use a smartcard as a keystore or truststore, set the
<code>javax.net.ssl.keyStoreType</code> and
<code>javax.net.ssl.trustStoreType</code> system properties,
respectively, to <code>pkcs11</code>, and set the
<code>javax.net.ssl.keyStore</code> and
<code>javax.net.ssl.trustStore</code> system properties,
respectively, to <code>NONE</code>. To specify the use of a
specific provider, use the
<code>javax.net.ssl.keyStoreProvider</code> and
<code>javax.net.ssl.trustStoreProvider</code> system properties
(for example, set them to <code>SunPKCS11-joe</code>). By using
these properties, you can configure an application that previously
depended on these properties to access a file-based keystore to use
a smartcard keystore with no changes to the application.</p>
<p>Some applications request the use of keystores programmatically.
These applications can continue to use the existing APIs to
instantiate a <code>Keystore</code> and pass it to its key manager
and trust manager. If the <code>Keystore</code> instance refers to
a PKCS#11 keystore backed by a Smartcard, then the JSSE application
will have access to the keys on the smartcard.</p>
<!-- ********************************** -->
<h3><a name="MultiDynamicKeystores" id=
"MultiDynamicKeystores">Multiple and Dynamic Keystores</a></h3>
<p>smartcards (and other removable tokens) have additional
requirements for an <code>X509KeyManager</code>. Different
smartcards can be present in a smartcard reader during the lifetime
of a Java application, and they can be protected using different
passwords.</p>
<p>The <a href=
"../../../../api/java/security/KeyStore.Builder.html"><code>java.security.KeyStore.Builder</code></a>
class abstracts the construction and initialization of a
<code>KeyStore</code> object. It supports the use of
<code>CallbackHandler</code> for password prompting, and its
subclasses can be used to support additional features as desired by
an application. For example, it is possible to implement a
<code>Builder</code> that allows individual <code>KeyStore</code>
entries to be protected with different passwords. The <a href=
"../../../../api/javax/net/ssl/KeyStoreBuilderParameters.html"><code>
javax.net.ssl.KeyStoreBuilderParameters</code></a> class then can
be used to initialize a KeyManagerFactory using one or more of
these <code>Builder</code> objects.</p>
<p>A <code>X509KeyManager</code> implementation in the SunJSSE
provider called NewSunX509 supports these parameters. If multiple
certificates are available, it attempts to pick a certificate with
the appropriate key usage and prefers valid to expired
certificates.</p>
<p>The following example illustrates how to tell JSSE to use both a
PKCS#11 keystore (which might in turn use a smartcard) and a
PKCS#12 file-based keystore.</p>
<pre class="codeblock">
import javax.net.ssl.*;
import java.security.KeyStore.*;
...

// Specify keystore builder parameters for PKCS#11 keystores
Builder scBuilder = Builder.newInstance("PKCS11", null,
    new CallbackHandlerProtection(myGuiCallbackHandler));

// Specify keystore builder parameters for a specific PKCS#12 keystore
Builder fsBuilder = Builder.newInstance("PKCS12", null,
    new File(pkcsFileName), new PasswordProtection(pkcsKsPassword));

// Wrap them as key manager parameters
ManagerFactoryParameters ksParams = new KeyStoreBuilderParameters(
    Arrays.asList(new Builder[] { scBuilder, fsBuilder }) );

// Create KeyManagerFactory
KeyManagerFactory factory = KeyManagerFactory.getInstance("NewSunX509");

// Pass builder parameters to factory
factory.init(ksParams);

// Use factory
SSLContext ctx = SSLContext.getInstance("TLS");
ctx.init(factory.getKeyManagers(), null, null);
</pre>
<!-- ********************************** -->
<h2><a name="KRB" id="KRB">Kerberos Cipher Suites</a></h2>
<p>The SunJSSE provider has support for Kerberos cipher suites, as
described in <a href="http://www.ietf.org/rfc/rfc2712.txt">RFC
2712</a>. The following cipher suites are supported but not enabled
by default:</p>
<ul>
<li>TLS_KRB5_WITH_RC4_128_SHA</li>
<li>TLS_KRB5_WITH_RC4_128_MD5</li>
<li>TLS_KRB5_WITH_3DES_EDE_CBC_SHA</li>
<li>TLS_KRB5_WITH_3DES_EDE_CBC_MD5</li>
<li>TLS_KRB5_WITH_DES_CBC_SHA</li>
<li>TLS_KRB5_WITH_DES_CBC_MD5</li>
<li>TLS_KRB5_EXPORT_WITH_RC4_40_SHA</li>
<li>TLS_KRB5_EXPORT_WITH_RC4_40_MD5</li>
<li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_SHA</li>
<li>TLS_KRB5_EXPORT_WITH_DES_CBC_40_MD5</li>
</ul>
<p>To enable the use of these cipher suites, you must do so
explicitly. For more information, see the API documentation for the
<a href=
"../../../../api/javax/net/ssl/SSLEngine.html#setEnabledCipherSuites-java.lang.String:A-">
<code>SSLEngine.setEnabledCipherSuites()</code></a> and <a href=
"../../../../api/javax/net/ssl/SSLSocket.html#setEnabledCipherSuites-java.lang.String:A-">
<code>SSLSocket.setEnabledCipherSuites()</code></a> methods. As
with all other SSL/TLS cipher suites, if a cipher suite is not
supported by the peer, then it will not be selected during cipher
negotiation. Furthermore, if the application and/or server cannot
acquire the necessary Kerberos credentials, then the Kerberos
cipher suites also will not be selected.</p>
<p>The following is an example of a TLS client that will only use
the <code>TLS_KRB5_WITH_DES_CBC_SHA</code> cipher suite:</p>
<pre class="codeblock">
// Create socket
SSLSocketFactory sslsf = (SSLSocketFactory) SSLSocketFactory.getDefault();
SSLSocket sslSocket = (SSLSocket) sslsf.createSocket(tlsServer, serverPort);

// Enable only one cipher suite
String enabledSuites[] = { "TLS_KRB5_WITH_DES_CBC_SHA" };
sslSocket.setEnabledCipherSuites(enabledSuites);
</pre>
<!-- ********************************** -->
<h3><a name="KRBRequire" id="KRBRequire">Kerberos
Requirements</a></h3>
<p>You must have the Kerberos infrastructure set up in your
deployment environment before you can use the Kerberos cipher
suites with JSSE. In particular, both the TLS client and server
must have accounts set up with the Kerberos Key Distribution Center
(KDC). At runtime, if one or more of the Kerberos cipher suites
have been enabled, then the TLS client and server will acquire
their Kerberos credentials associated with their respective account
from the KDC. For example, a TLS server running on the machine
<code>mach1.imc.org</code> in the Kerberos realm
<code>IMC.ORG</code> must have an account with the name
<code>host/mach1.imc.org@IMC.ORG</code> and be configured to use
the KDC for <code>IMC.ORG</code>. For information about using
Kerberos with Java SE, see the <a href=
"../jgss/tutorials/KerberosReq.html">Kerberos Requirements</a>
document.</p>
<p>An application can acquire its Kerberos credentials by using the
<a href="../jaas/JAASRefGuide.html">Java Authentication and
Authorization Service (JAAS)</a> and a Kerberos login module. The
JDK comes with a <a href=
"../../../../jre/api/security/jaas/spec/com/sun/security/auth/module/Krb5LoginModule.html">
Kerberos login module</a>. You can use the Kerberos cipher suites
with JSSE with or without JAAS programming, similar to how you can
use the <a href="../jgss/tutorials/index.html">Java Generic
Security Services (Java GSS)</a> with or without JAAS
programming.</p>
<p>To use the Kerberos cipher suites with JSSE without JAAS
programming, you must use the index names
<code>com.sun.net.ssl.server</code> or <code>other</code> for the
TLS server JAAS configuration entry, and
<code>com.sun.net.ssl.client</code> or <code>other</code> for the
TLS client, and set the
<code>javax.security.auth.useSubjectCredsOnly</code> system
property to false. For example, a TLS server that is not using JAAS
programming might have the following JAAS configuration file:</p>
<pre class="codeblock">
    com.sun.net.ssl.server {
      com.sun.security.auth.module.Krb5LoginModule required
            principal="host/mach1.imc.org@IMC.ORG"
            useKeyTab=true
            keyTab=mach1.keytab
            storeKey=true;
    };
</pre>
<p>An example of how to use Java GSS and Kerberos without JAAS
programming is described in the <a href=
"../jgss/tutorials/BasicClientServer.html">Java GSS Tutorial</a>.
You can adapt it to use JSSE by replacing Java GSS calls with JSSE
calls.</p>
<p>To use the Kerberos cipher suites with JAAS programming, you can
use any index name because your application is responsible for
creating the JAAS <code>LoginContext</code> using the index name,
and then wrapping the JSSE calls inside of a
<code>Subject.doAs()</code> or
<code>Subject.doAsPrivileged()</code> call. An example of how to
use JAAS with Java GSS and Kerberos is described in the <a href=
"../jgss/tutorials/ClientServer.html">Java GSS Tutorial</a>. You
can adapt it to use JSSE by replacing Java GSS calls with JSSE
calls.</p>
<p>If you have trouble using or configuring the JSSE application to
use Kerberos, see the <a href=
"../jgss/tutorials/Troubleshooting.html">Troubleshooting</a>
section of the Java GSS Tutorial.</p>
<!-- ********************************** -->
<h3><a name="KRBPeerID" id="KRBPeerID">Peer Identity
Information</a></h3>
<p>To determine the identity of the peer of an SSL connection, use
the <code>getPeerPrincipal()</code> method in the following
classes:</p>
<ul>
<li><code>javax.net.ssl.SSLSession</code></li>
<li><code>javax.net.ssl.HttpsURLConnection</code></li>
<li><code>javax.net.HandshakeCompletedEvent</code></li>
</ul>
<p>Similarly, to get the identity that was sent to the peer (to
identify the local entity), use the
<code>getLocalPrincipal()</code> method in these classes. For
X509-based cipher suites, these methods will return an instance of
<code>javax.security.auth.x500.X500Principal</code>; for Kerberos
cipher suites, these methods will return an instance of
<code>javax.security.auth.kerberos.KerberosPrincipal</code>.</p>
<p>JSSE applications use <code>getPeerCertificates()</code> and
similar methods in <code>javax.net.ssl.SSLSession</code>,
<code>javax.net.ssl.HttpsURLConnection</code>, and
<code>javax.net.HandshakeCompletedEvent</code> classes to obtain
information about the peer. When the peer does not have any
certificates, <code>SSLPeerUnverifiedException</code> is
thrown.</p>
<p>If the application must determine only the identity of the peer
or identity sent to the peer, then it should use the
<code>getPeerPrincipal()</code> and
<code>getLocalPrincipal()</code> methods, respectively. It should
use <code>getPeerCertificates()</code> and
<code>getLocalCertificates()</code> methods only if it must examine
the contents of those certificates. Furthermore, the application
must be prepared to handle the case where an authenticated peer
might not have any certificate.</p>
<!-- ********************************** -->
<h3><a name="KRBSM" id="KRBSM">Security Manager</a></h3>
<p>When the security manager has been enabled, in addition to the
<code>SocketPermission</code> needed to communicate with the peer,
a TLS client application that uses the Kerberos cipher suites also
needs the following permission:</p>
<pre class="codeblock">
javax.security.auth.kerberos.ServicePermission(<i>serverPrincipal</i>, "initiate");
</pre>
<p>In the preceding code, <i>serverPrincipal</i> is the Kerberos
principal name of the TLS server that the TLS client will be
communicating with (such as
<code>host/mach1.imc.org@IMC.ORG</code>). A TLS server application
needs the following permission:</p>
<pre class="codeblock">
javax.security.auth.kerberos.ServicePermission(<i>serverPrincipal</i>, "accept");
</pre>
<p>In the preceding code, <i>serverPrincipal</i> is the Kerberos
principal name of the TLS server (such as
<code>host/mach1.imc.org@IMC.ORG</code>). If the server or client
must contact the KDC (for example, if its credentials are not
cached locally), then it also needs the following permission:</p>
<pre class="codeblock">
javax.security.auth.kerberos.ServicePermission(<i>tgtPrincipal</i>, "initiate");
</pre>
In the preceding code, <i>tgtPrincipal</i> is the principal name of
the KDC (such as <code>krbtgt/IMC.ORG@IMC.ORG</code>). 
<!-- ********************************** -->
<h2><a name="KeystoreFormats" id="KeystoreFormats">Additional
Keystore Formats (PKCS12)</a></h2>
<p>The <a href=
"http://www.rsa.com/rsalabs/node.asp?id=2138">PKCS#12 (Personal
Information Exchange Syntax Standard)</a> specifies a portable
format for storage and/or transport of a user's private keys,
certificates, miscellaneous secrets, and other items. The SunJSSE
provider supplies a complete implementation of the PKCS12
<code>java.security.KeyStore</code> format for reading and writing
PKCS12 files. This format is also supported by other toolkits and
applications for importing and exporting keys and certificates,
such as Netscape/Mozilla, Microsoft's Internet Explorer, and
OpenSSL. For example, these implementations can export client
certificates and keys into a file using the .p12 file name
extension.</p>
<p>With the SunJSSE provider, you can access PKCS12 keys through
the <code>KeyStore</code> API with a keystore type of PKCS12. In
addition, you can list the installed keys and associated
certificates by using the <code>keytool</code> command with the
<code>-storetype</code> option set to <code>pkcs12</code>. For more
information about <code>keytool</code>, see <a href=
"../../../tools/index.html#security">Security Tools</a>.</p>
<!-- ********************************** -->
<h2><a name="SNIExtension" id="SNIExtension">Server Name Indication
(SNI) Extension</a></h2>
<p>The SNI extension is a feature that extends the SSL/TLS
protocols to indicate what server name the client is attempting to
connect to during handshaking. Servers can use server name
indication information to decide if specific <code>SSLSocket</code>
or <code>SSLEngine</code> instances should accept a connection. For
example, when multiple virtual or name-based servers are hosted on
a single underlying network address, the server application can use
SNI information to determine whether this server is the exact
server that the client wants to access. Instances of this class can
be used by a server to verify the acceptable server names of a
particular type, such as host names. For more information, see
section 3 of <a href="http://www.ietf.org/rfc/rfc6066.txt">TLS
Extensions (RFC 6066)</a>.</p>
<p>Developers of client applications can explicitly set the server
name indication using the
<code>SSLParameters.setServerNames(List&lt;SNIServerName&gt;
serverNames)</code> method. The following example illustrates this
functionality:</p>
<pre class="codeblock">
 
SSLSocketFactory factory = ...
SSLSocket sslSocket = factory.createSocket("172.16.10.6", 443);
// SSLEngine sslEngine = sslContext.createSSLEngine("172.16.10.6", 443);

SNIHostName serverName = new SNIHostName("www.example.com");
List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
serverNames.add(serverName);

SSLParameters params = sslSocket.getSSLParameters();
params.setServerNames(serverNames);
sslSocket.setSSLParameters(params);
// sslEngine.setSSLParameters(params);
</pre>
<p>Developers of server applications can use the
<code>SNIMatcher</code> class to decide how to recognize server
name indication. The following two examples illustrate this
functionality:</p>
<p><b>Example 1</b></p>
<pre class="codeblock">
 
SSLSocket sslSocket = sslServerSocket.accept();

SNIMatcher matcher = SNIHostName.createSNIMatcher("www\\.example\\.(com|org)");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);

SSLParameters params = sslSocket.getSSLParameters();
params.setSNIMatchers(matchers);
sslSocket.setSSLParameters(params);
</pre>
<p><b>Example 2</b></p>
<pre class="codeblock">
 
SSLServerSocket sslServerSocket = ...;

SNIMatcher matcher = SNIHostName.createSNIMatcher("www\\.example\\.(com|org)");
Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
matchers.add(matcher);

SSLParameters params = sslServerSocket.getSSLParameters();
params.setSNIMatchers(matchers);
sslServerSocket.setSSLParameters(params);

SSLSocket sslSocket = sslServerSocket.accept();
</pre>
<p>The following list provides examples for the behavior of the
<code>SNIMatcher</code> when receiving various server name
indication requests in the ClientHello message:</p>
<ul>
<li>
<p>Matcher configured to <code>www\\.example\\.com</code>:</p>
<ul>
<li>If the requested host name is <code>www.example.com</code>,
then it will be accepted and a confirmation will be sent in the
ServerHello message.</li>
<li>If the requested host name is <code>www.example.org</code>,
then it will be rejected with an <code>unrecognized_name</code>
fatal error.</li>
<li>If there is no requested host name or it is empty, then the
request will be accepted but no confirmation will be sent in the
ServerHello message.</li>
</ul>
</li>
<li>
<p>Matcher configured to <code>www\\.invalid\\.com</code>:</p>
<ul>
<li>If the requested host name is <code>www.example.com</code>,
then it will be rejected with an <code>unrecognized_name</code>
fatal error.</li>
<li>If the requested host name is <code>www.example.org</code>,
then it will be accepted and a confirmation will be sent in the
ServerHello message.</li>
<li>If there is no requested host name or it is empty, then the
request will be accepted but no confirmation will be sent in the
ServerHello message.</li>
</ul>
</li>
<li>
<p>Matcher is not configured:</p>
<p>Any requested host name will be accepted but no confirmation
will be sent in the ServerHello message.</p>
</li>
</ul>
<p>For descriptions of new classes that implement the SNI
extension, see:</p>
<ul>
<li><a href="#StandardConstants">StandardConstants Class</a></li>
<li><a href="#SNIServerName">SNIServerName Class</a></li>
<li><a href="#SNIMatcher">SNIMatcher Class</a></li>
<li><a href="#SNIHostName">SNIHostName Class</a></li>
</ul>
<p>For examples, see <a href="#SNIExamples">Using the Server Name
Indication (SNI) Extension</a>.</p>
<!-- ********************************** -->
<h2><a name="Troubleshooting" id=
"Troubleshooting">Troubleshooting</a></h2>
<p>This section contains information for troubleshooting JSSE.
First, it provides some common <a href=
"#InstallProbs">configuration problems</a> and ways to solve them,
and then it describes helpful <a href="#Debug">debugging
utilities</a>.</p>
<!-- ********************************** -->
<h3><a name="InstallProbs" id="InstallProbs">Configuration
Problems</a></h3>
<p>This section describes some common configuration problems that
might arise when you use JSSE.</p>
<!-- ********************************** -->
<h3>CertificateException While Handshaking</h3>
<p><b>Problem:</b> When negotiating an SSL connection, the client
or server throws a <code>CertificateException</code>.</p>
<p><b>Cause 1:</b> This is generally caused by the remote side
sending a certificate that is unknown to the local side.</p>
<p><b>Solution 1:</b> The best way to debug this type of problem is
to turn on debugging (see <a href="#Debug">Debugging Utilities</a>)
and watch as certificates are loaded and when certificates are
received via the network connection. Most likely, the received
certificate is unknown to the trust mechanism because the wrong
trust file was loaded. Refer to the following sections for more
information:</p>
<ul>
<li><a href="#JSSEClasses">JSSE Classes and Interfaces</a></li>
<li><a href="#TrustManager">The TrustManager Interface</a></li>
<li><a href="#KeyManager">The KeyManager Interface</a></li>
</ul>
<p><b>Cause 2:</b> The system clock is not set correctly. In this
case, the perceived time may be outside the validity period on one
of the certificates, and unless the certificate can be replaced
with a valid one from a truststore, the system must assume that the
certificate is invalid, and therefore throw the exception.</p>
<p><b>Solution 2:</b> Correct the system clock time.</p>
<!-- ********** 11.22.05 -->
<h3>java.security.KeyStoreException: TrustedCertEntry Not
Supported</h3>
<p><b>Problem:</b> Attempt to store trusted certificates in PKCS12
keystore throws <code>java.security.KeyStoreException:
TrustedCertEntry not supported.</code></p>
<p><b>Cause:</b> Storing trusted certificates in a PKCS12 keystore
is not supported. PKCS12 is mainly used to deliver private keys
with the associated certificate chains. It does not have any notion
of "trusted" certificates. In terms of interoperability, other
PKCS12 vendors have the same restriction. Browsers such as Mozilla
and Internet Explorer do not accept a PKCS12 file with only trusted
certificates.</p>
<p><b>Solution:</b> Use the JKS keystore for storing trusted
certificates.</p>
<!-- ********** 11.22.05 -->
<h3>Runtime Exception: SSL Service Not Available</h3>
<p><b>Problem:</b> When running a program that uses JSSE, an
exception occurs indicating that an SSL service is not available.
For example, an exception similar to one of the following is
thrown:</p>
<pre class="codeblock">
    Exception in thread "main" java.net.SocketException:
        no SSL Server Sockets
    
    Exception in thread "main":
        SSL implementation not available
</pre>
<p><b>Cause:</b> There was a problem with <code>SSLContext</code>
initialization, for example, due to an incorrect password on a
keystore or a corrupted keystore (a JDK vendor once shipped a
keystore in an unknown format, and that caused this type of
error).</p>
<p><b>Solution:</b> Check initialization parameters. Ensure that
any keystores specified are valid and that the passwords specified
are correct. One way that you can check this is by trying to use
the <a href=
"../../../tools/index.html#security"><code>keytool</code>
command-line utility</a> to examine the keystores and the relevant
contents.</p>
<!-- ********************************** -->
<h3><a name="NoAvailCert" id="NoAvailCert">Runtime Exception: "No
available certificate corresponding to the SSL cipher suites which
are enabled"</a></h3>
<p><b>Problem:</b> When trying to run a simple SSL server program,
the following exception is thrown:</p>
<pre class="codeblock">
    Exception in thread "main" javax.net.ssl.SSLException:
        No available certificate corresponding to the SSL cipher suites which are enabled...
</pre>
<p><b>Cause:</b> Various cipher suites require certain types of key
material. For example, if an RSA cipher suite is enabled, then an
RSA <code>keyEntry</code> must be available in the keystore. If no
such key is available, then this cipher suite cannot be used. This
exception is thrown if there are no available key entries for all
of the cipher suites enabled.</p>
<p><b>Solution:</b> Create key entries for the various cipher suite
types, or use an anonymous suite. Anonymous cipher suites are
inherently dangerous because they are vulnerable to MITM
(man-in-the-middle) attacks. For more information, see <a href=
"http://www.ietf.org/rfc/rfc2246.txt?number=2246">RFC 2246</a>.</p>
<p>Refer to the following sections to learn how to pass the correct
keystore and certificates:</p>
<ul>
<li><a href="#JSSEClasses">JSSE Classes and Interfaces</a></li>
<li><a href="#CustomizingStores">Customizing the Default Keystores
and Truststores, Store Types, and Store Passwords</a></li>
<li><a href="#KeystoreFormats">Additional Keystore Formats</a></li>
</ul>
<!-- ********************************** -->
<h3>Runtime Exception: No Cipher Suites in Common</h3>
<p><b>Problem 1:</b> When handshaking, the client and/or server
throw this exception.</p>
<p><b>Cause 1:</b> Both sides of an SSL connection must agree on a
common cipher suite. If the intersection of the client's cipher
suite set with the server's cipher suite set is empty, then you
will see this exception.</p>
<p><b>Solution 1:</b> Configure the enabled cipher suites to
include common cipher suites, and be sure to provide an appropriate
<code>keyEntry</code> for asymmetric cipher suites. Also see
<a href="#NoAvailCert">Runtime Exception: "No available
certificate..."</a> in this section.)</p>
<p><b>Problem 2:</b> When using Netscape Navigator or Microsoft
Internet Explorer to access files on a server that only has
DSA-based certificates, a runtime exception occurs indicating that
there are no cipher suites in common.</p>
<p><b>Cause 2:</b> By default, <code>keyEntries</code> created with
<code>keytool</code> use DSA public keys. If only DSA
<code>keyEntries</code> exist in the keystore, then only DSA-based
cipher suites can be used. By default, Navigator and Internet
Explorer send only RSA-based cipher suites. Because the
intersection of client and server cipher suite sets is empty, this
exception is thrown.</p>
<p><b>Solution 2:</b> To interact with Navigator or Internet
Explorer, you should create certificates that use RSA-based keys.
To do this, specify the <code>-keyalg</code> RSA option when using
keytool. For example:</p>
<pre class="codeblock">
    keytool -genkeypair -alias duke -keystore testkeys -keyalg rsa
</pre>
<!-- ********************************** -->
<h3>Slowness of the First JSSE Access</h3>
<p><b>Problem:</b> JSSE seems to stall on first access.</p>
<p><b>Cause:</b> JSSE must have a secure source of random numbers.
The initialization takes a while.</p>
<p><b>Solution:</b> Provide an alternative generator of random
numbers, or initialize ahead of time when the overhead will not be
noticed:</p>
<pre class="codeblock">
SecureRandom sr = new SecureRandom();
sr.nextInt();
SSLContext.init(..., ..., sr);
</pre>
<p>The <var>java-home</var>/lib/security/java.security file also
provides a way to specify the source of seed data for
<code>SecureRandom</code>. See the contents of the file for more
information. <!-- ********************************** --></p>
<h3><a name="HttpsURLConnectionEx" id="HttpsURLConnectionEx">Code
Using HttpsURLConnection Class Throws ClassCastException in JSSE
1.0.x</a></h3>
<p><b>Problem:</b> The following code snippet was written using
<code>com.sun.net.ssl.HttpsURLConnection</code> in JSSE 1.0.x:</p>
<pre class="codeblock">
import com.sun.net.ssl.*;
...deleted...
HttpsURLConnection urlc = new URL("https://example.com/").openConnection();
</pre>
<p>When running under JSSE 1.0.x, this code returns a
<code>javax.net.ssl.HttpsURLConnection</code> object and throws a
<code>ClassCastException</code>.</p>
<p><b>Cause:</b> By default, opening an HTTPS URL will create a
<code>javax.net.ssl.HttpsURLConnection</code>.</p>
<p><b>Solution:</b> Previous releases of the JDK (release 6 and
earlier) did not ship with an HTTPS URL implementation. The JSSE
1.0.x implementation did provide such an HTTPS URL handler, and the
installation guide described how to set the URL handler search path
to obtain a JSSE 1.0.x
<code>com.sun.net.ssl.HttpsURLConnection</code> implementation.</p>
<p>In the JDK, there is an HTTPS handler in the default URL handler
search path. It returns an instance of
<code>javax.net.ssl.HttpsURLConnection</code>. By prepending the
old JSSE 1.0.x implementation path to the URL search path via the
<code>java.protocol.handler.pkgs</code> variable, you can still
obtain a <code>com.sun.net.ssl.HttpsURLConnection</code>, and the
code will no longer throw cast exceptions.</p>
See the following examples:
<pre class="codeblock">
    % java -Djava.protocol.handler.pkgs=com.sun.net.ssl.internal.www.protocol YourClass
</pre>
<pre class="codeblock">
    System.setProperty("java.protocol.handler.pkgs", "com.sun.net.ssl.internal.www.protocol");
</pre>
<!-- ********************************** -->
<h3>Socket Disconnected After Sending ClientHello Message</h3>
<p><b>Problem:</b> A socket attempts to connect, sends a
ClientHello message, and is immediately disconnected.</p>
<p><b>Cause:</b> Some SSL/TLS servers will disconnect if a
ClientHello message is received in a format they do not understand
or with a protocol version number that they do not support.</p>
<p><strong>Solution</strong>: Try adjusting the enabled protocols
on the client side. This involves modifying or invoking some of the
following system properties and methods:</p>
<ul>
<li>System property <a href=
"#https_porocols"><code>https.protocols</code></a> for the
<code><a href=
"../../../../api/javax/net/ssl/HttpsURLConnection.html">HttpsURLConnection</a></code>
class</li>
<li>System property <a href=
"#jdk_tls_client_protocols"><code>jdk.tls.client.protocols</code></a></li>
<li><a href=
"../../../../api/javax/net/ssl/SSLContext.html#getInstance-java.lang.String-">
<code>SSLContext.getInstance</code></a> method</li>
<li><a href=
"../../../../api/javax/net/ssl/SSLEngine.html#setEnabledProtocols-java.lang.String:A-">
<code>SSLEngine.setEnabledProtocols</code></a> method</li>
<li><a href=
"../../../../api/javax/net/ssl/SSLSocket.html#setEnabledProtocols-java.lang.String:A-">
<code>SSLSocket.setEnabledProtocols</code></a> method</li>
<li><a href=
"../../../../api/javax/net/ssl/SSLParameters.html#setProtocols-java.lang.String:A-">
<code>SSLParameters.setProtocols</code></a> and <a href=
"../../../../api/javax/net/ssl/SSLEngine.html#setProtocols-java.lang.String:A-">
<code>SSLEngine.setSSLParameters</code></a> methods</li>
<li><a href=
"../../../../api/javax/net/ssl/SSLParameters.html#setProtocols-java.lang.String:A-">
<code>SSLParameters.setProtocols</code></a> and <a href=
"../../../../api/javax/net/ssl/SSLSocket.html#setProtocols-java.lang.String:A-">
<code>SSLSocket.setSSLParameters</code></a> methods</li>
</ul>
<!-- <p>Some older server implementations speak only SSLv3 and do not
understand TLS. Ideally, these implementations should negotiate
to SSLv3, but some simply hang up. For backwards compatibility,
some SSL/TLS implementations (such as <code>SunJSSE</code>) can send SSLv3/TLS
ClientHello messages encapsulated in an SSLv2 ClientHello packet.
The SunJSSE provider supports this feature. (See the section <a href="../SunProviders.html#SunJSSE_Protocols">Protocols</a>, which lists the protocols that are enabled by default for the <code>SunJSSE</code> provider.) If you want to use this feature, add the SSLv2Hello protocol to the enabled protocol list, if necessary.</p>
<p>Similarly, some other older server implementations can
speak to TLSv1 but do not understand TLSv1.1 or TLSv1.2. In this situation, consider using a SSL/TLS version fallback scheme:</p> -->
<p>For backwards compatibility, some SSL/TLS implementations (such
as SunJSSE) can send SSL/TLS ClientHello messages encapsulated in
the SSLv2 ClientHello format. The SunJSSE provider supports this
feature. If you want to use this feature, add the "SSLv2Hello"
protocol to the enabled protocol list, if necessary. (Also see the
<a href="../SunProviders.html#SunJSSE_Protocols">Protocols</a>
section, which lists the protocols that are enabled by default for
the SunJSSE provider.)</p>
<p>The SSL/TLS RFC standards require that implementations negotiate
to the latest version both sides speak, but some non-conforming
implementation simply hang up if presented with a version they
don't understand. For example, some older server implementations
that speak only SSLv3 will shutdown if TLSv1.2 is requested. In
this situation, consider using a SSL/TLS version fallback
scheme:</p>
<ol>
<li>Fall back from TLSv1.2 to TLSv1.1 if the server does not
understand TLSv1.2.</li>
<li>Fall back from TLSv1.1 to TLSv1.0 if the previous step does not
work.</li>
</ol>
<p>For example, if the enabled protocol list on the client is
TLSv1, TLSv1.1, and TLSv1.2, a typical SSL/TLS version fallback
scheme may look like:</p>
<ol>
<li>Try to connect to server. If server rejects the SSL/TLS
connection request immediately, go to step 2.</li>
<li>Try the version fallback scheme by removing the highest
protocol version (for example, TLSv1.2 for the first failure) in
the enabled protocol list.</li>
<li>Try to connect to the server again. If server rejects the
connection, go to step 2 unless there is no version to which the
server can fall back.</li>
<li>If the connection fails and SSLv2Hello is not on the enabled
protocol list, restore the enable protocol list and enable
SSLv2Hello. (For example, the enable protocol list should be
SSLv2Hello, SSLv3, TLSv1, TLSv1.1, and TLSv1.2.) Start again from
step 1.</li>
</ol>
<p><strong>Note</strong>: A fallback to a previous version normally
means security strength downgrading to a weaker protocol. It is not
suggested to use a fallback scheme unless it is really necessary,
and you clearly know that the server does not support a higher
protocol version.</p>
<p><strong>Note</strong>: As part of disabling SSLv3, some servers
have also disabled SSLv2Hello, which means communications with
SSLv2Hello-active clients (e.g. JDK 1.5/6) will fail. Starting with
JDK 7, SSLv2Hello default to disabled on clients, enabled on
servers.</p>
<!-- ********************************** -->
<h3>SunJSSE Cannot Find a JCA Provider That Supports a Required
Algorithm and Causes a NoSuchAlgorithmException</h3>
<p><b>Problem:</b> A handshake is attempted and fails when it
cannot find a required algorithm. Examples might include:</p>
<pre class="codeblock">
Exception in thread ...deleted...
    ...deleted...
    Caused by java.security.NoSuchAlgorithmException: Cannot find any
        provider supporting RSA/ECB/PKCS1Padding
</pre>
or
<pre class="codeblock">
Caused by java.security.NoSuchAlgorithmException: Cannot find any
    provider supporting AES/CBC/NoPadding
</pre>
<p><b>Cause:</b> SunJSSE uses JCE for all its cryptographic
algorithms. By default, the Oracle JDK will use the Standard
Extension ClassLoader to load the SunJCE provider located in
<var>java-home</var>/lib/ext/sunjce_provider.jar. If the file
cannot be found or loaded, or if the SunJCE provider has been
deregistered from the <code>Provider</code> mechanism and an
alternative implementation from JCE is not available, then this
exception will be thrown.</p>
<p><b>Solution:</b> Ensure that the SunJCE is available by checking
that the file is loadable and that the provider is registered with
the <code>Provider</code> interface. Try to run the following code
in the context of your SSL connection:</p>
<pre class="codeblock">
import javax.crypto.*;

System.out.println("=====Where did you get AES=====");
Cipher c = Cipher.getInstance("AES/CBC/NoPadding");
System.out.println(c.getProvider());
</pre>
<!-- ********************************** -->
<h3>FailedDownloadException Thrown When Trying to Obtain
Application Resources from Web Server over SSL</h3>
<p><b>Problem:</b> If you receive a
<code>com.sun.deploy.net.FailedDownloadException</code> when trying
to obtain application resources from your web server over SSL, and
your web server uses the virtual host with Server Name Indication
(SNI) extension (such as Apache HTTP Server), then you may have not
configured your web server correctly.</p>
<p><b>Cause:</b> Because Java SE 7 supports the SNI extension in
the JSSE client, the requested host name of the virtual server is
included in the first message sent from the client to the server
during the SSL handshake. The server may deny the client's request
for a connection if the requested host name (the server name
indication) does not match the expected server name, which should
be specified in the virtual host's configuration. This triggers an
SSL handshake unrecognized name alert, which results in a
<code>FailedDownloadException</code> being thrown.</p>
<p><b>Solution:</b> To better diagnose the problem, enable tracing
through the Java Console. See <a href=
"../../deploy/console_trace_log.html">Java Console, Tracing, and
Logging</a> for more information. If the cause of the problem is
<code>javax.net.ssl.SSLProtocolException: handshake alert:
unrecognized_name</code>, it is likely that the virtual host
configuration for SNI is incorrect. If you are using Apache HTTP
Server, see <a href=
"https://httpd.apache.org/docs/trunk/vhosts/name-based.html">Name-based
Virtual Host Support</a> for information about configuring virtual
hosts. In particular, ensure that the <code>ServerName</code>
directive is configured properly in a
<code>&lt;VirtualHost&gt;</code> block.</p>
<p>For more information, see the following:</p>
<ul>
<li><a href=
"https://wiki.apache.org/httpd/NameBasedSSLVHostsWithSNI">SSL with
Virtual Hosts Using SNI</a> from <a href=
"https://wiki.apache.org/httpd/FrontPage">Apache HTTP Server
Wiki</a></li>
<li><a href=
"https://httpd.apache.org/docs/trunk/ssl/ssl_faq.html">SSL/TLS
Strong Encryption: FAQ</a> from <a href=
"https://httpd.apache.org/docs/">Apache HTTP Server
Documentation</a></li>
<li><a href="https://www.ietf.org/rfc/rfc3546.txt">RFC 3546,
Transport Layer Security (TLS) Extensions</a></li>
<li><a href=
"http://bugs.java.com/bugdatabase/view_bug.do?bug_id=7194590">Bug
7194590: SSL handshaking error caused by virtual server
misconfiguration</a></li>
</ul>
<!-- ********************************** -->
<h3><a name="Debug" id="Debug">Debugging Utilities</a></h3>
<p>JSSE provides dynamic debug tracing support. This is similar to
the support used for debugging access control failures in the Java
SE platform. The generic Java dynamic debug tracing support is
accessed with the <code>java.security.debug</code> system property,
whereas the JSSE-specific dynamic debug tracing support is accessed
with the <code>javax.net.debug</code> system property.</p>
<hr />
<p><strong>Note:</strong> The <code>debug</code> utility is not an
officially supported feature of JSSE.</p>
<hr />
<p>To view the options of the JSSE dynamic debug utility, use the
following command-line option on the <code>java</code> command:</p>
<pre class="codeblock">
-Djavax.net.debug=help
</pre>
<hr />
<p><strong>Note:</strong> If you specify the value
<code>help</code> with either dynamic debug utility when running a
program that does not use any classes that the utility was designed
to debug, you will not get the debugging options.</p>
<hr />
<p>The following complete example shows how to get a list of the
debug options for an application named <code>MyApp</code> that uses
some of the JSSE classes:</p>
<pre class="codeblock">
java -Djavax.net.debug=help MyApp
</pre>
<p>The <code>MyApp</code> application will not run after the debug
help information is printed, as the help code causes the
application to exit.</p>
<p>Current options are:</p>
<ul>
<li><code>all</code>: Turn on all debugging</li>
<li><code>ssl</code>: Turn on SSL debugging</li>
</ul>
<p>The following can be used with the <code>ssl</code> option:</p>
<ul>
<li><code>record</code>: Enable per-record tracing</li>
<li><code>handshake</code>: Print each handshake message</li>
<li><code>keygen</code>: Print key generation data</li>
<li><code>session</code>: Print session activity</li>
<li><code>defaultctx</code>: Print default SSL initialization</li>
<li><code>sslctx</code>: Print <code>SSLContext</code> tracing</li>
<li><code>sessioncache</code>: Print session cache tracing</li>
<li><code>keymanager</code>: Print key manager tracing</li>
<li><code>trustmanager</code>: Print trust manager tracing</li>
</ul>
<p>Messages generated from the <code>handshake</code> option can be
widened with these options:</p>
<ul>
<li><code>data</code>: Hex dump of each handshake message</li>
<li><code>verbose</code>: Verbose handshake message printing</li>
</ul>
<p>Messages generated from the <code>record</code> option can be
widened with these options:</p>
<ul>
<li><code>plaintext</code>: Hex dump of record plaintext</li>
<li><code>packet</code>: Print raw SSL/TLS packets</li>
</ul>
<p>The <code>javax.net.debug</code> property value must be either
<code>all</code> or <code>ssl</code>, optionally followed by debug
specifiers. You can use one or more options. You do <i>not</i> have
to have a separator between options, although a separator such as a
colon (:) or a comma (,) helps readability. It does not matter what
separators you use, and the ordering of the option keywords is also
not important.</p>
<p>For an introduction to reading this debug information, see the
guide, <a href="ReadDebug.html">Debugging SSL/TLS
Connections</a>.</p>
<p>The following are examples of using the
<code>javax.net.debug</code> property:</p>
<ul>
<li>
<p>To view all debugging messages:</p>
<pre class="codeblock">
    java -Djavax.net.debug=all MyApp
        
</pre></li>
<li>
<p>To view the hexadecimal dumps of each handshake message, enter
the following (the colons are optional):</p>
<pre class="codeblock">
    java -Djavax.net.debug=ssl:handshake:data MyApp
        
</pre></li>
<li>
<p>To view the hexadecimal dumps of each handshake message, and to
print trust manager tracing, enter the following (the commas are
optional):</p>
<pre class="codeblock">
    java -Djavax.net.debug=SSL,handshake,data,trustmanager MyApp
        
</pre></li>
</ul>
<!-- ********************************** -->
<h2><a name="CodeExamples" id="CodeExamples">Code Examples</a></h2>
<p>The following code examples are included in this section:</p>
<ul>
<li><a href="#UnsecureSecure">Converting an Unsecure Socket to a
Secure Socket</a>
<ul>
<li><a href="#NoSSLSocket">Socket Example Without SSL</a></li>
<li><a href="#WithSSLSocket">Socket Example With SSL</a></li>
</ul>
</li>
<li><a href="#SampleCode">Running the JSSE Sample Code</a>
<ul>
<li><a href="#SecureConnSample">Sample Code Illustrating a Secure
Socket Connection Between a Client and a Server</a>
<ul>
<li><a href="#SampleConfig">Configuration Requirements</a></li>
<li><a href="#SSC">Running SSLSocketClient</a></li>
<li><a href="#SSCWT">Running SSLSocketClientWithTunneling</a></li>
<li><a href="#SSCWCA">Running
SSLSocketClientWithClientAuth</a></li>
<li><a href="#RunningCFS">Running ClassFileServer</a></li>
<li><a href="#SSCWCAnCFS">Running SSLSocketClientWithClientAuth
with ClassFileServer</a></li>
</ul>
</li>
<li><a href="#HTTPSSample">Sample Code Illustrating HTTPS
Connections</a>
<ul>
<li><a href="#URLReader">Running URLReader</a></li>
<li><a href="#URLReaderWO">Running URLReaderWithOptions</a></li>
</ul>
</li>
<li><a href="#RMISample">Sample Code Illustrating a Secure RMI
Connection</a></li>
<li><a href="#SSLEngineSample">Sample Code Illustrating the Use of
an SSLEngine</a>
<ul>
<li><a href="#RunningSSLEngineSimpleDemo">Running
SSLEngineSimpleDemo</a></li>
<li><a href="#RunningNioServer">Running the NIO-based
Server</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#CreateKeystore">Creating a Keystore to Use with
JSSE</a></li>
<li><a href="#SNIExamples">Using the Server Name Indication (SNI)
Extension</a>
<ul>
<li><a href="#ClientSNIExamples">Typical Client-Side Usage
Examples</a></li>
<li><a href="#ServerSNIExamples">Typical Server-Side Usage
Examples</a></li>
<li><a href="#VirtualSNIExamples">Working with Virtual
Infrastructures</a>
<ul>
<li><a href="#ClientHelloParser">Preparing the ClientHello
Parser</a></li>
<li><a href="#VirtualServerDispSocket">Virtual Server Dispatcher
Based on SSLSocket</a></li>
<li><a href="#VirtualServerDispEngine">Virtual Server Dispatcher
Based on SSLEngine</a></li>
<li><a href="#NoSNI">No SNI Extension Available</a></li>
<li><a href="#FailoverContext">Failover SSLContext</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<!-- ********************************** -->
<h3><a name="UnsecureSecure" id="UnsecureSecure">Converting an
Unsecure Socket to a Secure Socket</a></h3>
<p>This section provides examples of source code that illustrate
how to use JSSE to convert an unsecure socket connection to a
secure socket connection. The code in this section is excerpted
from the book <cite>Java SE 6 Network Security</cite> by Marco
Pistoia, et. al.</p>
<p>First, "Socket Example Without SSL" shows sample code that can
be used to set up communication between a client and a server using
unsecure sockets. This code is then modified in "Socket Example
with SSL" to use JSSE to set up secure socket communication.</p>
<!-- ********************************** -->
<h3><a name="NoSSLSocket" id="NoSSLSocket"></a>Socket Example
Without SSL</h3>
<p>The following examples demonstrates server-side and client-side
code for setting up an unsecure socket connection.</p>
<p>In a Java program that acts as a server and communicates with a
client using sockets, the socket communication is set up with code
similar to the following:</p>
<pre class="codeblock">
    import java.io.*;
    import java.net.*;
    
    . . .
    
    int port = availablePortNumber;
    
    ServerSocket s;
    
    try {
        s = new ServerSocket(port);
        Socket c = s.accept();
    
        OutputStream out = c.getOutputStream();
        InputStream in = c.getInputStream();
    
        // Send messages to the client through
        // the OutputStream
        // Receive messages from the client
        // through the InputStream
    } catch (IOException e) { }
</pre>
<p>The client code to set up communication with a server using
sockets is similar to the following:</p>
<pre class="codeblock">
    import java.io.*;
    import java.net.*;
    
    . . .
    
    int port = availablePortNumber;
    String host = "hostname";
    
    try {
        s = new Socket(host, port);
    
        OutputStream out = s.getOutputStream();
        InputStream in = s.getInputStream();
    
        // Send messages to the server through
        // the OutputStream
        // Receive messages from the server
        // through the InputStream
    } catch (IOException e) { }
</pre>
<!-- ********************************** -->
<h3><a name="WithSSLSocket" id="WithSSLSocket">Socket Example with
SSL</a></h3>
<p>The following examples demonstrate server-side and client-side
code for setting up a secure socket connection.</p>
<p>In a Java program that acts as a server and communicates with a
client using secure sockets, the socket communication is set up
with code similar to the following. Differences between this
program and the one for communication using unsecure sockets are
highlighted in bold.</p>
<pre class="codeblock">
    import java.io.*;
    import <b>javax.net.ssl.*</b>;
    
    . . .
    
    int port = availablePortNumber;
    
    <b>SSLServerSocket</b> s;
    
    try {
        <b>SSLServerSocketFactory sslSrvFact =
            (SSLServerSocketFactory)SSLServerSocketFactory.getDefault();
        s = (SSLServerSocket)sslSrvFact.createServerSocket(port);</b>
    
        <b>SSLSocket</b> c = <b>(SSLSocket)</b>s.accept();
    
        OutputStream out = c.getOutputStream();
        InputStream in = c.getInputStream();
    
        // Send messages to the client through
        // the OutputStream
        // Receive messages from the client
        // through the InputStream
    }
    
    catch (IOException e) {
    }
</pre>
<p>The client code to set up communication with a server using
secure sockets is similar to the following, where differences with
the unsecure version are highlighted in bold:</p>
<pre class="codeblock">
    import java.io.*;
    import <b>javax.net.ssl.*</b>;
    
    . . .
    
    int port = availablePortNumber;
    String host = "hostname";
    
    try {
        <b>SSLSocketFactory sslFact =
            (SSLSocketFactory)SSLSocketFactory.getDefault();
        SSLSocket s = (SSLSocket)sslFact.createSocket(host, port);</b>
    
        OutputStream out = s.getOutputStream();
        InputStream in = s.getInputStream();
    
        // Send messages to the server through
        // the OutputStream
        // Receive messages from the server
        // through the InputStream
    }
    
    catch (IOException e) {
    }
</pre>
<!-- ********************************** -->
<h3><a name="SampleCode" id="SampleCode">Running the JSSE Sample
Code</a></h3>
<p>The JSSE sample programs illustrate how to use JSSE to:</p>
<ul>
<li><a href="#SecureConnSample">Create a secure socket connection
between a client and a server</a></li>
<li><a href="#HTTPSSample">Create a secure connection to an HTTPS
website</a></li>
<li><a href="#RMISample">Use secure communications with
RMI</a></li>
<li><a href="#SSLEngineSample">Illustrate SSLEngine usage</a></li>
</ul>
<p>When you use the sample code, be aware that the sample programs
are designed to illustrate how to use JSSE. They are not designed
to be robust applications.</p>
<hr />
<p><strong>Note:</strong> Setting up secure communications involves
complex algorithms. The sample programs provide no feedback during
the setup process. When you run the programs, be patient: you may
not see any output for a while. If you run the programs with the
<code>javax.net.debug</code> system property set to
<code>all</code>, you will see more feedback. For an introduction
to reading this debug information, see the guide, <a href=
"ReadDebug.html">Debugging SSL/TLS Connections</a>.</p>
<hr />
<!-- ********************************** -->
<h3><a name="SamplesLoc" id="SamplesLoc">Where to Find the Sample
Code</a></h3>
<p>Most of the sample code is located in the <a href=
"samples/index.html">samples subdirectory</a> of the same directory
as that containing the document you are reading. Follow that link
to see a listing of all the sample code files and text files. That
page also provides a link to a ZIP file that you can download to
obtain all the sample code files, which is helpful if you are
viewing this documentation from the web.</p>
<p>The following sections describe the samples. For more
information, see <a href="samples/README.txt">README.txt</a>.</p>
<!-- ********************************** -->
<h3><a name="SecureConnSample" id="SecureConnSample">Sample Code
Illustrating a Secure Socket Connection Between a Client and a
Server</a></h3>
<p>The sample programs in the <code>samples/sockets</code>
directory illustrate how to set up a secure socket connection
between a client and a server.</p>
<p>When running the sample client programs, you can communicate
with an existing server, such as a commercial web server, or you
can communicate with the sample server program,
<code>ClassFileServer</code>. You can run the sample client and the
sample server programs on different machines connected to the same
network, or you can run them both on one machine but from different
terminal windows.</p>
<p>All the sample <code>SSLSocketClient*</code> programs in the
samples/sockets/client directory (and <code>URLReader*</code>
programs described in <a href="#HTTPSSample">Sample Code
Illustrating HTTPS Connections</a>) can be run with the
<code>ClassFileServer</code> sample server program. An example of
how to do this is shown in <a href="#SSCWCAnCFS">Running
SSLSocketClientWithClientAuth with ClassFileServer</a>. You can
make similar changes to run <code>URLReader</code>,
<code>SSLSocketClient</code>, or
<code>SSLSocketClientWithTunneling</code> with
<code>ClassFileServer</code>.</p>
<p>If an authentication error occurs during communication between
the client and the server (whether using a web server or
<code>ClassFileServer</code>), it is most likely because the
necessary keys are not in the <a href="#Stores">truststore</a>
(trust key database). For example, the <code>ClassFileServer</code>
uses a keystore called <code>testkeys</code> containing the private
key for <code>localhost</code> as needed during the SSL handshake.
The <code>testkeys</code> keystore is included in the same
samples/sockets/server directory as the
<code>ClassFileServer</code> source. If the client cannot find a
certificate for the corresponding public key of
<code>localhost</code> in the truststore it consults, then an
authentication error will occur. Be sure to use the
<code>samplecacerts</code> truststore (which contains the public
key and certificate of the <code>localhost</code>), as described in
the next section. <!-- ********************************** --></p>
<h3><a name="SampleConfig" id="SampleConfig">Configuration
Requirements</a></h3>
<p>When running the sample programs that create a secure socket
connection between a client and a server, you will need to make the
appropriate certificates file (truststore) available. For both the
client and the server programs, you should use the certificates
file <code>samplecacerts</code> from the <code>samples</code>
directory. Using this certificates file will allow the client to
authenticate the server. The file contains all the common
Certificate Authority (CA) certificates shipped with the JDK (in
the cacerts file), plus a certificate for <code>localhost</code>
needed by the client to authenticate <code>localhost</code> when
communicating with the sample server <code>ClassFileServer</code>.
The <code>ClassFileServer</code> uses a keystore containing the
private key for <code>localhost</code> that corresponds to the
public key in <code>samplecacerts</code>.</p>
<p>To make the <code>samplecacerts</code> file available to both
the client and the server, you can either copy it to the file
<var>java-home</var>/lib/security/jssecacerts, rename it to
cacerts, and use it to replace the
<var>java-home</var>/lib/security/cacerts file, or add the
following option to the command line when running the
<code>java</code> command for both the client and the server:</p>
<pre class="codeblock">
-Djavax.net.ssl.trustStore=<i>path_to_samplecacerts_file</i>
</pre>
<p>For more information about <var>java-home</var>, see <a href=
"#javaHome">The JRE Installation Directory</a>.</p>
<p>The password for the <code>samplecacerts</code> truststore is
<code>changeit</code>. You can substitute your own certificates in
the samples by using the <code>keytool</code> utility.</p>
<p>If you use a browser, such as Netscape Navigator or Microsoft's
Internet Explorer, to access the sample SSL server provided in the
<code>ClassFileServer</code> example, then a dialog box may pop up
with the message that it does not recognize the certificate. This
is normal because the certificate used with the sample programs is
self-signed and is for testing only. You can accept the certificate
for the current session. After testing the SSL server, you should
exit the browser, which deletes the test certificate from the
browser's namespace.</p>
<p>For client authentication, a separate <code>duke</code>
certificate is available in the appropriate directories. The public
key and certificate is also stored in the
<code>samplecacerts</code> file.</p>
<!-- ********************************** -->
<h3><a name="SSC" id="SSC">Running SSLSocketClient</a></h3>
<p>The <a href=
"samples/sockets/client/SSLSocketClient.java">SSLSocketClient.java</a>
program demonstrates how to create a client that uses an
<code>SSLSocket</code> to send an HTTP request and to get a
response from an HTTPS server. The output of this program is the
HTML source for
<code>https://www.verisign.com/index.html</code>.</p>
<p>You must not be behind a firewall to run this program as
provided. If you run it from behind a firewall, you will get an
<code>UnknownHostException</code> because JSSE cannot find a path
through your firewall to <code>www.verisign.com</code>. To create
an equivalent client that can run from behind a firewall, set up
proxy tunneling as illustrated in the sample program
<code>SSLSocketClientWithTunneling</code>.</p>
<!-- ********************************** -->
<h3><a name="SSCWT" id="SSCWT">Running
SSLSocketClientWithTunneling</a></h3>
<p>The <a href=
"samples/sockets/client/SSLSocketClientWithTunneling.java">SSLSocketClientWithTunneling.java</a>
program illustrates how to do proxy tunneling to access a secure
web server from behind a firewall. To run this program, you must
set the following Java system properties to the appropriate
values:</p>
<pre class="codeblock">
java -Dhttps.proxyHost=<i>webproxy</i>
-Dhttps.proxyPort=<i>ProxyPortNumber</i>
SSLSocketClientWithTunneling
</pre>
<hr />
<p><strong>Note:</strong> Proxy specifications with the
<code>-D</code> options are optional. Replace <i>webproxy</i> with
the name of your proxy host and <i>ProxyPortNumber</i> with the
appropriate port number.</p>
<p>The program will return the HTML source file from
<code>https://www.verisign.com/index.html</code>.</p>
<a name="SSCWCA" id="SSCWCA"></a> 
<!-- ********************************** -->
<h3>Running SSLSocketClientWithClientAuth</h3>
<p>The <a href=
"samples/sockets/client/SSLSocketClientWithClientAuth.java">SSLSocketClientWithClientAuth.java</a>
program shows how to set up a key manager to do client
authentication if required by a server. This program also assumes
that the client is not outside a firewall. You can modify the
program to connect from inside a firewall by following the example
in <code>SSLSocketClientWithTunneling</code>.</p>
<p>To run this program, you must specify three parameters: host,
port, and requested file path. To mirror the previous examples, you
can run this program without client authentication by setting the
host to <code>www.verisign.com</code>, the port to
<code>443</code>, and the requested file path to
<code>https://www.verisign.com/</code>. The output when using these
parameters is the HTML for the website
<code>https://www.verisign.com/</code>.</p>
<p>To run <code>SSLSocketClientWithClientAuth</code> to do client
authentication, you must access a server that requests client
authentication. You can use the sample program
<code>ClassFileServer</code> as this server. This is described in
the following sections.</p>
<!-- ********************************** -->
<h3><a name="RunningCFS" id="RunningCFS">Running
ClassFileServer</a></h3>
<p>The program referred to herein as <code>ClassFileServer</code>
is made up of two files: <a href=
"samples/sockets/server/ClassFileServer.java">ClassFileServer.java</a>
and <a href=
"samples/sockets/server/ClassServer.java">ClassServer.java</a>.</p>
<p>To execute them, run <code>ClassFileServer.class</code>, which
requires the following parameters:</p>
<ul>
<li><code>port</code> can be any available unused port number, for
example, you can use the number <code>2001</code>.</li>
<li><code>docroot</code> indicates the directory on the server that
contains the file you want to retrieve. For example, on Solaris,
you can use /home/<i>userid</i>/ (where <i>userid</i> refers to
your particular UID), whereas on Microsoft Windows systems, you can
use c:\.</li>
<li><code>TLS</code> is an optional parameter that indicates that
the server is to use SSL or TLS.</li>
<li><code>true</code> is an optional parameter that indicates that
client authentication is required. This parameter is only consulted
if the TLS parameter is set.</li>
</ul>
<hr />
<p><strong>Note:</strong> The <code>TLS</code> and
<code>true</code> parameters are optional. If you omit them,
indicating that an ordinary (not TLS) file server should be used,
without authentication, then nothing happens. This is because one
side (the client) is trying to negotiate with TLS, while the other
(the server) is not, so they cannot communicate.</p>
<hr />
<p><strong>Note:</strong> The server expects GET requests in the
form <code>GET /<i>path_to_file</i></code>.</p>
<hr />
<!-- ********************************** -->
<h3><a name="SSCWCAnCFS" id="SSCWCAnCFS">Running
SSLSocketClientWithClientAuth with ClassFileServer</a></h3>
<p>You can use the sample programs <a href=
"samples/sockets/client/SSLSocketClientWithClientAuth.java">SSLSocketClientWithClientAuth</a>
and <code>ClassFileServer</code> to set up authenticated
communication, where the client and server are authenticated to
each other. You can run both sample programs on different machines
connected to the same network, or you can run them both on one
machine but from different terminal windows or command prompt
windows. To set up both the client and the server, do the
following:</p>
<ol>
<li>Run the program <code>ClassFileServer</code> from one machine
or terminal window, as described in <a href="#RunningCFS">Running
ClassFileServer</a>.</li>
<li>Run the program <code>SSLSocketClientWithClientAuth</code> on
another machine or terminal window.
<code>SSLSocketClientWithClientAuth</code> requires the following
parameters:
<ul>
<li><code>host</code> is the host name of the machine that you are
using to run <code>ClassFileServer</code>.</li>
<li><code>port</code> is the same port that you specified for
<code>ClassFileServer</code>.</li>
<li>
<p><code>requestedfilepath</code> indicates the path to the file
that you want to retrieve from the server. You must give this
parameter as <code>/filepath</code>. Forward slashes are required
in the file path because it is used as part of a GET statement,
which requires forward slashes regardless of what type of operating
system you are running. The statement is formed as follows:</p>
<pre class="codeblock">
"GET " + requestedfilepath + " HTTP/1.0"
</pre></li>
</ul>
</li>
</ol>
<hr />
<p><strong>Note:</strong> You can modify the other
<code>SSLClient*</code> applications' <code>GET</code> commands to
connect to a local machine running
<code>ClassFileServer</code>.</p>
<!-- ********************************** -->
<h3><a name="HTTPSSample" id="HTTPSSample">Sample Code Illustrating
HTTPS Connections</a></h3>
<p>There are two primary APIs for accessing secure communications
through JSSE. One way is through a socket-level API that can be
used for arbitrary secure communications, as illustrated by the
<code>SSLSocketClient</code>,
<code>SSLSocketClientWithTunneling</code>, and
<code>SSLSocketClientWithClientAuth</code> (with and without
<code>ClassFileServer</code>) sample programs.</p>
<p>A second, and often simpler, way is through the standard Java
URL API. You can communicate securely with an SSL-enabled web
server by using the HTTPS URL protocol or scheme using the
<code>java.net.URL</code> class.</p>
<p>Support for HTTPS URL schemes is implemented in many of the
common browsers, which allows access to secured communications
without requiring the socket-level API provided with JSSE.</p>
<p>An example URL is <code>https://www.verisign.com</code>.</p>
<p>The trust and key management for the HTTPS URL implementation is
environment-specific. The JSSE implementation provides an HTTPS URL
implementation. To use a different HTTPS protocol implementation,
set the <code>java.protocol.handler.pkgs</code> <a href=
"#SystemProps">system property</a> to the package name. See the
<code>java.net.URL</code> class documentation for details.</p>
<p>The samples that you can download with JSSE include two sample
programs that illustrate how to create an HTTPS connection. Both of
these sample programs (<a href=
"samples/urls/URLReader.java"><code>URLReader.java</code></a> and
<a href=
"samples/urls/URLReaderWithOptions.java"><code>URLReaderWithOptions.java</code></a>)
are in the samples/urls directory.</p>
<!-- ********************************** -->
<h3><a name="URLReader" id="URLReader">Running URLReader</a></h3>
<p>The <a href="samples/urls/URLReader.java">URLReader.java</a>
program illustrates using the URL class to access a secure site.
The output of this program is the HTML source for
<code>https://www.verisign.com/</code>. By default, the HTTPS
protocol implementation included with JSSE is used. To use a
different implementation, set the system property
<code>java.protocol.handler.pkgs</code> value to be the name of the
package containing the implementation.</p>
<p>If you are running the sample code behind a firewall, then you
must set the <code>https.proxyHost</code> and
<code>https.proxyPort</code> system properties. For example, to use
the proxy host "webproxy" on port 8080, you can use the following
options for the <code>java</code> command:</p>
<pre class="codeblock">
-Dhttps.proxyHost=webproxy
-Dhttps.proxyPort=8080
</pre>
<p>Alternatively, you can set the system properties within the
source code with the <code>java.lang.System</code> method
<code>setProperty()</code>. For example, instead of using the
command-line options, you can include the following lines in your
program:</p>
<pre class="codeblock">
System.setProperty("java.protocol.handler.pkgs", "com.ABC.myhttpsprotocol");

System.setProperty("https.proxyHost", "webproxy");

System.setProperty("https.proxyPort", "8080");
</pre>
<!--
<hr />
<p><strong>Note:</strong> When running on Windows 95 or Windows 98, the maximum
number of characters allowed in an MS-DOS prompt may not be enough
to include all the command-line options. If you encounter this
problem, either create a BAT file with the entire command or add
the system properties to the source code and recompile the source
code.</p>
<hr />
-->
<!-- ********************************** -->
<h3><a name="URLReaderWO" id="URLReaderWO">Running
URLReaderWithOptions</a></h3>
<p>The <a href=
"samples/urls/URLReaderWithOptions.java">URLReaderWithOptions.java</a>
program is essentially the same as the URLReader.java program,
except that it allows you to optionally input any or all of the
following system properties as arguments to the program when you
run it:</p>
<ul>
<li><code>java.protocol.handler.pkgs</code></li>
<li><code>https.proxyHost</code></li>
<li><code>https.proxyPort</code></li>
<li><code>https.cipherSuites</code></li>
</ul>
<p>To run <code>URLReaderWithOptions</code>, enter the following
command:</p>
<pre class="codeblock">
java URLReaderWithOptions [-h <var>proxyhost</var> -p <var>proxyport</var>] [-k <var>protocolhandlerpkgs</var>] [-c <var>ciphersarray</var>]
</pre>
<hr />
<p><strong>Note:</strong> Multiple protocol handlers can be
included in the <code>protocolhandlerpkgs</code> argument as a list
with items separated by vertical bars. Multiple SSL cipher suite
names can be included in the <code>ciphersarray</code> argument as
a list with items separated by commas. The possible cipher suite
names are the same as those returned by the
<code>SSLSocket.getSupportedCipherSuites()</code> method. The suite
names are taken from the SSL and TLS protocol specifications.</p>
<p>You need a <code>protocolhandlerpkgs</code> argument only if you
want to use an HTTPS protocol handler implementation other than the
default one provided by Oracle.</p>
<p>If you are running the sample code behind a firewall, then you
must include arguments for the proxy host and the proxy port.
Additionally, you can include a list of cipher suites to
enable.</p>
<p>Here is an example of running <code>URLReaderWithOptions</code>
and specifying the proxy host "webproxy" on port 8080:</p>
<pre class="codeblock">
java URLReaderWithOptions -h webproxy -p 8080
</pre>
<!-- ********************************** -->
<h3><a name="RMISample" id="RMISample">Sample Code Illustrating a
Secure RMI Connection</a></h3>
<p>The sample code in the samples/rmi directory illustrates how to
create a secure Java Remote Method Invocation (RMI) connection. The
sample code is based on an <a href=
"../../rmi/socketfactory/index.html">RMI example</a> that is
basically a "Hello World" example modified to install and use a
custom RMI socket factory.</p>
<p>For more information about Java RMI, see the <a href=
"../../rmi/index.html">Java RMI documentation</a>. This web page
points to Java RMI tutorials and other information about Java
RMI.</p>
<!-- ********************************** -->
<h3><a name="SSLEngineSample" id="SSLEngineSample">Sample Code
Illustrating the Use of an SSLEngine</a></h3>
<p><code>SSLEngine</code> gives application developers flexibility
when choosing I/O and compute strategies. Rather than tie the
SSL/TLS implementation to a specific I/O abstraction (such as
single-threaded <code>SSLSockets</code>), <code>SSLEngine</code>
removes the I/O and compute constraints from the SSL/TLS
implementation.</p>
<p>As mentioned earlier, <code>SSLEngine</code> is an advanced API,
and is not appropriate for casual use. Some introductory sample
code is provided here that helps illustrate its use. The first demo
removes most of the I/O and threading issues, and focuses on many
of the SSLEngine methods. The second demo is a more realistic
example showing how <code>SSLEngine</code> might be combined with
Java NIO to create a rudimentary HTTP/HTTPS server.</p>
<!-- ********************************** -->
<h3><a name="RunningSSLEngineSimpleDemo" id=
"RunningSSLEngineSimpleDemo">Running SSLEngineSimpleDemo</a></h3>
<p>The <a href=
"samples/sslengine/SSLEngineSimpleDemo.java">SSLEngineSimpleDemo</a>
is a very simple application that focuses on the operation of the
<code>SSLEngine</code> while simplifying the I/O and threading
issues. This application creates two <code>SSLEngine</code> objects
that exchange SSL/TLS messages via common <code>ByteBuffer</code>
objects. A single loop serially performs all of the engine
operations and demonstrates how a secure connection is established
(handshaking), how application data is transferred, and how the
engine is closed.</p>
<p>The <code>SSLEngineResult</code> provides a great deal of
information about the current state of the <code>SSLEngine</code>.
This example does not examine all of the states. It simplifies the
I/O and threading issues to the point that this is not a good
example for a production environment; nonetheless, it is useful to
demonstrate the overall function of the <code>SSLEngine</code>.</p>
<!-- ********************************** -->
<h3><a name="RunningNioServer" id="RunningNioServer">Running the
NIO-Based Server</a></h3>
<p>To fully exploit the flexibility provided by
<code>SSLEngine</code>, you must first understand complementary
APIs, such as I/O and threading models.</p>
<p>An I/O model that large-scale application developers find of use
is the NIO <code>SocketChannel</code>. NIO was introduced in part
to solve some of the scaling problem inherent in the
<code>java.net.Socket</code> API. <code>SocketChannel</code> has
many different modes of operation including:</p>
<ul>
<li>Blocking</li>
<li>Nonblocking</li>
<li>Nonblocking with selectors</li>
</ul>
<p>Sample code for a basic HTTP server is provided that not only
demonstrates many of the new NIO APIs, but also shows how
<code>SSLEngine</code> can be employed to create a secure HTTPS
server. The server is not production quality, but does show many of
these new APIs in action.</p>
<p>Inside the samples directory is a README.txt file that
introduces the server, explains how to build and configure the
server, and provides a brief overview of the code layout. The files
of most interest for <code>SSLEngine</code> users are
<code>ChannelIO.java</code> and
<code>ChannelIOSecure.java</code>.</p>
<hr />
<p><strong>Note:</strong> The server example discussed in this
section is included in the JDK. You can find the code bundled in
the <var>jdk-home</var>/samples/nio/server directory.</p>
<hr />
<!-- ********************************** -->
<h3><a name="CreateKeystore" id="CreateKeystore">Creating a
Keystore to Use with JSSE</a></h3>

<p>This section demonstrates how you can use the
<code>keytool</code> utility to create a simple JKS keystore
suitable for use with JSSE. First you make a <code>keyEntry</code>
(with public and private keys) in the keystore, and then you make a
corresponding <code>trustedCertEntry</code> (public keys only) in a
truststore. For client authentication, you follow a similar process
for the client's certificates.</p>
<hr />
<p><strong>Note:</strong> Storing trust anchors and secret keys in
PKCS12 is supported since JDK 8.</p>
<hr />
<p><strong>Note:</strong> It is beyond the scope of this example to
explain each step in detail. For more information, see the
<code>keytool</code> documentation for <a href=
"../../../tools/unix/keytool.html">Solaris, Linux, or Mac OS X</a>
or <a href="../../../tools/windows/keytool.html">Microsoft
Windows</a>.</p>
<p>User input is shown in bold.</p>
<ol>
<li>
<p>Create a new keystore and self-signed certificate with
corresponding public and private keys.</p>
<pre class="codeblock">
    % <b>keytool -genkeypair -alias duke -keyalg RSA -validity 7 -keystore keystore </b>
    
    Enter keystore password:  <b>password</b>
    What is your first and last name?
    [Unknown]:  <b>Duke</b>
    What is the name of your organizational unit?
    [Unknown]:  <b>Java Software</b>
    What is the name of your organization?
    [Unknown]:  <b>Oracle, Inc.</b>
    What is the name of your City or Locality?
    [Unknown]:  <b>Palo Alto</b>
    What is the name of your State or Province?
    [Unknown]:  <b>CA</b>
    What is the two-letter country code for this unit?
    [Unknown]:  <b>US</b>
    Is CN=Duke, OU=Java Software, O="Oracle, Inc.",
    L=Palo Alto, ST=CA, C=US correct?
    [no]:  <b>yes</b>
    
    Enter key password for &lt;duke&gt;
    (RETURN if same as keystore password):  <b>&lt;CR&gt;</b>
    
</pre></li>
<li>
<p>Examine the keystore. Notice that the entry type is
<code>keyEntry</code>, which means that this entry has a private
key associated with it).</p>
<pre class="codeblock">
    % <b>keytool -list -v -keystore keystore</b>
    
    Enter keystore password:  <b>password</b>
    
    Keystore type: jks
    Keystore provider: SUN
    
    Your keystore contains 1 entry
    
    Alias name: duke
    Creation date: Dec 20, 2001
    Entry type: keyEntry
    Certificate chain length: 1
    Certificate[1]:
    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.",
    L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 3c22adc1
    Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
    Certificate fingerprints:
    MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
    SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74
    
</pre></li>
<li>
<p>Export and examine the self-signed certificate.</p>
<pre class="codeblock">
    % <b>keytool -export -alias duke -keystore keystore -rfc -file duke.cer</b>
    Enter keystore password:  <b>password</b>
    Certificate stored in file &lt;duke.cer&gt;
    % <b>cat duke.cer</b>
    -----BEGIN CERTIFICATE-----
    MIICXjCCAccCBDwircEwDQYJKoZIhvcNAQEEBQAwdjELMAkGA1UEBhMCVVMxCzAJBgNVBAgTAkNB
    MRIwEAYDVQQHEwlQYWxvIEFsdG8xHzAdBgNVBAoTFlN1biBNaWNyb3N5c3RlbXMsIEluYy4xFjAU
    BgNVBAsTDUphdmEgU29mdHdhcmUxDTALBgNVBAMTBER1a2UwHhcNMDExMjIxMDMzNDI1WhcNMDEx
    MjI4MDMzNDI1WjB2MQswCQYDVQQGEwJVUzELMAkGA1UECBMCQ0ExEjAQBgNVBAcTCVBhbG8gQWx0
    bzEfMB0GA1UEChMWU3VuIE1pY3Jvc3lzdGVtcywgSW5jLjEWMBQGA1UECxMNSmF2YSBTb2Z0d2Fy
    ZTENMAsGA1UEAxMERHVrZTCBnzANBgkqhkiG9w0BAQEFAAOBjQAwgYkCgYEA1loObJzNXsi5aSr8
    N4XzDksD6GjTHFeqG9DUFXKEOQetfYXvA8F9uWtz8WInrqskLTNzwXgmNeWkoM7mrPpK6Rf5M3G1
    NXtYzvxyi473Gh1h9k7tjJvqSVKO7E1oFkQYeUPYifxmjbSMVirWZgvo2UmA1c76oNK+NhoHJ4qj
    eCUCAwEAATANBgkqhkiG9w0BAQQFAAOBgQCRPoQYw9rWWvfLPQuPXowvFmuebsTc28qI7iFWm6BJ
    TT/qdmzti7B5MHOt9BeVEft3mMeBU0CS2guaBjDpGlf+zsK/UUi1w9C4mnwGDZzqY/NKKWtLxabZ
    5M+4MAKLZ92ePPKGpobM2CPLfM8ap4IgAzCbBKd8+CMp8yFmifze9Q==
    -----END CERTIFICATE-----
    
</pre>
<p>Alternatively, you could generate a Certificate Signing Request
(CSR) with <code>-certreq</code> and send that to a Certificate
Authority (CA) for signing, but that is beyond the scope of this
example.</p>
</li>
<li>
<p>Import the certificate into a new truststore.</p>
<pre class="codeblock">
    % <b>keytool -import -alias dukecert -file duke.cer -keystore truststore</b>
    Enter keystore password:  <b>trustword</b>
    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 3c22adc1
    Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
    Certificate fingerprints:
    MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
    SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74
    Trust this certificate? [no]:  <b>yes</b>
    Certificate was added to keystore
    
</pre></li>
<li>
<p>Examine the truststore. Note that the entry type is
<code>trustedCertEntry</code>, which means that a private key is
not available for this entry. It also means that this file is not
suitable as a keystore of the <code>KeyManager</code>.</p>
<pre class="codeblock">
    % <b>keytool -list -v -keystore truststore</b>
    Enter keystore password:  <b>trustword</b>
    
    Keystore type: jks
    Keystore provider: SUN
    
    Your keystore contains 1 entry
    
    Alias name: dukecert
    Creation date: Dec 20, 2001
    Entry type: trustedCertEntry
    
    Owner: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Issuer: CN=Duke, OU=Java Software, O="Oracle, Inc.", L=Palo Alto, ST=CA, C=US
    Serial number: 3c22adc1
    Valid from: Thu Dec 20 19:34:25 PST 2001 until: Thu Dec 27 19:34:25 PST 2001
    Certificate fingerprints:
    MD5: F1:5B:9B:A1:F7:16:CF:25:CF:F4:FF:35:3F:4C:9C:F0
    SHA1: B2:00:50:DD:B6:CC:35:66:21:45:0F:96:AA:AF:6A:3D:E4:03:7C:74
    
</pre></li>
<li>
<p>Now run your applications with the appropriate keystores.
Because this example assumes that the default
<code>X509KeyManager</code> and <code>X509TrustManager</code> are
used, you select the keystores using the system properties
described in <a href="#InstallationAndCustomization">Customizing
JSSE</a>.</p>
<pre class="codeblock">
    % java -Djavax.net.ssl.keyStore=keystore -Djavax.net.ssl.keyStorePassword=password Server
    
    % java -Djavax.net.ssl.trustStore=truststore -Djavax.net.ssl.trustStorePassword=trustword Client
    
</pre></li>
</ol>
<hr />
<p><strong>Note:</strong> This example authenticated the server
only. For client authentication, provide a similar keystore for the
client's keys and an appropriate truststore for the server.</p>
<hr />
<!-- ********************************** -->
<h3><a name="SNIExamples" id="SNIExamples">Using the Server Name
Indication (SNI) Extension</a></h3>
<p>This section provides code examples that illustrate how you can
use the <a href="#SNIExtension">Server Name Indication (SNI)</a>
extension for client-side and server-side applications, and how it
can be applied to a virtual infrastructure.</p>
<p>For all examples in this section, to apply the parameters after
you set them, call the <code>setSSLParameters(SSLParameters)</code>
method on the corresponding <code>SSLSocket</code>,
<code>SSLEngine</code>, or <code>SSLServerSocket</code> object.</p>
<!-- ********************************** -->
<h3><a name="ClientSNIExamples" id="ClientSNIExamples">Typical
Client-Side Usage Examples</a></h3>
<p>The following is a list of use cases that require understanding
of the SNI extension for developing a client application:</p>
<ul>
<li>
<p><b>Case 1. The client wants to access
<code>www.example.com</code>.</b></p>
<p>Set the host name explicitly:</p>
<pre class="codeblock">
    SNIHostName serverName = new SNIHostName("www.example.com");
    List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
    serverNames.add(serverName);
    sslParameters.setServerNames(serverNames);
        
</pre>
<p>The client should always specify the host name explicitly.</p>
</li>
<li>
<p><b>Case 2. The client does not want to use SNI because the
server does not support it.</b></p>
<p>Disable SNI with an empty server name list:</p>
<pre class="codeblock">
    List&lt;SNIServerName&gt; serverNames = new ArrayList&lt;&gt;(1);
    sslParameters.setServerNames(serverNames);
        
</pre></li>
<li>
<p><b>Case 3. The client wants to access URL
<code>https://www.example.com</code>.</b></p>
<p>Oracle providers will set the host name in the SNI extension by
default, but third-party providers may not support the default
server name indication. To keep your application
provider-independent, always set the host name explicitly.</p>
</li>
<li>
<p><b>Case 4. The client wants to switch a socket from server mode
to client mode.</b></p>
<p>First switch the mode with the following method:
<code>sslSocket.setUseClientMode(true)</code>. Then reset the
server name indication parameters on the socket.</p>
</li>
</ul>
<!-- ********************************** -->
<h3><a name="ServerSNIExamples" id="ServerSNIExamples">Typical
Server-Side Usage Examples</a></h3>
<p>The following is a list of use cases that require understanding
of the SNI extension for developing a server application:</p>
<ul>
<li>
<p><b>Case 1. The server wants to accept all server name indication
types.</b></p>
<p>If you do not have any code dealing with the SNI extension, then
the server ignores all server name indication types.</p>
</li>
<li>
<p><b>Case 2. The server wants to deny all server name indications
of type <code>host_name</code>.</b></p>
<p>Set an invalid server name pattern for
<code>host_name</code>:</p>
<pre class="codeblock">
    SNIMatcher matcher = SNIHostName.createSNIMatcher("");
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);
        
</pre>
<p>Another way is to create an <code>SNIMatcher</code> subclass
with a <code>matches()</code> method that always returns
<code>false</code>:</p>
<pre class="codeblock">
    class DenialSNIMatcher extends SNIMatcher {
        DenialSNIMatcher() {
            super(StandardConstants.SNI_HOST_NAME);
        }
    
        @Override
        public boolean matches(SNIServerName serverName) {
            return false;
        }
    }
    
    SNIMatcher matcher = new DenialSNIMatcher();
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);
        
</pre></li>
<li>
<p><b>Case 3. The server wants to accept connections to any host
names in the <code>example.com</code> domain.</b></p>
<p>Set the recognizable server name for <code>host_name</code> as a
pattern that includes all <code>*.example.com</code> addresses:</p>
<pre class="codeblock">
    SNIMatcher matcher = SNIHostName.createSNIMatcher("(.*\\.)*example\\.com");
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    sslParameters.setSNIMatchers(matchers);
        
</pre></li>
<li>
<p><b>Case 4. The server wants to switch a socket from client mode
to server mode.</b></p>
<p>First switch the mode with the following method:
<code>sslSocket.setUseClientMode(false)</code>. Then reset the
server name indication parameters on the socket.</p>
</li>
</ul>
<!-- ********************************** -->
<h3><a name="VirtualSNIExamples" id="VirtualSNIExamples">Working
with Virtual Infrastructures</a></h3>
<p>This section describes how to use the Server Name Indication
(SNI) extension from within a virtual infrastructure. It
illustrates how to create a parser for ClientHello messages from a
socket, provides examples of virtual server dispatchers using
<code>SSLSocket</code> and <code>SSLEngine</code>, describes what
happens when the SNI extension is not available, and demonstrates
how to create a failover <code>SSLContext</code>.</p>
<!-- ********************************** -->
<h4><a name="ClientHelloParser" id="ClientHelloParser">Preparing
the ClientHello Parser</a></h4>
<p>Applications must implement an API to parse the ClientHello
messages from a socket. The following examples illustrate the
<code>SSLCapabilities</code> and <code>SSLExplorer</code> classes
that can perform these functions.</p>
<p><a href=
"samples/sni/SSLCapabilities.java">SSLCapabilities.java</a>
encapsulates the SSL/TLS security capabilities during handshaking
(that is, the list of cipher suites to be accepted in an SSL/TLS
handshake, the record version, the hello version, and the server
name indication). It can be retrieved by exploring the network data
of an SSL/TLS connection via the <code>SSLExplorer.explore()</code>
method.</p>
<p><a href="samples/sni/SSLExplorer.java">SSLExplorer.java</a>
explores the initial ClientHello message from a TLS client, but it
does not initiate handshaking or consume network data. The
<code>SSLExplorer.explore()</code> method parses the ClientHello
message, and retrieves the security parameters into
<code>SSLCapabilities</code>. The method must be called before
handshaking occurs on any TLS connections.</p>
<!-- ********************************** -->
<h4><a name="VirtualServerDispSocket" id=
"VirtualServerDispSocket">Virtual Server Dispatcher Based on
SSLSocket</a></h4>
<p>This section describes the procedure for using a virtual server
dispatcher based on <code>SSLSocket</code>.</p>
<ol>
<li>
<p><b>Register the server name handler.</b></p>
<p>At this step, the application may create different
<code>SSLContext</code> objects for different server name
indications, or link a certain server name indication to a
specified virtual machine or distributed system.</p>
<p>For example, if the server name is <code>www.example.org</code>,
then the registered server name handler may be for a local virtual
hosting web service. The local virtual hosting web service will use
the specified <code>SSLContext</code>. If the server name is
<code>www.example.com</code>, then the registered server name
handler may be for a virtual machine hosting on
<code>10.0.0.36</code>. The handler may map this connection to the
virtual machine.</p>
</li>
<li>
<p><b>Create a <code>ServerSocket</code> and accept the new
connection.</b></p>
<pre class="codeblock">
    ServerSocket serverSocket = new ServerSocket(serverPort);
    Socket socket = serverSocket.accept();
        
</pre></li>
<li>
<p><b>Read and buffer bytes from the socket input stream, and then
explore the buffered bytes.</b></p>
<pre class="codeblock">
    InputStream ins = socket.getInputStream();
    
    byte[] buffer = new byte[0xFF];
    int position = 0;
    SSLCapabilities capabilities = null;
    
    // Read the header of TLS record
    while (position &lt; SSLExplorer.RECORD_HEADER_SIZE) {
        int count = SSLExplorer.RECORD_HEADER_SIZE - position;
        int n = ins.read(buffer, position, count);
        if (n &lt; 0) {
            throw new Exception("unexpected end of stream!");
        }
        position += n;
    }
    
    // Get the required size to explore the SSL capabilities
    int recordLength = SSLExplorer.getRequiredSize(buffer, 0, position);
    if (buffer.length &lt; recordLength) {
        buffer = Arrays.copyOf(buffer, recordLength);
    }
    
    while (position &lt; recordLength) {
        int count = recordLength - position;
        int n = ins.read(buffer, position, count);
        if (n &lt; 0) {
            throw new Exception("unexpected end of stream!");
        }
        position += n;
    }
    
    // Explore
    capabilities = SSLExplorer.explore(buffer, 0, recordLength);
    if (capabilities != null) {
        System.out.println("Record version: " + capabilities.getRecordVersion());
        System.out.println("Hello version: " + capabilities.getHelloVersion());
    }
        
</pre></li>
<li>
<p><b>Get the requested server name from the explored
capabilities.</b></p>
<pre class="codeblock">
    List&lt;SNIServerName&gt; serverNames = capabilities.getServerNames();
        
</pre></li>
<li>
<p><b>Look for the registered server name handler for this server
name indication.</b></p>
<p>If the service of the host name is resident in a virtual machine
or another distributed system, then the application must forward
the connection to the destination. The application will need to
read and write the raw internet data, rather then the SSL
application from the socket stream.</p>
<pre class="codeblock">
    Socket destinationSocket = new Socket(serverName, 443);
    
    // Forward buffered bytes and network data from the current socket to the <code>destinationSocket</code>.
        
</pre>
<p>If the service of the host name is resident in the same process,
and the host name service can use the <code>SSLSocket</code>
directly, then the application will need to set the
<code>SSLSocket</code> instance to the server:</p>
<pre class="codeblock">
    // Get service context from registered handler
    // or create the context
    SSLContext serviceContext = ...
    
    SSLSocketFactory serviceSocketFac = serviceContext.getSSLSocketFactory();
    
    // wrap the buffered bytes
    ByteArrayInputStream bais = new ByteArrayInputStream(buffer, 0, position);
    SSLSocket serviceSocket = (SSLSocket)serviceSocketFac.createSocket(socket, bais, true);
    
    // Now the service can use serviceSocket as usual.
    
</pre></li>
</ol>
<!-- ********************************** -->
<h4><a name="VirtualServerDispEngine" id=
"VirtualServerDispEngine">Virtual Server Dispatcher Based on
SSLEngine</a></h4>
<p>This section describes the procedure for using a virtual server
dispatcher based on <code>SSLEngine</code>.</p>
<ol>
<li>
<p><b>Register the server name handler.</b></p>
<p>At this step, the application may create different
<code>SSLContext</code> objects for different server name
indications, or link a certain server name indication to a
specified virtual machine or distributed system.</p>
<p>For example, if the server name is <code>www.example.org</code>,
then the registered server name handler may be for a local virtual
hosting web service. The local virtual hosting web service will use
the specified <code>SSLContext</code>. If the server name is
<code>www.example.com</code>, then the registered server name
handler may be for a virtual machine hosting on
<code>10.0.0.36</code>. The handler may map this connection to the
virtual machine.</p>
</li>
<li>
<p><b>Create a <code>ServerSocket</code> or
<code>ServerSocketChannel</code> and accept the new
connection.</b></p>
<pre class="codeblock">
    ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();
    serverSocketChannel.bind(...);
    ...
    SocketChannel socketChannel = serverSocketChannel.accept();
        
</pre></li>
<li>
<p><b>Read and buffer bytes from the socket input stream, and then
explore the buffered bytes.</b></p>
<pre class="codeblock">
    ByteBuffer buffer = ByteBuffer.allocate(0xFF);
    SSLCapabilities capabilities = null;
    while (true) {
        // ensure the capacity
        if (buffer.remaining() == 0) {
            ByteBuffer oldBuffer = buffer;
            buffer = ByteBuffer.allocate(buffer.capacity() + 0xFF);
            buffer.put(oldBuffer);
        }

        int n = sc.read(buffer);
        if (n &lt; 0) {
            throw new Exception("unexpected end of stream!");
        }

        int position = buffer.position();
        buffer.flip();
        capabilities = explorer.explore(buffer);
        buffer.rewind();
        buffer.position(position);
        buffer.limit(buffer.capacity());
        if (capabilities != null) {
            System.out.println("Record version: " +
                    capabilities.getRecordVersion());
            System.out.println("Hello version: " +
                    capabilities.getHelloVersion());
            break;
        }
    }
    buffer.flip();  // reset the buffer position and limitation 
        
</pre></li>
<li>
<p><b>Get the requested server name from the explored
capabilities.</b></p>
<pre class="codeblock">
    List&lt;SNIServerName&gt; serverNames = capabilities.getServerNames();
        
</pre></li>
<li>
<p><b>Look for the registered server name handler for this server
name indication.</b></p>
<p>If the service of the host name is resident in a virtual machine
or another distributed system, then the application must forward
the connection to the destination. The application will need to
read and write the raw internet data, rather then the SSL
application from the socket stream.</p>
<pre class="codeblock">
    Socket destinationSocket = new Socket(serverName, 443);
    
    // Forward buffered bytes and network data from the current socket to the <code>destinationSocket</code>.
        
</pre>
<p>If the service of the host name is resident in the same process,
and the host name service can use the <code>SSLEngine</code>
directly, then the application will simply feed the net data to the
<code>SSLEngine</code> instance:</p>
<pre class="codeblock">
    // Get service context from registered handler
    // or create the context
    SSLContext serviceContext = ...
    
    SSLEngine serviceEngine = serviceContext.createSSLEngine();

    // Now the service can use the buffered bytes and other byte buffer as usual.
    
</pre></li>
</ol>
<!-- ********************************** -->
<h4><a name="NoSNI" id="NoSNI">No SNI Extension Available</a></h4>
<p>If there is no server name indication in a ClientHello message,
then there is no way to select the proper service according to SNI.
For such cases, the application may need to specify a default
service, so that the connection can be delegated to it if there is
no server name indication.</p>
<!-- ********************************** -->
<h4><a name="FailoverContext" id="FailoverContext">Failover
SSLContext</a></h4>
<p>The <code>SSLExplorer.explore()</code> method does not check the
validity of SSL/TLS contents. If the record format does not comply
with SSL/TLS specification, or the <code>explore()</code> method is
invoked after handshaking has started, then the method may throw an
<code>IOException</code> and be unable to produce network data. In
such cases, handle the exception thrown by
<code>SSLExplorer.explore()</code> by using a failover
<code>SSLContext</code>, which is not used to negotiate an SSL/TLS
connection, but to close the connection with the proper alert
message. The following example illustrates a failover
<code>SSLContext</code>. You can find an example of the
<code>DenialSNIMatcher</code> class in Case 2 of the <a href=
"#ServerSNIExamples">Typical Server-Side Usage Examples</a>.</p>
<pre class="codeblock">
    byte[] buffer = ...       // buffered network data
    boolean failed = true;    // SSLExplorer.explore() throws an exception
    
    SSLContext context = SSLContext.getInstance("TLS");
        // the failover SSLContext
    
    context.init(null, null, null);
    SSLSocketFactory sslsf = context.getSocketFactory();
    ByteArrayInputStream bais = new ByteArrayInputStream(buffer, 0, position);
    SSLSocket sslSocket = (SSLSocket)sslsf.createSocket(socket, bais, true);
    
    SNIMatcher matcher = new DenialSNIMatcher();
    Collection&lt;SNIMatcher&gt; matchers = new ArrayList&lt;&gt;(1);
    matchers.add(matcher);
    SSLParameters params = sslSocket.getSSLParameters();
    params.setSNIMatchers(matchers);    // no recognizable server name
    sslSocket.setSSLParameters(params);
    
    try {
        InputStream sslIS = sslSocket.getInputStream();
        sslIS.read();
    } catch (Exception e) {
        System.out.println("Server exception " + e);
    } finally {
        sslSocket.close();
    }
</pre>
<!-- ********************************** -->
<h2><a name="AppA" id="AppA">Appendix A: Standard Names</a></h2>
<p>The JDK Security API requires and uses a set of standard names
for algorithms, certificates and keystore types. The specification
names previously found here in Appendix A and in the other security
specifications (JCA, CertPath) have been combined in the <a href=
"../StandardNames.html">Standard Names document</a>. Specific
provider information can be found in the <a href=
"../SunProviders.html">Oracle Provider Documentation</a>.</p>
<!-- ********************************** -->
<h2><a name="PLUG" id="PLUG">Appendix B: Provider
Pluggability</a></h2>
<p>JSSE is fully pluggable and does not restrict the use of
third-party JSSE providers in any way.</p>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
