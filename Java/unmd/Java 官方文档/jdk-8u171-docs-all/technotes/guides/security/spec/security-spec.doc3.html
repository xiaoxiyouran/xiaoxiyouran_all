<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>Java Security Architecture: -</title>
<link rel="stylesheet" type="text/css" href="../../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h2><a name="a19802" id="a19802"><i>3</i> Permissions and Security
Policy</a></h2>
<br />
<h3><a name="a17001" id="a17001"><!-- --></a> <i>3.1</i> The
Permission Classes</h3>
<a name="a19229" id="a19229"><!-- --></a> The permission classes
represent access to system resources. The java.security.Permission
class is an abstract class and is subclassed, as appropriate, to
represent specific accesses.
<p><a name="a28891" id="a28891"><!-- --></a> As an example of a
permission, the following code can be used to produce a permission
to read the file named "abc" in the /tmp directory:</p>
<pre>
    perm = new java.io.FilePermission("/tmp/abc", "read");
</pre>
<a name="a23134" id="a23134"><!-- --></a> New permissions are
subclassed either from the Permission class or one of its
subclasses, such as java.security.BasicPermission. Subclassed
permissions (other than BasicPermission) generally belong to their
own packages. Thus, FilePermission is found in the java.io package.
<p><a name="a17186" id="a17186"><!-- --></a> A crucial abstract
method that needs to be implemented for each new class of
permission is the <code>implies</code> method. Basically, "a
implies b" means that if one is granted permission "a", one is
naturally granted permission "b". This is important when making
access control decisions.</p>
<p><a name="a19232" id="a19232"><!-- --></a> Associated with the
abstract class java.security.Permission are the abstract class
named java.security.PermissionCollection and the final class
java.security.Permissions.</p>
<p><a name="a28899" id="a28899"><!-- --></a> Class
java.security.PermissionCollection represents a collection (i.e., a
set that allows duplicates) of Permission objects for a single
category (such as file permissions), for ease of grouping. In cases
where permissions can be added to the PermissionCollection object
in any order, such as for file permissions, it is crucial that the
PermissionCollection object ensure that the correct semantics are
followed when the <code>implies</code> function is called.</p>
<p><a name="a18949" id="a18949"><!-- --></a> Class
java.security.Permissions represents a collection of collections of
Permission objects, or in other words, a super collection of
heterogeneous permissions.</p>
<p><a name="a19896" id="a19896"><!-- --></a> Applications are free
to add new categories of permissions that the system supports. How
to add such application-specific permissions is discussed later in
this document.</p>
<p><a name="a19897" id="a19897"><!-- --></a> Now we describe the
syntax and semantics of all built-in permissions.</p>
<br />
<a name="a19902" id="a19902"><!-- --></a>
<h4><i>3.1.1 java.security.Permission</i></h4>
<a name="a19924" id="a19924"><!-- --></a> This abstract class is
the ancestor of all permissions. It defines the essential
functionalities required for all permissions.
<p><a name="a19953" id="a19953"><!-- --></a> Each permission
instance is typically generated by passing one or more string
parameters to the constructor. In a common case with two
parameters, the first parameter is usually "the name of the target"
(such as the name of a file for which the permission is aimed), and
the second parameter is the action (such as "read" action on a
file). Generally, a set of actions can be specified together as a
comma-separated composite string.</p>
<br />
<a name="a19905" id="a19905"><!-- --></a>
<h4><i>3.1.2 java.security.PermissionCollection</i></h4>
<a name="a19925" id="a19925"><!-- --></a> This class holds a
homogeneous collection of permissions. In other words, each
instance of the class holds only permissions of the same
type.<br />
<a name="a19911" id="a19911"><!-- --></a>
<h4><i>3.1.3 java.security.Permissions</i></h4>
<a name="a19926" id="a19926"><!-- --></a> This class is designed to
hold a heterogeneous collection of permissions. Basically, it is a
collection of java.security.PermissionCollection objects.<br />
<a name="a22515" id="a22515"><!-- --></a>
<h4><i>3.1.4 java.security.UnresolvedPermission</i></h4>
<a name="a22517" id="a22517"><!-- --></a> Recall that the internal
state of a security policy is normally expressed by the permission
objects that are associated with each code source. Given the
dynamic nature of Java technology, however, it is possible that
when the policy is initialized the actual code that implements a
particular permission class has not yet been loaded and defined in
the Java application environment. For example, a referenced
permission class may be in a JAR file that will later be loaded.
<p><a name="a29080" id="a29080"><!-- --></a> The
UnresolvedPermission class is used to hold such "unresolved"
permissions. Similarly, the class
java.security.UnresolvedPermissionCollection stores a collection of
UnresolvedPermission permissions.</p>
<p><a name="a24363" id="a24363"><!-- --></a> During access control
checking on a permission of a type that was previously unresolved,
but whose class has since been loaded, the unresolved permission is
"resolved" and the appropriate access control decision is made.
That is, a new object of the appropriate class type is
instantiated, if possible, based on the information in the
UnresolvedPermission. This new object replaces the
UnresolvedPermission, which is removed.</p>
<p><a name="a22542" id="a22542"><!-- --></a> If the permission is
still unresolvable at this time, the permission is considered
invalid, as if it is never granted in a security policy.</p>
<br />
<a name="a19913" id="a19913"><!-- --></a>
<h4><i>3.1.5 java.io.FilePermission</i></h4>
<a name="a19994" id="a19994"><!-- --></a> The targets for this
class can be specified in the following ways, where directory and
file names are strings that cannot contain white spaces.
<pre>
file
directory (same as directory/)
directory/file
directory/* (all files in this directory)
* (all files in the current directory)
directory/- (all files in the file system under this directory)
- (all files in the file system under the current directory)
"&lt;&lt;ALL FILES&gt;&gt;" (all files in the file system)
</pre>
<a name="a19990" id="a19990"><!-- --></a> Note that "&lt;&lt;ALL
FILES&gt;&gt;" is a special string denoting all files in the
system. On a Solaris, Linux, or Mac OS X system,
this includes all files under the root
directory. On an MS-DOS system, this includes all files on all
drives.
<p><a name="a23161" id="a23161"><!-- --></a> The actions are:
<b>read</b>, <b>write</b>, <b>delete</b>, and <b>execute</b>.
Therefore, the following are valid code samples for creating file
permissions:</p>
<pre>
import java.io.FilePermission;

FilePermission p = new FilePermission("myfile", "read,write");
FilePermission p = new FilePermission("/home/gong/", "read");
FilePermission p = new FilePermission("/tmp/mytmp", "read,delete");
FilePermission p = new FilePermission("/bin/*", "execute");
FilePermission p = new FilePermission("*", "read");
FilePermission p = new FilePermission("/-", "read,execute");
FilePermission p = new FilePermission("-", "read,execute");
FilePermission p = new FilePermission("&lt;&lt;ALL FILES&gt;&gt;", "read");
</pre>
&gt;<a name="a19988" id="a19988"><!-- --></a> The
<code>implies</code> method in this class correctly interprets the
file system. For example, FilePermission("/-", "read,execute")
implies FilePermission("/home/gong/public_html/index.html",
"read"), and FilePermission("bin/*", "execute") implies
FilePermission("bin/emacs19.31", "execute").
<p><a name="a24371" id="a24371"><!-- --></a> Note: Most of these
strings are given in platform-dependent format. For example, to
represent read access to the file named "foo" in the "temp"
directory on the C drive of a Windows system, you would use</p>
<pre>
FilePermission p = new FilePermission("c:\\temp\\foo", "read");
</pre>
<a name="a25819" id="a25819"><!-- --></a> The double backslashes
are necessary to represent a single backslash because the strings
are processed by a tokenizer (java.io.StreamTokenizer), which
allows "\" to be used as an escape string (e.g., "\n" to indicate a
new line) and which thus requires two backslashes to indicate a
single backslash. After the tokenizer has processed the above
FilePermission target string, converting double backslashes to
single backslashes, the end result is the actual path
<pre>
"c:\temp\foo"
</pre>
<a name="a24395" id="a24395"><!-- --></a> It is necessary that the
strings be given in platform-dependent format until there is a
universal file description language. Note also that the use of meta
symbols such as "*" and "-" prevents the use of specific file
names. We think this is a small limitation that can be tolerated
for the moment. Finally, note that "/-" and "&lt;&lt;ALL
FILES&gt;&gt;" are the same target on Solaris, Linux, and Mac OS X
systems in that they
both refer to the entire file system. (They can refer to multiple
file systems if they are all available). The two targets are
potentially different on other operating systems, such as MS
Windows and MacOS.
<p><a name="a24336" id="a24336"><!-- --></a> Also note that a
target name that specifies just a directory, with a "read" action,
as in</p>
<pre>
FilePermission p = new FilePermission("/home/gong/", "read");
</pre>
<a name="a24338" id="a24338"><!-- --></a> means you are only giving
permission to list the files in that directory, not read any of
them. To allow read access to files, you must specify either an
explicit file name, or an "*" or "-", as in
<pre>
FilePermission p = new FilePermission("/home/gong/myfile", "read");
FilePermission p = new FilePermission("/home/gong/*", "read");
FilePermission p = new FilePermission("/home/gong/-", "read");
</pre>
<a name="a27675" id="a27675"><!-- --></a> And finally, note that
code always automatically has permission to read files from its
same (URL) location, and subdirectories of that location; it does
not need explicit permission to do so.<br />
<a name="a19915" id="a19915"><!-- --></a>
<h4><i>3.1.6 java.net.SocketPermission</i></h4>
<a name="a19989" id="a19989"><!-- --></a> This class represents
access to a network via sockets. The target for this class can be
given as "hostname:port_range", where hostname can be given in the
following ways:
<pre>
hostname (a single host)
IP address (a single host)
localhost (the local machine)
"" (equivalent to "localhost")
hostname.domain (a single host within the domain)
hostname.subdomain.domain
*.domain (all hosts in the domain)
*.subdomain.domain
* (all hosts)
</pre>
<a name="a26297" id="a26297"><!-- --></a> That is, the host is
expressed as a DNS name, as a numerical IP address, as "localhost"
(for the local machine) or as "" (which is equivalent to specifying
"localhost").
<p><a name="a26313" id="a26313"><!-- --></a> The wildcard "*" may
be included once in a DNS name host specification. If it is
included, it must be in the leftmost position, as in
"*.sun.com".</p>
<p><a name="a26312" id="a26312"><!-- --></a> The port_range can be
given as follows:</p>
<pre>
N (a single port)
N- (all ports numbered N and above)
-N (all ports numbered N and below)
N1-N2 (all ports between N1 and N2, inclusive)
</pre>
<a name="a20027" id="a20027"><!-- --></a> Here N, N1, and N2 are
non-negative integers ranging from 0 to 65535 (2^16-1).
<p><a name="a20036" id="a20036"><!-- --></a> The actions on sockets
are <b>accept</b>, <b>connect</b>, <b>listen</b>, and
<b>resolve</b> (which is basically DNS lookup). Note that
implicitly, the action "resolve" is implied by "accept", "connect",
and "listen" -- i.e., those who can listen or accept incoming
connections from or initiate out-going connections to a host should
be able to look up the name of the remote host.</p>
<p><a name="a20042" id="a20042"><!-- --></a> Below are some
examples of socket permissions.</p>
<pre>
import java.net.SocketPermission;

SocketPermission p = new SocketPermission("java.example.com","accept");
p = new SocketPermission("192.0.2.99","accept");
p = new SocketPermission("*.com","connect");
p = new SocketPermission("*.example.com:80","accept");
p = new SocketPermission("*.example.com:-1023","accept");
p = new SocketPermission("*.example.com:1024-","connect");
p = new SocketPermission("java.example.com:8000-9000",
         "connect,accept");
p = new SocketPermission("localhost:1024-",
          "accept,connect,listen");
</pre>
<a name="a20092" id="a20092"><!-- --></a> Note that
SocketPermission("java.example.com:80,8080","accept") and
SocketPermission("java.example.com,javasun.example.com","accept")
are not valid socket permissions.
<p><a name="a21604" id="a21604"><!-- --></a> Moreover, because
<b>listen</b> is an action that applies only to ports on the local
host, whereas <b>accept</b> is an action that applies to ports on
both the local and remote host, both actions are necessary.</p>
<br />
<a name="a20057" id="a20057"><!-- --></a>
<h4><i>3.1.7 java.security.BasicPermission</i></h4>
<a name="a23199" id="a23199"><!-- --></a> The BasicPermission class
extends the Permission class. It can be used as the base class for
permissions that want to follow the same naming convention as
BasicPermission (see below).
<p><a name="a23200" id="a23200"><!-- --></a> The name for a
BasicPermission is the name of the given permission (for example,
"exitVM", "setFactory", "queuePrintJob", etc). The naming
convention follows the hierarchical property naming convention. An
asterisk may appear at the end of the name, following a ".", or by
itself, to signify a wildcard match. For example: "java.*" or "*"
is valid, "*java" or "a*b" is not valid.</p>
<p><a name="a23201" id="a23201"><!-- --></a> The action string
(inherited from Permission) is unused.Thus, BasicPermission is
commonly used as the base class for "named" permissions (ones that
contain a name but no actions list; you either have the named
permission or you don't.) Subclasses may implement actions on top
of BasicPermission, if desired.</p>
<p><a name="a27099" id="a27099"><!-- --></a> Some of the
BasicPermission subclasses are java.lang.RuntimePermission,
java.security.SecurityPermission, java.util.PropertyPermission, and
java.net.NetPermission.</p>
<br />
<a name="a20107" id="a20107"><!-- --></a>
<h4><i>3.1.8 java.util.PropertyPermission</i></h4>
<a name="a20118" id="a20118"><!-- --></a> The targets for this
class are basically the names of Java properties as set in various
property files. Examples are the "java.home" and "os.name"
properties. Targets can be specified as "*" (any property), "a.*"
(any property whose name has a prefix "a."), "a.b.*", and so on.
Note that the wildcard can occur only once and can only be at the
rightmost position.
<p><a name="a24233" id="a24233"><!-- --></a> This is one of the
BasicPermission subclasses that implements actions on top of
BasicPermission. The actions are read and write. Their meaning is
defined as follows: "read" permission allows the
<code>getProperty</code> method in java.lang.System to be called to
get the property value, and "write" permission allows the
<code>setProperty</code> method to be called to set the property
value.</p>
<br />
<a name="a20113" id="a20113"><!-- --></a>
<h4><i>3.1.9 java.lang.RuntimePermission</i></h4>
<a name="a20122" id="a20122"><!-- --></a> The target for a
RuntimePermission can be represented by any string, and there is no
action associated with the targets. For example,
RuntimePermission("exitVM") denotes the permission to exit the Java
Virtual Machine.
<p><a name="a20310" id="a20310"><!-- --></a> The target names
are:</p>
<pre>
createClassLoader
getClassLoader
setContextClassLoader
setSecurityManager
createSecurityManager
exitVM
setFactory
setIO
modifyThread
stopThread
modifyThreadGroup
getProtectionDomain
readFileDescriptor
writeFileDescriptor
loadLibrary.{library name}
accessClassInPackage.{package name}
defineClassInPackage.{package name}
accessDeclaredMembers.{class name}
queuePrintJob
</pre>
<br />
<a name="a20327" id="a20327"><!-- --></a>
<h4><i>3.1.10 java.awt.AWTPermission</i></h4>
<a name="a20351" id="a20351"><!-- --></a> This is in the same
spirit as the RuntimePermission; it's a permission without actions.
The targets for this class are:
<pre>
accessClipboard
accessEventQueue
listenToAllAWTEvents
showWindowWithoutWarningBanner
</pre>
<br />
<a name="a20353" id="a20353"><!-- --></a>
<h4><i>3.1.11 java.net.NetPermission</i></h4>
<a name="a20120" id="a20120"><!-- --></a> This class contains the
following targets and no actions:
<pre>
requestPasswordAuthentication
setDefaultAuthenticator
specifyStreamHandler
</pre>
<br />
<a name="a26158" id="a26158"><!-- --></a>
<h4><i>3.1.12 java.lang.reflect.ReflectPermission</i></h4>
<a name="a26161" id="a26161"><!-- --></a> This is the Permission
class for reflective operations. A ReflectPermission is a named
permission (like RuntimePermission) and has no actions. The only
name currently defined is
<pre>
suppressAccessChecks
</pre>
<a name="a26186" id="a26186"><!-- --></a> which allows suppressing
the standard Java programming language access checks -- for public,
default (package) access, protected, and private members --
performed by reflected objects at their point of use.<br />
<a name="a26159" id="a26159"><!-- --></a>
<h4><i>3.1.13 java.io.SerializablePermission</i></h4>
<a name="a26194" id="a26194"><!-- --></a> This class contains the
following targets and no actions:
<pre>
enableSubclassImplementation
enableSubstitution
</pre>
<br />
<a name="a26196" id="a26196"><!-- --></a>
<h4><i>3.1.14 java.security.SecurityPermission</i></h4>
<a name="a26201" id="a26201"><!-- --></a> SecurityPermissions
control access to security-related objects, such as Security,
Policy, Provider, Signer, and Identity objects. This class contains
the following targets and no actions:
<pre>
getPolicy
setPolicy
getProperty.{key}
setProperty.{key}
insertProvider.{provider name}
removeProvider.{provider name}
setSystemScope
setIdentityPublicKey
setIdentityInfo
printIdentity
addIdentityCertificate
removeIdentityCertificate
clearProviderProperties.{provider name}
putProviderProperty.{provider name}
removeProviderProperty.{provider name}
getSignerPrivateKey
setSignerKeyPair
</pre>
<br />
<a name="a26221" id="a26221"><!-- --></a>
<h4><i>3.1.15 java.security.AllPermission</i></h4>
<a name="a22641" id="a22641"><!-- --></a> This permission implies
all permissions. It is introduced to simplify the work of system
administrators who might need to perform multiple tasks that
require all (or numerous) permissions. It would be inconvenient to
require the security policy to iterate through all permissions.
Note that AllPermission also implies new permissions that are
defined in the future.
<p><a name="a22644" id="a22644"><!-- --></a> Clearly much caution
is necessary when considering granting this permission.</p>
<br />
<a name="AuthPermission" id="AuthPermission"><!-- --></a>
<h4><i>3.1.16 javax.security.auth.AuthPermsision</i></h4>
<a name="AuthPermission_description" id=
"AuthPermission_description"><!-- --></a> AuthPermission handles
authentication permissions and authentication-related object such
as Subject, SubjectDomainCombiner, LoginContext, and Configuration.
This class contains the following targets and no actions:
<pre>
doAs
doAsPrivileged
getSubject
getSubjectFromDomainCombiner
setReadOnly
modifyPrincipals
modifyPublicCredentials
modifyPrivateCredentials
refreshCredential
destroyCredential
createLoginContext.{name}
getLoginConfiguration
setLoginConfiguration
refreshLoginConfiguration
</pre>
<br />
<a name="a22640" id="a22640"><!-- --></a>
<h4><i>3.1.17 Discussion of Permission Implications</i></h4>
<a name="a22636" id="a22636"><!-- --></a> Recall that permissions
are often compared against each other, and to facilitate such
comparisons, we require that each permission class defines an
<code>implies</code> method that represents how the particular
permission class relates to other permission classes. For example,
java.io.FilePermission("/tmp/*", "read") implies
java.io.FilePermission("/tmp/a.txt", "read") but does not imply any
java.net.NetPermission.
<p><a name="a22639" id="a22639"><!-- --></a> There is another layer
of implication that may not be immediately obvious to some readers.
Suppose that one applet has been granted the permission to write to
the entire file system. This presumbly allows the applet to replace
the system binary, including the JVM runtime environment. This
effectively means that the applet has been granted all
permissions.</p>
<p><a name="a22642" id="a22642"><!-- --></a> Another example is
that if an applet is granted the runtime permission to create class
loaders, it is effectively granted many more permissions, as a
class loader can perform sensitive operations.</p>
<p><a name="a22643" id="a22643"><!-- --></a> Other permissions that
are "dangerous" to give out include those that allow the setting of
system properties, runtime permissions for defining packages and
for loading native code libraries (because the Java security
architecture is not designed to and does not prevent malicious
behavior at the level of native code), and of course the
AllPermission.</p>
<p><a name="a29284" id="a29284"><!-- --></a> For more information
about permissions, including tables enumerating the risks of
assigning specific permissions as well as a table of all the Java 2
SDK built-in methods that require permissions, see <a href="../permissions.html">Permissions in the Java Development Kit</a>.</p>
<br />
<a name="a20211" id="a20211"><!-- --></a>
<h4><i>3.1.18 How To Create New Types of Permissions</i></h4>
<a name="a20183" id="a20183"><!-- --></a> It is essential that no
one except Sun Microsystems should extend the permissions that are
built into the Java 2 SDK, either by adding new functionality or by
introducing additional target keywords into a class such as
java.lang.RuntimePermission. This maintains consistency.
<p><a name="a21125" id="a21125"><!-- --></a> To create a new
permission, the following steps are recommended, as shown by an
example. Suppose an application developer from company ABC wants to
create a customized permission to "watch TV".</p>
<p><a name="a21131" id="a21131"><!-- --></a> First, create a new
class com.abc.Permission that extends the abstract class
java.security.Permission (or one of its subclasses), and another
new class com.abc.TVPermission that extends the com.abc.Permission.
Make sure that the <code>implies</code> method, among others, is
correctly implemented. (Of course, com.abc.TVPermission can
directly extend java.security.Permission; the intermediate
com.abc.Permission is not required.)</p>
<pre>
public class com.abc.Permission extends java.security.Permission

public class com.abc.TVPermission extends com.abc.Permission
</pre>
<a name="a20190" id="a20190"><!-- --></a> The following figure
shows the subclass relationship.
<p><a name="a22238" id="a22238"><!-- --></a></p>
<img alt=
"Flow chart showing the logic flows from Permission to the subclass com.abc.Permission and then to com.abc.TVPermission"
src="security-spec.doc.anc8.gif" />
<p><a name="a20195" id="a20195"><!-- --></a></p>
<p><a name="a20219" id="a20219"><!-- --></a> Second, include these
new classes with the application package.</p>
<p><a name="a29053" id="a29053"><!-- --></a> Each user that wants
to allow this new type of permission for specific code does so by
adding an entry in a policy file. (Details of the policy file
syntax are given in a later section.) An example of a policy file
entry granting code from <code>http://example.com/</code> permission to watch
channel 5 would be:</p>
<pre>
grant codeBase  "http://example.com/" {
    permission com.abc.TVPermission "channel-5", "watch";
    }
</pre>
<a name="a20199" id="a20199"><!-- --></a> In the application's
resource management code, when checking to see if a permission
should be granted, call AccessController's
<code>checkPermission</code> method using a com.abc.TVPermission
object as the parameter.
<pre>
   com.abc.TVPermission tvperm = new
        com.abc.TVPermission("channel-5", "watch");
   AccessController.checkPermission(tvperm);
</pre>
<a name="a25739" id="a25739"><!-- --></a> Note that, when adding a
new permission, one should create a new (permission) class and not
add a new method to the security manager. (In the past, in order to
enable checking of a new type of access, you had to add a new
method to the SecurityManager class.)
<p><a name="a23227" id="a23227"><!-- --></a> If more elaborate
TVPermissions such as "channel-1:13" or "channel-*" are allowed,
then it may be necessary to implement a TVPermissionCollection
object that knows how to deal with the semantics of these pseudo
names.</p>
<p><a name="a24463" id="a24463"><!-- --></a> New code should always
invoke a permission check by calling the
<code>checkPermission</code> method of the AccessController class
in order to exercise the built-in access control algorithm. There
is no essential need to examine whether there is a ClassLoader or a
SecurityManager. On the other hand, if the algorithm should be left
to the installed security manager class, then the method
<code>SecurityManager.checkPermission</code> should be invoked
instead.</p>
<br />
<h3><a name="a25999" id="a25999"><!-- --></a> <i>3.2</i>
java.security.CodeSource</h3>
<a name="a27604" id="a27604"><!-- --></a> This class extends the
concept of a codebase within HTML to encapsulate not only the code
location (URL) but also the certificate(s) containing public keys
that should be used to verify signed code originating from that
location. Note that this is not the equivalent of the CodeBase tag
in HTML files. Each certificate is represented as a
java.security.cert.Certificate, and each URL as a
java.net.URL.<br />
<h3><a name="a20128" id="a20128"><!-- --></a> <i>3.3</i>
java.security.Policy</h3>
<a name="a23559" id="a23559"><!-- --></a> The system security
policy for a Java application environment, specifying which
permissions are available for code from various sources, is
represented by a Policy object. More specifically, it is
represented by a Policy subclass providing an implementation of the
abstract methods in the Policy class.
<p><a name="a23620" id="a23620"><!-- --></a> In order for an applet
(or an application running under a SecurityManager) to be allowed
to perform secured actions, such as reading or writing a file, the
applet (or application) must be granted permission for that
particular action. The only exception is that code always
automatically has permission to read files from its same
CodeSource, and subdirectories of that CodeSource; it does not need
explicit permission to do so.</p>
<p><a name="a23520" id="a23520"><!-- --></a> There could be
multiple instances of the Policy object, although only one is "in
effect" at any time. The currently-installed Policy object can be
obtained by calling the <code>getPolicy</code> method, and it can
be changed by a call to the <code>setPolicy</code> method (by code
with permission to reset the Policy).</p>
<p><a name="a23433" id="a23433"><!-- --></a> The source location
for the policy information utilized by the Policy object is up to
the Policy implementation. The policy configuration may be stored,
for example, as a flat ASCII file, as a serialized binary file of
the Policy class, or as a database. There is a Policy reference
implementation that obtains its information from static policy
configuration files.</p>
<br />
<a name="a20131" id="a20131"><!-- --></a>
<h4><i>3.3.1 Policy File Format</i></h4>
<a name="a23601" id="a23601"><!-- --></a> In the Policy reference
implementation, the policy can be specified within one or more
policy configuration files. The configuration files indicate what
permissions are allowed for code from specified code sources. Each
configuration file must be encoded in UTF-8.
<p><a name="a24120" id="a24120"><!-- --></a> A policy configuration
file essentially contains a list of entries. It may contain a
"keystore" entry, and contains zero or more "grant" entries.</p>
<p><a name="a23697" id="a23697"><!-- --></a> A keystore is a
database of private keys and their associated digital certificates
such as X.509 certificate chains authenticating the corresponding
public keys. The keytool utility is used to create and administer
keystores. The keystore specified in a policy configuration file is
used to look up the public keys of the signers specified in the
grant entries of the file. A keystore entry must appear in a policy
configuration file if any grant entries specify signer aliases, or
if any grant entries specify a principal alias (see below).</p>
<p><a name="a23698" id="a23698"><!-- --></a> At this time, there
can be only one keystore entry in the policy file (others after the
first one are ignored), and it can appear anywhere outside the
file's grant entries . It has the following syntax:</p>
<pre>
keystore "some_keystore_url", "keystore_type";
</pre>
<a name="a23919" id="a23919"><!-- --></a> Here, "some_keystore_url"
specifies the URL location of the keystore, and "keystore_type"
specifies the keystore type. The latter is optional. If not
specified, the type is assumed to be that specified by the
"keystore.type" property in the security properties file.
<p><a name="a27653" id="a27653"><!-- --></a> The URL is relative to
the policy file location. Thus if the policy file is specified in
the security properties file as:</p>
<pre>
policy.url.1=http://foo.bar.example.com/blah/some.policy
</pre>
<a name="a23922" id="a23922"><!-- --></a> and that policy file has
an entry:
<pre>
keystore ".keystore";
</pre>
<a name="a23924" id="a23924"><!-- --></a> then the keystore will be
loaded from:
<pre>
http://foo.bar.example.com/blah/.keystore
</pre>
<a name="a23689" id="a23689"><!-- --></a> The URL can also be
absolute.
<p><a name="a27656" id="a27656"><!-- --></a> A keystore type
defines the storage and data format of the keystore information,
and the algorithms used to protect private keys in the keystore and
the integrity of the keystore itself. The default type supported by
Sun Microsystems is a proprietary keystore type named "JKS".</p>
<p><a name="a24132" id="a24132"><!-- --></a> Each grant entry in a
policy file essentially consists of a CodeSource and its
permissions. Actually, a CodeSource consists of a URL and a set of
certificates, while a policy file entry includes a URL and a list
of signer names. The system creates the corresponding CodeSource
after consulting the keystore to determine the certificate(s) of
the specified signers.</p>
<p><a name="a20263" id="a20263"><!-- --></a> Each grant entry in
the policy file is of the following format, where the leading
"grant" is a reserved word that signifies the beginning of a new
entry and optional items appear in brackets. Within each entry, a
leading "permission" is another reserved word that marks the
beginning of a new permission in the entry. Each grant entry grants
a set of permissions to a specified code source and principals.</p>
<pre>
grant [SignedBy "signer_names"] [, CodeBase "URL"]
      [, Principal [principal_class_name] "principal_name"]
      [, Principal [principal_class_name] "principal_name"] ... {
    permission permission_class_name [ "target_name" ] 
               [, "action"] [, SignedBy "signer_names"];
    permission ...
};
</pre>
<a name="a21173" id="a21173"><!-- --></a> White spaces are allowed
immediately before or after any comma. The name of the permission
class must be a fully qualified class name, such as
java.io.FilePermission, and cannot be abbreviated (for example, to
FilePermission).
<p><a name="a20259" id="a20259"><!-- --></a> Note that the action
field is optional in that it can be omitted if the permission class
does not require it. If it is present, then it must come
immediately after the target field.</p>
<p><a name="a29148" id="a29148"><!-- --></a> The exact meaning of a
CodeBase URL value depends on the characters at the end. A CodeBase
with a trailing "/" matches all class files (not JAR files) in the
specified directory. A CodeBase with a trailing "/*" matches all
files (both class and JAR files) contained in that directory. A
CodeBase with a trailing "/-" matches all files (both class and JAR
files) in the directory and recursively all files in subdirectories
contained in that directory.</p>
<p><a name="a29146" id="a29146"><!-- --></a> The CodeBase field
(URL) is optional in that, if it is omitted, it signifies "any code
base".</p>
<p><a name="a20250" id="a20250"><!-- --></a> The first signer name
field is a string alias that is mapped, via a separate mechanism,
to a set of public keys (within certificates in the keystore) that
are associated with the signers. These keys are used to verify that
certain signed classes are really signed by these signers.</p>
<p><a name="a20298" id="a20298"><!-- --></a> This signer field can
be a comma-separated string containing names of multiple signers,
an example of which is "Adam,Eve,Charles", which means signed by
Adam and Eve and Charles (i.e., the relationship is AND, not
OR).</p>
<p><a name="a20299" id="a20299"><!-- --></a> This field is optional
in that, if it is omitted, it signifies "any signer", or in other
words, "It doesn't matter whether the code is signed or not".</p>
<p><a name="a22285" id="a22285"><!-- --></a> The second signer
field, inside a Permission entry, represents the alias to the
keystore entry containing the public key corresponding to the
private key used to sign the bytecodes that implemented the said
permission class. This permission entry is effective (i.e., access
control permission will be granted based on this entry) only if the
bytecode implementation is verified to be correctly signed by the
said alias.</p>
<p><a name="principal_description" id="principal_description">
<!-- --></a> A principal value specifies a
class_name/principal_name pair which must be present within the
executing threads principal set. The principal set is associated
with the executing code by way of a Subject. The principal field is
optional in that, if it is omitted, it signifies "any
principals".</p>
<p><a name="keystoreAliasReplace" id="keystoreAliasReplace"><b>Note
on KeyStore Alias Replacement:</b></a></p>
<p>If the principal class_name/principal_name pair is specified as
a single quoted string, it is treated as a keystore alias. The
keystore is consulted and queried (via the alias) for an X509
Certificate. If one is found, the principal_class is automatically
treated as <code>javax.security.auth.x500.X500Principal</code>, and
the principal_name is automatically treated as the subject
distinguished name from the certificate. If an X509 Certificate
mapping is not found, the entire grant entry is ignored.</p>
<p><a name="a21134" id="a21134"><!-- --></a> The order between the
CodeBase, SignedBy, and Principal fields does not matter.</p>
<p><a name="a21178" id="a21178"><!-- --></a> An informal BNF
grammer for the Policy file format is given below, where
non-capitalized terms are terminals:</p>
<pre>
PolicyFile -&gt; PolicyEntry | PolicyEntry; PolicyFile
PolicyEntry -&gt; grant {PermissionEntry}; |
           grant SignerEntry {PermissionEntry} |
           grant CodebaseEntry {PermissionEntry} |
           grant PrincipalEntry {PermissionEntry} |
           grant SignerEntry, CodebaseEntry {PermissionEntry} |
           grant CodebaseEntry, SignerEntry {PermissionEntry} |
           grant SignerEntry, PrincipalEntry {PermissionEntry} |
           grant PrincipalEntry, SignerEntry {PermissionEntry} |
           grant CodebaseEntry, PrincipalEntry {PermissionEntry} |
           grant PrincipalEntry, CodebaseEntry {PermissionEntry} |
           grant SignerEntry, CodebaseEntry, PrincipalEntry {PermissionEntry} |
           grant CodebaseEntry, SignerEntry, PrincipalEntry {PermissionEntry} |
           grant SignerEntry, PrincipalEntry, CodebaseEntry {PermissionEntry} |
           grant CodebaseEntry, PrincipalEntry, SignerEntry {PermissionEntry} |
           grant PrincipalEntry, CodebaseEntry, SignerEntry {PermissionEntry} |
           grant PrincipalEntry, SignerEntry, CodebaseEntry {PermissionEntry} |
           keystore "url"
SignerEntry -&gt; signedby (a comma-separated list of strings)
CodebaseEntry -&gt; codebase (a string representation of a URL)
PrincipalEntry -&gt; OnePrincipal | OnePrincipal, PrincipalEntry
OnePrincipal -&gt; principal [ principal_class_name ] "principal_name" (a principal)
PermissionEntry -&gt; OnePermission | OnePermission PermissionEntry
OnePermission -&gt; permission permission_class_name
                 [ "target_name" ] [, "action_list"]
                 [, SignerEntry];

</pre>
<a name="a25673" id="a25673"><!-- --></a> Now we give some
examples. The following policy grants permission a.b.Foo to code
signed by Roland:
<pre>
grant signedBy "Roland" {
    permission a.b.Foo;
};
</pre>
<a name="a21211" id="a21211"><!-- --></a> The following grants a
FilePermission to all code (regardless of the signer and/or
codeBase):
<pre>
grant {
   permission java.io.FilePermission ".tmp", "read";
};
</pre>
<a name="a21218" id="a21218"><!-- --></a> The following grants two
permissions to code that is signed by both Li and Roland:
<pre>
grant signedBy "Roland,Li" {
  permission java.io.FilePermission "/tmp/*", "read";
  permission java.util.PropertyPermission "user.*";
};
</pre>
<a name="a21226" id="a21226"><!-- --></a> The following grants two
permissions to code that is signed by Li and that comes from
<code>http://example.com</code>:
<pre>
grant codeBase "http://example.com/*", signedBy "Li" {
    permission java.io.FilePermission "/tmp/*", "read";
    permission java.io.SocketPermission "*", "connect";
};
</pre>
<a name="a22293" id="a22293"><!-- --></a> The following grants two
permissions to code that is signed by both Li and Roland, and only
if the bytecodes implementing com.abc.TVPermission are genuinely
signed by Li.
<pre>
grant signedBy "Roland,Li" {
  permission java.io.FilePermission "/tmp/*", "read";
  permission com.abc.TVPermission "channel-5", "watch", 
     signedBy "Li";
};
</pre>
<a name="a22296" id="a22296"><!-- --></a> The reason for including
the second signer field is to prevent spoofing when a permission
class does not reside with the Java runtime installation. For
example, a copy of the com.abc.TVPermission class can be downloaded
as part of a remote JAR archive, and the user policy might include
an entry that refers to it. Because the archive is not long-lived,
the second time the com.abc.TVPermission class is downloaded,
posssibly from a different web site, it is crucial that the second
copy is authentic, as the presence of the permission entry in the
user policy might reflect the user's confidence or belief in the
first copy of the class bytecode.
<p><a name="a22304" id="a22304"><!-- --></a> The reason we chose to
use digital signatures to ensure authenticity, rather than storing
(a hash value of) the first copy of the bytecodes and using it to
compare with the second copy, is because the author of the
permission class can legitimately update the class file to reflect
a new design or implementation.</p>
<p><a name="a25676" id="a25676"><!-- --></a> Please note: The
strings for a file path must be specified in a platform-dependent
format; this is necessary until there is a universal file
description language. The above examples have shown strings
appropriate on Solaris systems. On Windows systems, when you
directly specify a file path in a string, you need to include two
backslashes for each actual single backslash in the path, as in</p>
<pre>
grant signedBy "Roland" {
  permission java.io.FilePermission "C:\\users\\Cathy\\*", "read";
};
</pre>
<a name="a25679" id="a25679"><!-- --></a> This is because the
strings are processed by a tokenizer (java.io.StreamTokenizer),
which allows "\" to be used as an escape string (e.g., "\n" to
indicate a new line) and which thus requires two backslashes to
indicate a single backslash. After the tokenizer has processed the
above FilePermission target string, converting double backslashes
to single backslashes, the end result is the actual path
<pre>
"C:\users\Cathy\*"
</pre>
<a name="principal_grant_example" id="principal_grant_example">
<!-- --></a> Finally, here are some principal-based grant entries:
<pre>
grant principal javax.security.auth.x500.X500Principal "cn=Alice" {
  permission java.io.FilePermission "/home/Alice", "read, write";
};
</pre>
This permits any code executing as the X500Principal, "cn=Alice",
permission to read and write to "/home/Alice".
<p>The following example shows a grant statement with both
codesource and principal information.</p>
<pre>
  grant codebase "http://www.games.example.com",
        signedBy "Duke",
        principal javax.security.auth.x500.X500Principal "cn=Alice" {
    permission java.io.FilePermission "/tmp/games", "read, write";
  };
</pre>
This allows code downloaded from "www.games.example.com", signed by
"Duke", and executed by "cn=Alice", permission to read and write
into the "/tmp/games" directory.
<p>The following example shows a grant statement with KeyStore
alias replacement:</p>
<pre>
  keystore "http://foo.bar.example.com/blah/.keystore";

  grant principal "alice" {
    permission java.io.FilePermission "/tmp/games", "read, write";
  };
</pre>
"alice" will be replaced by javax.security.auth.x500.X500Principal
"cn=Alice" assuming the X.509 certificate associated with the
keystore alias, <i>alice</i>, has a subject distinguished name of
"cn=Alice". This allows code executed by the X500Principal
"cn=Alice" permission to read and write into the "/tmp/games"
directory.<br />
<a name="a25970" id="a25970"><!-- --></a>
<h4><i>3.3.2 Property Expansion in Policy Files</i></h4>
<a name="a25971" id="a25971"><!-- --></a> Property expansion is
possible in policy files and in the security properties file.
<p><a name="a24003" id="a24003"><!-- --></a> Property expansion is
similar to expanding variables in a shell. That is, when a string
like</p>
<p><a name="a23943" id="a23943"><!-- --></a> "${some.property}"</p>
<p><a name="a23944" id="a23944"><!-- --></a> appears in a policy
file, or in the security properties file, it will be expanded to
the value of the specified system property. For example,</p>
<pre>
permission java.io.FilePermission "${user.home}", "read";
</pre>
<a name="a23948" id="a23948"><!-- --></a> will expand
"${user.home}" to use the value of the "user.home" system property.
If that property's value is "/home/cathy", then the above is
equivalent to
<pre>
permission java.io.FilePermission "/home/cathy", "read";
</pre>
<a name="a24022" id="a24022"><!-- --></a> In order to assist in
platform-independent policy files, you can also use the special
notation of "${/}", which is a shortcut for "${file.separator}".
This allows permission designations such as
<pre>
permission java.io.FilePermission "${user.home}${/}*", "read";
</pre>
<a name="a23952" id="a23952"><!-- --></a> If user.home is
/home/cathy, and you are on Solaris, the above gets converted to:
<pre>
permission java.io.FilePermission "/home/cathy/*", "read";
</pre>
<a name="a23955" id="a23955"><!-- --></a> If on the other hand
user.home is C:\users\cathy and you are on a Windows system, the
above gets converted to:
<pre>
permission java.io.FilePermission "C:\users\cathy\*", "read";
</pre>
<a name="a23958" id="a23958"><!-- --></a> Also, as a special case,
if you expand a property in a codebase, such as
<pre>
grant codeBase "file:/${java.home}/lib/ext/"
</pre>
<a name="a23962" id="a23962"><!-- --></a> then any file.separator
characters will be automatically converted to /'s, which is
desirable since codebases are URLs. Thus on a Windows system, even
if java.home is set to C:\j2sdk1.2, the above would get converted
to
<pre>
grant codeBase "file:/C:/j2sdk1.2/lib/ext/"
</pre>
<a name="a23965" id="a23965"><!-- --></a> Thus you don't need to
use ${/} in codebase strings (and you shouldn't).
<p><a name="a23967" id="a23967"><!-- --></a> Property expansion
takes place anywhere a double quoted string is allowed in the
policy file. This includes the signedby, codebase, target names,
and actions fields.</p>
<p><a name="a25580" id="a25580"><!-- --></a> Whether or not
property expansion is allowed is controlled by the value of the
"policy.expandProperties" property in the security properties file.
If the value of this property is true (the default), expansion is
allowed.</p>
<p><a name="a25584" id="a25584"><!-- --></a> Please note: You can't
use nested properties; they will not work. For example,</p>
<pre>
"${user.${foo}}"
</pre>
<a name="a25601" id="a25601"><!-- --></a> doesn't work, even if the
"foo" property is set to "home". The reason is the property parser
doesn't recognize nested properties; it simply looks for the first
"${", and then keeps looking until it finds the first "}" and tries
to interpret the result "${user.$foo}" as a property, but fails if
there is no such property.
<p><a name="a25616" id="a25616"><!-- --></a> Also note: If a
property can't be expanded in a grant entry, permission entry, or
keystore entry, that entry is ignored. For example, if the system
property "foo" is not defined and you have:</p>
<pre>
grant codeBase "${foo}" {
  permission ...;
  permission ...;
};
</pre>
<a name="a25624" id="a25624"><!-- --></a> then all the permissions
in this grant entry are ignored. If you have
<pre>
grant {
  permission Foo "${foo}";
  permission Bar;
};
</pre>
<a name="a25629" id="a25629"><!-- --></a> then only the "permission
Foo..." entry is ignored. And finally, if you have
<pre>
keystore "${foo}";
</pre>
<a name="a25632" id="a25632"><!-- --></a> then the keystore entry
is ignored.
<p><a name="a25478" id="a25478"><!-- --></a> One final note: On
Windows systems, when you directly specify a file path in a string,
you need to include two backslashes for each actual single
backslash in the path, as in</p>
<pre>
"C:\\users\\cathy\\foo.bat"
</pre>
<a name="a25480" id="a25480"><!-- --></a> This is because the
strings are processed by a tokenizer (java.io.StreamTokenizer),
which allows "\" to be used as an escape string (e.g., "\n" to
indicate a new line) and which thus requires two backslashes to
indicate a single backslash. After the tokenizer has processed the
above string, converting double backslashes to single backslashes,
the end result is
<pre>
"C:\users\cathy\foo.bat"
</pre>
<a name="a25529" id="a25529"><!-- --></a> Expansion of a property
in a string takes place <em>after</em> the tokenizer has processed
the string. Thus if you have the string
<pre>
"${user.home}\\foo.bat"
</pre>
<a name="a25503" id="a25503"><!-- --></a> then first the tokenizer
processes the string, converting the double backslashes to a single
backslash, and the result is
<pre>
"${user.home}\foo.bat"
</pre>
<a name="a25541" id="a25541"><!-- --></a> Then the ${user.home}
property is expanded and the end result is
<pre>
"C:\users\cathy\foo.bat"
</pre>
<a name="a25511" id="a25511"><!-- --></a> assuming the user.home
value is "C:\users\cathy". Of course, for platform independence, it
would be better if the string was initially specified without any
explicit slashes, i.e., using the ${/} property instead, as in
<pre>
"${user.home}${/}foo.bat"
</pre>
<br />
<a name="a20264" id="a20264"><!-- --></a>
<h4><i>3.3.3 General Expansion in Policy Files</i></h4>
<a name="a20265" id="a20265"><!-- --></a> Generalized forms of
expansion are also supported in policy files. For example,
permission names may contain a string of the form:
${{protocol:protocol_data}} If such a string occurs in a permission
name, then the value in <i>protocol</i> determines the exact type
of expansion that should occur, and <i>protocol_data</i> is used to
help perform the expansion. <i>protocol_data</i> may be empty, in
which case the above string should simply take the form:
${{protocol}}
<p>There are two protocols supported in the default policy file
implementation:</p>
<ol>
<li>${{self}}
<p>The protocol, <b>self</b>, denotes a replacement of the entire
string, ${{self}}, with one or more principal class/name pairs. The
exact replacement performed depends upon the contents of the grant
clause to which the permission belongs.</p>
<p>If the grant clause does not contain any principal information,
the permission will be ignored (permissions containing ${{self}} in
their target names are only valid in the context of a
principal-based grant clause). For example, BarPermission will
always be ignored in the following grant clause:</p>
<pre>
            grant codebase "www.foo.example.com", signedby "duke" {
                permission BarPermission "... ${{self}} ...";
            };
        
</pre>
If the grant clause contains principal information, ${{self}} will
be replaced with that same principal information. For example,
${{self}} in BarPermission will be replaced by
<b>javax.security.auth.x500.X500Principal "cn=Duke"</b> in the
following grant clause:
<pre>
            grant principal javax.security.auth.x500.X500Principal "cn=Duke" {
                permission BarPermission "... ${{self}} ...";
            };
        
</pre>
If there is a comma-separated list of principals in the grant
clause, then ${{self}} will be replaced by the same comma-separated
list or principals. In the case where both the principal class and
name are wildcarded in the grant clause, ${{self}} is replaced with
all the principals associated with the <code>Subject</code> in the
current <code>AccessControlContext</code>.
<p>The following example describes a scenario involving both
<b>self</b> and <a href="#keystoreAliasReplace">KeyStore alias
replacement</a> together:</p>
<pre>
            keystore "http://foo.bar.example.com/blah/.keystore";

            grant principal "duke" {
                permission BarPermission "... ${{self}} ...";
            };
        
</pre>
In the above example, "duke" will first be expanded into
<b>javax.security.auth.x500.X500Principal "cn=Duke"</b> assuming
the X.509 certificate associated with the KeyStore alias, "duke",
has a subject distinguished name of "cn=Duke". Next, ${{self}} will
be replaced with the same principal information that just got
expanded in the grant clause:
<b>javax.security.auth.x500.X500Principal "cn=Duke"</b>.</li>
<li>${{alias:<i>alias_name</i>}}
<p>The protocol, <b>alias</b>, denotes a java.security.KeyStore
alias substitution. The <code>KeyStore</code> used is the one
specified in the <a href="#a20131">KeyStore entry</a>.
<i>alias_name</i> represents an alias into the
<code>KeyStore</code>. ${{alias:<i>alias_name</i>}} is replaced
with <b>javax.security.auth.x500.X500Principal "DN"</b>, where
<i>DN</i> represents the subject distinguished name of the
certificate belonging to <i>alias_name</i>. For example:</p>
<pre>
            keystore "http://foo.bar.example.com/blah/.keystore";

            grant codebase "www.foo.example.com" {
                permission BarPermission "... ${{alias:duke}} ...";
            };
        
</pre>
In the above example the X.509 certificate associated with the
alias, <i>duke</i>, is retrieved from the <code>KeyStore</code>,
<i>foo.bar.example.com/blah/.keystore</i>. Assuming duke's
certificate specifies "o=dukeOrg, cn=duke" as the subject
distinguished name, then ${{alias:duke}} is replaced with
<b>javax.security.auth.x500.X500Principal "o=dukeOrg, cn=duke"</b>.
<p>The permission entry is ignored under the following error
conditions:</p>
<ul>
<li>The keystore entry is unspecified</li>
<li>The <i>alias_name</i> is not provided</li>
<li>The certificate for <i>alias_name</i> can not be retrieved</li>
<li>The certificate retrieved is not an X.509 certificate</li>
</ul>
</li>
</ol>
<h4><i>3.3.4 Assigning Permissions</i></h4>
<a name="a20233" id="a20233"><!-- --></a> When a principal executes
a class that originated from a particular CodeSource, the security
mechanism consults the policy object to determine what permissions
to grant. This is done by invoking the <code>getPermissions</code>
or <code>implies</code> method on the Policy object that is
installed in the VM.
<p><a name="a20161" id="a20161"><!-- --></a> Clearly, a given code
source in a ProtectionDomain can match the code source given in
multiple entries in the policy, for example because the wildcard
"*" is allowed.</p>
<p><a name="a20162" id="a20162"><!-- --></a> The following
algorithm is used to locate the appropriate set of permissions in
the policy.</p>
<pre>
1. match the public keys, if code is signed.
2. if a key is not recognized in the policy, ignore the key
   if every key is ignored, treat the code as unsigned.
3. if the keys are matched, or no signer was specified {
       try to match all URLs in the policy for the keys
   }
4. if the keys are matched (or no signer was specified),
   and the URLs are matched (or no codebase was specified) {
       try to match all principals in the policy with
       the principals associated with the current executing thread.
5. if either key, URL, or principals are not matched, use built-in default
       permission, which is the original sandbox permission.
</pre>
<a name="a29102" id="a29102"><!-- --></a> The exact meaning of a
policy entry codeBase URL value depends on the characters at the
end. A codeBase with a trailing "/" matches all class files (not
JAR files) in the specified directory. A codeBase with a trailing
"/*" matches all files (both class and JAR files) contained in that
directory. A codeBase with a trailing "/-" matches all files (both
class and JAR files) in the directory and recursively all files in
subdirectories contained in that directory.
<p><a name="a29117" id="a29117"><!-- --></a> As an example, given
"http://example.com/-" in the policy, then any code base that is
on this web site matches the policy entry. Matching code bases
include "http://example.com/j2se/sdk/" and
"http://example.com/people/gong/appl.jar".</p>
<p><a name="a20772" id="a20772"><!-- --></a> If multiple entries
are matched, then all the permissions given in those entries are
granted. In other words, permission assignment is additive. For
example, if code signed with key A gets permission X and code
signed by key B gets permission Y and no particular codebase is
specified, then code signed by both A and B gets permissions X and
Y. Similarly, if code with codeBase "http://example.com/-" is
given permission X, and "http://example.com/people/*" is given
permission Y, and no particular signers are specified, then an
applet from "http://example.com/people/applet.jar" gets both X and
Y.</p>
<p><a name="a20770" id="a20770"><!-- --></a> Note that URL matching
here is purely syntactic. For example, a policy can give an entry
that specifies a URL "ftp://ftp.sun.com". Such an entry is useful
only when one can obtain Java code directly from ftp for
execution.</p>
<p><a name="a23755" id="a23755"><!-- --></a> To specify URLs for
the local file system, a file URL can be used. For example, to
specify files in the /home/cathy/temp directory in a Solaris
system, you'd use</p>
<pre>
"file:/home/cathy/temp/*"
</pre>
<a name="a23757" id="a23757"><!-- --></a> To specify files in the
"temp" directory on the C drive in a Windows system, use
<pre>
"file:/c:/temp/*"
</pre>
<a name="a23759" id="a23759"><!-- --></a> Note: code base URLs
always use slashes (no backlashes), regardless of the platform they
apply to.
<p><a name="a23753" id="a23753"><!-- --></a> You can also use an
absolute path name such as</p>
<pre>
"/home/gong/bin/MyWonderfulJava"
</pre>
<br />
<a name="a23883" id="a23883"><!-- --></a>
<h4><i>3.3.5 Default System and User Policy Files</i></h4>
<a name="a27128" id="a27128"><!-- --></a> In the Policy reference
implementation, the policy can be specified within one or more
policy configuration files. The configuration files specify what
permissions are allowed for code from specified code sources.
<p><a name="a27131" id="a27131"><!-- --></a> A policy file can be
composed via a simple text editor, or via a graphical PolicyTool
utility that is described later.</p>
<p><a name="a27133" id="a27133"><!-- --></a> There is by default a
single system-wide policy file, and a single user policy file.</p>
<p><a name="a27135" id="a27135"><!-- --></a> The system policy file
is by default located at</p>
<pre>
{java.home}/lib/security/java.policy  (Solaris)
{java.home}\lib\security\java.policy  (Windows)
</pre>
<a name="a27138" id="a27138"><!-- --></a> Here, <em>java.home</em>
is a system property specifying the directory into which the Java 2
SDK was installed.
<p><a name="a27140" id="a27140"><!-- --></a> The user policy file
is by default located at</p>
<pre>
{user.home}/.java.policy  (Solaris)
{user.home}\.java.policy  (Windows)
</pre>
<a name="a27143" id="a27143"><!-- --></a> Here, <em>user.home</em>
is a system property specifying the user's home directory.
<p><a name="a27144" id="a27144"><!-- --></a> When the Policy is
initialized, the system policy is loaded in first, and then the
user policy is added to it. If neither policy is present, a
built-in policy is used. This built-in policy is the same as the
original sandbox policy.</p>
<p><a name="a27148" id="a27148"><!-- --></a> Policy file locations
are specified in the security properties file, which is located
at</p>
<pre>
{java.home}/lib/security/java.security  (Solaris)
{java.home}\lib/security\java.security  (Windows)
</pre>
<a name="a27152" id="a27152"><!-- --></a> The policy file locations
are specified as the values of properties whose names are of the
form
<pre>
policy.url.<em>n
</em>
</pre>
<a name="a27155" id="a27155"><!-- --></a> Here, <em>n</em> is a
number. You specify each such property value in a line of the
following form:
<pre>
policy.url.n=<em>URL
</em>
</pre>
<a name="a28997" id="a28997"><!-- --></a> Here, <em>URL</em> is a
URL specification. For example, the default system and user policy
files are defined in the security properties file as
<pre>
policy.url.1=file:${java.home}/lib/security/java.policy
policy.url.2=file:${user.home}/.java.policy
</pre>
<a name="a27159" id="a27159"><!-- --></a> You can actually specify
a number of URLs, including ones of the form "http://", and all the
designated policy files will get loaded. You can also comment out
or change the second one to disable reading the default user policy
file.
<p><a name="a27163" id="a27163"><!-- --></a> The algorithm starts
at policy.url.1, and keeps incrementing until it does not find a
URL. Thus if you have policy.url.1 and policy.url.3, policy.url.3
will never be read.</p>
<p><a name="a27166" id="a27166"><!-- --></a> It is also possible to
specify an additional or a different policy file when invoking
execution of an application. This can be done via the
"-Djava.security.policy" command-line argument, which sets the
value of the <em>java.security.policy</em> property. For example,
if you use</p>
<pre>
java -Djava.security.manager -Djava.security.policy=<em>pURL</em> SomeApp
</pre>
<a name="a27170" id="a27170"><!-- --></a> Here, <em>pURL</em> is a
URL specifying the location of a policy file, then the specified
policy file will be loaded in addition to all the policy files that
are specified in the security properties file. (The
"-Djava.security.manager" argument ensures that the default
security manager is installed, and thus the application is subject
to policy checks, as described in "Security Management for Applets
and Applications". It is not required if the application
<em>SomeApp</em> installs a security manager.)
<p><a name="a29013" id="a29013"><!-- --></a> If you use the
following, with a double equals, then just the specified policy
file will be used; all others will be ignored.</p>
<pre>
java -Djava.security.manager -Djava.security.policy==<em>pURL</em> SomeApp
</pre>
<a name="a27430" id="a27430"><!-- --></a> If you want to pass a
policy file to the appletviewer, again use a
"-Djava.security.policy" argument as follows:
<pre>
appletviewer -J-Djava.security.policy=pURL  myApplet
</pre>
<a name="a27509" id="a27509"><!-- --></a> Please note: The
"-Djava.security.policy" policy file value will be ignored (for
both java and appletviewer commands) if the
"policy.allowSystemProperty" property in the security properties
file is set to false. The default is true.<br />
<a name="a27428" id="a27428"><!-- --></a>
<h4><i>3.3.6 Customizing Policy Evaluation</i></h4>
<a name="a20394" id="a20394"><!-- --></a> The current design of the
Policy class is not as comprehensive as it could be. We have given
the issues much thought and are progressing cautiously, partly to
ensure that we define method calls that are appropriate for the
most common cases. <em>For the meantime</em>, an alternative policy
class can be given to replace the default policy class, as long as
the former is a subclass of the abstract Policy class and
implements the <code>getPermissions</code> method (and other
methods as necessary).
<p><a name="a23576" id="a23576"><!-- --></a> The Policy reference
implementation can be changed by resetting the value of the
"policy.provider" security property (in the security properties
file) to the fully qualified name of the desired Policy
implementation class. The security properties file is located in
the file named</p>
<pre>
{java.home}/lib/security/java.security (Solaris)
{java.home}\lib\security\java.security (Windows)
</pre>
<a name="a24098" id="a24098"><!-- --></a> Here, {java.home} refers
to the directory where the runtime environment is installed --
either the <tt>jre</tt> directory inside the Java 2 SDK, or the
top-level directory of the Java 2 Runtime Environment.
<p><a name="a21107" id="a21107"><!-- --></a> The property
policy.provider specifies the name of the policy class, and the
default is the following:</p>
<pre>
policy.provider=sun.security.provider.PolicyFile
</pre>
<a name="a21109" id="a21109"><!-- --></a> To customize, you can
change the property value to specify another class, as in
<pre>
policy.provider=com.mycom.MyPolicy
</pre>
<a name="a21112" id="a21112"><!-- --></a> Note that the MyPolicy
class must be a subclass of java.security.Policy. It is perhaps
worth emphasizing that such an override of the policy class is a
temporary solution and a more comprehensive policy API will
probably make this unnecessary.<br />
<h3><a name="a28292" id="a28292"><!-- --></a> <i>3.4</i>
java.security.GeneralSecurityException</h3>
<a name="a28293" id="a28293"><!-- --></a> This is a new exception
class that is a subclass of java.lang.Exception. The intention is
that there should be two types of exceptions associated with
security and the security packages.
<ul>
<li><a name="a28294" id="a28294"><!-- --></a>
java.lang.SecurityException and its subclasses should be runtime
exceptions (unchecked, not declared) that are likely to cause the
execution of a program to stop.</li>
</ul>
<a name="a28295" id="a28295"><!-- --></a> Such an exception is
thrown only when some sort of security violation is detected. For
example, such an exception is thrown when some code attempts to
access a file, but it does not have permission for the access.
Application developers may catch these exceptions, if they want.
<ul>
<li><a name="a28296" id="a28296"><!-- --></a>
java.security.GeneralSecurityException, which is a subclass of
java.lang.Exception (must be declared or caught) that is thrown in
all other cases from within the security packages.</li>
</ul>
<a name="a28297" id="a28297"><!-- --></a> Such an exception is
security related but non-vital. For example, passing in an invalid
key is probably not a security violation and should be caught and
dealt with by a developer.
<p><a name="a28298" id="a28298"><!-- --></a> There are currently
still two exceptions within the java.security package that are
subclasses from RuntimeException. We at this moment cannot change
these due to backward compatibility requirements. We will revisit
this issue in the future.</p>
<br />
<hr />
<a href="security-specTOC.fm.html">CONTENTS</a>| <a href=
"security-spec.doc2.html">PREV</a>| <a href=
"security-spec.doc4.html">NEXT</a>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
