<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>Java Object Serialization Specification: 1 - System
Architecture</title>
</head>
<body bgcolor="#FFFFFF">
<table width="100%" summary="">
<tr>
<td>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --><a href="serialTOC.html">CONTENTS</a> |
<a href="changelog.html">PREV</a> | <a href="output.html">NEXT</a> 
<!-- | <a href="examples.html">INDEX</a>  -->
<!-- /font --></td>
<td align="right"><i>Java Object Serialization Specification<br />
version 6.0</i></td>
</tr>
</table>
<br />
<a name="a5800" id="a5800"><!-- --></a>
<h1>System Architecture</h1>
<!--
<hr size="1" width="100%" align="left" noshade>
-->
<br />
<br />
<br />
<a name="a5801" id="a5801"><!-- --></a>
<hr size="8" width="35%" align="left" noshade="noshade" />
<p><u><b>CHAPTER 1</b></u></p>
<br />
<a name="a5802" id="a5802"><!-- --></a>
<h2><i>Topics:</i></h2>
<ul>
<li><a name="a3543" id="a3543"><!-- --></a> <a href=
"serial-arch.html#a6428">Overview</a></li>
<li><a name="a3548" id="a3548"><!-- --></a> <a href=
"serial-arch.html#a4176">Writing to an Object Stream</a></li>
<li><a name="a3549" id="a3549"><!-- --></a> <a href=
"serial-arch.html#a4188">Reading from an Object Stream</a></li>
<li><a name="a4171" id="a4171"><!-- --></a> <a href=
"serial-arch.html#a962">Object Streams as Containers</a></li>
<li><a name="a6275" id="a6275"><!-- --></a> <a href=
"serial-arch.html#a6250">Defining Serializable Fields for a
Class</a></li>
<li><a name="a6447" id="a6447"><!-- --></a> <a href=
"serial-arch.html#a5251">Documenting Serializable Fields and Data
for a Class</a></li>
<li><a name="a5868" id="a5868"><!-- --></a> <a href=
"serial-arch.html#a5253">Accessing Serializable Fields of a
Class</a></li>
<li><a name="a4556" id="a4556"><!-- --></a> <a href=
"serial-arch.html#a4542">The ObjectOutput Interface</a></li>
<li><a name="a4561" id="a4561"><!-- --></a> <a href=
"serial-arch.html#a4548">The ObjectInput Interface</a></li>
<li><a name="a4526" id="a4526"><!-- --></a> <a href=
"serial-arch.html#a4539">The Serializable Interface</a></li>
<li><a name="a4889" id="a4889"><!-- --></a> <a href=
"serial-arch.html#a7185">The Externalizable Interface</a></li>
<li><a name="a7308" id="a7308"><!-- --></a> <a href=
"serial-arch.html#a6469">Serialization of Enum Constants</a></li>
<li><a name="a6425" id="a6425"><!-- --></a> <a href=
"serial-arch.html#a7231">Protecting Sensitive Information</a></li>
</ul>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a6428" id="a6428"><i>1.1</i> Overview</a></h2>
<a name="a3539" id="a3539"><!-- --></a> The ability to store and
retrieve Java<sup>TM</sup> objects is essential to building all but
the most transient applications. The key to storing and retrieving
objects in a serialized form is representing the state of objects
sufficient to reconstruct the object(s). Objects to be saved in the
stream may support either the <code>Serializable</code> or the
<code>Externalizable</code> interface. For Java<sup>TM</sup>
objects, the serialized form must be able to identify and verify
the Java<sup>TM</sup> class from which the contents of the object
were saved and to restore the contents to a new instance. For
serializable objects, the stream includes sufficient information to
restore the fields in the stream to a compatible version of the
class. For Externalizable objects, the class is solely responsible
for the external format of its contents.
<p><a name="a1081" id="a1081"><!-- --></a> Objects to be stored and
retrieved frequently refer to other objects. Those other objects
must be stored and retrieved at the same time to maintain the
relationships between the objects. When an object is stored, all of
the objects that are reachable from that object are stored as
well.</p>
<p><a name="a999" id="a999"><!-- --></a> The goals for serializing
Java<sup>TM</sup> objects are to:</p>
<ul>
<li><a name="a1010" id="a1010"><!-- --></a> Have a simple yet
extensible mechanism.</li>
<li><a name="a1011" id="a1011"><!-- --></a> Maintain the
Java<sup>TM</sup> object type and safety properties in the
serialized form.</li>
<li><a name="a3223" id="a3223"><!-- --></a> Be extensible to
support marshaling and unmarshaling as needed for remote
objects.</li>
<li><a name="a1003" id="a1003"><!-- --></a> Be extensible to
support simple persistence of Java<sup>TM</sup> objects.</li>
<li><a name="a1041" id="a1041"><!-- --></a> Require per class
implementation only for customization.</li>
<li><a name="a3844" id="a3844"><!-- --></a> Allow the object to
define its external format.</li>
</ul>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a4176" id="a4176"><i>1.2</i> Writing to an Object
Stream</a></h2>
<a name="a4177" id="a4177"><!-- --></a> Writing objects and
primitives to a stream is a straightforward process. For example:
<p><a name="a4178" id="a4178"><!-- --></a></p>
<pre>
// Serialize today&#39;s date to a file.
    FileOutputStream f = new FileOutputStream("tmp");
    ObjectOutput&#160;s&#160;=&#160;new&#160;ObjectOutputStream(f);
    s.writeObject("Today");
    s.writeObject(new Date());
    s.flush();
</pre>
<a name="a4179" id="a4179"><!-- --></a> First an
<code>OutputStream</code>, in this case a
<code>FileOutputStream</code>, is needed to receive the bytes. Then
an <code>ObjectOutputStream</code> is created that writes to the
<code>FileOutputStream</code>. Next, the string &#34;Today&#34; and
a Date object are written to the stream. More generally, objects
are written with the <code>writeObject</code> method and primitives
are written to the stream with the methods of
<code>DataOutput</code>.
<p><a name="a4184" id="a4184"><!-- --></a> The <code><a href=
"output.html#a1038">writeObject</a></code> method (see <a href=
"output.html#a861">Section&#160;2.3, &#34;The writeObject
Method</a>&#34;) serializes the specified object and traverses its
references to other objects in the object graph recursively to
create a complete serialized representation of the graph. Within a
stream, the first reference to any object results in the object
being serialized or externalized and the assignment of a handle for
that object. Subsequent references to that object are encoded as
the handle. Using object handles preserves sharing and circular
references that occur naturally in object graphs. Subsequent
references to an object use only the handle allowing a very compact
representation.</p>
<p><a name="a4185" id="a4185"><!-- --></a> Special handling is
required for arrays, enum constants, and objects of type
<code>Class</code>, <code>ObjectStreamClass</code>, and
<code>String</code>. Other objects must implement either the
<code>Serializable</code> or the <code>Externalizable</code>
interface to be saved in or restored from a stream.</p>
<p><a name="a5809" id="a5809"><!-- --></a> Primitive data types are
written to the stream with the methods in the
<code>DataOutput</code> interface, such as <code>writeInt</code>,
<code>writeFloat</code>, or <code>writeUTF</code>. Individual bytes
and arrays of bytes are written with the methods of
<code>OutputStream</code>. Except for serializable fields,
primitive data is written to the stream in block-data records, with
each record prefixed by a marker and an indication of the number of
bytes in the record.</p>
<p><a name="a5817" id="a5817"><!-- --></a>
<code>ObjectOutputStream</code> can be extended to customize the
information about classes in the stream or to replace objects to be
serialized. Refer to the <code>annotateClass</code> and
<code>replaceObject</code> method descriptions for details.</p>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a4188" id="a4188"><i>1.3</i> Reading from an Object
Stream</a></h2>
<a name="a4189" id="a4189"><!-- --></a> Reading an object from a
stream, like writing, is straightforward:
<p><a name="a4190" id="a4190"><!-- --></a></p>
<pre>
// Deserialize a string and date from a file.
    FileInputStream in = new FileInputStream(&#34;tmp&#34;);
    ObjectInputStream s = new ObjectInputStream(in);
    String today = (String)s.readObject();
    Date date = (Date)s.readObject();
</pre>
<a name="a4191" id="a4191"><!-- --></a> First an
<code>InputStream</code>, in this case a
<code>FileInputStream</code>, is needed as the source stream. Then
an <code>ObjectInputStream</code> is created that reads from the
<code>InputStream</code>. Next, the string &#34;Today&#34; and a
Date object are read from the stream. Generally, objects are read
with the <code>readObject</code> method and primitives are read
from the stream with the methods of <code>DataInput</code>.
<p><a name="a4195" id="a4195"><!-- --></a> The <code><a href=
"input.html#a2971">readObject</a></code> method deserializes the
next object in the stream and traverses its references to other
objects recursively to create the complete graph of objects
serialized.</p>
<p><a name="a4248" id="a4248"><!-- --></a> Primitive data types are
read from the stream with the methods in the <code>DataInput</code>
interface, such as <code>readInt</code>, <code>readFloat</code>, or
<code>readUTF</code>. Individual bytes and arrays of bytes are read
with the methods of <code>InputStream</code>. Except for
serializable fields, primitive data is read from block-data
records.</p>
<p><a name="a4199" id="a4199"><!-- --></a>
<code>ObjectInputStream</code> can be extended to utilize
customized information in the stream about classes or to replace
objects that have been deserialized. Refer to the
<code>resolveClass</code> and <code>resolveObject</code> method
descriptions for details.</p>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a962" id="a962"><i>1.4</i> Object Streams as
Containers</a></h2>
<a name="a4267" id="a4267"><!-- --></a> Object Serialization
produces and consumes a stream of bytes that contain one or more
primitives and objects. The objects written to the stream, in turn,
refer to other objects, which are also represented in the stream.
Object Serialization produces just one stream format that encodes
and stores the contained objects.
<p><a name="a4374" id="a4374"><!-- --></a> Each object that acts as
a container implements an interface which allows primitives and
objects to be stored in or retrieved from it. These interfaces are
the <code>ObjectOutput</code> and <code>ObjectInput</code>
interfaces which:</p>
<ul>
<li><a name="a4417" id="a4417"><!-- --></a> Provide a stream to
write to and to read from</li>
<li><a name="a7056" id="a7056"><!-- --></a> Handle requests to
write primitive types and objects to the stream</li>
<li><a name="a4418" id="a4418"><!-- --></a> Handle requests to read
primitive types and objects from the stream</li>
</ul>
<a name="a4357" id="a4357"><!-- --></a> Each object which is to be
stored in a stream must explicitly allow itself to be stored and
must implement the protocols needed to save and restore its state.
Object Serialization defines two such protocols. The protocols
allow the container to ask the object to write and read its state.
<p><a name="a7090" id="a7090"><!-- --></a> To be stored in an
Object Stream, each object must implement either the
<code>Serializable</code> or the <code>Externalizable</code>
interface:</p>
<ul>
<li><a name="a5805" id="a5805"><!-- --></a> For a
<code>Serializable</code> class, Object Serialization can
automatically save and restore fields of each class of an object
and automatically handle classes that evolve by adding fields or
supertypes. A serializable class can declare which of its fields
are saved or restored, and write and read optional values and
objects.</li>
<li><a name="a6552" id="a6552"><!-- --></a> For an
<code>Externalizable</code> class, Object Serialization delegates
to the class complete control over its external format and how the
state of the supertype(s) is saved and restored.</li>
</ul>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a6250" id="a6250"><i>1.5</i> Defining Serializable
Fields for a Class</a></h2>
<a name="a7370" id="a7370"><!-- --></a> The serializable fields of
a class can be defined two different ways. Default serializable
fields of a class are defined to be the non-transient and
non-static fields. This default computation can be overridden by
declaring a special field in the <code>Serializable</code> class,
<code>serialPersistentFields</code>. This field must be initialized
with an array of <code>ObjectStreamField</code> objects that list
the names and types of the serializable fields. The modifiers for
the field are required to be private, static, and final. If the
field&#39;s value is null or is otherwise not an instance of
<code>ObjectStreamField[]</code>, or if the field does not have the
required modifiers, then the behavior is as if the field were not
declared at all.
<p><a name="a7412" id="a7412"><!-- --></a> For example, the
following declaration duplicates the default behavior.</p>
<p><a name="a6853" id="a6853"><!-- --></a></p>
<pre>
class List implements Serializable {
    List next;

    private static final ObjectStreamField[] serialPersistentFields
                 = {new ObjectStreamField(&#34;next&#34;, List.class)};
</pre>
<a name="a6854" id="a6854"><!-- --></a>
<pre>
}
</pre>
<a name="a7105" id="a7105"><!-- --></a> By using
<code>serialPersistentFields</code> to define the Serializable
fields for a class, there no longer is a limitation that a
serializable field must be a field within the current definition of
the <code>Serializable</code> class. The <code>writeObject</code>
and <code>readObject</code> methods of the
<code>Serializable</code> class can map the current implementation
of the class to the serializable fields of the class using the
interface that is described in <a href=
"serial-arch.html#a5253">Section&#160;1.7, &#34;Accessing
Serializable Fields of a Class</a>.&#34; Therefore, the fields for
a <code>Serializable</code> class can change in a later release, as
long as it maintains the mapping back to its Serializable fields
that must remain compatible across release boundaries.
<hr noshade="noshade" size="1" />
<b><a name="a7110" id="a7110">Note -</a></b> There is, however, a
limitation to the use of this mechanism to specify serializable
fields for inner classes. Inner classes can only contain final
static fields that are initialized to constants or expressions
built up from constants. Consequently, it is not possible to set
<code>serialPersistentFields</code> for an inner class (though it
is possible to set it for static member classes). For other
restrictions pertaining to serialization of inner class instances,
see section <a href="serial-arch.html#a4539">Section&#160;1.10,
&#34;The Serializable Interface</a>&#34;.
<hr noshade="noshade" size="1" />
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a5251" id="a5251"><i>1.6</i> Documenting Serializable
Fields and Data for a Class</a></h2>
<a name="a6925" id="a6925"><!-- --></a> It is important to document
the serializable state of a class to enable interoperability with
alternative implementations of a Serializable class and to document
class evolution. Documenting a serializable field gives one a final
opportunity to review whether or not the field should be
serializable. The serialization javadoc tags, <code>@serial</code>,
<code>@serialField</code>, and <code>@serialData</code>, provide a
way to document the serialized form for a Serializable class within
the source code.
<ul>
<li><a name="a6812" id="a6812"><!-- --></a> The
<code>@serial</code> tag should be placed in the javadoc comment
for a default serializable field. The syntax is as follows:
<code>@serial</code> <em>field-description</em> The optional
<em>field-description</em> describes the meaning of the field and
its acceptable values. The <em>field-description</em> can span
multiple lines. When a field is added after the initial release, a
<em>@since</em> tag indicates the version the field was added. The
<em>field-description</em> for <code>@serial</code> provides
serialization-specific documentation and is appended to the javadoc
comment for the field within the serialized form
documentation.</li>
<li><a name="a6813" id="a6813"><!-- --></a> The
<code>@serialField</code> tag is used to document an
<code>ObjectStreamField</code> component of a
<code>serialPersistentFields</code> array. One of these tags should
be used for each <code>ObjectStreamField</code> component. The
syntax is as follows: <code>@serialField</code> <em>field-name
field-type field-description</em></li>
<li><a name="a6814" id="a6814"><!-- --></a> The
<code>@serialData</code> tag describes the sequences and types of
data written or read. The tag describes the sequence and type of
optional data written by <code>writeObject</code> or all data
written by the <code>Externalizable.writeExternal</code> method.
The syntax is as follows: <code>@serialData</code>
<em>data-description</em></li>
</ul>
<a name="a6835" id="a6835"><!-- --></a> The javadoc application
recognizes the serialization javadoc tags and generates a
specification for each Serializable and Externalizable class. See
<a href="examples.html#a4420">Section&#160;C.1, &#34;Example
Alternate Implementation of java.io.File</a>&#34; for an example
that uses these tags.
<p><a name="a6836" id="a6836"><!-- --></a> When a class is declared
Serializable, the serializable state of the object is defined by
serializable fields (by name and type) plus optional data. Optional
data can only be written explicitly by the <code>writeObject</code>
method of a <code>Serializable</code> class. Optional data can be
read by the <code>Serializable</code> class&#39;
<code>readObject</code> method or serialization will skip unread
optional data.</p>
<p><a name="a6834" id="a6834"><!-- --></a> When a class is declared
Externalizable, the data that is written to the stream by the class
itself defines the serialized state. The class must specify the
order, types, and meaning of each datum that is written to the
stream. The class must handle its own evolution, so that it can
continue to read data written by and write data that can be read by
previous versions. The class must coordinate with the superclass
when saving and restoring data. The location of the superclasses
data in the stream must be specified.</p>
<p><a name="a6915" id="a6915"><!-- --></a> The designer of a
Serializable class must ensure that the information saved for the
class is appropriate for persistence and follows the
serialization-specified rules for interoperability and evolution.
Class evolution is explained in greater detail in <a href=
"version.html#a9420">Chapter&#160;5</a>, &#34;Versioning of
Serializable Objects.&#34;</p>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a5253" id="a5253"><i>1.7</i> Accessing Serializable
Fields of a Class</a></h2>
<a name="a5520" id="a5520"><!-- --></a> Serialization provides two
mechanisms for accessing the serializable fields in a stream:
<ul>
<li><a name="a6679" id="a6679"><!-- --></a> The default mechanism
requires no customization</li>
<li><a name="a6680" id="a6680"><!-- --></a> The Serializable Fields
API allows a class to explicitly access/set the serializable fields
by name and type</li>
</ul>
<a name="a5254" id="a5254"><!-- --></a> The default mechanism is
used automatically when reading or writing objects that implement
the <code>Serializable</code> interface and do no further
customization. The serializable fields are mapped to the
corresponding fields of the class and values are either written to
the stream from those fields or are read in and assigned
respectively. If the class provides <code>writeObject</code> and
<code>readObject</code> methods, the default mechanism can be
invoked by calling <code>defaultWriteObject</code> and
<code>defaultReadObject</code>. When the <code>writeObject</code>
and <code>readObject</code> methods are implemented, the class has
an opportunity to modify the serializable field values before they
are written or after they are read.
<p><a name="a5255" id="a5255"><!-- --></a> When the default
mechanism cannot be used, the serializable class can use the
<code>putFields</code> method of <code>ObjectOutputStream</code> to
put the values for the serializable fields into the stream. The
<code>writeFields</code> method of <code>ObjectOutputStream</code>
puts the values in the correct order, then writes them to the
stream using the existing protocol for serialization.
Correspondingly, the <code>readFields</code> method of
<code>ObjectInputStream</code> reads the values from the stream and
makes them available to the class by name in any order. See
<a href="output.html#a5068">Section&#160;2.2, &#34;The
ObjectOutputStream.PutField Class</a>&#34; and <a href=
"input.html#a4936">Section&#160;3.2, &#34;The
ObjectInputStream.GetField Class</a>.&#34; for a detailed
description of the Serializable Fields API.</p>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a4542" id="a4542"><i>1.8</i> The ObjectOutput
Interface</a></h2>
<a name="a4543" id="a4543"><!-- --></a> The
<code>ObjectOutput</code> interface provides an abstract,
stream-based interface to object storage. It extends the DataOutput
interface so those methods can be used for writing primitive data
types. Objects that implement this interface can be used to store
primitives and objects.
<p><a name="a4930" id="a4930"><!-- --></a></p>
<pre>
package java.io;

public interface ObjectOutput extends DataOutput
{
    public void writeObject(Object obj) throws IOException;
    public void write(int b) throws IOException;
    public void write(byte b[]) throws IOException;
     public void write(byte b[], int off, int len) throws IOException;
    public void flush() throws IOException;
    public void close() throws IOException;
}
</pre>
<a name="a4545" id="a4545"><!-- --></a> <code>The</code>
<code>writeObject</code> method is used to write an object. The
exceptions thrown reflect errors while accessing the object or its
fields, or exceptions that occur in writing to storage. If any
exception is thrown, the underlying storage may be corrupted. If
this occurs, refer to the object that is implementing this
interface for more information.
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a4548" id="a4548"><i>1.9</i> The ObjectInput
Interface</a></h2>
<a name="a4909" id="a4909"><!-- --></a> The
<code>ObjectInput</code> interface provides an abstract stream
based interface to object retrieval. It extends the
<code>DataInput</code> interface so those methods for reading
primitive data types are accessible in this interface.
<p><a name="a5029" id="a5029"><!-- --></a></p>
<pre>
package java.io;

public interface ObjectInput extends DataInput
{
    public Object readObject()
        throws ClassNotFoundException, IOException;
    public int read() throws IOException;
    public int read(byte b[]) throws IOException;
    public int read(byte b[], int off, int len) throws IOException;
    public long skip(long n) throws IOException;
    public int available() throws IOException;
    public void close() throws IOException;
}
</pre>
<a name="a4551" id="a4551"><!-- --></a> The <code>readObject</code>
method is used to read and return an object. The exceptions thrown
reflect errors while accessing the objects or its fields or
exceptions that occur in reading from the storage. If any exception
is thrown, the underlying storage may be corrupted. If this occurs,
refer to the object implementing this interface for additional
information.
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a4539" id="a4539"><i>1.10</i> The Serializable
Interface</a></h2>
<a name="a4444" id="a4444"><!-- --></a> Object Serialization
produces a stream with information about the Java<sup>TM</sup>
classes for the objects which are being saved. For serializable
objects, sufficient information is kept to restore those objects
even if a different (but compatible) version of the implementation
of the class is present. The <code>Serializable</code> interface is
defined to identify classes which implement the serializable
protocol:
<p><a name="a4461" id="a4461"><!-- --></a></p>
<pre>
package java.io;

public interface Serializable {};
</pre>
<a name="a4425" id="a4425"><!-- --></a> A Serializable class must
do the following:
<ul>
<li><a name="a4426" id="a4426"><!-- --></a> Implement the
<code>java.io.Serializable</code> interface</li>
<li><a name="a5928" id="a5928"><!-- --></a> Identify the fields
that should be serializable</li>
</ul>
<dl>
<dd><a name="a7084" id="a7084"><!-- --></a> (Use the
<code>serialPersistentFields</code> member to explicitly declare
them serializable or use the transient keyword to denote
nonserializable fields.)</dd>
</dl>
<ul>
<li><a name="a5929" id="a5929"><!-- --></a> Have access to the
no-arg constructor of its first nonserializable superclass</li>
</ul>
<a name="a7085" id="a7085"><!-- --></a> The class can optionally
define the following methods:
<ul>
<li><a name="a4428" id="a4428"><!-- --></a> A
<code>writeObject</code> method to control what information is
saved or to append additional information to the stream</li>
<li><a name="a6300" id="a6300"><!-- --></a> A
<code>readObject</code> method either to read the information
written by the corresponding <code>writeObject</code> method or to
update the state of the object after it has been restored</li>
<li><a name="a6532" id="a6532"><!-- --></a> A
<code>writeReplace</code> method to allow a class to nominate a
replacement object to be written to the stream</li>
</ul>
<dl>
<dd><a name="a7086" id="a7086"><!-- --></a> (See <a href=
"output.html#a5324">Section&#160;2.5, &#34;The writeReplace
Method</a>&#34; for additional information.)</dd>
</dl>
<ul>
<li><a name="a6533" id="a6533"><!-- --></a> A
<code>readResolve</code> method to allow a class to designate a
replacement object for the object just read from the stream</li>
</ul>
<dl>
<dd><a name="a7081" id="a7081"><!-- --></a> (See <a href=
"input.html#a5903">Section&#160;3.7, &#34;The readResolve
Method</a>&#34; for additional information.)</dd>
</dl>
<a name="a5895" id="a5895"><!-- --></a>
<code>ObjectOutputStream</code> and <code>ObjectInputStream</code>
allow the serializable classes on which they operate to evolve
(allow changes to the classes that are compatible with the earlier
versions of the classes). See <a href=
"version.html#a6519">Section&#160;5.5, &#34;Compatible
Java<sup>TM</sup> Type Evolution</a>&#34; for information about the
mechanism which is used to allow compatible changes.
<hr noshade="noshade" size="1" />
<b><a name="a7182" id="a7182">Note -</a></b> Serialization of inner
classes (i.e., nested classes that are not static member classes),
including local and anonymous classes, is strongly discouraged for
several reasons. Because inner classes declared in non-static
contexts contain implicit non-transient references to enclosing
class instances, serializing such an inner class instance will
result in serialization of its associated outer class instance as
well. Synthetic fields generated by <code>javac</code> (or other
Java<sup>TM</sup> compilers) to implement inner classes are
implementation dependent and may vary between compilers;
differences in such fields can disrupt compatibility as well as
result in conflicting default <code>serialVersionUID</code> values.
The names assigned to local and anonymous inner classes are also
implementation dependent and may differ between compilers. Since
inner classes cannot declare static members other than compile-time
constant fields, they cannot use the
<code>serialPersistentFields</code> mechanism to designate
serializable fields. Finally, because inner classes associated with
outer instances do not have zero-argument constructors
(constructors of such inner classes implicitly accept the enclosing
instance as a prepended parameter), they cannot implement
<code>Externalizable</code>. None of the issues listed above,
however, apply to static member classes.
<hr noshade="noshade" size="1" />
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a7185" id="a7185"><i>1.11</i> The Externalizable
Interface</a></h2>
<a name="a4334" id="a4334"><!-- --></a> For Externalizable objects,
only the identity of the class of the object is saved by the
container; the class must save and restore the contents. The
<code>Externalizable</code> interface is defined as follows:
<p><a name="a4465" id="a4465"><!-- --></a></p>
<pre>
package java.io;

public interface Externalizable extends Serializable
{
    public void writeExternal(ObjectOutput out)
        throws IOException;

    public void readExternal(ObjectInput in)
        throws IOException, java.lang.ClassNotFoundException;
}
</pre>
<a name="a3920" id="a3920"><!-- --></a> The class of an
Externalizable object must do the following:
<ul>
<li><a name="a3928" id="a3928"><!-- --></a> Implement the
<code>java.io.Externalizable</code> interface</li>
<li><a name="a3933" id="a3933"><!-- --></a> Implement a
<code>writeExternal</code> method to save the state of the
object</li>
</ul>
<dl>
<dd><a name="a7082" id="a7082"><!-- --></a> (It must explicitly
coordinate with its supertype to save its state.)</dd>
</dl>
<ul>
<li><a name="a3936" id="a3936"><!-- --></a> Implement a
<code>readExternal</code> method to read the data written by the
<code>writeExternal</code> method from the stream and restore the
state of the object</li>
</ul>
<dl>
<dd><a name="a7083" id="a7083"><!-- --></a> (It must explicitly
coordinate with the supertype to save its state.)</dd>
</dl>
<ul>
<li><a name="a3934" id="a3934"><!-- --></a> Have the
<code>writeExternal</code> and <code>readExternal</code> methods be
solely responsible for the format, if an externally defined format
is written</li>
</ul>
<hr noshade="noshade" size="1" />
<b><a name="a6336" id="a6336">Note -</a></b> The
<code>writeExternal</code> and <code>readExternal</code> methods
are public and raise the risk that a client may be able to write or
read information in the object other than by using its methods and
fields. These methods must be used only when the information held
by the object is not sensitive or when exposing it does not present
a security risk.
<hr noshade="noshade" size="1" />
<ul>
<li><a name="a7141" id="a7141"><!-- --></a> Have a public no-arg
constructor</li>
</ul>
<hr noshade="noshade" size="1" />
<b><a name="a7146" id="a7146">Note -</a></b> Inner classes
associated with enclosing instances cannot have no-arg
constructors, since constructors of such classes implicitly accept
the enclosing instance as a prepended parameter. Consequently the
<code>Externalizable</code> interface mechanism cannot be used for
inner classes and they should implement the
<code>Serializable</code> interface, if they must be serialized.
Several limitations exist for serializable inner classes as well,
however; see <a href="serial-arch.html#a4539">Section&#160;1.10,
&#34;The Serializable Interface</a>&#34;, for a full enumeration.
<hr noshade="noshade" size="1" />
<a name="a7139" id="a7139"><!-- --></a> An Externalizable class can
optionally define the following methods:
<ul>
<li><a name="a6385" id="a6385"><!-- --></a> A
<code>writeReplace</code> method to allow a class to nominate a
replacement object to be written to the stream</li>
</ul>
<dl>
<dd><a name="a7079" id="a7079"><!-- --></a> (See <a href=
"output.html#a5324">Section&#160;2.5, &#34;The writeReplace
Method</a>&#34; for additional information.)</dd>
</dl>
<ul>
<li><a name="a6338" id="a6338"><!-- --></a> A
<code>readResolve</code> method to allow a class to designate a
replacement object for the object just read from the stream</li>
</ul>
<dl>
<dd><a name="a7080" id="a7080"><!-- --></a> (See <a href=
"input.html#a5903">Section&#160;3.7, &#34;The readResolve
Method</a>&#34; for additional information.)</dd>
</dl>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a6469" id="a6469"><i>1.12</i> Serialization of Enum
Constants</a></h2>
<a name="a7232" id="a7232"><!-- --></a> Enum constants are
serialized differently than ordinary serializable or externalizable
objects. The serialized form of an enum constant consists solely of
its name; field values of the constant are not present in the form.
To serialize an enum constant, <code>ObjectOutputStream</code>
writes the value returned by the enum constant&#39;s
<code>name</code> method. To deserialize an enum constant,
<code>ObjectInputStream</code> reads the constant name from the
stream; the deserialized constant is then obtained by calling the
<code>java.lang.Enum.valueOf</code> method, passing the
constant&#39;s enum type along with the received constant name as
arguments. Like other serializable or externalizable objects, enum
constants can function as the targets of back references appearing
subsequently in the serialization stream.
<p><a name="a7248" id="a7248"><!-- --></a> The process by which
enum constants are serialized cannot be customized: any
class-specific <code>writeObject</code>, <code>readObject</code>,
<code>readObjectNoData</code>, <code>writeReplace</code>, and
<code>readResolve</code> methods defined by enum types are ignored
during serialization and deserialization. Similarly, any
<code>serialPersistentFields</code> or
<code>serialVersionUID</code> field declarations are also
ignored--all enum types have a fixed <code>serialVersionUID</code>
of <code>0L</code>. Documenting serializable fields and data for
enum types is unnecessary, since there is no variation in the type
of data sent.</p>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a7231" id="a7231"><i>1.13</i> Protecting Sensitive
Information</a></h2>
<a name="a1414" id="a1414"><!-- --></a> When developing a class
that provides controlled access to resources, care must be taken to
protect sensitive information and functions. During
deserialization, the private state of the object is restored. For
example, a file descriptor contains a handle that provides access
to an operating system resource. Being able to forge a file
descriptor would allow some forms of illegal access, since
restoring state is done from a stream. Therefore, the serializing
runtime must take the conservative approach and not trust the
stream to contain only valid representations of objects. To avoid
compromising a class, the sensitive state of an object must not be
restored from the stream, or it must be reverified by the class.
Several techniques are available to protect sensitive data in
classes.
<p><a name="a1415" id="a1415"><!-- --></a> The easiest technique is
to mark fields that contain sensitive data as <em>private
transient</em>. Transient fields are not persistent and will not be
saved by any persistence mechanism. Marking the field will prevent
the state from appearing in the stream and from being restored
during deserialization. Since writing and reading (of private
fields) cannot be superseded outside of the class, the transient
fields of the class are safe.</p>
<p><a name="a1416" id="a1416"><!-- --></a> Particularly sensitive
classes should not be serialized at all. To accomplish this, the
object should not implement either the <code>Serializable</code> or
the <code>Externalizable</code> interface.</p>
<p><a name="a5785" id="a5785"><!-- --></a> Some classes may find it
beneficial to allow writing and reading but specifically handle and
revalidate the state as it is deserialized. The class should
implement <code>writeObject</code> and <code>readObject</code>
methods to save and restore only the appropriate state. If access
should be denied, throwing a <code>NotSerializableException</code>
will prevent further access.</p>
<p><br /></p>
<hr />
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --><a href="serialTOC.html">CONTENTS</a> |
<a href="changelog.html">PREV</a> | <a href="output.html">NEXT</a> 
<!-- | <a href="examples.html">INDEX</a>  -->
<!-- /font -->
<hr />
<font size="-1"><i><a href=
"../../../legal/SMICopyright.html">Copyright</a> &copy; 2005, 2010,
Oracle and/or its affiliates. All rights reserved.</i></font> 
<!-- This HTML file was created with Quadralay WebWorks Publisher Professional Edition 7.0.2.1128 -->
<!-- by Suzette Haines -->
<!-- Last updated: Mon Nov 21 12:31:33 2005 -->
</body>
</html>
