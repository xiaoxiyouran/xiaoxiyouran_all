<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>Java Object Serialization Specification: 3 - Object Input
Classes</title>
</head>
<body bgcolor="#FFFFFF">
<table summary="" width="100%">
<tr>
<td>
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --><a href="serialTOC.html">CONTENTS</a> |
<a href="output.html">PREV</a> | <a href="class.html">NEXT</a> 
<!-- | <a href="examples.html">INDEX</a>  -->
<!-- /font --></td>
<td align="right"><i>Java Object Serialization Specification<br />
version 6.0</i></td>
</tr>
</table>
<br />
<a name="a60" id="a60"><!-- --></a>
<h1>Object Input Classes</h1>
<!--
<hr size="1" width="100%" align="left" noshade>
-->
<br />
<br />
<br />
<a name="a64" id="a64"><!-- --></a>
<hr size="8" width="35%" align="left" noshade="noshade" />
<table summary="" border="0">
<tr valign="bottom">
<td valign="bottom"><br />
<u><b>CHAPTER 3</b></u></td>
</tr>
</table>
<br />
<a name="a883" id="a883"><!-- --></a>
<p><i>Topics:</i></p>
<ul>
<li><a name="a2983" id="a2983"><!-- --></a> <a href=
"input.html#a961">The ObjectInputStream Class</a></li>
<li><a name="a5224" id="a5224"><!-- --></a> <a href=
"input.html#a4936">The ObjectInputStream.GetField Class</a></li>
<li><a name="a2984" id="a2984"><!-- --></a> <a href=
"input.html#a3403">The ObjectInputValidation Interface</a></li>
<li><a name="a5887" id="a5887"><!-- --></a> <a href=
"input.html#a2971">The readObject Method</a></li>
<li><a name="a3424" id="a3424"><!-- --></a> <a href=
"input.html#a6014">The readExternal Method</a></li>
<li><a name="a5919" id="a5919"><!-- --></a> <a href=
"input.html#a5903">The readResolve Method</a></li>
</ul>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a961" id="a961"><i>3.1</i> The ObjectInputStream
Class</a></h2>
<a name="a1162" id="a1162"><!-- --></a> Class
<code>ObjectInputStream</code> implements object deserialization.
It maintains the state of the stream including the set of objects
already deserialized. Its methods allow primitive types and objects
to be read from a stream written by
<code>ObjectOutputStream</code>. It manages restoration of the
object and the objects that it refers to from the stream.
<p><a name="a5015" id="a5015"><!-- --></a></p>
<pre>
package java.io;

public class ObjectInputStream
    extends InputStream
    implements ObjectInput, ObjectStreamConstants
{
    public ObjectInputStream(InputStream in)
        throws StreamCorruptedException, IOException;
</pre>
<a name="a5233" id="a5233"><!-- --></a>
<pre>
    public final Object readObject()
        throws OptionalDataException, ClassNotFoundException, 
            IOException;

    public Object readUnshared()
        throws OptionalDataException, ClassNotFoundException, 
            IOException;

    public void defaultReadObject()
        throws IOException, ClassNotFoundException,
            NotActiveException;

    public GetField readFields()
        throws IOException;

    public synchronized void registerValidation(
        ObjectInputValidation obj, int prio)
        throws NotActiveException, InvalidObjectException;

    protected ObjectStreamClass readClassDescriptor()
        throws IOException, ClassNotFoundException;

    protected Class resolveClass(ObjectStreamClass v)
        throws IOException, ClassNotFoundException;

    protected Object resolveObject(Object obj)
        throws IOException;

    protected boolean enableResolveObject(boolean enable)
        throws SecurityException;

    protected void readStreamHeader()
        throws IOException, StreamCorruptedException;

    public int read() throws IOException;

    public int read(byte[] data, int offset, int length)
        throws IOException

    public int available() throws IOException;

    public void close() throws IOException;

    public boolean readBoolean() throws IOException;

    public byte readByte() throws IOException;

    public int readUnsignedByte() throws IOException;

    public short readShort() throws IOException;

    public int readUnsignedShort() throws IOException;

    public char readChar() throws IOException;

    public int readInt() throws IOException;

    public long readLong() throws IOException;

    public float readFloat() throws IOException;

    public double readDouble() throws IOException;

    public void readFully(byte[] data) throws IOException;

    public void readFully(byte[] data, int offset, int size)
        throws IOException;

    public int skipBytes(int len) throws IOException;

    public String readLine() throws IOException;

    public String readUTF() throws IOException;

    // Class to provide access to serializable fields.
    static abstract public class GetField
    {
        public ObjectStreamClass getObjectStreamClass();

        public boolean defaulted(String name)
            throws IOException, IllegalArgumentException;

        public char get(String name, char default)
            throws IOException, IllegalArgumentException;

        public boolean get(String name, boolean default)
            throws IOException, IllegalArgumentException;

        public byte get(String name, byte default)
            throws IOException, IllegalArgumentException;

        public short get(String name, short default)
            throws IOException, IllegalArgumentException;

        public int get(String name, int default)
            throws IOException, IllegalArgumentException;

        public long get(String name, long default)
            throws IOException, IllegalArgumentException;

        public float get(String name, float default)
            throws IOException, IllegalArgumentException;

        public double get(String name, double default)
            throws IOException, IllegalArgumentException;

        public Object get(String name, Object default)
            throws IOException, IllegalArgumentException;
    }

    protected ObjectInputStream()
        throws StreamCorruptedException, IOException;

    protected readObjectOverride()
        throws OptionalDataException, ClassNotFoundException,
            IOException;
}
</pre>
<a name="a1168" id="a1168"><!-- --></a>
<p>The single-argument <code>ObjectInputStream</code> constructor
requires an <code>InputStream</code>. The constructor calls
<code>readStreamHeader</code> to read and verifies the header and
version written by the corresponding
<code>ObjectOutputStream.writeStreamHeader</code> method. If a
security manager is installed, this constructor checks for the
<code>&#34;enableSubclassImplementation&#34;</code>
<code>SerializablePermission</code> when invoked directly or
indirectly by the constructor of a subclass which overrides the
<code>readFields</code> and/or <code>readUnshared</code>
methods.</p>
<hr noshade="noshade" size="1" />
<b><a name="a5998" id="a5998">Note -</a></b> The
<code>ObjectInputStream</code> constructor blocks until it
completes reading the serialization stream header. Code which waits
for an <code>ObjectInputStream</code> to be constructed before
creating the corresponding <code>ObjectOutputStream</code> for that
stream will deadlock, since the <code>ObjectInputStream</code>
constructor will block until a header is written to the stream, and
the header will not be written to the stream until the
<code>ObjectOutputStream</code> constructor executes. This problem
can be resolved by creating the <code>ObjectOutputStream</code>
before the <code>ObjectInputStream</code>, or otherwise removing
the timing dependency between completion of
<code>ObjectInputStream</code> construction and the creation of the
<code>ObjectOutputStream</code>.
<hr noshade="noshade" size="1" />
<a name="a1169" id="a1169"><!-- --></a> The <code>readObject</code>
method is used to deserialize an object from the stream. It reads
from the stream to reconstruct an object.
<p><a name="a5509" id="a5509"><!-- --></a></p>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>1.</strong></td>
<td width="89%" align="left" valign="baseline">If the
<code>ObjectInputStream</code> subclass is overriding the
implementation, call the <code>readObjectOverride</code> method and
return. Reimplementation is described at the end of this
section.</td>
</tr>
</table>
<a name="a5512" id="a5512"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>2.</strong></td>
<td width="89%" align="left" valign="baseline">If a block data
record occurs in the stream, throw a
<code>BlockDataException</code> with the number of available
bytes.</td>
</tr>
</table>
<a name="a4418" id="a4418"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>3.</strong></td>
<td width="89%" align="left" valign="baseline">If the object in the
stream is null, return null.</td>
</tr>
</table>
<a name="a5328" id="a5328"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>4.</strong></td>
<td width="89%" align="left" valign="baseline">If the object in the
stream is a handle to a previous object, return the object.</td>
</tr>
</table>
<a name="a5330" id="a5330"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>5.</strong></td>
<td width="89%" align="left" valign="baseline">If the object in the
stream is a <code>Class</code>, read its
<code>ObjectStreamClass</code> descriptor, add it and its handle to
the set of known objects, and return the corresponding
<code>Class</code> object.</td>
</tr>
</table>
<a name="a3491" id="a3491"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>6.</strong></td>
<td width="89%" align="left" valign="baseline">If the object in the
stream is an <code>ObjectStreamClass</code>, read in its data
according to the formats described in section <a href=
"class.html#a5421">4.3</a>. Add it and its handle to the set of
known objects. In versions 1.3 and later of the Java 2 SDK,
Standard Edition, the <code>readClassDescriptor</code> method is
called to read in the <code>ObjectStreamClass</code> if it
represents a class that is not a dynamic proxy class, as indicated
in the stream data. If the class descriptor represents a dynamic
proxy class, call the <code>resolveProxyClass</code> method on the
stream to get the local class for the descriptor; otherwise, call
the <code>resolveClass</code> method on the stream to get the local
class. If the class cannot be resolved, throw a
ClassNotFoundException. Return the resulting
<code>ObjectStreamClass</code> object.</td>
</tr>
</table>
<a name="a5334" id="a5334"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>7.</strong></td>
<td width="89%" align="left" valign="baseline">If the object in the
stream is a <code>String</code>, read its length information
followed by the contents of the string encoded in modified UTF-8.
For details, refer to <a href=
"protocol.html#a8299">Section&#160;6.2, &#34;Stream
Elements</a>&#34;. Add the <code>String</code> and its handle to
the set of known objects, and proceed to Step 12.</td>
</tr>
</table>
<a name="a3492" id="a3492"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>8.</strong></td>
<td width="89%" align="left" valign="baseline">If the object in the
stream is an array, read its <code>ObjectStreamClass</code> and the
length of the array. Allocate the array, and add it and its handle
in the set of known objects. Read each element using the
appropriate method for its type and assign it to the array. Proceed
to Step 12.</td>
</tr>
</table>
<a name="a3483" id="a3483"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>9.</strong></td>
<td width="89%" align="left" valign="baseline">If the object in the
stream is an enum constant, read its <code>ObjectStreamClass</code>
and the enum constant name. If the <code>ObjectStreamClass</code>
represents a class that is not an enum type, an
<code>InvalidClassException</code> is thrown. Obtain a reference to
the enum constant by calling the
<code>java.lang.Enum.valueOf</code> method, passing the enum type
bound to the received <code>ObjectStreamClass</code> along with the
received name as arguments. If the <code>valueOf</code> method
throws an <code>IllegalArgumentException</code>, an
<code>InvalidObjectException</code> is thrown with the
<code>IllegalArgumentException</code> as its cause. Add the enum
constant and its handle in the set of known objects, and proceed to
Step 12.</td>
</tr>
</table>
<a name="a6255" id="a6255"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>10.</strong></td>
<td width="89%" align="left" valign="baseline">For all other
objects, the <code>ObjectStreamClass</code> of the object is read
from the stream. The local class for that
<code>ObjectStreamClass</code> is retrieved. The class must be
serializable or externalizable, and must not be an enum type. If
the class does not satisfy these criteria, an
<code>InvalidClassException</code> is thrown.</td>
</tr>
</table>
<a name="a4917" id="a4917"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>11.</strong></td>
<td width="89%" align="left" valign="baseline">An instance of the
class is allocated. The instance and its handle are added to the
set of known objects. The contents restored appropriately:</td>
</tr>
</table>
<a name="a4918" id="a4918"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="12%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>a.</strong></td>
<td width="85%" align="left" valign="baseline">For serializable
objects, the no-arg constructor for the first non-serializable
supertype is run. For serializable classes, the fields are
initialized to the default value appropriate for its type. Then the
fields of each class are restored by calling class-specific
<code>readObject</code> methods, or if these are not defined, by
calling the <code>defaultReadObject</code> method. Note that field
initializers and constructors are not executed for serializable
classes during deserialization. In the normal case, the version of
the class that wrote the stream will be the same as the class
reading the stream. In this case, all of the supertypes of the
object in the stream will match the supertypes in the
currently-loaded class. If the version of the class that wrote the
stream had different supertypes than the loaded class, the
<code>ObjectInputStream</code> must be more careful about restoring
or initializing the state of the differing classes. It must step
through the classes, matching the available data in the stream with
the classes of the object being restored. Data for classes that
occur in the stream, but do not occur in the object, is discarded.
For classes that occur in the object, but not in the stream, the
class fields are set to default values by default
serialization.</td>
</tr>
</table>
<a name="a3584" id="a3584"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="12%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>b.</strong></td>
<td width="85%" align="left" valign="baseline">For externalizable
objects, the no-arg constructor for the class is run and then the
<code>readExternal</code> method is called to restore the contents
of the object.</td>
</tr>
</table>
<a name="a5072" id="a5072"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>12.</strong></td>
<td width="89%" align="left" valign="baseline">Process potential
substitutions by the class of the object and/or by a subclass of
<code>ObjectInputStream</code><code>:</code></td>
</tr>
</table>
<a name="a5078" id="a5078"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="12%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>a.</strong></td>
<td width="85%" align="left" valign="baseline">If the class of the
object is not an enum type and defines the appropriate
<code>readResolve</code> method, the method is called to allow the
object to replace itself.</td>
</tr>
</table>
<a name="a5079" id="a5079"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="12%">&nbsp;</td>
<td width="3%" align="left" valign="baseline">
<strong>b.</strong></td>
<td width="85%" align="left" valign="baseline">Then if previously
enabled by <code>enableResolveObject,</code> the
<code>resolveObject</code> method is called to allow subclasses of
the stream to examine and replace the object. If the previous step
did replace the original object, the <code>resolveObject</code>
method is called with the replacement object.</td>
</tr>
</table>
<a name="a5080" id="a5080"><!-- --></a>
<table summary="" border="0" width="100%">
<tr>
<td width="8%">&nbsp;</td>
<td width="3%" align="left" valign="baseline"></td>
<td width="89%" align="left" valign="baseline">If a replacement
took place, the table of known objects is updated so the
replacement object is associated with the handle. The replacement
object is then returned from <code>readObject</code>.</td>
</tr>
</table>
<a name="a3621" id="a3621"><!-- --></a>
<p>All of the methods for reading primitives types only consume
bytes from the block data records in the stream. If a read for
primitive data occurs when the next item in the stream is an
object, the read methods return <em>-1</em> or the
<code>EOFException</code> as appropriate. The value of a primitive
type is read by a <code>DataInputStream</code> from the block data
record.</p>
<a name="a4427" id="a4427"><!-- --></a> The exceptions thrown
reflect errors during the traversal or exceptions that occur on the
underlying stream. If any exception is thrown, the underlying
stream is left in an unknown and unusable state.
<p><a name="a4563" id="a4563"><!-- --></a> When the reset token
occurs in the stream, all of the state of the stream is discarded.
The set of known objects is cleared.</p>
<p><a name="a4564" id="a4564"><!-- --></a> When the exception token
occurs in the stream, the exception is read and a new
<code>WriteAbortedException</code> is thrown with the terminating
exception as an argument. The stream context is reset as described
earlier.</p>
<p><a name="a3502" id="a3502"><!-- --></a></p>
<p>The <code>readUnshared</code> method is used to read
&#34;unshared&#34; objects from the stream. This method is
identical to <code>readObject</code>, except that it prevents
subsequent calls to <code>readObject</code> and
<code>readUnshared</code> from returning additional references to
the deserialized instance returned by the original call to
<code>readUnshared</code>. Specifically:</p>
<ul>
<li><a name="a6120" id="a6120"><!-- --></a> If
<code>readUnshared</code> is called to deserialize a back-reference
(the stream representation of an object which has been written
previously to the stream), an <code>ObjectStreamException</code>
will be thrown.</li>
<li><a name="a6139" id="a6139"><!-- --></a> If
<code>readUnshared</code> returns successfully, then any subsequent
attempts to deserialize back-references to the stream handle
deserialized by <code>readUnshared</code> will cause an
<code>ObjectStreamException</code> to be thrown.</li>
</ul>
<a name="a6344" id="a6344"><!-- --></a> Deserializing an object via
<code>readUnshared</code> invalidates the stream handle associated
with the returned object. Note that this in itself does not always
guarantee that the reference returned by <code>readUnshared</code>
is unique; the deserialized object may define a
<code>readResolve</code> method which returns an object visible to
other parties, or <code>readUnshared</code> may return a
<code>Class</code> object or enum constant obtainable elsewhere in
the stream or through external means. If the deserialized object
defines a <code>readResolve</code> method and the invocation of
that method returns an array, then <code>readUnshared</code>
returns a shallow clone of that array; this guarantees that the
returned array object is unique and cannot be obtained a second
time from an invocation of <code>readObject</code> or
<code>readUnshared</code> on the <code>ObjectInputStream</code>,
even if the underlying data stream has been manipulated.
<p><a name="a6363" id="a6363"><!-- --></a> The
<code>defaultReadObject</code> method is used to read the fields
and object from the stream. It uses the class descriptor in the
stream to read the fields in the canonical order by name and type
from the stream. The values are assigned to the matching fields by
name in the current class. Details of the versioning mechanism can
be found in <a href="version.html#a6519">Section&#160;5.5,
&#34;Compatible Java Type Evolution</a>.&#34; Any field of the
object that does not appear in the stream is set to its default
value. Values that appear in the stream, but not in the object, are
discarded. This occurs primarily when a later version of a class
has written additional fields that do not occur in the earlier
version. This method may only be called from the
<code>readObject</code> method while restoring the fields of a
class. When called at any other time, the
<code>NotActiveException</code> is thrown.</p>
<p><a name="a4979" id="a4979"><!-- --></a> The
<code>readFields</code> method reads the values of the serializable
fields from the stream and makes them available via the
<code>GetField</code> class. The <code>readFields</code> method is
only callable from within the <code>readObject</code> method of a
serializable class. It cannot be called more than once or if
<code>defaultReadObject</code> has been called. The
<code>GetFields</code> object uses the current object&#39;s
<code>ObjectStreamClass</code> to verify the fields that can be
retrieved for this class. The <code>GetFields</code> object
returned by <code>readFields</code> is only valid during this call
to the classes <code>readObject</code> method. The fields may be
retrieved in any order. Additional data may only be read directly
from stream after <code>readFields</code> has been called.</p>
<p><a name="a1302" id="a1302"><!-- --></a> The
<code>registerValidation</code> method can be called to request a
callback when the entire graph has been restored but before the
object is returned to the original caller of
<code>readObject</code>. The order of validate callbacks can be
controlled using the priority. Callbacks registered with higher
values are called before those with lower values. The object to be
validated must support the <code>ObjectInputValidation</code>
interface and implement the <code>validateObject</code> method. It
is only correct to register validations during a call to a
class&#39;s <code>readObject</code> method. Otherwise, a
<code>NotActiveException</code> is thrown. If the callback object
supplied to <code>registerValidation</code> is null, an
<code>InvalidObjectException</code> is thrown.</p>
<p><a name="a5994" id="a5994"><!-- --></a> Starting with the Java
SDK, Standard Edition, v1.3, the <code>readClassDescriptor</code>
method is used to read in all <code>ObjectStreamClass</code>
objects. <code>readClassDescriptor</code> is called when the
<code>ObjectInputStream</code> expects a class descriptor as the
next item in the serialization stream. Subclasses of
<code>ObjectInputStream</code> may override this method to read in
class descriptors that have been written in non-standard formats
(by subclasses of <code>ObjectOutputStream</code> which have
overridden the <code>writeClassDescriptor</code> method). By
default, this method reads class descriptors according to the
format described in <a href=
"protocol.html#a10258">Section&#160;6.4, &#34;Grammar for the
Stream Format</a>&#34;.</p>
<p><a name="a1194" id="a1194"><!-- --></a> The
<code>resolveClass</code> method is called while a class is being
deserialized, and after the class descriptor has been read.
Subclasses may extend this method to read other information about
the class written by the corresponding subclass of
<code>ObjectOutputStream</code>. The method must find and return
the class with the given name and <code>serialVersionUID</code>.
The default implementation locates the class by calling the class
loader of the closest caller of <code>readObject</code> that has a
class loader. If the class cannot be found
<code>ClassNotFoundException</code> should be thrown. Prior to JDK
1.1.6, the <code>resolveClass</code> method was required to return
the same fully qualified class name as the class name in the
stream. In order to accommodate package renaming across releases,
<code>method</code> <code>resolveClass</code> only needs to return
a class with the same base class name and
<code>SerialVersionUID</code> in JDK 1.1.6 and later versions.</p>
<p><a name="a5264" id="a5264"><!-- --></a> The
<code>resolveObject</code> method is used by trusted subclasses to
monitor or substitute one object for another during
deserialization. Resolving objects must be enabled explicitly by
calling <code>enableResolveObject</code> before calling
<code>readObject</code> for the first object to be resolved. Once
enabled, <code>resolveObject</code> is called once for each
serializable object just prior to the first time it is being
returned from <code>readObject</code>. Note that the
<code>resolveObject</code> method is not called for objects of the
specially handled classes, <code>Class</code>,
<code>ObjectStreamClass</code>, <code>String</code>, and arrays. A
subclass&#39;s implementation of <code>resolveObject</code> may
return a substitute object that will be assigned or returned
instead of the original. The object returned must be of a type that
is consistent and assignable to every reference of the original
object or else a <code>ClassCastException</code> will be thrown.
All assignments are type-checked. All references in the stream to
the original object will be replaced by references to the
substitute object.</p>
<p><a name="a5120" id="a5120"><!-- --></a> The
<code>enableResolveObject</code> method is called by trusted
subclasses of <code>ObjectOutputStream</code> to enable the
monitoring or substitution of one object for another during
deserialization. Replacing objects is disabled until
<code>enableResolveObject</code> is called with a <code>true</code>
value. It may thereafter be disabled by setting it to
<code>false</code>. The previous setting is returned. The
<code>enableResolveObject</code> method checks if the stream has
permission to request substitution during serialization. To ensure
that the private state of objects is not unintentionally exposed,
only trusted streams may use <code>resolveObject</code>. Trusted
classes are those classes with a class loader equal to null or
belong to a security protection domain that provides permission to
enable substitution.</p>
<p><a name="a5521" id="a5521"><!-- --></a> If the subclass of
<code>ObjectInputStream</code> is not considered part of the system
domain, a line has to be added to the security policy file to
provide to a subclass of <code>ObjectInputStream</code> permission
to call <code>enableResolveObject</code>. The
<code>SerializablePermission</code> to add is
<code>&#34;enableSubstitution&#34;</code>.
<code>AccessControlException</code> is thrown if the protection
domain of the subclass of <code>ObjectStreamClass</code> does not
have permission to <code>&#34;enableSubstitution&#34;</code> by
calling <code>enableResolveObject</code>. See the document Java
Security Architecture (JDK 1.2) for additional information about
the security model.</p>
<p><a name="a5059" id="a5059"><!-- --></a> The
<code>readStreamHeader</code> method reads and verifies the magic
number and version of the stream. If they do not match, the
<code>StreamCorruptedMismatch</code> is thrown.</p>
<p><a name="a5506" id="a5506"><!-- --></a></p>
<p>To override the implementation of deserialization, a subclass of
<code>ObjectInputStream</code> should call the protected no-arg
<code>ObjectInputStream</code>, constructor. There is a security
check within the no-arg constructor for
<code>SerializablePermission
&#34;enableSubclassImplementation&#34;</code> to ensure that only
trusted classes are allowed to override the default implementation.
This constructor does not allocate any private data for
<code>ObjectInputStream</code> and sets a flag that indicates that
the final <code>readObject</code> method should invoke the
<code>readObjectOverride</code> method and return. All other
<code>ObjectInputStream</code> methods are not final and can be
directly overridden by the subclass.</p>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a4936" id="a4936"><i>3.2</i> The
ObjectInputStream.GetField Class</a></h2>
<a name="a5058" id="a5058"><!-- --></a> The class
<code>ObjectInputStream.GetField</code> provides the API for
getting the values of serializable fields. The protocol of the
stream is the same as used by <code>defaultReadObject.</code> Using
<code>readFields</code> to access the serializable fields does not
change the format of the stream. It only provides an alternate API
to access the values which does not require the class to have the
corresponding non-transient and non-static fields for each named
serializable field. The serializable fields are those declared
using <code>serialPersistentFields</code> or if it is not declared
the non-transient and non-static fields of the object. When the
stream is read the available serializable fields are those written
to the stream when the object was serialized. If the class that
wrote the stream is a different version not all fields will
correspond to the serializable fields of the current class. The
available fields can be retrieved from the
<code>ObjectStreamClass</code> of the <code>GetField</code> object.
<p><a name="a5029" id="a5029"><!-- --></a> The
<code>getObjectStreamClass</code> method returns an
<code>ObjectStreamClass</code> object representing the class in the
stream. It contains the list of serializable fields.</p>
<p><a name="a4941" id="a4941"><!-- --></a> The
<code>defaulted</code> method returns <em>true</em> if the field is
not present in the stream. An <code>IllegalArgumentException</code>
is thrown if the requested field is not a serializable field of the
current class.</p>
<p><a name="a4942" id="a4942"><!-- --></a></p>
<p>Each <code>get</code> method returns the specified serializable
field from the stream. I/O exceptions will be thrown if the
underlying stream throws an exception. An
<code>IllegalArgumentException</code> is thrown if the name or type
does not match the name and type of an field serializable field of
the current class. The default value is returned if the stream does
not contain an explicit value for the field.</p>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a3403" id="a3403"><i>3.3</i> The ObjectInputValidation
Interface</a></h2>
<a name="a2942" id="a2942"><!-- --></a>
<p>This interface allows an object to be called when a complete
graph of objects has been deserialized. If the object cannot be
made valid, it should throw the
<code>ObjectInvalidException</code>. Any exception that occurs
during a call to <code>validateObject</code> will terminate the
validation process, and the <code>InvalidObjectException</code>
will be thrown.</p>
<a name="a2969" id="a2969"><!-- --></a>
<pre>
package java.io;

public interface ObjectInputValidation
{
    public void validateObject()
        throws InvalidObjectException;
}
</pre>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a2971" id="a2971"><i>3.4</i> The readObject
Method</a></h2>
<a name="a4567" id="a4567"><!-- --></a> For serializable objects,
the <code>readObject</code> method allows a class to control the
deserialization of its own fields. Here is its signature:
<p><a name="a1081" id="a1081"><!-- --></a></p>
<pre>
    private void readObject(ObjectInputStream stream)
        throws IOException, ClassNotFoundException;
</pre>
<a name="a4580" id="a4580"><!-- --></a> Each subclass of a
serializable object may define its own <code>readObject</code>
method. If a class does not implement the method, the default
serialization provided by <code>defaultReadObject</code> will be
used. When implemented, the class is only responsible for restoring
its own fields, not those of its supertypes or subtypes.
<p><a name="a4581" id="a4581"><!-- --></a> The
<code>readObject</code> method of the class, if implemented, is
responsible for restoring the state of the class. The values of
every field of the object whether transient or not, static or not
are set to the default value for the fields type. Either
<code>ObjectInputStream</code>&#39;s <code>defaultReadObject</code>
or <code>readFields</code> method must be called once (and only
once) before reading any optional data written by the corresponding
<code>writeObject</code> method; even if no optional data is read,
<code>defaultReadObject</code> or <code>readFields</code> must
still be invoked once. If the <code>readObject</code> method of the
class attempts to read more data than is present in the optional
part of the stream for this class, the stream will return
<code>-1</code> for bytewise reads, throw an
<code>EOFException</code> for primitive data reads (e.g.,
<code>readInt</code>, <code>readFloat</code>), or throw an
<code>OptionalDataException</code> with the <code>eof</code> field
set to <code>true</code> for object reads.</p>
<p><a name="a6186" id="a6186"><!-- --></a> The responsibility for
the format, structure, and versioning of the optional data lies
completely with the class. The <code>@serialData</code> javadoc tag
within the javadoc comment for the <code>readObject</code> method
should be used to document the format and structure of the optional
data.</p>
<p><a name="a6108" id="a6108"><!-- --></a> If the class being
restored is not present in the stream being read, then its
<code>readObjectNoData</code> method, if defined, is invoked
(instead of <code>readObject</code>); otherwise, its fields are
initialized to the appropriate default values. For further detail,
see section <a href="input.html#a6053">3.5</a>.</p>
<p><a name="a6109" id="a6109"><!-- --></a> Reading an object from
the <code>ObjectInputStream</code> is analogous to creating a new
object. Just as a new object&#39;s constructors are invoked in the
order from the superclass to the subclass, an object being read
from a stream is deserialized from superclass to subclass. The
<code>readObject</code> or <code>readObjectNoData</code> method is
called instead of the constructor for each
<code>Serializable</code> subclass during deserialization.</p>
<p><a name="a6012" id="a6012"><!-- --></a></p>
<p>One last similarity between a constructor and a
<code>readObject</code> method is that both provide the opportunity
to invoke a method on an object that is not fully constructed. Any
overridable (neither private, static nor final) method called while
an object is being constructed can potentially be overridden by a
subclass. Methods called during the construction phase of an object
are resolved by the actual type of the object, not the type
currently being initialized by either its constructor or
<code>readObject</code>/<code>readObjectNoData</code> method.
Therefore, calling an overridable method from within a
<code>readObject</code> or <code>readObjectNoData</code> method may
result in the unintentional invocation of a subclass method before
the superclass has been fully initialized.</p>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a6053" id="a6053"><i>3.5</i> The readObjectNoData
Method</a></h2>
<a name="a6054" id="a6054"><!-- --></a> For serializable objects,
the <code>readObjectNoData</code> method allows a class to control
the initialization of its own fields in the event that a subclass
instance is deserialized and the serialization stream does not list
the class in question as a superclass of the deserialized object.
This may occur in cases where the receiving party uses a different
version of the deserialized instance&#39;s class than the sending
party, and the receiver&#39;s version extends classes that are not
extended by the sender&#39;s version. This may also occur if the
serialization stream has been tampered; hence,
<code>readObjectNoData</code> is useful for initializing
deserialized objects properly despite a &#34;hostile&#34; or
incomplete source stream.
<p><a name="a6068" id="a6068"><!-- --></a></p>
<pre>
  private void readObjectNoData() throws ObjectStreamException;
</pre>
<a name="a6066" id="a6066"><!-- --></a>
<p>Each serializable class may define its own
<code>readObjectNoData</code> method. If a serializable class does
not define a <code>readObjectNoData</code> method, then in the
circumstances listed above the fields of the class will be
initialized to their default values (as listed in The Java Language
Specification); this behavior is consistent with that of
<code>ObjectInputStream</code> prior to version 1.4 of the Java 2
SDK, Standard Edition, when support for
<code>readObjectNoData</code> methods was introduced. If a
serializable class does define a <code>readObjectNoData</code>
method and the aforementioned conditions arise, then
<code>readObjectNoData</code> will be invoked at the point during
deserialization when a class-defined <code>readObject</code> method
would otherwise be called had the class in question been listed by
the stream as a superclass of the instance being deserialized.</p>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a6014" id="a6014"><i>3.6</i> The readExternal
Method</a></h2>
<a name="a5177" id="a5177"><!-- --></a> Objects implementing
<code>java.io.Externalizable</code> must implement the
<code>readExternal</code> method to restore the entire state of the
object. It must coordinate with its superclasses to restore their
state. All of the methods of <code>ObjectInput</code> are available
to restore the object&#39;s primitive typed fields and object
fields.
<p><a name="a3410" id="a3410"><!-- --></a></p>
<pre>
    public void readExternal(ObjectInput stream)
        throws IOException;
</pre>
<hr noshade="noshade" size="1" />
<b><a name="a1234" id="a1234">Note -</a></b> The
<code>readExternal</code> method is public, and it raises the risk
of a client being able to overwrite an existing object from a
stream. The class may add its own checks to insure that this is
only called when appropriate.
<hr noshade="noshade" size="1" />
<a name="a5238" id="a5238"><!-- --></a> A new stream protocol
version has been introduced in JDK 1.2 to correct a problem with
<code>Externalizable</code> objects. The old definition of
<code>Externalizable</code> objects required the local virtual
machine to find a <code>readExternal</code> method to be able to
properly read an <code>Externalizable</code> object from the
stream. The new format adds enough information to the stream
protocol so serialization can skip an <code>Externalizable</code>
object when the local <code>readExternal</code> method is not
available. Due to class evolution rules, serialization must be able
to skip an <code>Externalizable</code> object in the input stream
if there is not a mapping for the object using the local classes.
<p><a name="a6050" id="a6050"><!-- --></a> An additional benefit of
the new <code>Externalizable</code> stream format is that
<code>ObjectInputStream</code> can detect attempts to read more
External data than is available, and can also skip by any data that
is left unconsumed by a <code>readExternal</code> method. The
behavior of <code>ObjectInputStream</code> in response to a read
past the end of External data is the same as the behavior when a
class-defined <code>readObject</code> method attempts to read past
the end of its optional data: bytewise reads will return
<code>-1</code>, primitive reads will throw
<code>EOFException</code>s, and object reads will throw
<code>OptionalDataException</code>s with the <code>eof</code> field
set to <code>true</code>.</p>
<p><a name="a5325" id="a5325"><!-- --></a></p>
<p>Due to the format change, JDK 1.1.6 and earlier releases are not
able to read the new format. <code>StreamCorruptedException</code>
is thrown when JDK 1.1.6 or earlier attempts to read an
<code>Externalizable</code> object from a stream written in
<code>PROTOCOL_VERSION_2</code>. Compatibility issues are discussed
in more detail in <a href="protocol.html#a5849">Section&#160;6.3,
&#34;Stream Protocol Versions</a>.&#34;</p>
<hr size="8" width="35%" align="left" noshade="noshade" />
<h2><a name="a5903" id="a5903"><i>3.7</i> The readResolve
Method</a></h2>
<a name="a5904" id="a5904"><!-- --></a> For Serializable and
Externalizable classes, the <code>readResolve</code> method allows
a class to replace/resolve the object read from the stream before
it is returned to the caller. By implementing the
<code>readResolve</code> method, a class can directly control the
types and instances of its own instances being deserialized. The
method is defined as follows:
<p><a name="a5905" id="a5905"><!-- --></a></p>
<pre>
   ANY-ACCESS-MODIFIER Object readResolve()
                throws ObjectStreamException;
</pre>
<a name="a5906" id="a5906"><!-- --></a> The
<code>readResolve</code> method is called when
<code>ObjectInputStream</code> has read an object from the stream
and is preparing to return it to the caller.
<code>ObjectInputStream</code> checks whether the class of the
object defines the <code>readResolve</code> method. If the method
is defined, the <code>readResolve</code> method is called to allow
the object in the stream to designate the object to be returned.
The object returned should be of a type that is compatible with all
uses. If it is not compatible, a <code>ClassCastException</code>
will be thrown when the type mismatch is discovered.
<p><a name="a5907" id="a5907"><!-- --></a></p>
<p>For example, a <code>Symbol</code> class could be created for
which only a single instance of each symbol binding existed within
a virtual machine. The <code>readResolve</code> method would be
implemented to determine if that symbol was already defined and
substitute the preexisting equivalent <code>Symbol</code> object to
maintain the identity constraint. In this way the uniqueness of
<code>Symbol</code> objects can be maintained across
serialization.</p>
<hr noshade="noshade" size="1" />
<b><a name="a5981" id="a5981">Note -</a></b> The
<code>readResolve</code> method is not invoked on the object until
the object is fully constructed, so any references to this object
in its object graph will not be updated to the new object nominated
by <code>readResolve</code>. However, during the serialization of
an object with the <code>writeReplace</code> method, all references
to the original object in the replacement object&#39;s object graph
are replaced with references to the replacement object. Therefore
in cases where an object being serialized nominates a replacement
object whose object graph has a reference to the original object,
deserialization will result in an incorrect graph of objects.
Furthermore, if the reference types of the object being read
(nominated by <code>writeReplace</code>) and the original object
are not compatible, the construction of the object graph will raise
a <code>ClassCastException</code>.
<hr noshade="noshade" size="1" />
<br />
<hr />
<!-- Bug in Communicator w/font: NavBar text disappears for Times 14pt pref. -->
<!-- font size="-1" --><a href="serialTOC.html">CONTENTS</a> |
<a href="output.html">PREV</a> | <a href="class.html">NEXT</a> 
<!-- | <a href="examples.html">INDEX</a>  -->
<!-- /font -->
<hr />
<font size="-1"><i><a href=
"../../../legal/SMICopyright.html">Copyright</a> &#169; 2005, 2010,
Oracle and/or its affiliates. All rights reserved.</i></font> 
<!-- This HTML file was created with Quadralay WebWorks Publisher Professional Edition 7.0.2.1128 -->
<!-- by Suzette Haines -->
<!-- Last updated: Mon Nov 21 12:31:37 2005 -->
</body>
</html>
