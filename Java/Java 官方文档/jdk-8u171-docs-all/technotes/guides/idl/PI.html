<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xml:lang=
"en-US">
<head>
<title>Java IDL: Portable Interceptors (PI)</title>
<link rel="stylesheet" type="text/css" href="../../../technotes/css/guide.css" />
</head>
<body>
<!-- STATIC HEADER -->

<!-- header start -->
<div id="javaseheader">
<div id="javaseheaderlogo">
<img src="../../../images/javalogo.gif"
alt="Java logo" />
</div>
<div id="javaseheaderindex">

<a href=
"../../../index.html">Documentation Contents</a>
</div>
<div class="clear"></div>
</div>

<!-- header end -->


<h1>Java IDL and Java RMI-IIOP Technologies: Using
Portable Interceptors (PI)</h1>
<p>Last Update: 4/25/2002</p>
<p><strong>NOTICE:</strong> This document is intended for advanced
CORBA developers.</p>
<p>The Java CORBA Object Request Broker (ORB) provides hooks, or
interception points, through which ORB services can intercept the
normal flow of execution of the ORB. These <em>Portable
Interceptors</em> provide a mechanism for plugging in additional
ORB behavior, or, by modifying the communications between client
and server, for modifying the behavior of the ORB. The <a href=
"#example">example</a> that follows shows different ways of using
Portable Interceptors.</p>
<p>Support for Portable Interceptors is a major recent addition to
the CORBA specification. Using <em>RequestInterceptors</em>, one
can easily write and attach portable ORB hooks that will intercept
any ORB-mediated invocation. Using <em>IORInterceptors</em>, one
can write code to annotate CORBA object references.</p>
<p><strong>It is highly recommended that you read the Portable
Interceptors Specification at <a href=
"http://www.omg.org/cgi-bin/doc?ptc/2001-03-04">ptc/2001-03-04</a>
before reading this document.</strong></p>
<p>The following topics are included in this document:</p>
<ul>
<li><a href="#types">Interceptor Types</a></li>
<li><a href="#register">Registering <code>ORBInitializers</code> in
Java</a>
<ul>
<li><a href="#scope_notes">Notes About the Scope of
Interceptors</a></li>
<li><a href="#notes_order">Notes on Interceptor Order</a></li>
<li><a href="#notes_register">Notes about Registering
Interceptors</a></li>
</ul>
</li>
<li><a href="#PICurrent">Portable Interceptor Current
(<tt>PICurrent</tt>)</a>
<ul>
<li><a href="#obtainPICurrent">Obtaining PICurrent</a></li>
<li><a href="#obtainPICurrent">Obtaining PICurrent</a></li>
<li><a href="#scope">Request Scope vs Thread Scope</a></li>
</ul>
</li>
<li><a href="#example">Portable Interceptor Example</a>
<ul>
<li><a href="#contextinformationflow">Flowing Context Information
between Clients and Servers</a></li>
<li><a href="#infinite_recursion">Avoiding Infinite Recursion
During Interceptor Outcalls</a></li>
<li><a href="#avoid_recursion_colocated">Avoiding Recursion for
Colocated Outcall References</a></li>
<li><a href="#multiORB">Avoid recursion by using multiple
ORBs</a></li>
</ul>
</li>
<li><a href="#Example_Code">Example Code</a></li>
<li><a href="#running">Compiling and running the
application</a></li>
</ul>
<p><a name="types" id="types"></a></p>
<h2>Interceptor Types</h2>
<p>There are currently three types of interceptors that can be
registered, as shown below. Examples of each are shown in the
<a href="#example">example</a> that follows.</p>
<ul>
<li><a href=
"../../../api/org/omg/PortableInterceptor/IORInterceptor.html"><code>
IORInterceptor</code></a>
<p>In some cases, a portable ORB service implementation may need to
add information describing the server's or object's ORB
service-related capabilities to object references in order to
enable the ORB service implementation in the client to function
properly. This is supported through the <tt>IORInterceptor</tt> and
<tt>IORInfo</tt> interfaces. The IOR Interceptor is used to
establish tagged components in the profiles within an Interoperable
Object Reference (IOR).</p>
<p>An example of an IOR Interceptor is shown in the file <a href=
"#AServiceIORInterceptor"><tt>AServiceIORInterceptor.java</tt></a>
in the example that follows.</p>
</li>
<li><a href=
"../../../api/org/omg/PortableInterceptor/ClientRequestInterceptor.html">
<code>ClientRequestInterceptor</code></a>
<p>A request Interceptor is designed to intercept the flow of a
request/reply sequence through the ORB at specific points so that
services can query the request information and manipulate the
service contexts which are propagated between clients and servers.
The primary use of request Interceptors is to enable ORB services
to transfer context information between clients and servers.</p>
<p>A <code>ClientRequestInterceptor</code> intercepts the flow of a
request/reply sequence through the ORB on the <i>client</i>
side.</p>
</li>
<li>
<p>An example of a <tt>ClientRequestInterceptor</tt> is shown in
the file <a href=
"#ClientIntercept"><tt>LoggingServiceClientInterceptor.java</tt></a>
in the example that follows.</p>
</li>
<li><a href=
"../../../api/org/omg/PortableInterceptor/ServerRequestInterceptor.html">
<code>ServerRequestInterceptor</code></a>
<p>A <code>ServerRequestInterceptor</code> intercepts the flow of a
request/reply sequence through the ORB on the <i>server</i>
side.</p>
<p>An example of a <tt>ServerRequestInterceptor</tt> is shown in
the file <a href=
"#LoggingServiceServerInterceptor"><tt>LoggingServiceServerInterceptor.java</tt></a>
in the example that follows.</p>
</li>
</ul>
<p><a name="register" id="register"></a></p>
<h2>Registering <code>ORBInitializers</code> in Java</h2>
<p>The <a href=
"../../../api/org/omg/PortableInterceptor/ORBInitializer.html"><code>
ORBInitializer</code></a> interface facilitates interceptor
registration and ORB initialization.</p>
<p>Interceptors are intended to be a means by which ORB services
gain access to ORB processing, effectively becoming part of the
ORB. Since interceptors are part of the ORB, when
<code>ORB.init</code> returns an ORB, the interceptors shall have
been registered. Interceptors cannot be registered on an ORB after
it has been returned by a call to <code>ORB.init</code>.</p>
<p><code>ORBInitializers</code> are registered via Java ORB
properties. An interceptor is registered by registering an
associated <code>ORBInitializer</code> object which implements the
<code>ORBInitializer</code> interface. When an ORB is initializing,
it shall call each registered <code>ORBInitializer</code>, passing
it an <code>ORBInitInfo</code> object which is used to register its
interceptor.</p>
<p>The property names are of the form:</p>
<pre class="codeblock">
org.omg.PortableInterceptor.ORBInitializerClass.&lt;Service&gt;
</pre>
<p>where <code>&lt;Service&gt;</code> is the string name of a class
which implements</p>
<pre class="codeblock">
org.omg.PortableInterceptor.ORBInitializer
</pre>
To avoid name collisions, the reverse DNS name convention should be
used. For example, if company <code>Example</code> has three
initializers, it could define the following properties:
<ul>
<li>
<code>org.omg.PortableInterceptor.ORBInitializerClass.com.example.Init1</code></li>
<li>
<code>org.omg.PortableInterceptor.ORBInitializerClass.com.example.Init2</code></li>
<li>
<code>org.omg.PortableInterceptor.ORBInitializerClass.com.example.Init3</code></li>
</ul>
<p><strong>Note:</strong> Any values associated with
<code>ORBInitializerClass</code> properties are ignored.</p>
<p>During <tt>ORB.init</tt>, these ORB properties which begin with
<code>org.omg.PortableInterceptor.ORBInitializerClass</code> shall
be collected, the <code>&lt;Service&gt;</code> portion of each
property shall be extracted, an object shall be instantiated with
the <code>&lt;Service&gt;</code> string as its class name, and the
<code>pre_init</code> and <code>post_init</code> methods shall be
called on that object. If there are any exceptions, the ORB shall
ignore them and proceed.</p>
<p><a name="scope_notes" id="scope_notes"></a></p>
<h2>Notes About the Scope of Interceptors</h2>
<ul>
<li>Interceptors are registered on a per-ORB basis.</li>
<li>To achieve virtual per-POA interceptors, instantiate each POA
with a different ORB.</li>
</ul>
<a name="notes_order" id="notes_order"></a>
<h2>Notes on Interceptor Order</h2>
<ul>
<li>While interceptors may be ordered administratively, there is no
concept of order with respect to the registration of interceptors.
Request Interceptors are concerned with service contexts. Service
contexts have no order, so there is no purpose for request
interceptors to have an order. IOR Interceptors are concerned with
tagged components. Tagged components also have no order, so there
is no purpose for IOR Interceptors to have an order.</li>
</ul>
<a name="notes_register" id="notes_register"></a>
<h2>Notes about Registering Interceptors</h2>
<ul>
<li>Registration code should avoid using the ORB (i.e., calling
<code>ORB.init</code> with the provided <code>orb_id</code>). Since
registration occurs during ORB initialization, results of
invocations on this ORB while it is in this state are
undefined.</li>
</ul>
<p><a name="PICurrent" id="PICurrent"></a></p>
<h2>Portable Interceptor Current (<tt>PICurrent</tt>)</h2>
<p>The <tt>PortableInterceptor::Current</tt> object (hereafter
referred to as <tt>PICurrent</tt>) is a <tt>Current</tt> object
that is used specifically by portable Interceptors to transfer
thread context information to a request context. Portable
Interceptors are not required to use <tt>PICurrent</tt>, but if
information from a client's thread context is required at an
Interceptor's interception points, then <tt>PICurrent</tt> can be
used to propagate that information. <tt>PICurrent</tt> allows
portable service code to be written regardless of an ORB's
threading model.</p>
<p><strong>Note:</strong> <tt>PICurrent</tt> is typically NOT used
directly by CORBA client or server code. Instead, it is generally
used by interceptor-based service implementations as demonstrated
in the <tt><a href="#AService_diagram">AService</a></tt> example
interceptor which follows. <a name="obtainPICurrent" id=
"obtainPICurrent"></a></p>
<h2>Obtaining PICurrent</h2>
<p>Before an invocation is made, <tt>PICurrent</tt> is obtained via
a call to <tt>ORB::resolve_initial_references ( PICurrent )</tt>.
From within the interception points, the data on <tt>PICurrent</tt>
that has moved from the thread scope to the request scope is
available via the <tt>get_slot</tt> operation on the
<tt>RequestInfo</tt> object. A <tt>PICurrent</tt> can still be
obtained via <tt>resolve_initial_references</tt>, but that is the
Interceptor's thread scope PICurrent. <a name="scope" id=
"scope"></a></p>
<h2>Request Scope vs Thread Scope</h2>
<p>The thread scope <tt>PICurrent</tt> (TSC) is the
<tt>PICurrent</tt> that exists within a thread's context. A request
scope <tt>PICurrent</tt> (RSC) is the <tt>PICurrent</tt> associated
with the request. On the client-side, the thread scope
<tt>PICurrent</tt> is logically copied to the request scope
<tt>PICurrent</tt> from the thread s context when a request begins
and is attached to the <tt>ClientRequestInfo</tt> object. On the
server-side, the request scope <tt>PICurrent</tt> is attached to
the <tt>ServerRequestInfo</tt> and follows the request processing.
It is logically copied to the thread scope <tt>PICurrent</tt> after
the list of <tt>receive_request_service_contexts</tt> interception
points are processed. See the <a target="AuxWindow" href=
"http://www.omg.org/cgi-bin/doc?ptc/2001-03-04"><em>Updated
Interceptors specification</em></a>, Section, 21.4.4.5, <em>Flow of
PICurrent between Scopes</em> for a detailed discussion of the
scope of <tt>PICurrent</tt>.</p>
<p><!--  ***************   TUTORIAL    ****************-->
<a name="example" id="example"></a></p>
<h2>Portable Interceptor Example</h2>
<p>This section contains an example logging service application.
The sample code for this application is quite complicated because
it covers even subtle "corner cases". The following scenarios are
covered in this sample application:</p>
<ol>
<li>A logging service which logs invocations. Neither client nor
server explicitly use the logging service.</li>
<li>An "empty" service which passes information from the client to
the server. The client and server explicitly use this service but
are not aware that it is implemented using interceptors.</li>
</ol>
<p><strong>Note:</strong> These examples explicitly register
<tt>ORBInitializers</tt> to make the code easier to experiment with
and setup. Typically this would not be done. Instead, this
information would be passed as <tt>-D</tt> properties to the Java
virtual machine when the applications are started. That way the
applications are not coupled to the fact that either the service
exists (e.g., the logging service) or that a service that they
explicitly use (e.g., the <tt>AService</tt> interface) is
implemented as an interceptor.</p>
<p>The purpose of the logging service example is to show how to
avoid infinite recursion when making outcalls (i.e., invocations on
CORBA references) from within interception points. This turns out
to be quite involved when all corner cases are covered.</p>
<p>The purpose of the "empty" service example is to show how to
implement services which flow context information from client to
server and back. <a name="contextinformationflow" id=
"contextinformationflow"></a></p>
<h2>Flowing Context Information between Clients and Servers</h2>
<p>A typical interceptor-based service will flow context
information between clients and servers. The <tt>AService</tt>
example shows how this information is flowed from the client thread
into the client interceptors, across the wire into the server
interceptors, to the servant thread and back.</p>
<p>It is important to note that neither the client nor the servant
is aware that the service is implemented using interceptors.
Instead, they interact with the service through local object
references (the <tt>aService</tt> reference in this example).
<a name="AService_diagram" id="AService_diagram"></a></p>
<p><strong><tt>AService</tt> diagram</strong></p>
<img src="images/AService.gif" align="middle" alt=
"AService diagram" />
<p>Description of the steps of the <tt>AService</tt> diagram:</p>
<ol>
<li>The client invokes <tt>aService.begin()</tt>.
<p>1.a. <tt>aService.begin()</tt> sets the service context
information in a slot it has reserved in <tt>PICurrent</tt>.</p>
</li>
<li>The client invokes a method on some reference (i.e.,
<tt>ref.method()</tt>). This invocation is taking place inside the
context of the service since <tt>aService.begin()</tt> has been
invoked.</li>
<li><tt>send_request</tt> is entered for the <tt>ref.method
call</tt>.</li>
<li><tt>get_effective_component(s)</tt> may be called to determine
if the reference being invoked needs to interact with the
service.</li>
<li><tt>get_slot</tt> is called to retrieve the context set in step
1a. Slots set in <tt>PICurrent</tt> are logically copied and made
available to <tt>ClientRequestInfo</tt>.</li>
<li>The service interceptor adds a service context containing the
appropriate context (most likely depending on the context set in
step 1a and any components retrieved in step 4). It uses
<tt>add_request_service_context</tt> to add this context
information to the request which is sent over the wire.</li>
<li>The <tt>ref.method request</tt> arrives at the server,
activating the <tt>receive_request_service_contexts</tt>
interception point.</li>
<li><tt>get_request_service_context</tt> is used to retrieve the
service context added at step 6.</li>
<li><tt>ServerRequestInfo.set_slot</tt> is used to transfer the
context information from the service context retrieved in step 8 to
the logical thread local data.</li>
<li><tt>receive_request</tt> is entered.</li>
<li>The "ref" Servant's "method" is entered.</li>
<li>The servant method invokes <tt>aService.verify()</tt> to
interact with the service.</li>
<li>The service uses <tt>get_slot</tt> on <tt>PICurrent</tt> to
retrieve the context information sent from the client side. The
service may also use <tt>set_slot</tt> on <tt>PICurrent</tt> to set
any return context information.</li>
<li>After the Servant completes, the <tt>send_*</tt> interception
point is entered. If the service set any return context
information, it would add a service context to the return. This is
not shown in this example.</li>
<li>When the reply arrives at the client, the <tt>receive_*</tt>
interception point is entered. If the service set any return
context information, it would be retrieved at this point. This is
not shown in this example.</li>
</ol>
<a name="infinite_recursion" id="infinite_recursion"></a>
<h2>Avoiding Infinite Recursion During Interceptor Outcalls</h2>
<p>Some services may need to make invocations on other CORBA object
references from within interception points. When making outcalls
from within interception points, steps must be taken to avoid
infinite recursion since those outcalls will flow through the
interception points. The <tt>LoggingService</tt> example
illustrates this case.</p>
<p>The <tt>LoggingService example</tt> is comprised of
<tt>ClientRequestInterceptors</tt> registered in a client program,
and <tt>ServerRequestInterceptors</tt> registered in a server
program. These interceptors send information from the client and
server to a <tt>LoggingService</tt> implemenation which logs this
information.</p>
<p>However, since the <tt>LoggingService</tt> implementation is
itself a CORBA server, we must ensure that we do not log calls to
the logger. The following diagrams illustrate the steps taken to
avoid infinite recursion.</p>
<p>The following diagram shows the simplest case of avoiding
recursion when calling an external logger from within interceptors.
These steps are useful for the case where the client ORB only
contains <tt>ClientRequestInterceptors</tt>, the server ORB only
contains <tt>ServerRequestInterceptors</tt>, and the
<tt>LoggingService</tt> is external to both the client and server
ORBs. <a name="LoggingService_diagram" id=
"LoggingService_diagram"></a></p>
<p><strong><tt>LoggingService</tt> diagram</strong></p>
<img src="images/LoggingService.gif" align="middle" alt=
"Logging Service diagram" />
<p>Description of the steps of the <tt>LoggingService</tt>
diagram:</p>
<ol>
<li>The client invokes a method on some reference.</li>
<li>The client interceptor's <tt>send_request</tt> method is
entered for the method invoked in step 1.</li>
<li>A slot reserved for indicating an outcall is set to
<tt>true</tt> on <tt>PICurrent</tt>.</li>
<li>The same slot is checked on <tt>ClientRequestInfo</tt> via
<tt>get_slot</tt>. This value will not be set since it represents
the client's thread state at step 1. Therefore a call to the logger
will be made.</li>
<li><tt>send_request</tt> is recursively entered for the logger
invocation made in step 4.</li>
<li>A slot reserved for indicating an outcall is set to
<tt>true</tt> on <tt>PICurrent</tt>. Note, this slot is always
unconditionally set. This is necessary when there are 2 or more
interceptors doing outcalls. Since interceptors do not know about
the existence of other interceptors we always set the
<tt>PICurrent</tt> slot.</li>
<li>The slot is checked on <tt>ClientRequestInfo</tt> via
<tt>get_slot</tt>. This time the value is set (from step 3).
Therefore we do not log this call (which is the call to the logger
itself). The <tt>send_request</tt> point that entered at step 5
finishes.</li>
<li>The ORB sends the log invocation made at step 4 to the logging
service.</li>
<li>The <tt>send_request</tt> point for step 2 finishes. The ORB
sends the initial client invocation made in step 1 to the server
for the appropriate reference.</li>
<li>The server's <tt>receive_request_service_contexts</tt> point is
entered. It logs the incoming request. A server which does not
contain client interceptors which make outcalls and which does not
contain the implementation of the logger itself does not need to
set recursion avoidance slots. That is what this diagram
represents.</li>
<li>- &nbsp;&nbsp;13.&nbsp;&nbsp;&nbsp; Therefore all the server
side interception points are entered with no further checking and
the response from the method initially invoked by the client is
returned to the client ORB.</li>
<li value="14">The client's <tt>receive_*</tt> point is entered.
Steps similar to steps 2 through 9 will occur if this point needs
to make an outcall.</li>
</ol>
<a name="avoid_recursion_colocated" id=
"avoid_recursion_colocated"></a>
<h2>Avoiding Recursion for Colocated Outcall References</h2>
<p>The following diagram illustrates the case where the
<tt>LoggingService</tt> may be colocated in the same ORB as the
reference being invoked by the client. In general, it is not
possible to know that a particular object reference is NOT
colocated with any other objects hosted by that ORB. Therefore, to
cover all corner cases, more steps must be taken.</p>
<p>This diagram shows only the server side. The client side steps
are identical to those in the preceding diagram. <a name=
"LoggingServiceColocated_diagram" id=
"LoggingServiceColocated_diagram"></a></p>
<p><strong><tt>LoggingServiceColocated</tt> diagram</strong></p>
<img src="images/LoggingServiceColocated.gif" align="middle" alt=
"LoggingServiceColocated diagram" />
<p>Description of the steps of the <tt>LoggingServiceColocated</tt>
diagram:</p>
<ol>
<li>The request from the client ORB arrives, activating the
<tt>receive_request_service_contexts</tt> interception point.</li>
<li>A slot reserved for indicating an outcall is set to
<tt>true</tt> on <tt>PICurrent</tt>.</li>
<li><tt>ServerRequestInfo.get_request_service_context</tt> is used
to check for the presence of a service context indicating an
outcall. The service context is not present so the logger is
invoked from within the interception point.</li>
<li>The <tt>send_request</tt> interception point is entered for the
logger request.</li>
<li><tt>get_slot</tt> checks for the outcall indicator.</li>
<li>The outcall indicator slot has been set (from step 2),
therefore <tt>add_request_service_context</tt> is used to a service
context indicating an outcall. This is necessary since there is no
logical relationship between client and server threads.</li>
<li>The logger invocation arrives at
<tt>receive_request_service_contexts</tt>.</li>
<li>A slot reserved for indicating an outcall is set to
<tt>true</tt> on <tt>PICurrent</tt>.</li>
<li><tt>ServerRequestInfo.get_request_service_context</tt> is used
to check for the presence of a service context indicating an
outcall. The service context is present so no further action is
taken. <tt>receive_request_service_contexts</tt> exits.</li>
<li>The logger request proceeds to <tt>receive_request</tt>. Steps
similar to those taken inside
<tt>receive_request_service_context</tt> are necessary if the
logger is called at the <tt>receive_request point</tt> (this is not
shown in the diagram (although the example code logs all
points)).</li>
<li>The logger request arrives at the <tt>LoggingService</tt>
Servant, which logs the initial client request (not invocation of
the logger).</li>
<li>The logger request proceeds to
<tt>ServerRequestInterceptor.send_*</tt> (most likely
<tt>send_reply</tt>).</li>
<li>The logger request proceeds to
<tt>ClientRequestInterceptor.receive_*</tt> (most likely
<tt>receive_reply</tt>).
<p>After Step 13, the original request that left off at Step 3
would be serviced.</p>
</li>
</ol>
<p>The main point illustrated in this example is the necessity of
using both client and server interceptors in conjunction with
<tt>PICurrent</tt> slots and service contexts to indicate an
outcall. <a name="multiORB" id="multiORB"></a></p>
<h2>Avoid recursion by using multiple ORBs</h2>
<p>A simpler way to avoid recursion is to ensure that the outcall
references are associated with a different ORB that does not have
the logging interceptors registered. That way the outcall
invocations never go through interceptors.</p>
<p>This seems like a simple solution, but, in general, interceptors
are registered via properties passed to the VM during startup. This
means that all ORBs created in that VM will contain all
interceptors so this solution will not work.</p>
<p>This solution will only work where interceptors are explicitly
registered in client code during <tt>ORB.init</tt>. However, that
is neither a typical nor a recommended way to register
interceptor-based services.</p>
<p><a name="Example_Code" id="Example_Code"></a></p>
<h2>Example Code</h2>
<p>The following files contain the code which the above diagrams
illustrate. Instructions for compiling and executing these examples
follow the code. The files included in this example are:</p>
<ul>
<li><a href="#idl"><code>serviceexample.idl</code></a></li>
<li><a href=
"#clientorbinit"><code>LoggingServiceClientORBInitializer.java</code></a></li>
<li><a href=
"#ClientIntercept"><code>LoggingServiceClientInterceptor.java</code></a></li>
<li><a href=
"#LoggingServiceServerORBInitializer"><code>LoggingServiceServerORBInitializer.java</code></a></li>
<li><a href=
"#LoggingServiceServerInterceptor"><code>LoggingServiceServerInterceptor.java</code></a></li>
<li><a href=
"#LoggingServiceImpl"><code>LoggingServiceImpl.java</code></a></li>
<li><a href=
"#AServiceORBInitializer"><code>AServiceORBInitializer.java</code></a></li>
<li><a href="#AServiceImpl"><code>AServiceImpl.java</code></a></li>
<li><a href=
"#AServiceInterceptor"><code>AServiceInterceptor.java</code></a></li>
<li><a href=
"#AServiceIORInterceptor"><code>AServiceIORInterceptor.java</code></a></li>
<li><a href=
"#ArbitaryObjectImpl"><code>ArbitaryObjectImpl.java</code></a></li>
<li><a href="#Client"><code>Client.java</code></a></li>
<li><a href=
"#ColocatedServers"><code>ColocatedServers.java</code></a></li>
</ul>
<a name="idl" id="idl"></a>
<h2><code>serviceexample.idl</code></h2>
<p>This is the Interface Definition Language (IDL) file that
contains definitions of an arbitrary object on which to make
invocations and two services which will service calls to the
arbitrary object.</p>
<pre class="codeblock">

// <strong>serviceexample.idl</strong>
// <a href="examplelicense.html">Copyright and License</a> 

module pi
{
module serviceexample
{

    // Create some arbitrary object to call.  Those calls
    // will be serviced by the service implemented using interceptors.

    exception ArbitraryObjectException { string reason; };

    interface ArbitraryObject
    {
             string         arbitraryOperation1 ( in string a1 );

        oneway void         arbitraryOperation2 ( in long a1 );

               void         arbitraryOperation3 ( in string a1 )
                                raises (ArbitraryObjectException);
    };


    // This would typically be in a file separate from the "ArbitraryObject"
    // and probably unknown to it.

    interface LoggingService
    {
        void log ( in string a1 );
    };

    // This would also typically be in a file of its own.
    // IMPORTANT: the interface should be a local object to avoid
    // unnecessary overhead.
    
    /*local*/ interface AService
    {
        void begin();
        void end();
        void verify();
    };

    // Tagged component for adding to an IOR to indicate that
    // the AService must be in effect when invocations are made 
    // on the object containing this tagged component.

    // Note: we explicitly declare the tag type rather than using
    // the IOP typedef (commented out) to simplify compiling this
    // example (i.e., to avoid includes and make include path directives).
    //const IOP::ComponentId TAG_ASERVICE_COMPONENT = 2345;
    const unsigned long TAG_ASERVICE_COMPONENT = 2345;

    struct ASERVICE_COMPONENT {
        boolean requiresAService;
    };

}; // module serviceexample

}; // module pi
</pre>
<p><a name="clientorbinit" id="clientorbinit"></a></p>
<h2><code>LoggingServiceClientORBInitializer.java</code></h2>
<p>This file creates and registers the logging service interceptor
used by object clients.</p>
<pre class="codeblock">

// <strong>LoggingServiceClientORBInitializer.java</strong>
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.PortableInterceptor.Current;
import org.omg.PortableInterceptor.CurrentHelper;
import org.omg.PortableInterceptor.ORBInitInfo;

public class LoggingServiceClientORBInitializer 
    extends org.omg.CORBA.LocalObject
    implements org.omg.PortableInterceptor.ORBInitializer
{
    public void pre_init(ORBInitInfo info)
    {
    }

    public void post_init(ORBInitInfo info)
    {
        try {

            // Get a reference to the LoggingService object.

            NamingContext nameService = 
                NamingContextHelper.narrow(
                    info.resolve_initial_references("NameService"));

            NameComponent path[] =
                { new NameComponent("LoggingService", "") };
            LoggingService loggingService = 
                LoggingServiceHelper.narrow(nameService.resolve(path));

            // Get a reference to TSC PICurrent.

            Current piCurrent =
                CurrentHelper.narrow(
                    info.resolve_initial_references("PICurrent"));

            // Allocate a slot id to use for the interceptor to indicate
            // that it is making an outcall.  This is used to avoid
            // infinite recursion.

            int outCallIndicatorSlotId = info.allocate_slot_id();

            // Create (with the above data) and register the client
            // side interceptor.

            LoggingServiceClientInterceptor interceptor =
                new LoggingServiceClientInterceptor(loggingService, 
                                                    piCurrent,
                                                    outCallIndicatorSlotId);

            info.add_client_request_interceptor(interceptor);
        } catch (Throwable t) {
            System.out.println("Exception handling not shown.");
        }
    }
}
</pre>
<p><a name="ClientIntercept" id="ClientIntercept"></a></p>
<h2><code>LoggingServiceClientInterceptor.java</code></h2>
<p>This interceptor logs client side interception points. It
illustrates how to make invocations on other objects from within an
interceptor and how to avoid infinite recursion during those
"outcall" invocations.</p>
<pre class="codeblock">

// <strong>LoggingServiceClientInterceptor.java</strong>
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.CORBA.Any;
import org.omg.CORBA.ORB;
import org.omg.CORBA.TCKind;
import org.omg.IOP.ServiceContext;
import org.omg.PortableInterceptor.ClientRequestInterceptor;
import org.omg.PortableInterceptor.ClientRequestInfo;
import org.omg.PortableInterceptor.Current;
import org.omg.PortableInterceptor.InvalidSlot;

public class LoggingServiceClientInterceptor
    extends org.omg.CORBA.LocalObject
    implements ClientRequestInterceptor
{
    private LoggingService loggingService;
    private Current piCurrent;
    private int outCallIndicatorSlotId;

    public LoggingServiceClientInterceptor(LoggingService loggingService,
                                           Current piCurrent,
                                           int outCallIndicatorSlotId)
    {
        this.loggingService = loggingService;
        this.piCurrent = piCurrent;
        this.outCallIndicatorSlotId = outCallIndicatorSlotId;
    }

    //
    // Interceptor operations
    //

    public String name() 
    {
        return "LoggingServiceClientInterceptor";
    }

    public void destroy() 
    {
    }

    //
    // ClientRequestInterceptor operations
    //

    public void send_request(ClientRequestInfo ri)
    {
        log(ri, "send_request");
    }

    public void send_poll(ClientRequestInfo ri)
    {
        log(ri, "send_poll");
    }

    public void receive_reply(ClientRequestInfo ri)
    {
        log(ri, "receive_reply");
    }

    public void receive_exception(ClientRequestInfo ri)
    {
        log(ri, "receive_exception");
    }

    public void receive_other(ClientRequestInfo ri)
    {
        log(ri, "receive_other");
    }

    //
    // Utilities.
    //

    public void log(ClientRequestInfo ri, String point)
    {
        // IMPORTANT: Always set the TSC out call indicator in case
        // other interceptors make outcalls for this request.
        // Otherwise the outcall will not be set for the other interceptor's
        // outcall resulting in infinite recursion.

        Any indicator = ORB.init().create_any();
        indicator.insert_boolean(true);
        try {
            piCurrent.set_slot(outCallIndicatorSlotId, indicator);
        } catch (InvalidSlot e) { }

        try {
            indicator = ri.get_slot(outCallIndicatorSlotId);

            // If the RSC out call slot is not set then log this invocation.
            // If it is set that indicates the interceptor is servicing the
            // invocation of loggingService itself.  In that case do
            // nothing (to avoid infinite recursion).

            if (indicator.type().kind().equals(TCKind.tk_null)) {
                loggingService.log(ri.operation() + " " + point);
            }
        } catch (InvalidSlot e) {
            System.out.println("Exception handling not shown.");            
        }
    }
}
</pre>
<p><a name="LoggingServiceServerORBInitializer" id=
"LoggingServiceServerORBInitializer"></a></p>
<h2><code>LoggingServiceServerORBInitializer.java</code></h2>
This file creates and registers the logging service interceptor
used by object servers. Even though this interceptor is meant to
only log server-side interception points, it is both a client and
server interceptor. The code illustrates how to avoid infinite
recursion in the case where the object being called is colocated in
the same ORB in which the interceptors are registered.
<pre class="codeblock">

// <strong>LoggingServiceServerORBInitializer.java</strong>
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.PortableInterceptor.Current;
import org.omg.PortableInterceptor.CurrentHelper;
import org.omg.PortableInterceptor.ORBInitInfo;

public class LoggingServiceServerORBInitializer 
    extends org.omg.CORBA.LocalObject
    implements org.omg.PortableInterceptor.ORBInitializer
{
    public void pre_init(ORBInitInfo info)
    {
    }

    public void post_init(ORBInitInfo info)
    {
        try {

            // Create and register the logging service interceptor.
            // Give that interceptor references to the NameService and
            // PICurrent to avoid further lookups (i.e., optimization).
            // More importantly, allocate and give the interceptor
            // a slot id which is will use to tell itself not to
            // log calls that the interceptor makes to the logging process.

            NamingContext nameService = 
                NamingContextHelper.narrow(
                    info.resolve_initial_references("NameService"));

            Current piCurrent =
                CurrentHelper.narrow(
                    info.resolve_initial_references("PICurrent"));

            int outCallIndicatorSlotId = info.allocate_slot_id();

            LoggingServiceServerInterceptor interceptor =
                new LoggingServiceServerInterceptor(nameService,
                                                    piCurrent,
                                                    outCallIndicatorSlotId);

            info.add_client_request_interceptor(interceptor);
            info.add_server_request_interceptor(interceptor);
        } catch (Throwable t) {
            System.out.println("Exception handling not shown.");
        }
    }
}
</pre>
<p><a name="LoggingServiceServerInterceptor" id=
"LoggingServiceServerInterceptor"></a></p>
<h2><code>LoggingServiceServerInterceptor.java</code></h2>
<p>This interceptor logs server side interception points, and is
implemented as both a <tt>ClientRequestInterceptor</tt> and a
<tt>ServerRequestInterceptor</tt> to illustrate the need to set
some "out call" service context data (in addition to setting an out
call slot) to avoid infinite recursion for the case noted in the
description of
<tt>LoggingServiceServerORBInitializer.java</tt>.</p>
<pre class="codeblock">

// <strong>LoggingServiceServerInterceptor.java</strong>
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.CORBA.Any;
import org.omg.CORBA.BAD_PARAM;
import org.omg.CORBA.ORB;
import org.omg.CORBA.TCKind;
import org.omg.IOP.ServiceContext;
import org.omg.PortableInterceptor.ClientRequestInterceptor;
import org.omg.PortableInterceptor.ClientRequestInfo;
import org.omg.PortableInterceptor.Current;
import org.omg.PortableInterceptor.InvalidSlot;
import org.omg.PortableInterceptor.ServerRequestInterceptor;
import org.omg.PortableInterceptor.ServerRequestInfo;

public class LoggingServiceServerInterceptor
    extends org.omg.CORBA.LocalObject
    implements ClientRequestInterceptor,
               ServerRequestInterceptor
{
    private NamingContext nameService;
    private LoggingService loggingService;
    private Current piCurrent;
    private int outCallIndicatorSlotId;
    private static final int serviceContextId = 100001;
    private static final byte[] serviceContextData = {1};

    // Returns a reference to the logging process.

    private LoggingService loggingService()
    {
        if (loggingService == null) {
            NameComponent path[] =
                { new NameComponent("LoggingService", "") };
            try {
                loggingService = 
                    LoggingServiceHelper.narrow(nameService.resolve(path));
            } catch (Throwable t) {
                System.out.println("Exception handling not shown.");
            }
        }
        return loggingService;
    }

    public LoggingServiceServerInterceptor(NamingContext nameService,
                                           Current piCurrent,
                                           int outCallIndicatorSlotId)
    {
        this.nameService = nameService;
        this.piCurrent = piCurrent;
        this.outCallIndicatorSlotId = outCallIndicatorSlotId;
    }

    //
    // Interceptor operations
    //

    public String name() 
    {
        return "LoggingServiceServerInterceptor";
    }

    public void destroy() 
    {
    }

    //
    // ClientRequestInterceptor operations
    //

    public void send_request(ClientRequestInfo ri)
    {

        // If the server interceptor sets the recursion slot then
        // put in the service context so the server doesn't make
        // the call again in the case where the server side interceptor
        // is colocated in the same ORB as the object being invoked.

        try {
            Any indicator = ri.get_slot(outCallIndicatorSlotId);
            if (indicator.type().kind().equals(TCKind.tk_boolean)) {
                ServiceContext serviceContext =
                    new ServiceContext(serviceContextId, serviceContextData);
                ri.add_request_service_context(serviceContext, false);
            }
        } catch (InvalidSlot e) {
            System.out.println("Exception handling not shown.");
        }
    }

    public void send_poll(ClientRequestInfo ri)
    {
    }

    public void receive_reply(ClientRequestInfo ri)
    {
    }

    public void receive_exception(ClientRequestInfo ri)
    {
    }

    public void receive_other(ClientRequestInfo ri)
    {
    }

    //
    // ServerRequestInterceptor operations
    //

    public void receive_request_service_contexts(ServerRequestInfo ri)
    {
        log(ri, "receive_request_service_contexts");
    }

    public void receive_request(ServerRequestInfo ri)
    {
        log(ri, "receive_request");
    }

    public void send_reply(ServerRequestInfo ri)
    {
        log(ri, "send_reply");
    }

    public void send_exception(ServerRequestInfo ri)
    {
        log(ri, "send_exception");
    }

    public void send_other(ServerRequestInfo ri)
    {
        log(ri, "send_other");
    }

    //
    // Utilities.
    //

    public void log(ServerRequestInfo ri, String point)
    {
        // This is only relevant for the colocated example.
        // Do not attempt to log until the logging service object
        // has been bound in naming.  Otherwise the attempt to call
        // rebind on naming will call log which will fail.
        if (! ColocatedServers.colocatedBootstrapDone) {
            return;
        }

        // IMPORTANT:
        // The conditional logging of the invocation is only necessary
        // if there is a chance that the object being invoked is colocated
        // in the same ORB as this interceptor.  Otherwise the outcall to 
        // the logging service can be made unconditionally.

        // Always set the recursion slot.

        Any indicator = ORB.init().create_any();
        indicator.insert_boolean(true);
        try {
            piCurrent.set_slot(outCallIndicatorSlotId, indicator);
        } catch (InvalidSlot e) {
            System.out.println("Exception handling not shown.");
        }

        // Make the out call if you have not already done so.

        try {

            // Only the presence of the service context counts.
            // The data is ignored.

            ri.get_request_service_context(serviceContextId);
        } catch (BAD_PARAM e) {
            // Recursion indicator not set so make the call.
            loggingService().log(ri.operation() + " " + point);
        }
    }
}
</pre>
<p><a name="LoggingServiceImpl" id="LoggingServiceImpl"></a></p>
<h2><code>LoggingServiceImpl.java</code></h2>
This file is the implementation of the logging object to which the
logging service interceptors send their data.
<pre class="codeblock">

// 
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.CORBA.ORB;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.PortableServer.POAHelper;

import java.util.Properties;

class LoggingServiceImpl
    extends LoggingServicePOA
{
    public static ORB orb;

    //
    // The IDL operations.
    //

    public void log(String a1)
    {
        System.out.println(a1);
    }

    //
    // The server.
    //

    public static void main(String[] av)
    {
        try {
            if (orb == null) {
                orb = ORB.init(av, null);
            }
            
            POA rootPOA =  POAHelper.narrow( orb.resolve_initial_references("RootPOA"));
            rootPOA.the_POAManager().activate();
            
            byte[] objectId =
                rootPOA.activate_object(new LoggingServiceImpl());
            org.omg.CORBA.Object ref = rootPOA.id_to_reference(objectId);

            NamingContext nameService = 
                NamingContextHelper.narrow(
                    orb.resolve_initial_references("NameService"));
            NameComponent path[] =
                { new NameComponent("LoggingService", "") };
            nameService.rebind(path, ref);

            // Only relevant for colocated example.
            ColocatedServers.colocatedBootstrapDone = true;

            System.out.println("LoggingService ready.");

            orb.run();

        } catch (Exception e) {
            e.printStackTrace();
            System.exit(-1);
        }
        System.exit(0);
    }
}
</pre>
<p><a name="AServiceORBInitializer" id=
"AServiceORBInitializer"></a></p>
<h2><code>AServiceORBInitializer.java</code></h2>
The file creates and registers the <tt>AServiceInterceptor</tt> as
both a client and server interceptor, creates and registers the
<tt>AServiceIORInterceptor</tt> which puts a TaggedComponent into
IORs, and creates a local object to be used by applications to
explicitly control the services offered by <tt>AService</tt>. This
local object is registered as an initial service with the ORB such
that it can be obtained by clients using
<tt>org.omg.CORBA.ORB.resolve_initial_references</tt>.
<pre class="codeblock">

// <strong>AServiceORBInitializer.java</strong>
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.IOP.Codec;
import org.omg.IOP.CodecFactory;
import org.omg.IOP.CodecFactoryHelper;
import org.omg.IOP.Encoding;
import org.omg.PortableInterceptor.Current;
import org.omg.PortableInterceptor.CurrentHelper;
import org.omg.PortableInterceptor.ORBInitInfo;


public class AServiceORBInitializer 
    extends org.omg.CORBA.LocalObject
    implements org.omg.PortableInterceptor.ORBInitializer
{
    private AServiceImpl aServiceImpl;
    private AServiceInterceptor aServiceInterceptor;

    public void pre_init(ORBInitInfo info)
    {
        try {
            int id = info.allocate_slot_id();

            aServiceInterceptor = new AServiceInterceptor(id);

            info.add_client_request_interceptor(aServiceInterceptor);
            info.add_server_request_interceptor(aServiceInterceptor);

            // Create and register a reference to the service to be
            // used by client code.

            aServiceImpl = new AServiceImpl(id);

            info.register_initial_reference("AService", aServiceImpl);

        } catch (Throwable t) {
            System.out.println("Exception handling not shown.");
        }
    }

    public void post_init(ORBInitInfo info)
    {
        try {

            Current piCurrent =
                CurrentHelper.narrow(
                    info.resolve_initial_references("PICurrent"));
            aServiceImpl.setPICurrent(piCurrent);

            CodecFactory codecFactory =
                CodecFactoryHelper.narrow(
                    info.resolve_initial_references("CodecFactory"));
            Encoding encoding = new Encoding((short)0, (byte)1, (byte)2);
            Codec codec = codecFactory.create_codec(encoding);
            aServiceInterceptor.setCodec(codec);
            
            AServiceIORInterceptor aServiceIORInterceptor =
                new AServiceIORInterceptor(codec);
            info.add_ior_interceptor(aServiceIORInterceptor);

        } catch (Throwable t) {
            System.out.println("Exception handling not shown.");
        }
    }

}
</pre>
<p><a name="AServiceImpl" id="AServiceImpl"></a></p>
<h2><code>AServiceImpl.java</code></h2>
This file contains an object that is explicitly used by client and
servant code to communicate with the service. When the client calls
<tt>begin()</tt> on the service, the service causes a
<tt>ServiceID</tt> specific to the service to be put in the TSC
<tt>PICurrent</tt> slot reserved by this service. When the client
calls <tt>end()</tt> on the service, it sets the TSC slot to a
non-valid value to indicate that the service is not in effect.
Servants use the <tt>verify()</tt> method to determine whether the
<tt>ServiceID</tt> was passed from the client side to the server
side.
<pre class="codeblock">

// 
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.CORBA.Any;
import org.omg.CORBA.TCKind;
import org.omg.CORBA.LocalObject;
import org.omg.CORBA.ORB;
import org.omg.PortableInterceptor.Current;
import org.omg.PortableInterceptor.InvalidSlot;

class AServiceImpl
    extends LocalObject
    implements AService
{
    private int slotId;

    private int currentServiceId = 0;

    private Current piCurrent;

    private Any NOT_IN_EFFECT;

    public AServiceImpl(int slotId)
    {
        this.slotId = slotId;
        NOT_IN_EFFECT = ORB.init().create_any();
    }

    // Package protected so the AService ORBInitializer can access this
    // non-IDL defined method.
    void setPICurrent(Current piCurrent)
    {
        this.piCurrent = piCurrent;
    }

    public void begin()
    {
        Any any = ORB.init().create_any();
        any.insert_long(++currentServiceId);
        setSlot(any);
    }

    public void end()
    {
        setSlot(NOT_IN_EFFECT);
    }

    public void verify()
    {
        try {
            Any any = piCurrent.get_slot(slotId);
            if (any.type().kind().equals(TCKind.tk_long)) {
                System.out.println("Service present: " + any.extract_long());
            } else {
                System.out.println("Service not present");
            }
        } catch (InvalidSlot e) {
            System.out.println("Exception handling not shown.");
        }
    }

    // Synchronized because two threads in the same ORB could be
    // sharing this object.
    synchronized private void setSlot(Any any)
    {
        try {
            piCurrent.set_slot(slotId, any);
        } catch (InvalidSlot e) {
            System.out.println("Exception handling not shown.");
        }
    }
}
</pre>
<p><a name="AServiceInterceptor" id="AServiceInterceptor"></a></p>
<h2><code>AServiceInterceptor.java</code></h2>
<p>This interceptor is responsible for arranging to pass the client
side <tt>AService</tt> information to the service side.</p>
<p>On the client side, if <tt>AService.begin()</tt> has been
called, the <tt>send_request(ri)</tt> point will see the service id
in the RSC slot. In this case, it inserts the value of that service
id into an <tt>org.omg.CORBA.ServiceContext</tt> and adds that
service context to the data to be passed along with the
invocation.</p>
<p>On the server side, <tt>receive_request_service_context(ri)</tt>
looks for the presence of that service context. When present, it
extracts the service id value from the <tt>ServiceContext</tt> and
sets the RSC slot to that value. When the servant is executing, the
value of that RSC slot is available in the TSC slot.</p>
<pre class="codeblock">

// <strong>AServiceInterceptor.java</strong>
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.CORBA.Any;
import org.omg.CORBA.BAD_PARAM;
import org.omg.CORBA.ORB;
import org.omg.CORBA.TCKind;
import org.omg.IOP.Codec;
import org.omg.IOP.CodecPackage.FormatMismatch;
import org.omg.IOP.CodecPackage.TypeMismatch;
import org.omg.IOP.ServiceContext;
import org.omg.IOP.TaggedComponent;
import org.omg.PortableInterceptor.ClientRequestInterceptor;
import org.omg.PortableInterceptor.ClientRequestInfo;
import org.omg.PortableInterceptor.InvalidSlot;
import org.omg.PortableInterceptor.ServerRequestInterceptor;
import org.omg.PortableInterceptor.ServerRequestInfo;

public class AServiceInterceptor
    extends org.omg.CORBA.LocalObject
    implements ClientRequestInterceptor, ServerRequestInterceptor
{
    private int slotId;
    private Codec codec;

    private static final int serviceContextId = 1234;

    public AServiceInterceptor(int slotId)
    {
        this.slotId = slotId;
    }

    void setCodec(Codec codec)
    {
        this.codec = codec;
    }

    //
    // Interceptor operations
    //

    public String name() 
    {
        return "AServiceInterceptor";
    }

    public void destroy() 
    {
    }

    //
    // ClientRequestInterceptor operations
    //

    public void send_request(ClientRequestInfo ri)
    {
        //
        // See if the target object contains an ASERVICE_COMPONENT.
        //

        try {
            TaggedComponent taggedComponent =
                ri.get_effective_component(TAG_ASERVICE_COMPONENT.value);

            Any sAny = null;
            try {
                sAny = codec.decode_value(taggedComponent.component_data,
                                          ASERVICE_COMPONENTHelper.type());
            } catch (TypeMismatch e) {
                System.out.println("Exception handling not shown.");
            } catch (FormatMismatch e) {
                System.out.println("Exception handling not shown.");
            }

            ASERVICE_COMPONENT aServiceComponent =
                ASERVICE_COMPONENTHelper.extract(sAny);

            //
            // Only send the service context if the target object requires it.
            //

            if (aServiceComponent.requiresAService) {
                try {
                    Any any = ri.get_slot(slotId);
                    if (any.type().kind().equals(TCKind.tk_long)) {
                        int serviceId = any.extract_long();
                        byte[] serviceContextData = {
                            // Little endian to make it
                            // easier to see in debugger.
                            (byte)((serviceId &gt;&gt;&gt;  0) &amp;  0xFF),
                            (byte)((serviceId &gt;&gt;&gt;  8) &amp;  0xFF),
                            (byte)((serviceId &gt;&gt;&gt; 16) &amp;  0xFF),
                            (byte)((serviceId &gt;&gt;&gt; 24) &amp;  0xFF)
                        };
                        ri.add_request_service_context(
                            new ServiceContext(serviceContextId,
                                               serviceContextData),
                            false);
                    }
                } catch (InvalidSlot e) {
                    System.out.println("Exception handling not shown.");
                }
            }
        } catch (BAD_PARAM e) {
            // If it is not present, do nothing.
            ;
        }
    }

    public void send_poll(ClientRequestInfo ri)
    {
    }

    public void receive_reply(ClientRequestInfo ri)
    {
    }

    public void receive_exception(ClientRequestInfo ri)
    {
    }

    public void receive_other(ClientRequestInfo ri)
    {
    }

    //
    // ServerRequestInterceptor operations
    //

    public void receive_request_service_contexts(ServerRequestInfo ri)
    {
        try {
            ServiceContext serviceContext =
                ri.get_request_service_context(serviceContextId);
            byte[] data = serviceContext.context_data;
            int b1, b2, b3, b4;
            b4 = (data[0] &lt;&lt;  0) &amp; 0x000000FF;
            b3 = (data[1] &lt;&lt;  8) &amp; 0x0000FF00;
            b2 = (data[2] &lt;&lt; 16) &amp; 0x00FF0000;
            b1 = (data[3] &lt;&lt; 24) &amp; 0xFF000000;
            int serviceId = (b1 | b2 | b3 | b4);
            Any any = ORB.init().create_any();
            any.insert_long(serviceId);
            ri.set_slot(slotId, any);
        } catch (BAD_PARAM e) {
            // Not present means service is not in effect.
            // Do nothing.
            ;
        } catch (InvalidSlot e) {
            System.out.println("Exception handling not shown.");
        }
    }

    public void receive_request(ServerRequestInfo ri)
    {
    }

    public void send_reply(ServerRequestInfo ri)
    {
    }

    public void send_exception(ServerRequestInfo ri)
    {
    }

    public void send_other(ServerRequestInfo ri)
    {
    }
}
</pre>
<p><a name="AServiceIORInterceptor" id=
"AServiceIORInterceptor"></a></p>
<h2><code>AServiceIORInterceptor.java</code></h2>
This file adds a <tt>TaggedComponent</tt> to IORs.
<pre class="codeblock">

// <strong>AServiceIORInterceptor.java</strong>
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.CORBA.Any;
import org.omg.CORBA.LocalObject;
import org.omg.CORBA.ORB;
import org.omg.IOP.TaggedComponent;
import org.omg.IOP.Codec;
import org.omg.IOP.CodecPackage.InvalidTypeForEncoding;
import org.omg.PortableInterceptor.IORInfo;
import org.omg.PortableInterceptor.IORInterceptor;

public class AServiceIORInterceptor
    extends org.omg.CORBA.LocalObject
    implements IORInterceptor
{
    private Codec codec;

    public AServiceIORInterceptor(Codec codec)
    {
        this.codec = codec;
    }

    //
    // Interceptor operations
    //

    public String name() 
    {
        return "AServiceInterceptor";
    }

    public void destroy() 
    {
    }

    //
    // IOR Interceptor operations
    //

    public void establish_components(IORInfo info)
    {
        //
        // Note: typically, rather than just inserting a tagged component
        // this interceptor would check info.get_effective_policy(int)
        // to determine if a tagged component reflecting that policy
        // should be added to the IOR.  That is not shown in this example.
        // 

        ASERVICE_COMPONENT aServiceComponent = new ASERVICE_COMPONENT(true);
        Any any = ORB.init().create_any();
        ASERVICE_COMPONENTHelper.insert(any, aServiceComponent);
        byte[] value = null;
        try {
            value = codec.encode_value(any);
        } catch (InvalidTypeForEncoding e) {
            System.out.println("Exception handling not shown.");
        }
        TaggedComponent taggedComponent =
            new TaggedComponent(TAG_ASERVICE_COMPONENT.value, value);
        info.add_ior_component(taggedComponent);
    }

}
</pre>
<p><a name="ArbitaryObjectImpl" id="ArbitaryObjectImpl"></a></p>
<h2><code>ArbitaryObjectImpl.java</code></h2>
<p>This file is an implementation and server for the
<tt>ArbitraryObject</tt> IDL interface. The implementations of the
IDL interface operations explicitly call the
<tt>AServiceImpl.verify()</tt> method to illustrate the end-to-end
passing of data from the client (via <tt>AService.begin()</tt>) to
the servant.</p>
<pre class="codeblock">

// <strong>ArbitaryObjectImpl.java</strong>
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.CORBA.ORB;
import org.omg.CORBA.ORBPackage.InvalidName;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;
import org.omg.PortableServer.POAHelper;

import java.util.Properties;

class ArbitraryObjectImpl
    extends ArbitraryObjectPOA
{
    public static ORB orb;

    private AService aService;

    //
    // The IDL operations.
    //

    public String arbitraryOperation1(String a1)
    {
        verifyService();
        return "I got this from the client: " + a1;
    }

    public void arbitraryOperation2 (int a1)
    {
        verifyService();
    }

    public void arbitraryOperation3(String a1)
        throws ArbitraryObjectException
    {
        verifyService();
        if (a1.equals("throw exception")) {
            throw new ArbitraryObjectException("because you told me to");
        }
    }

    private void verifyService()
    {
        getAService().verify();
    }

    private AService getAService()
    {
        // Only look up the service once, then cache it.

        if (aService == null) {
            try {
                aService =      
                    AServiceHelper.narrow(
                        orb.resolve_initial_references("AService"));
            } catch (InvalidName e) {
                System.out.println("Exception handling not shown.");
            }
        }
        return aService;
    }

    //
    // The server.
    //

    public static void main(String[] av)
    {
        try {
            if (orb == null) {
                Properties props = new Properties();
                props.put("org.omg.PortableInterceptor.ORBInitializerClass."
                          + "pi.serviceexample.AServiceORBInitializer",
                          "");
                props.put("org.omg.PortableInterceptor.ORBInitializerClass."
                          + "pi.serviceexample.LoggingServiceServerORBInitializer",
                          "");
                orb = ORB.init(av, props);
            }
            
            POA rootPOA =  POAHelper.narrow( orb.resolve_initial_references("RootPOA"));
            // Create a POA so the IOR interceptor executes.
            POA childPOA = rootPOA.create_POA("childPOA", null, null);
            childPOA.the_POAManager().activate();
            
            byte[] objectId =
                childPOA.activate_object(new ArbitraryObjectImpl());
            org.omg.CORBA.Object ref = childPOA.id_to_reference(objectId);

            NamingContext nameService = 
                NamingContextHelper.narrow(
                    orb.resolve_initial_references("NameService"));
            NameComponent path[] =
                { new NameComponent("ArbitraryObject", "") };
            nameService.rebind(path, ref);

            System.out.println("ArbitaryObject ready.");

            orb.run();

        } catch (Exception e) {
            e.printStackTrace();
            System.exit(-1);
        }
        System.exit(0);
    }
}
</pre>
<p><a name="Client" id="Client"></a></p>
<h2><code>Client.java</code></h2>
<p>This is a client that calls methods on <tt>ArbitraryObject</tt>.
It makes some of those calls within the context of
<tt>AService</tt> and some outside of its context. It is unaware of
the existence of the logging interceptor (except that it explicitly
registers the <tt>LoggingServerClientORBInitializer</tt> as noted
above).</p>
<pre class="codeblock">

// <strong>Client.java</strong>
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.CORBA.ORB;
import org.omg.CosNaming.*;
import org.omg.CosNaming.NamingContextPackage.*;

import java.util.Properties;

public class Client 
{
    public static void main(String av[])
    {
        try {
            Properties props = new Properties();
            props.put("org.omg.PortableInterceptor.ORBInitializerClass."
                      + "pi.serviceexample.AServiceORBInitializer",
                      "");
            props.put("org.omg.PortableInterceptor.ORBInitializerClass."
                      + "pi.serviceexample.LoggingServiceClientORBInitializer",
                      "");
            ORB orb = ORB.init(av, props);

            //
            // The client obtains a reference to a service.
            // The client does not know the service is implemented
            // using interceptors.
            //

            AService aService = 
                AServiceHelper.narrow(
                    orb.resolve_initial_references("AService"));

            //
            // The client obtains a reference to some object that
            // it will invoke.
            //

            NamingContext nameService = 
                NamingContextHelper.narrow(
                    orb.resolve_initial_references("NameService"));
            NameComponent arbitraryObjectPath[] =
                { new NameComponent("ArbitraryObject", "") };
            ArbitraryObject arbitraryObject =
                ArbitraryObjectHelper.narrow(nameService.resolve(arbitraryObjectPath));

            //
            // The client begins the service so that invocations of
            // any object will be done with that service in effect.
            //

            aService.begin();
            
            arbitraryObject.arbitraryOperation1("one");
            arbitraryObject.arbitraryOperation2(2);

            //
            // The client ends the service so that further invocations
            // of any object will not be done with that service in effect.
            //

            aService.end();

            // This invocation is not serviced by aService since
            // it is outside the begin/end.
            arbitraryObject.arbitraryOperation3("just return");


            aService.begin();
            try {
                arbitraryObject.arbitraryOperation3("throw exception");
                throw new RuntimeException("should not see this");
            } catch (ArbitraryObjectException e) {
                // Expected in this example, so do nothing.
            }
            aService.end();

        } catch (Exception e) {
            e.printStackTrace();
            System.exit(-1);
        }
        System.out.println("Client done.");
        System.exit(0);
    }
}
</pre>
<p><a name="ColocatedServers" id="ColocatedServers"></a></p>
<h2><code>ColocatedServers.java</code></h2>
<p>This is a server which runs both <tt>ArbitraryObject</tt> and
<tt>LoggingService</tt> in the same ORB. This means that these
objects are <em>colocated</em>.</p>
<p>The server is created this way in order to exercise the code in
<tt>LoggingServiceServerInterceptor</tt> that illustrates when
interceptors make out calls to objects colocated in the same ORB
extra steps must be taken to avoid infinite recursion.</p>
<pre class="codeblock">

// <strong>ColocatedServers.java</strong>
// <a href="examplelicense.html">Copyright and License</a> 

package pi.serviceexample;

import org.omg.CORBA.ORB;
import java.util.Properties;

public class ColocatedServers
{
    public static ORB orb;

    public static boolean colocatedBootstrapDone = false;

    public static void main (String[] av)
    {
        try {

            //
            // Share an ORB between objects servers.
            //

            Properties props = new Properties();
            props.put("org.omg.PortableInterceptor.ORBInitializerClass."
                      + "pi.serviceexample.AServiceORBInitializer",
                      "");
            props.put("org.omg.PortableInterceptor.ORBInitializerClass."
                      + "pi.serviceexample.LoggingServiceServerORBInitializer",
                      "");
            ORB orb = ORB.init(av, props);
            ArbitraryObjectImpl.orb = orb;
            LoggingServiceImpl.orb = orb;

            //
            // Start both object servers.
            //

            ServerThread ServerThread = new ServerThread(av);
            ServerThread.start();
            ArbitraryObjectImpl.main(av);
        } catch (Exception e) {
            e.printStackTrace();
            System.exit(-1);
        }
    }
}

class ServerThread extends Thread
{
    String[] av;
    ServerThread (String[] av)
    {
        this.av = av;
    }
    public void run ()
    {
        LoggingServiceImpl.main(av);
    }
}
</pre>
<h2><a name="running" id="running">Compiling and running the
application</a></h2>
<p>The example code, which contains the logging example and the
service example, may be compiled and run using a Makefile such as
that shown below:</p>
<pre class="codeblock">

# <strong>Makefile for the Example Files</strong>
# <a href="examplelicense.html">Copyright and License</a> 

JAVA_HOME=/path_to_J2SE_installation

CLASSPATH=.

JAVAC=$(JAVA_HOME)/bin/javac
JAVA=$(JAVA_HOME)/bin/java

ORB_INITIAL_PORT=1050

IDLJ=$(JAVA_HOME)/bin/idlj
IDLJ_FLAGS=-fall -td $(CLASSPATH) -verbose

ORBD=${JAVA_HOME}/bin/orbd -ORBInitialPort ${ORB_INITIAL_PORT}

build:
        $(IDLJ) $(IDLJ_FLAGS) serviceexample.idl
        $(JAVAC) -d $(CLASSPATH) *.java
        $(JAVAC) pi/serviceexample/*.java

runorbd:
        $(ORBD)

runloggingservice:
        $(JAVA) -classpath $(CLASSPATH) pi.serviceexample.LoggingServiceImpl \
                -ORBInitialPort ${ORB_INITIAL_PORT}

runarbitraryobject:
        $(JAVA) -classpath $(CLASSPATH) pi.serviceexample.ArbitraryObjectImpl \
                -ORBInitialPort ${ORB_INITIAL_PORT}

runcolocatedservers:
        $(JAVA) -classpath $(CLASSPATH) pi.serviceexample.ColocatedServers \
                -ORBInitialPort ${ORB_INITIAL_PORT}

runclient:
        $(JAVA) -classpath $(CLASSPATH) pi.serviceexample.Client \
                -ORBInitialPort ${ORB_INITIAL_PORT}
        
clean: 
        rm -rf pi
        rm -rf orb.db

# Order of steps:
# Build:     clean build
# Remote:    runorbd runloggingservice runarbitraryobjectimpl runclient
# Colocated: runorbd runcolocatedservers runclient
</pre>
<p>The following steps show how to build and run the example on the
Solaris operating system using the above Makefile. From the command
prompt, run these commands as shown. The <code>%</code> symbol is
used as a reminder that these are commands that are to be run from
the command prompt.</p>
<ol>
<li><tt>% make clean</tt></li>
<li><tt>% make build</tt></li>
<li><tt>% make runorbd &amp;</tt></li>
<li><tt>% make runloggingservice &amp;</tt></li>
<li><tt>% make runarbitraryobject &amp;</tt></li>
<li><tt>% make runclient</tt>
<p>After this step, you will see output such as this:</p>
<pre class="codeblock">
resolve send_request
resolve receive_reply
arbitraryOperation1 send_request
Service present: 1
arbitraryOperation1 receive_reply
arbitraryOperation2 send_request
Service present: 1
arbitraryOperation2 receive_other
arbitraryOperation3 send_request
Service not present
arbitraryOperation3 receive_reply
arbitraryOperation3 send_request
Service present: 2
arbitraryOperation3 receive_exception
Client done.
</pre></li>
<li><tt>% jobs</tt>
<p>After this step, you will see output such as this:</p>
<pre class="codeblock">
[1]   Running                 make runorbd &amp;
[2]-  Running                 make runloggingservice &amp;
[3]+  Running                 make runarbitraryobject &amp;
</pre></li>
<li><tt>% kill %2 %3</tt></li>
<li><tt>% make runcolocatedservers &amp;</tt></li>
<li><tt>% make runclient</tt>
<p>After this step, you will see output such as this:</p>
<pre class="codeblock">
log receive_request_service_contexts
log receive_request
resolve send_request
log send_reply
log receive_request_service_contexts
log receive_request
resolve receive_reply
log send_reply
log receive_request_service_contexts
log receive_request
arbitraryOperation1 send_request
log send_reply
arbitraryOperation1 receive_request_service_contexts
arbitraryOperation1 receive_request
Service present: 1
arbitraryOperation1 send_reply
log receive_request_service_contexts
log receive_request
arbitraryOperation1 receive_reply
log send_reply
log receive_request_service_contexts
log receive_request
arbitraryOperation2 send_request
log send_reply
arbitraryOperation2 receive_request_service_contexts
arbitraryOperation2 receive_request
log receive_request_service_contexts
Service present: 1
arbitraryOperation2 send_reply
log receive_request
arbitraryOperation2 receive_other
log send_reply
log receive_request_service_contexts
log receive_request
arbitraryOperation3 send_request
log send_reply
arbitraryOperation3 receive_request_service_contexts
arbitraryOperation3 receive_request
Service not present
arbitraryOperation3 send_reply
log receive_request_service_contexts
log receive_request
arbitraryOperation3 receive_reply
log send_reply
log receive_request_service_contexts
log receive_request
arbitraryOperation3 send_request
log send_reply
arbitraryOperation3 receive_request_service_contexts
arbitraryOperation3 receive_request
Service present: 2
arbitraryOperation3 send_exception
log receive_request_service_contexts
log receive_request
arbitraryOperation3 receive_exception
log send_reply
Client done.
</pre></li>
<li><tt>% jobs</tt>
<p>After this step, you will see output such as this:</p>
<pre class="codeblock">
[1]-  Running                 make runorbd &amp;
[4]+  Running                 make runcolocatedservers &amp;
</pre></li>
<li><tt>% kill %1 %4</tt></li>
<li><tt>% make clean</tt></li>
</ol>
<dl>
<dt>See Also:</dt>
<dd><a href=
"../../../api/org/omg/PortableInterceptor/ORBInitInfo.html"><code>ORBInitInfo</code></a></dd>
<dd><a href=
"../../../api/org/omg/PortableInterceptor/package-summary.html"><tt>
org.omg.PortableInterceptor</tt> package</a>.</dd>
<dd>Portable Interceptors Specification at <a href=
"http://www.omg.org/cgi-bin/doc?ptc/2001-03-04">ptc/2001-08-31</a></dd>
</dl>

<!--  footer start -->
<div id="javasefooter">
<div class="hr">
<hr /></div>
<div id="javasecopyright">
<img id="oraclelogofooter" src=
"../../../images/oraclelogo.gif" alt="Oracle and/or its affiliates"
border="0" width="100" height="29" name=
"oraclelogofooter" />

<a href="../../../legal/cpyr.html">Copyright
&#169;</a> 1993, 2018, Oracle and/or its affiliates. All rights
reserved.</div>
<div id="javasecontactus">
<a href=
"http://docs.oracle.com/javase/feedback.html">Contact
Us</a>
</div>
</div>
<!-- footer end -->

<!-- STATIC FOOTER -->

</body>
</html>
