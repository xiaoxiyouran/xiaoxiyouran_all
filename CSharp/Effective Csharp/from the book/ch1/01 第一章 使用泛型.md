# 01 第一章 使用泛型

1- 泛型在C# 2.0 中引入

与传统的弱类型（依赖于 System.Object）, 泛型更能够保证 ==编译期类型== 安全；

<br>

2- 泛型常用于： 集合， 创建接口， 事件处理程序 以及 常用算法；

3- 为c# 添加泛型，需要修改C#编译器、 JIT(Just in time) 编译器 以及 CLR（Common language Runtime, 公共语言运行时）；

- C# 编译器 以代码生成 微软中间语言（Microsoft Intermediate Language, MSIL 或IL）表示的泛型类型定义。
- JIT 编译器则会把泛型类型定义与一系列的类型参数组合起来， 从而创建出封闭的泛型类型。
- CLR 将在运行时同时支持上述两种概念

<br>

4- 封闭泛型类型（closed generic type）: 所有类型参数已经明确给出的泛型类型；

开放泛型类型（open generic type）: 仅给出了部分类型参数；

5- 泛型的工作过程：

- 1） IL 为初始化某个完整的泛型烈性预留了占位符（降低了硬件存储）；
- 2） JIT 编译器在运行时生成机器码时 补全该封闭泛型类型的定义（多个封装泛型类型会增大处理代码的开销）；

在生成多个封闭泛型类型时， JIT 编译器和CLR会对过程进行优化， 以便降低对内存的压力；

只有JIT编译器将IL转换成 ==机器指令==之后， 生成的机器码才会被放置于只读的代码页中。

==无论是否泛型， 每个类型都会执行上述过程==。

- 对于非泛型类型： 类的IL 和 其生成的机器码之间是  ==一对一==关系；
- 泛型， JIT编译器将检查当前的类型参数，并根据参数生成特定的指令；

JIT编译器会对该过程进行一系列的优化， 以便让 ==不同的类型参数能使用同样的机器码==。

首先也是最重要的， JIT编译器将专门 ==为所有引用类型生成泛型类的一个机器码版本==。

<br>

一下实例化代码在运行时的机器码均完全相同；

``` csharp
List<string> stringList = new List<string>();
List<Stream> OpenFiles = new List<Stream>();
List<MyClassType> anotherList = new List<MyClassType>();
```

C# 编译器将在编译期保证类型安全， 有了这种保证后， JIT 编译器即可生成更加优化的机器码。

<br>

6- 如果某个封装类型中使用了 ==至少一个值类型的类型参数==， JIT 编译器将采用不同的策略。 这种， JIT 编译器将为不同的类型参数创建==不同版本的机器指令==。

以下三种类型生成的机器码将各不相同：

```csharp
List<double> doubleList = new List<double>();
List<int> markers = new List<int>();
List<MyStruct> values = new List<MyStruct>();
```

使用多个 ==引用类型== 参数的泛型类型并不会影响程序的内存占用， 其被JIT编译后 ==只生成一份代码==；

若是封闭泛型类型中包含 ==值类型== 作为参数， 那么JIT编译后的代码则会 ==各不相同==；

<br>

7- 当JIT编译一个泛型定义（泛型方法或泛型类），其至少有一个类型参数为 值类型时， 该过程分为两个步骤：

- 1)   编译器将创建一个新的 IL 类， 用来表示该封闭泛型类型； 如 将泛型定义中的 T 用 int 或者其它值类型替换；
- 2)   随后， JIT 把该代码编译成 x86 指令；

分为两个步骤很重要， 这样JIT并不是在类加载时 就为其生成完整的 x86 指令， 而是 ==在类中的每个方法被第一次调用时才开始编译的==；

- 第一步： 在IL代码上执行一个替换操作；
- 第二步： 像普通类定义一样按需编译；

<br>

8- 运行时的额外内存分为如下两个部分：

- 1） 为每种用值类型作为参数的封闭泛型类型 保存一份 ==IL定义的副本==；
- 2） 为每种用值类型作为参数的封闭泛型类型 保存一份 ==所调用方法的机器码的副本==；

<br>

9- 使用值类型作为泛型参数的好处：

- 1） 避免了对值类型的装箱和拆箱， 也就降低了值类型的代码/数据所占用的空间；
- 2） 类型安全由编译器保证， 也将让框架不必忙于 进行时检查，进一步降低了代码量提高了程序性能；

10- ==与创建泛型类相比，泛型方法== 有助于降低为支持不同实例而需要额外生成的IL代码量（条目8介绍）。

只有实际用到的方法才会被实例化， 非泛型类中定义的泛型方法将不会被JIT编译。

 <br>

本章将介绍如何把 .NET 1.x 的类型（使用 System.Object） 迁移至使用泛型的 .NET 2.0 类型；





























