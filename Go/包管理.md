# 包管理

包管理是一个挺神奇的东西。好好整理一下。

## 管理包

LZ问的应该是如何处理非开源包路径的问题

不管开源闭源
都应该放到gopath/src下 【==项目组织在这下面==】
如果不在gopath/src下，才可以使用相对导入，而相对导入有时不被接收

比如你的开源项目可能为gopath/src/github.com/tom/myproject
闭源项目可能为gopath/src/myproject

如果clone，也应该clone到gopath/src下

[参考](https://segmentfault.com/q/1010000010846304)

<br>

## 什么是Go语言中的包

这里我们直接讲Go语言实战的笔记，就不介绍Go语言的入门了，要入门，可以参考我的这篇文章 [Go语言开发环境搭建详解](http://www.flysnow.org/2017/01/05/install-golang.html)

我们在使用其他语言，比如Java，是有包的概念的，它是Java语言中组织我们的Java文件的一个概念，比如`java.lang`这个包，他里面有很多我们常用的类，比如String。在Go语言中，包也是类似的概念，它是把我们的go文件组织起来，可以方便进行归类、复用等目的。 比如Go内置的net包

```bash
net				# 顶层文件夹
├── http		# 文件夹
├── internal
├── mail
├── rpc
├── smtp
├── testdata
├── textproto
└── url
```

以上是net包的一个目录结构，==net本身是一个包，net目录下的http又是一个包==。从这个大家可以看到，go语言的包其实就是我们计算机里的==目录==，或者==叫文件夹==，通过它们进行目录结构和文件组织，go只是对目录名字做了一个翻译，叫【包】而已。比如这里的net包其实就是net目录，http包其实就是http目录，这也是go语言中的一个命名习惯，包名和文件所在的目录名是一样的。

<br>

## 包的命名

go语言的包的命名，遵循简洁、==小写==、和go文件==所在目录同名==的原则，这样就便于我们引用，书写以及快速定位查找。

比如go==自带的http这个包==，它这个http目录下的==所有go文件都属于这个http包==,所以我们使用http包里的函数、接口的时候，导入这个http包就可以了。【注意，这里的一个包 管理 成千上万个文件 （也可以将它们合并成一个文件看待）， 使用时，用 `package.函数() `调用】

```go
package main

import "net/http"

func main() {
	http.ListenAndServe("127.0.0.1:80",handler); 	// 使用包名调用函数
}
```

从这个例子可以看到，我们导入的是`net/http`,这在go里叫做全路径，因为http包在net里面，net是最顶级的包，所以必须使用==全路径导入==，go编译程序才能找到http这个包，和我们文件系统的目录路径是一样的。

因为有了全路径，所以命名的包名可以和其他库的一样，只要它们的全路径不同就可以了，使用全路径的导入，也增加了包名命名的灵活性。

对于自己或者公司开发的程序而言，我们一般==采用域名作为顶级包名==的方式，这样就==不用担心和其他开发者包名重复的问题==了，比如我的个人域名是`www.flysnow.org`,那么我自己开发的go程序都以`flysnow.org`作为全路径中的最顶层部分，比如导入我开发的一个工具包:

```go
package main

import "flysnow.org/tools"
```

如果你没有自己的域名，怎么办呢？这时候可以==使用github.com==。干研发这一行的，在github都会有个账号，如果没有赶紧申请一个，这时候我们就可以使用`github.com/<username>`作为你的顶级路径了，别人是不会和你重名的。

```go
package main

import "github.com/rujews/tools"
```

这就是换成github.com命名的方式。

<br>

## main包

当把一个go文件的==包名声明为`main`时，就等于告诉go编译程序，我这个是一个可执行的程序==，那么go编译程序就会尝试把它编译为一个二进制的可执行文件。

==一个`main`的包，一定会包含一个`main()`函数==，这种我们也不陌生，比如C和Java都有`main()`函数,它是一个程序的入口，没这个函数，程序就无法执行。

> 在go语言里，同时要满足`main`包和包含`main()`函数，才会被编译成一个可执行文件。

我们看一个Hello World的Go语言版本，来说明`main` 包。

```go
package main

import "fmt"

func main() {
	fmt.Println("Hello, 世界")
}
```

假设该go文件叫hello.go,放在`$GOPATH/src/hello`目录下，那么我们在这个目录下执行`go build`命令就会生成二进制的可执行文件，在window系统下生成的是`hello.exe`，在Unix，MAC和Linux下生成的是`hello`,我们在CMD或者终端里执行它，就可以看到控制台打印的:

```bash
Hello, 世界
```

> 二进制可执行文件的名字，就是该main包的go文件所在目录的名字，因为hello.go**在hello目录**下，所以生成的可执行文件就是hello这个名字。【==生成的文件， 用的是包名啊==】

<br>

## 导入包

要想使用一个包，必须先导入它才可以使用，Go语言提供了`import`关键字来导入一个包，这个关键字告诉Go编译器到磁盘的哪里去找要想导入的包，所以==导入的包必须是一个全路径的包，也就是包所在的位置==。

```go
import "fmt"
```

这就表示我们导入了`fmt`包，也就等于告诉go编译器，我们要使用这个包下面的代码。如果要导入多个包怎么办呢？Go语言还为我们提供的导入块。

```go
import (
	"net/http"
	"fmt"
)
```

使用一对括号包含的导入块，每个包独占一行。

> 对于多于一个路径的包名，在==代码中引用的时候==，使用全路径==最后一个包名==作为引用的包名，比如`net/http`,我们在代码使用的是`http`，而不是`net`。

现在我导入了包，那么编译的时候，go编译器去什么位置找他们呢？这里就要介绍下Go的环境变量了。Go有两个==很重要的环境变量`GOROOT`和`GOPATH`,==这是两个定义路径的环境变量，`GOROOT`是安装Go的路径，比如`/usr/local/go`；==`GOPATH`是我们自己定义的开发者个人的工作空间==，比如`/home/flysnow/go`。

编译器会使用我们设置的这两个路径，再加上`import`导入的相对全路径来查找磁盘上的包，比如我们导入的`fmt`包，编译器最终找到的是`/usr/local/go/fmt`这个位置。

值得了解的是：对于包的查找，是有优先级的，编译器会==优先在`GOROOT`里搜索，其次是`GOPATH`,一旦找到，就会马上停止搜索==。如果最终都没找到，就报编译异常了。

<br>

## 远程包导入

互联网的时代，现在大家使用类似于==Github共享代码==的越来越多，如果有的Go包共享在Github上，我们一样有办法使用他们，这就是==远程导入包==了，或者是网络导入，Go==天生就支持==这种情况，所以我们可以很随意的使用Github上的Go库开发程序。

```go
import "github.com/spf13/cobra"
```

这种导入，前提必须是该包托管在一个分布式的版本控制系统上，比如Github、==Bitbucket==等，并且是==Public的权限==，可以让我们直接访问它们。

编译在导入它们的时候，会先在`GOPATH`下搜索这个包，如果没有找到，就会使用 ==`go get`工具从版本控制系统（GitHub）获取==，并且会把获取到的源代码==存储在`GOPATH`目录下对应URL的目录里==，以供编译使用。

`go get`工具可以==递归获取依赖包==，如果`github.com/spf13/cobra`也引用了其他的远程包，该工具可以一并下载下来。

<br>

## 命名导入

我们知道，在使用`import`关键字导入包之后，我们就可以在代码中通过包名使用该包下相应的函数、接口等。如果我们==导入的包名正好有重复==的怎么办呢？针对这种情况，Go语言可以让我们==对导入的包重新命名==，这就是命名导入。

```go
package main

import (
	"fmt"
	myfmt "mylib/fmt"
)

func main() {
	fmt.Println()
	myfmt.Println()
}
```

如果没有重新命名，那么对于编译器来说，这两个`fmt`它是区分不清楚的。重命名也很简单，在我们导入的时候，==在包名的左侧，起一个新的包名就可以了==。

Go语言规定，==导入的包必须要使用==，否则会包编译错误，这是一个非常好的规则，因为这样可以避免我们引用很多无用的代码而导致的代码臃肿和程序的庞大，因为很多时候，我们都不知道哪些包是否使用，这在C和Java上会经常遇到，有时候我们不得不==借助工具来查找我们没有使用的文件、类型、方法和变量等，把它们清理掉==。

但是有时候，我们需要导入一个包，但是又不使用它，按照规则，这是不行的，为此Go语言给我们提供了一个空白标志符`_`,只需要我们==使用`_`重命名我们导入的包==就可以了。

```go
package main

import (
	_ "mylib/fmt"
)
```

<br>

## 包的init函数

每个包都可以==有任意多个init函数==，这些init函数都会==在main函数之前执行==。init函数通常用来做==初始化变量、设置包==或者其他需要在程序执行前的引导工作。比如上面我们讲的需要==使用`_`空标志符来导入一个包的目的，就是想执行这个包里的init函数。==

我们以数据库的驱动为例，Go语言为了==统一关于数据库的访问，使用`databases/sql`抽象了一层数据库的操作==，可以满足我们操作MYSQL、Postgre等数据库，这样不管我们使用这些数据库的哪个驱动，编码操作都是一样的，想换驱动的时候，就可以直接换掉，而不用修改具体的代码。

这些数据库驱动的实现，就是具体的，可以由任何人实现的，它的原理就是==定义了init函数，在程序运行之前，把实现好的驱动注册到sql包里，这样我们就使用使用它操作数据库了。==

```go
package mysql

import (
	"database/sql"
)

func init() {
	sql.Register("mysql", &MySQLDriver{})
}
```

因为我们只是想执行这个mysql包的init方法，并不想使用这个包，所以我们在导入这个包的时候，需要使用`_`重命名包名，避免编译错误。

```go
import "database/sql"
import _ "github.com/go-sql-driver/mysql"

db, err := sql.Open("mysql", "user:password@/dbname")
```

看非常简洁，剩下针对的数据库的操作，都是使用的`database/sql`标准接口，如果我们想换一个mysql的驱动的话，只需要换个导入就可以了，灵活方便，这也是==面向接口编程==的便利。

这里关于Go包管理使用的就结束了，后面会接着讲Go的一些常用工具、文档以及依赖管理。**欢迎大家关注公众号[flysnow_org]，敬请期待后续。** 

<br>

## See Also

- [Go语言环境搭建详解](http://www.flysnow.org/2017/01/05/install-golang.html)
- [Golang必备技巧：接口型函数](http://www.flysnow.org/2016/12/30/golang-function-interface.html)
- [从Java到Golang快速入门](http://www.flysnow.org/2016/12/28/from-java-to-golang.html)
- [GitHub上优秀的Go开源项目](http://www.flysnow.org/2016/12/27/golang-hot-project-in-github.html)
- [一个简单的Golang实现的Socket5 Proxy](http://www.flysnow.org/2016/12/26/golang-socket5-proxy.html)

<br>

## 参考

http://www.flysnow.org/2017/03/04/go-in-action-go-package.html