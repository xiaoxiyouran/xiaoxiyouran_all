# 20180413 CPP  中 冒号 和 双冒号的用法

```
主要是注意位域，表示的是多少bit
```



-------------------

原文链接：https://segmentfault.com/a/1190000000345680

### 1.冒号（:）用法

###（1）表示机构内位域的定义（即该变量占几个bit空间）

```cpp
typedef struct _XXX{
unsigned char a:4;
unsigned char c;
} ;

sizeof(_XXX)	// 2bytes
 
_XXX stru;
stru.a = 1;
 /// sizeof(stru.a)   不能对bit 域运用sizeof() 
```

###（2）构造函数后面的冒号起分割作用，是类给成员变量赋值的方法，初始化列表，更适用于成员变量的常量const型。

```cpp
struct _XXX{
_XXX() : y(0xc0) {}

  unsigned char y;
};
```

初始化变量赋值，const 变量必须用这种方式，否则会报错。举一个带const 变量的例子

```cpp
class myClass{
public :
myClass();// 构造函数，无返回类型，可以有参数列表，这里省去
~myClass();// 析构函数
int a;
const int b;	//// 
}

myClass::myClass():a(1),b(1)// 初始化列表
{
}
```

上面的例子展示了冒号的这个用法，下面对这个用法进行几点说明：

- 初始化列表的作用相当于在构造函数内进行相应成员变量的赋值，但两者是有差别的。

在初始化列表中是对变量进行初始化，而在构造函数内是进行赋值操作。两都的差别在对于像const类型数据的操作上表现得尤为明显。我们知道，**const类型的变量必须在定义时进行初始化**，而不能对const型的变量进行赋值，因此const类型的成员变量只能（而且必须）在初始化列表中进行初始化，即下面的代码将会出错：

```cpp
myClass::myClass（）
{
a = 1;// 没错，效果相当于在初始化列表中进行初始化
b = 1;// 出错，const变量不能进行赋值操作；
}
```

- public:和private:后面的冒号，表示后面定义的所有成员都是公有或私有的，直到下一个"public:”或"private:”出现为止。"private:"为默认处理。

  ###(3)类名冒号后面的是用来定义类的继承。

```cpp
class 派生类名 : 继承方式 基类名
{
	派生类的成员
};

继承方式：public、private和protected，默认处理是public。
```

- 初始化的顺序与成员变量**声名的顺序相同**。

先看一下下面的程序：

```cpp
myClass::myClass():b(1),a(b){
}

```

这样的执行结果a,b各是多少呢？b=1,a=1?不是，b=1而a是个随机数。这一点是相当重要的哦，一般在初始化列表中进行初始化时，初始化的顺序应与声明的顺序保持一致，防止出现不必要的错误。

- 对于继承的类来说，在初始化列表中也可以进行基类的初始化，初始化的顺序是**先基类初始化，然后再根据该类自己的变量的声明顺序进行初始化**。



### ?: 表达式

?:具有很低的优先级，这个要注意哦，下面的程序执行结果是啥呢？

```cpp
int i = 3;
int j = 2;
cout << i>j?i:j;// 出错，<<比>具有更高的优先级，执行顺序为 ((cout<<i)>j)?i:j,相当于是比较cout<<i与j的大小，然后根据比较结果决定表达式值为i或j，这显然要出错的，cout<<i的值是cout，不能跟整型数j进行比较。
cout << (i>j)?i:j;//输出1或0，相当于(cout<<(i>j))作为判决条件，来决定表达式的值为i或j，而cout<<(i>j)，i>j则输出1否则0，然后再将(cout<<(i>j))作为？：的条件，如果cout正确执行则为1（true），否则为0（false），以此决定表达式值为i或j
cout <<(i>j?i:j);//i>j则输出i，否则输出j，表达式值为true如果cout正确执行，否则为false
```





### 2．双冒号（::）用法

（1）表示“域操作符”
例：声明了一个类A，类A里声明了一个成员函数void f()，但没有在类的声明里给出f的定义，那么在类外定义f时，
就要写成void A::f()，表示这个f()函数是类A的成员函数。

（2）直接用在全局函数前，表示是全局函数
例：在VC里，你可以在调用API 函数里，在API函数名前加：：

（3）表示引用成员函数及变量，作用域成员运算符

例：System::Math::Sqrt() 相当于System.Math.Sqrt()

-------------------------

VC中如下

::是C++里的“作用域分解运算符”。比如声明了一个类A，类A里声明了一个成员函数voidf()，但没有在类的声明里给出f的定义，那么在类外定义f时，就要写成voidA::f()，表示这个f()函数是类A的成员函数。
　　:: 一般还有一种用法，就是直接用在全局函数前，表示是全局函数。当类的成员函数跟类外的一个全局函数同名时，考试,大提示在类内定义的时候，打此函数名默认调用的是本身的成员函数；如果要调用同名的全局函数时，就必须打上::以示区别。比如在VC里，你可以在调用API函数时，在API函数名前加::。



