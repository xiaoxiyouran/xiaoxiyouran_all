# 20180620 全局变量的使用

## 编译单元（模块）

1- 很多程序员最怕的就是处理连接错误(LINK ERROR), 因为它不像==编译错误那样可以给出你程序错误的具体位置==，

2- 但是如果你经常使用gcc，makefile等工具在linux或者嵌入式下做开发工作的话，那么你可能非常的理解编译与连接的区别！当在VC这样的开发工具上编写完代码，点击编译按钮准备生成exe文件时，VC其实做了两步工作，第一步，将==每个.cpp(.c)和相应.h文件编译成obj文件==；

第二步，将工程中所有的obj文件进行LINK生成最终的.exe文件，那么错误就有可能在两个地方产生，一个是==编译时==的错误，这个主要是语法错误，另一个是==连接错误，主要是重复定义变量==等。

3- 编译单元就是指在==编译阶段生成的每个obj文件==，一个obj文件就是一个编译单元，也就是说一个cpp(.c)和它相应的.h文件共同组成了一个编译单元，一个工程由很多个编译单元组成，每个obj文件里包含了变量存储的相对地址等 。

<br>

## 声明与定义的区别

 函数或变量在==声明==时，==并没有给它实际的物理内存空间==，它有时候可以保证你的程序编译通过， 但是当函数或变量定义的时候，它就在内存中有了实际的物理空间，如果你在编译模块中引用的==外部变量没有在整个工程中任何一个地方定义的话==， 那么即使它在编译时可以通过，在连接时也会报错，因为程序在内存中找不到这个变量！你也可以这样理解， 对同一个变量或函数的==声明可以有多次，而定义只能有一次!==

<br>

## extern 的作用

1- extern有两个作用，

- 第一个,当它与"C"一起连用时，如: extern "C" void fun(int a, int b); 则告诉编译器在编译fun这个函数名时按着C的规则去翻译相应的函数名而不是C++的， C++的规则在翻译这个函数名时会把fun这个名字变得面目全非，可能是fun@aBc_int_int#%$也可能是别的，这要看编译器的"脾气"了(不同的编译器采用的方法不一样)，为什么这么做呢，因为C++支持函数的重载啊，在这里不去过多的论述这个问题，如果你有兴趣可以去网上搜索，相信你可以得到满意的解释!
-  当extern不与"C"在一起修饰变量或函数时，如在头文件中: extern int g_Int;  它的作用就是声明函数或全局变量的作用范围的关键字，其声明的函数和变量可以在本模块活其他模块中使用，记住==它是一个声明不是定义==!也就是说B模块(编译单元)要是引用模块(编译单元)A中定义的全局变量或函数时，它只要包含A模块的头文件即可, 在编译阶段，模块B虽然找不到该函数或变量，但它不会报错，它会在连接时从模块A生成的目标代码中找到此函数。

<br>

### extern 修饰的全局变量

1- 头文件中声明全局变量：

```cpp
// test1.h
#ifndef TEST1H
#define TEST1H
    extern char g_str[]; // 声明全局变量g_str
    void fun1();
#endif
```

在源代码文件中定义全局变量：

```cpp
// test1.cpp
#include "test1.h"

char g_str[] = "123456"; // 定义全局变量g_str
    
void fun1()
{
   cout << g_str << endl;
}
```

以上是test1模块， 它的编译和连接都可以通过,如果我们还有test2模块也想使用g_str,只需要在原文件中引用就可以了：

```cpp
// test2.cpp
 #include "test1.h"			// 包含头文件就可以了。
void fun2()
{
  cout << g_str << endl;
}
```

以上test1和test2可以同时编译连接通过，如果你感兴趣的话可以用ultraEdit打开test1.obj,你可以在里面着"123456"这个字符串,但是你却不能在test2.obj里面找到，这是因为g_str是整个工程的全局变量，==在内存中只存在一份,== test2.obj这个编译单元不需要再有一份了，不然会在连接时报告重复定义这个错误!     

有些人喜欢把全局变量的声明和定义放在一起，这样可以防止忘记了定义，如把上面test1.h改为

```cpp
// test1.h
   extern char g_str[] = "123456"; // 这个时候相当于没有extern
```

 然后把test1.cpp中的g_str的定义去掉,这个时候再编译连接test1和test2两个模块时，会报连接错误，这是因为你把全局变量g_str的定义放在了头文件之后，test1.cpp这个模块包含了test1.h所以定义了一次g_str,而 test2.cpp也包含了test1.h所以再一次定义了g_str, 这个时候连接器在连接test1和test2时发现两个g_str。

```cpp
// test1.cpp
#include "test1.h"

// char g_str[] = "123456"; // 定义全局变量g_str
    
void fun1()
{
   cout << g_str << endl;
}
```

```cpp
// test2.cpp
 #include "test1.h"			// 包含头文件就可以了。
void fun2()
{
  cout << g_str << endl;
}
```

如果你非要把g_str的定义放在test1.h中的话，那么就把test2的代码中#include "test1.h"去掉 换成:

```cpp
// test2.cpp
   extern char g_str[];
    void fun2()
    {
        cout << g_str << endl;
    }
```

这个时候编译器就知道g_str是引自于外部的一个编译模块了，不会在本模块中再重复定义一个出来，但是我想说这样做非常糟糕，因为你由于==无法在test2.cpp中使用#include "test1.h"==, 那么test1.h中声明的其他函数你也无法使用了，除非也用都用extern修饰，这样的话你光声明的函数就要一大串，而且头文件的作用就是要给外部提供接口使用的，所以 请记住， ==只在头文件中做声明==，真理总是这么简单。

<br>

##  用static修饰的全局变量

1- 首先，我要告诉你static与extern是一对==“水火不容==”的家伙，也就是说extern和static不能同时修饰一个变量；

其次，static修饰的全局变量==声明与定义同时进行==，也就是说当你在头文件中使用static声明了全局变量后，它也同时被定义了；

最后，static修饰全局变量的==作用域只能是本身的编译单元==，也就是说它的“全局”只对本编译单元有效，其他编译单元则看不到它,如:

```cpp
 // test1.h:
 #ifndef TEST1H
 #define TEST1H
 static char g_str[] = "123456"; 		// 声明 + 定义一个静态变量
 void fun1();
 #endif
```

```cpp
// test1.cpp
#include "test1.h"

void fun1()
{
    cout << g_str << endl;
}
```



```cpp
// test2.cpp
#include "test1.h"

void fun2()
{
    cout << g_str << endl;
}
```

上两个编译单元可以连接成功, 当你打开test1.obj时，你可以在它里面找到字符串"123456", 同时你也可以在test2.obj中找到它们，它们之所以可以连接成功而没有报重复定义的错误是因为虽然它们有相同的内容，但是存储的物理地址并不一样，就像是==两个不同变量赋了相同的值一样，而这两个变量分别作用于它们各自的编译单元==。

 也许你比较较真，自己偷偷的跟踪调试上面的代码,结果你发现两个编译单元（test1, test2）的g_str的内存地址相同，于是你下结论static修饰的变量也可以作用于其他模块，但是我要告诉你，那是你的编译器在欺骗你，大多数编译器都对代码都有==优化功能==，以达到生成的目标程序更节省内存，执行效率更高，当编译器在连接各个编译单元的时候，它会把相同内容的内存只拷贝一份，比如上面的"123456", 位于两个编译单元中的变量都是同样的内容，那么在连接的时候它在内存中就只会存在一份了， 如果你把上面的代码改成下面的样子，你马上就可以拆穿编译器的谎言:

```cpp
// test1.cpp:
#include "test1.h"

void fun1()
{
    g_str[0] = 'a';
    cout << g_str << endl;
}
```



```cpp
// test2.cpp
#include "test1.h"

void fun2()
{
    cout << g_str << endl;
}
```



```cpp
void main()
    {
        fun1(); // a23456
        fun2(); // 123456
    }
```

  这个时候你在跟踪代码时，就会发现两个编译单元中的g_str地址并不相同，因为你在一处修改了它，所以编译器被强行的恢复内存的原貌，在内存中存在了两份拷贝给两个模块中的变量使用。

​    正是因为static有以上的特性，所以一般==定义static全局变量时，都把它放在原文件中==而不是头文件，这样就不会给其他模块造成不必要的信息污染，同样记住这个原则吧！

<br>

## const修饰的全局常量

const修饰的全局常量用途很广，比如软件中的错误信息字符串都是用全局常量来定义的。const修饰的全局常量据有跟static相同的特性，即它们只能作用于本编译模块中，但是==const可以与extern连用来声明该常量可以作用于其他编译模块中==, 如

```cpp
// xx.h
#ifndef _XX_
#define _XX_
extern const char g_str[];
#endif
```


​    然后在原文件中别忘了定义:

```cpp
// xx.cpp
#inclue "xx.h"
const char g_str[] = "123456";
```

​    所以当const单独使用时它就与static相同，而当与extern一起合作的时候，它的特性就跟extern的一样了！所以对const我没有什么可以过多的描述，

我只是想提醒你，``const char* g_str = "123456" ``与` const char g_str[] = “123465"`是不同的， 前面那个const 修饰的是``char * ``而不是g_str,它的g_str并不是常量，它被看做是一个定义了的全局变量（可以被其他编译单元使用），

所以如果你像让`char *g_str`遵守const的全局常量的规则，最好这么定义 `const char* const g_str="123456”` 



转自http://wrchen.blog.sohu.com/71617539.html