# 002 无重复字符的最长子串

## 链接和考点

| LeetCode | https://leetcode-cn.com/problems/median-of-two-sorted-arrays/description/ |
| -------- | ------------------------------------------------------------ |
| 考点     | 数组                                                         |
| 难度     | Hard                                                         |

<br>

## 题意

给定两个大小为 m 和 n 的有序数组 **nums1** 和 **nums2** 。

请找出这两个有序数组的中位数。要求算法的时间复杂度为 O(log (m+n)) 。

你可以假设 **nums1** 和 **nums2** 均不为空。 

**示例 1:**

```
nums1 = [1, 3]
nums2 = [2]

中位数是 2.0
```

**示例 2:**

```
nums1 = [1, 2]
nums2 = [3, 4]

中位数是 (2 + 3)/2 = 2.5
```

<br>

## 分析

参考: https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2481/Share-my-O(log(min(mn))-solution-with-explanation

中位数的定义： 将数组分成两半： 长度相等， 且一边大于另一边；

1- 对大小为m的数组A 按i进行随机划分：

```
      left_A             |        right_A
A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
```

i = 0 时，左边为空; i=m, 右边为空；

<br>

2- 用同样的方法，对大小为n的数组B 按随机位置j进行划分：

```
      left_B             |        right_B
B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
```

<br>

3- 将数组A的左半部分和B的左半部分组合， A的右半部分与B的右半部分组合：

```
      left_part          |        right_part
A[0], A[1], ..., A[i-1]  |  A[i], A[i+1], ..., A[m-1]
B[0], B[1], ..., B[j-1]  |  B[j], B[j+1], ..., B[n-1]
```

对于中位数，我们保证这两个条件：

```
1) len(left_part) == len(right_part)
2) max(left_part) <= min(right_part)
```

那么中位值是：`median = (max(left_part) + min(right_part))/2` ;

这两个条件可以转化为：

```
(1) i + j == m - i + n - j (or: m - i + n - j + 1)
    if n >= m, we just need to set: i = 0 ~ m, j = (m + n + 1)/2 - i
(2) B[j-1] <= A[i] and A[i-1] <= B[j]
```

条件1： 假设 ` A[i-1],B[j-1],A[i],B[j]` 总是有效的，暂时不考虑 `i=0, i=m, j=0, j=n` 这些边界条件；

条件2： `n >= m`. 因为要保证j是非负的， 由 $0 \le i \le m$ 和 $j = \frac{m+n+1}{2} - i$ , 如果 `n < m` , j 将会为负值，这将导致错误的结果；

<br>

4- 我们需要做的是： 在`[0,m]` 中找一个 i  满足如下条件：

```
 B[j-1] <= A[i] and A[i-1] <= B[j], ( where j = (m + n + 1)/2 - i )
```

<br>

5- 二分搜索的步骤如下：

- 1） 设置 `imin = 0, imax = m`, 那么 i 的搜索范围为 `[imin, imax]`;
- 2)    设置 `i = (imin + imax)/2, j = (m + n + 1)/2 - i`
- 3)    当我们有了 `len(left_part)==len(right_part)` 条件后， 剩下三种情况：

ii-1) 如果 `B[j-1] <= A[i] and A[i-1] <= B[j]` , 说明找到了划分数组的i;

ii-2)  如果 `B[j-1] > A[i]` ,  说明 `A[i]` 太小了，可以通过调整 i 使得 `B[j-1]<A[i]` ：

方法一：增大 i

​		当i增加时， j 减小， `A[i]` 是增加的， `B[j-1]` 是减小的， 总有某个时刻满足  `B[j-1]<A[i]`

方法二： 减小i

​	当 i 减小的时候， j 增加， `A[i]` 是减小的， `B[j-1]` 是增加的， 小的更小，大的更大， `B[j-1]<A[i]` 永远也无法满足；

所以， 增加i， 将i的范围调整为 `[i+1, imax]`, 设置 `imin = i+1`, 跳转第2步；

ii-3)  如果 `A[i-1] > B[j]` ,  说明 `A[i-1]` 太大了， 这时候就减小 i， 直到 `A[i-1] <= B[j]`;

所以， 减小i， 将i的范围调整为 `[imin, i-1]`, 设置 `imax = i-1`, 跳转第2步；

- 4) 当划分的 i 找到之后， 中位数为：

```
max(A[i-1], B[j-1]) (when m + n is odd)
or 
(max(A[i-1], B[j-1]) + min(A[i], B[j]))/2 (when m + n is even)
```

<br>

6- 考虑边界情况，` i=0,i=m,j=0,j=n` 的时候，`A[i-1],B[j-1],A[i],B[j]` 可能会不存在；









<br>

## 参考答案

时间复杂度： O(n)

空间复杂度：O(n)

```cpp
#include <iostream>
#include <unordered_map>
//#include <vector>
using namespace std;

/*
 reference: https://leetcode.com/problems/longest-substring-without-repeating-characters/discuss/1729/11-line-simple-Java-solution-O(n)-with-explanation
 */

template <typename T, typename  U>
void print_hash(unordered_map<T, U> hashmap){
    for( auto it = hashmap.begin(); it != hashmap.end(); it ++){
        std::cout << it->first << " : " << it -> second << std::endl;
    }
}

class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(s.size() == 0)
            return 0;
        unordered_map<char, int> hashmap;
        int maxLen = 0;
        for( int i=0, j=0; i<s.size(); i++ ){
            if( hashmap.count(s[i]) > 0 ){
                j = max(j, hashmap[s[i]] + 1);           // 2- 出现第一个重复的字母，就将左指针往右移1
                hashmap.erase(s[i]);                     // 3- 要向插入重复的，必选先删除之前的，否则插不进去
            }

            hashmap.insert(std::make_pair(s[i],i) );     // 1- 将不重复的元素存到hashmap
//            hashmap[s[i]] = i;
            maxLen = max(maxLen, i - j + 1);
//            print_hash(hashmap);
        }
        return maxLen;
    }
};



int main() {
    string s1 = "abcabcbb";
    string s2 = "bbbbb";
    string s3 = "pwwkew";
    string s4 = "abba";

//    cout << Solution().lengthOfLongestSubstring(s1) << std::endl;
//    cout << Solution().lengthOfLongestSubstring(s2) << std::endl;
//    cout << Solution().lengthOfLongestSubstring(s3) << std::endl;
    cout << Solution().lengthOfLongestSubstring(s4) << std::endl;

    std::cout<<"Hello, World!"<<std::endl;
    return 0;
}
/*output:
a : 0

a : 0
b : 1

a : 0
b : 2

b : 2
a : 3

3
*/
```

