# 20180410 招行走多少步的问题

在数轴上，小Q位于原点， 假设它位于n，那么它下一步，可以n + 1, n - 1 或者 n *2.

比如小Q 初始在原点，要走到 3，最少需要多少步。

```cpp
0  +1 +1(*2) +1
如上，总共需要三步。    
```

用dp来解决.

```cpp
dp[n]  表示走到位置n 需要的最少步数，那么
dp[n] = min{
dp[n-1] + 1; 					 #1
dp[n+1] + 1; /// 后退一步   	  #2	
dp[n/2] + 1; /// 如果n是偶数则可以  #3
}

看着有三步，但其实， 详细解读#2，如果想走到 dp[n+1] 位置，则 n+1 肯定是一个偶数，即从 n+1/2 再跳一步跳到的，如果n + 1是奇数呢？
所以分这么两种：
n+1 % 2=0  dp[n+1] = dp[n+1/2] +1
n+1 %2 =1  dp[n+1] = dp[n] + 1; 做了往返运动，再到 ---> dp[n]？ 删除
           dp[n+1] = dp[n+2] +1 = dp[n+2/2] + 1 + 1= dp[n/2 + 1] + 2, 既然n能被2 整除，为什么不是上面第三种情况呢？所以舍弃
           
所以 #2 变为 dp[n+1/2] +1 +1= dp[n+1/2] + 2  /// 如果n 是奇数 [我当时不知道怎么分析的，认为#2 走的步数肯定比#3 多，就省略的#2，这可能是只Access 80% 的原因吧]
#3 是 如果n是偶数

```

只Access了80% 的答案。

```cpp
#include <bits/stdc++.h>
using namespace std;


int main(){
    int pos;
    cin >> pos;
    if(pos < 0)
        pos = -pos;	/// 负数就放到正半轴一样。
    vector<int> vec(pos+1,0);
    vec[0] = 0;
    vec[1] = 1;
    vec[2] = 2;
    vec[3] = 3;

    for(int i=4; i< pos+1; i++){
        int a = vec[i-1] + 1;
        if( i% 2 == 0){
            int b = vec[i/2] + 1;
            if(b < a)
                a = b;
        }
        vec[i] = a;

    }

    cout << vec[pos] << endl;

    return 0;
}
```

